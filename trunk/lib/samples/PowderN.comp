/*****************************************************************************
*
*
* McStas, neutron ray-tracing package
*         Copyright 1997-2000 Risoe National Laboratory, Roskilde, Denmark
*
* %I
* Written by: E.M.Lauridsen, N.B.Christensen, A.B.Abrahamsen
* Date: 4.2.98
* Version: $Revision: 1.9 $
* Origin: McStas release
* Modified by: KL, KN 20.3.98 (rewrite)
* Modified by: KL, 28.09.01   (two lines)
* Modified by: KL, 22.05.03   (background)
* Modified by: KL, 01.05.05   (N lines)
*
* General powder sample (N lines, single scattering)
*
* %D
* General powder sample with
*         many scattering vectors
*         possibility for intrinsic line broadening
*         incoherent backgorund ratio is specified by user.
*         No multiple scattering. No secondary extinction.
*
* Based on Powder1/Powder2/Single_crystal.
* Powder structure is specified with an ascii data file. Each line contains 5
* or more numbers, separated by white space:
*
*       ... j d F2 DW      (and Delta_d >= 0, then w=Delta_d)
* or
*       ... j d F2 DW w    (and Delta_d <  0)
*
* The last columns are read as multiplicity, d-spacing (2*PI/q), Debey-Waller
* factor and width in d-spacing. If the file does not contain the last
* column, then set the Delta_d parameter to a positive or 0 value.
* The rest of the numbers are not used;
* Lines begining by '#' are read as comments (ignored).
* You may use Powder1 and Powder2 to define scattering lines as parameters.
* Geometry is a powder filled cylinder.
* Incoherent scattering is only provided here to account for a background
* The efficient is highly improved when restricting the vertical scattering
* range within 'd_phi'.
*
* Example: PowderN(reflections = "c60.lau", d_phi = 15 , radius = 0.01,
*   yheight = 0.05, Vc = 1076.89, sigma_a = 0, Delta_d=0)
*
* %P
* INPUT PARAMETERS
*
* d_phi:   Focussing angle corresponding to the angular range generated on the
*            on the left and right side of the Debye-Scherrer cone [deg,0-180]
* radius:   Radius of sample in (x,z) plane [m]
* yheight:  Height of sample y direction [m]
* pack:     Packing factor [1]
* Vc:       Volume of unit cell [AA^3]
* sigma_a:  Absorption cross section per unit cell at 2200 m/s [fm^2]
* sigma_inc:Incoherent cross section per unit cell [fm^2]
* frac:     Fraction of incoherently scattered neutron rays [1]
* reflections: Input file for reflections.
*                Use only incoherent scattering if NULL or "" [string]
* Delta_d:  global d-spacing spreading when last 'w' column
*             is not available [Angs]
*
* Optional parameters:
* xwidth:  horiz. dimension of sample, as a width [m]
* zthick:  thickness of sample [m]
* h:       the same as yheight [m]
*
* Variables calculated in the component
*
* my_s: Attenuation factor due to scattering [m^-1]
* my_a: Attenuation factor due to absorbtion [m^-1]
*
* %L
* See also: Powder1, Powder2 and PowderN
*
* %E
*****************************************************************************/
DEFINE COMPONENT PowderN
DEFINITION PARAMETERS (reflections)
SETTING PARAMETERS (d_phi=0, radius=0.01, yheight=0.05,
        pack=1, Vc, sigma_a=0, sigma_inc=0, Delta_d=-1, frac=0,
        xwidth=0, zthick=0, h=0)
OUTPUT PARAMETERS (line_info, Nq, my_s_v2,
  my_s_v2_sum, my_a_v, my_inc, q_v, w_v, isrect)
STATE PARAMETERS (x,y,z,vx,vy,vz,t,s1,s2,p)

SHARE
%{
  /* used for reading data table from file */
  %include "read_table-lib"
/* Declare structures and functions only once in each instrument. */
#ifndef POWDERN_DECL
#define POWDERN_DECL

    struct line_data
    {
      double F2;                  /* Value of structure factor */
      double q;                   /* Qvector */
      int j;                      /* Multiplicity */
      double DW;                  /* Debye-Waller factor */
      double w;                   /* Intrinsic line width */
    };

  struct line_info_struct
    {
      struct line_data *list;     /* Reflection array */
      int  count;                  /* Number of reflections */
      double Dd;
      char compname[256];
    };

  int read_line_data(char *SC_file, struct line_info_struct *info)
  {
    struct line_data *list = NULL;
    int    size = 0;
    t_Table sTable; /* sample data table structure from SC_file */
    int    i=0;
    int    mult_count  =0;
    double dspace_count=0;
    char   flag_shift=0;

    if (!SC_file || !strlen(SC_file)) {
      printf("PowderN: %s: Using incoherent elastic scattering only\n",
          info->compname);
      return(0);
    }

    Table_Read(&sTable, SC_file, 1); /* read 1st block data from SC_file into sTable*/
    if (sTable.columns < 4)
      exit(fprintf(stderr, "PowderN: %s: Error: The number of columns in %s\n"
          "should be at least %d for [j,d,F2,DW] or [j,d,F2,DW,w]\n",
          info->compname, SC_file, 4));
    if (!sTable.rows)
      exit(fprintf(stderr, "PowderN: %s: Error: The number of rows in %s"
          "should be at least %d\n", info->compname, SC_file, 1));
    else size = sTable.rows;
    printf("PowderN: %s: Reading %d rows from %s\n",
          info->compname, size, SC_file);
    /* allocate line_data array */
    list = (struct line_data*)malloc(size*sizeof(struct line_data));
    if (info->Dd >= 0) flag_shift=1;
    for (i=0; i<size; i++)
    {
      /*      printf("Reading in line %i\n",i);*/
      double j, d, w, DW, F2;
      double b1[3], b2[3];
      int    index;

      /* get data from table */
      j = Table_Index(sTable, i, sTable.columns-5+flag_shift);
      d = Table_Index(sTable, i, sTable.columns-4+flag_shift);
      F2= Table_Index(sTable, i, sTable.columns-3+flag_shift);
      DW= Table_Index(sTable, i, sTable.columns-2+flag_shift);
      if (!flag_shift)
        w = Table_Index(sTable, i, sTable.columns-1); /* last column */
      else w=info->Dd;
      /*
      if (size >= 4) {
        printf("Reflection %d: j=%g, d=%g, F2=%g, DW=%g, w=%g\n",
                i,j,d,F2,DW,w);
      }
      */
      list[i].j = j;
      list[i].q = (d ? 2*PI/d : 0);
      list[i].DW = DW;
      list[i].w = (w ? 2*PI/w : 0);
      list[i].F2 = F2;

      /* adjust multiplicity if j-column + multiple d-spacing lines */
      if (!mult_count)  dspace_count  = d;
      if (mult_count && dspace_count != d) {
        if (j == mult_count) {
          printf("PowderN: %s: Set multiplicity to 1 for lines [%i:%i]\n"
                 "         (d-spacing %s is duplicated)\n",
          info->compname, i-mult_count, i-1, d);
          for (index=i-mult_count; index<i; list[index++].j = 1);
        }
        mult_count = 0;
      } else mult_count++;
    }
    printf("PowderN: %s: File %s done.\n", info->compname, SC_file);
    Table_Free(&sTable);
    info->list = list;
    info->count = i;

    return(i);
  }
#endif /* !POWDERN_DECL */

%}

DECLARE
%{
  struct line_info_struct line_info;
  int Nq=0;
  double my_s_v2_sum;
  double my_a_v, my_inc;
  double *w_v,*q_v, *my_s_v2;
  char   isrect=0;
%}
INITIALIZE
%{
  int i;
  struct line_data *L;
  line_info.Dd = Delta_d;
  strncpy(line_info.compname, NAME_CURRENT_COMP, 256);



  if (!radius || !yheight) {
    if (!xwidth || !yheight || !zthick) exit(fprintf(stderr,"PowderN: %s: sample has no volume (zero dimensions)\n", NAME_CURRENT_COMP));
    else isrect=1; }

  my_a_v = pack*sigma_a/Vc*2200;           /* Is not yet divided by v */
  my_inc = pack*sigma_inc/Vc;
  my_s_v2_sum=0;

  if (read_line_data(reflections, &line_info)) {
    L = line_info.list;

    Nq  = line_info.count;
    q_v = malloc(Nq*sizeof(double));
    w_v = malloc(Nq*sizeof(double));
    my_s_v2 = malloc(Nq*sizeof(double));

    for(i=0; i<Nq; i++)
    {
      my_s_v2[i] = 4*PI*PI*PI*pack*L[i].DW
                 /(Vc*Vc*V2K*V2K)*(L[i].j * L[i].F2 / L[i].q);
                                        /* Is not yet divided by v^2 */
      /* Squires [3.103] */
      my_s_v2_sum+=my_s_v2[i];
      q_v[i] = L[i].q*K2V;
      w_v[i] = L[i].w*K2V;
    }
  }

%}
TRACE
%{
  double t0, t1, v, v1,l_full, l, l_1, dt, d_phi0, theta, my_s, my_s_n;
  double solid_angle;
  double arg, tmp_vx, tmp_vy, tmp_vz, vout_x, vout_y, vout_z;
  int    line;
  char   intersect=0;

  if (isrect)
    intersect = box_intersect(&t0, &t1, x, y, z, vx, vy, vz, xwidth, yheight, zthick);
  else
    intersect = cylinder_intersect(&t0, &t1, x, y, z, vx, vy, vz, radius, yheight);
  if(intersect)
  {
    if(t0 < 0) t0=0; /* already in sample */

    /* Neutron enters at t=t0. */
    v = sqrt(vx*vx + vy*vy + vz*vz);
    l_full = v * (t1 - t0);     /* Length of full path through sample */
    dt = rand01()*(t1 - t0);    /* Time of scattering */
    PROP_DT(dt+t0);             /* Point of scattering */
    l = v*dt;                   /* Penetration in sample */

    my_s = my_s_v2_sum/(v*v)+my_inc;
        /* Total attenuation from scattering */

    if (frac <= 0 || (frac < 1 && rand01() >= frac))
    {   /* Make coherent scattering event */
      /* Choose point on Debye-Scherrer cone */
      if (d_phi>0)
      {
        d_phi0  = 2*rand01()*d_phi;
        if (d_phi0 > d_phi) arg = 1; else arg = 0;
        if (arg) {
          d_phi0=180+(d_phi0-1.5*d_phi);
        } else {
          d_phi0=d_phi0-0.5*d_phi;
        }
        d_phi0 *= DEG2RAD;
        p *= d_phi/180;
      }
      else
        d_phi0 = PI*randpm1();

      if (Nq > 1) line=floor(Nq*rand01());  /* Select between Nq powder lines */
      else line = 0;
      if (w_v[line])
        arg = (q_v[line]+w_v[line]*randnorm())/(2.0*v);
      else
        arg = q_v[line]/(2.0*v);
      my_s_n = my_s_v2[line]/(v*v);
      if(fabs(arg) > 1)
        ABSORB;                   /* No bragg scattering possible*/
      theta = asin(arg);          /* Bragg scattering law */

      /* now find a nearly vertical rotation axis:
        *  (v along Z) x (X axis) -> nearly Y axis
        */
      vec_prod(tmp_vx,tmp_vy,tmp_vz, vx,vy,vz, 1,0,0);

      /* handle case where v and aim are parallel */
      if (!tmp_vx && !tmp_vy && !tmp_vz) { tmp_vx=tmp_vz=0; tmp_vy=1; }

      /* v_out = rotate 'v' by 2*theta around tmp_v: Bragg angle */
      rotate(vout_x,vout_y,vout_z, vx,vy,vz, 2*theta, tmp_vx,tmp_vy,tmp_vz);

      /* tmp_v = rotate v_out by d_phi0 around 'v' (Debye-Scherrer cone) */
      rotate(tmp_vx,tmp_vy,tmp_vz, vout_x,vout_y,vout_z, d_phi0, vx, vy, vz);
      vx = tmp_vx;
      vy = tmp_vy;
      vz = tmp_vz;

      arg=0;
      if (isrect && !box_intersect(&t0, &t1, x, y, z, vx, vy, vz, xwidth, yheight, zthick)) arg=1;
      else if(!isrect && !cylinder_intersect(&t0, &t1, x, y, z,
                            vx, vx, vx, radius, yheight)) arg=1;

      if (arg) {
        /* Strange error: did not hit cylinder */
        fprintf(stderr, "PowderN: FATAL ERROR: Did not hit sample from inside.\n");
        ABSORB;
      }
      l_1 = v*t1; /* go to exit */

      arg= Nq*l_full*my_s_n*exp(-(my_a_v/v+my_s)*(l+l_1))/(1-frac);

    }  /* Coherent scattering event */
    else
    {  /* Make incoherent scattering event */
      v = sqrt(vx*vx+vy*vy+vz*vz);
      if(d_phi) {
        randvec_target_rect_angular(&vx, &vy, &vz, &solid_angle,
            0, 0, 1,
            2*PI, d_phi*DEG2RAD, ROT_A_CURRENT_COMP);
      } else {
        randvec_target_circle(&vx, &vy, &vz,
          &solid_angle, 0, 0, 1, 0);
      }
      p *= solid_angle/4*PI;
      v1 = sqrt(vx*vx+vy*vy+vz*vz);
      vx *= v/v1;
      vy *= v/v1;
      vz *= v/v1;

      arg=0;
      if (isrect && !box_intersect(&t0, &t1, x, y, z, vx, vy, vz, xwidth, yheight, zthick)) arg=1;
      else if(!isrect && !cylinder_intersect(&t0, &t1, x, y, z,
                            vx, vx, vx, radius, yheight)) arg=1;

      if (arg) {
        /* Strange error: did not hit cylinder */
        fprintf(stderr, "PowderN: FATAL ERROR: Did not hit sample from inside.\n");
        ABSORB;
      }
      l_1 = v*t1;

      p *= l_full*my_inc*exp(-(my_a_v/v+my_s)*(l+l_1))/(frac);
      p *= solid_angle/(4*PI);

    }  /* Incoherent scattering event */
    p *= arg;
  } /* else transmit non interacting neutrons */

%}

MCDISPLAY
%{
  double h;
  h=yheight;
  magnify("xyz");
  if (!isrect) {
    circle("xz", 0,  h/2.0, 0, radius);
    circle("xz", 0, -h/2.0, 0, radius);
    line(-radius, -h/2.0, 0, -radius, +h/2.0, 0);
    line(+radius, -h/2.0, 0, +radius, +h/2.0, 0);
    line(0, -h/2.0, -radius, 0, +h/2.0, -radius);
    line(0, -h/2.0, +radius, 0, +h/2.0, +radius);
  } else {
    double xmin = -0.5*xwidth;
    double xmax =  0.5*xwidth;
    double ymin = -0.5*yheight;
    double ymax =  0.5*yheight;
    double zmin = -0.5*zthick;
    double zmax =  0.5*zthick;
    multiline(5, xmin, ymin, zmin,
                 xmax, ymin, zmin,
                 xmax, ymax, zmin,
                 xmin, ymax, zmin,
                 xmin, ymin, zmin);
    multiline(5, xmin, ymin, zmax,
                 xmax, ymin, zmax,
                 xmax, ymax, zmax,
                 xmin, ymax, zmax,
                 xmin, ymin, zmax);
    line(xmin, ymin, zmin, xmin, ymin, zmax);
    line(xmax, ymin, zmin, xmax, ymin, zmax);
    line(xmin, ymax, zmin, xmin, ymax, zmax);
    line(xmax, ymax, zmin, xmax, ymax, zmax);
  }
%}
END
