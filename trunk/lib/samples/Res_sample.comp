/*******************************************************************************
*
* McStas, the neutron ray-tracing package: Res_sample.comp
*         Copyright 1977-2001 Risoe National Laboratory, Roskilde, Denmark
*
* Component: Res_sample
*
* %I
* Written by: Kristian Nielsen
* Date: 1999
* Version: $Revision: 1.11 $
* Origin: McStas 1.5
*
* Sample for resolution function calculation.
*
* %D
* An inelastic sample with completely uniform scattering in both Q and
* energy. This sample is used together with the Res_monitor component and
* (optionally) the mcresplot front-end to compute the resolution function of
* triple-axis or inverse-geometry time-of-flight instruments.
*
* The shape of the sample is either a hollow cylinder or a rectangular box. The
* hollow cylinder shape is specified with an inner and outer radius. If the
* outher radius is negative, the shape is instead a box.
*
* The scattered neutrons will have directions towards a given sphere and
* energies betweed E0-dE and E0+dE.
*
* Example: Res_sample(radius_i=0.001,radius_o=0.02,h=0.4,focus_r=0.05,
*     E0=14.6,dE=2, target_x=0, target_y=0, target_z=1000)
*
* %P
* INPUT PARAMETERS:
*       
* radius_i  : Inner radius of hollow cylinder in (x,z) plane, or width of
*             box along X (m)
* radius_o  : Outer radius of hollow cylinder, or negative box depth along Z (m)
* h         : Height of box or cylinder along Y (m)
* focus_r   : Radius of sphere containing target. (m)
* target_x  :
* target_y  : position of target to focus at (m)
* target_z  :
* E0        : Center of scattered energy range [meV]
* dE        : half width of scattered energy range [meV]
*
* %E
*******************************************************************************/

DEFINE COMPONENT Res_sample
DEFINITION PARAMETERS ()
SETTING PARAMETERS (radius_i,radius_o,h,focus_r=0.05,E0=14,dE=2,
		    target_x=0, target_y=0, target_z=1000)
OUTPUT PARAMETERS (res_struct)
STATE PARAMETERS (x,y,z,vx,vy,vz,t,s1,s2,p)

DECLARE
%{
  struct Res_sample_struct
    {
      double ki_x,ki_y,ki_z,kf_x,kf_y,kf_z;
      double rx,ry,rz,pi;
    } res_struct;
%}
INITIALIZE
%{
%}
TRACE
%{
  double t0, t3;                /* Entry/exit time for outer cylinder */
  double t1, t2;                /* Entry/exit time for inner cylinder */
  double v;                     /* Neutron velocity */
  double E;
  double l_full;                /* Flight path length for non-scattered neutron */
  double dt0, dt1, dt2, dt;     /* Flight times through sample */
  double solid_angle;           /* Solid angle of target as seen from scattering point */
  double aim_x, aim_y, aim_z;   /* Position of target relative to scattering point */
  double scat_factor;           /* Simple cross-section model */

  if(radius_o < 0.0)
  {                             /* Flat sample */
    PROP_Z0;
    if(x <= -0.5*radius_i || x >= 0.5*radius_i ||
       y <= -0.5*h || y >= 0.5*h)
      ABSORB;
    t0 = 0;
    t1 = t2 = t3 = (-radius_o)/vz;
    scat_factor = -2*radius_o;
  }
  else
  {                             /* Hollow cylinder sample */
    if(!cylinder_intersect(&t0, &t3, x, y, z, vx, vy, vz, radius_o, h))
      ABSORB;
    if(t0 < 0)
      ABSORB;
    /* Neutron enters at t=t0. */
    if(!cylinder_intersect(&t1, &t2, x, y, z, vx, vy, vz, radius_i, h))
      t1 = t2 = t3;
    scat_factor = 2*radius_o;
  }
  dt0 = t1-t0;                  /* Time in sample, ingoing */
  dt1 = t2-t1;                  /* Time in hole */
  dt2 = t3-t2;                  /* Time in sample, outgoing */
  v = sqrt(vx*vx + vy*vy + vz*vz);
  l_full = v * (dt0 + dt2);     /* Length of full path through sample */
  p *= l_full/scat_factor;      /* Scattering probability */
  dt = rand01()*(dt0+dt2);      /* Time of scattering (relative to t0) */
  if (dt > dt0)
    dt += dt1;

  PROP_DT(dt+t0);             /* Point of scattering */

  /* Store initial neutron state. */
  if(p == 0) ABSORB;
  res_struct.pi = p;
  res_struct.ki_x = V2K*vx;
  res_struct.ki_y = V2K*vy;
  res_struct.ki_z = V2K*vz;
  res_struct.rx = x;
  res_struct.ry = y;
  res_struct.rz = z;

  aim_x = target_x-x;         /* Vector pointing at target (anal./det.) */
  aim_y = target_y-y;
  aim_z = target_z-z;
  randvec_target_sphere(&vx, &vy, &vz, &solid_angle, aim_x, aim_y, aim_z, focus_r);
  NORM(vx, vy, vz);
  E=E0+dE*randpm1();
  v=sqrt(E)*SE2V;
  vx *= v;
  vy *= v;
  vz *= v;
  SCATTER;

    /* Store final neutron state. */
  res_struct.kf_x = V2K*vx;
  res_struct.kf_y = V2K*vy;
  res_struct.kf_z = V2K*vz;
%}

MCDISPLAY
%{
  magnify("xyz");
  if(radius_o < 0.0)
  {                             /* Flat sample. */
    double xmin = -0.5*radius_i;
    double xmax =  0.5*radius_i;
    double ymin = -0.5*h;
    double ymax =  0.5*h;
    double len = -radius_o;
    multiline(5, xmin, ymin, 0.0,
                 xmax, ymin, 0.0,
                 xmax, ymax, 0.0,
                 xmin, ymax, 0.0,
                 xmin, ymin, 0.0);
    multiline(5, xmin, ymin, len,
                 xmax, ymin, len,
                 xmax, ymax, len,
                 xmin, ymax, len,
                 xmin, ymin, len);
    line(xmin, ymin, 0.0, xmin, ymin, len);
    line(xmax, ymin, 0.0, xmax, ymin, len);
    line(xmin, ymax, 0.0, xmin, ymax, len);
    line(xmax, ymax, 0.0, xmax, ymax, len);
  }
  else
  {
    circle("xz", 0,  h/2.0, 0, radius_i);
    circle("xz", 0,  h/2.0, 0, radius_o);
    circle("xz", 0, -h/2.0, 0, radius_i);
    circle("xz", 0, -h/2.0, 0, radius_o);
    line(-radius_i, -h/2.0, 0, -radius_i, +h/2.0, 0);
    line(+radius_i, -h/2.0, 0, +radius_i, +h/2.0, 0);
    line(0, -h/2.0, -radius_i, 0, +h/2.0, -radius_i);
    line(0, -h/2.0, +radius_i, 0, +h/2.0, +radius_i);
    line(-radius_o, -h/2.0, 0, -radius_o, +h/2.0, 0);
    line(+radius_o, -h/2.0, 0, +radius_o, +h/2.0, 0);
    line(0, -h/2.0, -radius_o, 0, +h/2.0, -radius_o);
    line(0, -h/2.0, +radius_o, 0, +h/2.0, +radius_o);
  }
%}

END
