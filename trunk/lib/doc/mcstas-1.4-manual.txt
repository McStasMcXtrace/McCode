Ris{R{1175(EN)
User and Programmers Guide to the
Neutron Ray-Tracing Package
McStas, Version 1.4
Kristian Nielsen, Kim Lefmann
Ris National Laboratory, Roskilde, Denmark
July 2000

Abstract
The software package McStas is a tool for writing Monte Carlo ray-tracing simula-
tions of neutron scattering instruments with very high complexity and precision. The
simulations can compute all aspects of the performance of instruments and can thus be
used to optimize the use of existing equipment as well as the design of new instrumen-
tation. McStas is based on a unique design where an automatic compilation process
translates high-level textual instrument descriptions into e∆cient ANSI C code. This
design makes it simple to set up typical simulations and also give essentially unlimited
freedom to handle more unusual needs.
This report constitutes the reference manual for McStas, and contains full doc-
umentation for all ascpects of the program. It covers the various ways to compile
and run simulations; a description of the metalanguage used to dene simulations;
a full description of all algorithms used to calculate the eects of the various opti-
cal components in instruments; and some example simulations performed with the
program.
This report documents McStas version 1.4, released July 28, 2000.
Front page illustration:
Simulated scattering from a vanadium sample taking into account the secondary extinc-
tion. See section D.1.
ISBN 87{550{2683{4
ISBN 87{550{2684{2 (Internet)
ISSN 0106{2840
Information Service Department  Ris  2000

Contents
Preface and acknowledgements 7
1 Introduction to McStas 8
1.1 Background . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
1.1.1 The goals of McStas . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
1.2 The design of McStas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
1.3 Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
2 Running McStas 12
2.1 Using the graphical user interface . . . . . . . . . . . . . . . . . . . . . . . . 12
2.2 Obtaining McStas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
2.3 Compiling McStas from source . . . . . . . . . . . . . . . . . . . . . . . . . 13
2.4 Running the instrument compiler . . . . . . . . . . . . . . . . . . . . . . . . 14
2.4.1 Code generation options . . . . . . . . . . . . . . . . . . . . . . . . . 15
2.4.2 Specifying the location of les . . . . . . . . . . . . . . . . . . . . . . 15
2.4.3 Embedding the generated simulations in other programs . . . . . . . 16
2.4.4 Running the C compiler . . . . . . . . . . . . . . . . . . . . . . . . . 16
2.5 Running the simulations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
2.6 Using simulation front-ends . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
2.6.1 The graphical user interface . . . . . . . . . . . . . . . . . . . . . . . 19
2.6.2 Running simulations with automatic compilation . . . . . . . . . . . 21
2.6.3 The gscan front-end . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
2.6.4 Graphical display of simulations . . . . . . . . . . . . . . . . . . . . 23
2.6.5 Plotting the results of a simulation . . . . . . . . . . . . . . . . . . . 24
2.6.6 Plotting resolution functions . . . . . . . . . . . . . . . . . . . . . . 24
2.7 Analyzing and visualizing the simulation results . . . . . . . . . . . . . . . . 25
3 The McStas kernel and meta-language 27
3.1 Notational conventions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
3.2 Syntactical conventions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
3.3 Writing instrument denitions . . . . . . . . . . . . . . . . . . . . . . . . . . 29
3.3.1 The instrument denition head . . . . . . . . . . . . . . . . . . . . . 29
3.3.2 The DECLARE section . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
3.3.3 The INITIALIZE section . . . . . . . . . . . . . . . . . . . . . . . . . 30
3.3.4 The TRACE section . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
3.3.5 The FINALLY section . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
Ris{R{1175(EN) 3

3.3.6 The end of the instrument denition . . . . . . . . . . . . . . . . . . 31
3.4 Writing component denitions . . . . . . . . . . . . . . . . . . . . . . . . . . 32
3.4.1 The component denition header . . . . . . . . . . . . . . . . . . . . 32
3.4.2 The DECLARE section . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
3.4.3 The INITIALIZE section . . . . . . . . . . . . . . . . . . . . . . . . . 34
3.4.4 The TRACE section . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
3.4.5 The FINALLY section . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
3.4.6 The MCDISPLAY section . . . . . . . . . . . . . . . . . . . . . . . . . 37
3.4.7 The end of the component denition . . . . . . . . . . . . . . . . . . 38
3.4.8 McDoc, the McStas component documentation tool . . . . . . . . . 38
4 Monte Carlo Techniques and simulation strategy 40
4.1 The neutron weight, p . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
4.1.1 Statistical errors of non-integer counts . . . . . . . . . . . . . . . . . 41
4.2 Weight factor transformations during a Monte Carlo choice . . . . . . . . . 42
4.3 Focusing components . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
4.4 Transformation of random numbers . . . . . . . . . . . . . . . . . . . . . . . 43
5 The component library 45
5.1 Source components . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
5.1.1 Source at: A circular continuous source with a at energy spectrum 46
5.1.2 Source at lambda: A continous source with at wavelength spectrum 46
5.1.3 Source ux lambda: A continuous source with absolute ux . . . . . 46
5.1.4 Source div: A divergent source . . . . . . . . . . . . . . . . . . . . . 47
5.1.5 Moderator: A time-of-ight source . . . . . . . . . . . . . . . . . . . 47
5.1.6 Source adapt: A neutron source with adaptive importance sampling 47
5.1.7 Source Optimizer: A general Optimizer for McStas . . . . . . . . . . 50
5.2 Simple optical components: Arms, slits, collimators, lters . . . . . . . . . . 52
5.2.1 Arm: The generic component . . . . . . . . . . . . . . . . . . . . . . 53
5.2.2 Slit: The rectangular slit . . . . . . . . . . . . . . . . . . . . . . . . 53
5.2.3 Circular slit: The circular slit . . . . . . . . . . . . . . . . . . . . . . 53
5.2.4 Beamstop rectangular: The rectangular beam stop . . . . . . . . . . 53
5.2.5 Beamstop circular: The circular beam stop . . . . . . . . . . . . . . 53
5.2.6 Soller: The simple Soller blade collimator . . . . . . . . . . . . . . . 53
5.2.7 Filter: A transmission lter . . . . . . . . . . . . . . . . . . . . . . . 55
5.3 Advanced optical components: mirrors and guides . . . . . . . . . . . . . . 55
5.3.1 Mirror reectivity . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55
5.3.2 Mirror: The single mirror . . . . . . . . . . . . . . . . . . . . . . . . 56
5.3.3 Guide: The guide section . . . . . . . . . . . . . . . . . . . . . . . . 56
5.3.4 Channeled guide: A guide section component with multiple channels 58
5.4 Chopper-like components . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
5.4.1 V selector: The rotating velocity selector . . . . . . . . . . . . . . . 59
5.4.2 Chopper: The disc chopper . . . . . . . . . . . . . . . . . . . . . . . 59
5.4.3 First chopper: The rst disc chopper . . . . . . . . . . . . . . . . . . 60
5.5 Detectors and monitors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61
5.5.1 Monitor: The single monitor . . . . . . . . . . . . . . . . . . . . . . 62
4 Ris{R{1175(EN)

5.5.2 Monitor 4PI: The 4 monitor . . . . . . . . . . . . . . . . . . . . . . 62
5.5.3 PSD monitor: The PSD monitor . . . . . . . . . . . . . . . . . . . . 62
5.5.4 PSD monitor 4PI: The 4 PSD monitor . . . . . . . . . . . . . . . . 62
5.5.5 PSD monitor 4PI log: The 4 PSD monitor with log scale . . . . . . 63
5.5.6 TOF monitor: The time-of-ight monitor . . . . . . . . . . . . . . . 63
5.5.7 E monitor: The energy sensitive monitor . . . . . . . . . . . . . . . 63
5.5.8 L monitor: The wavelength sensitive monitor . . . . . . . . . . . . . 63
5.5.9 Divergence monitor: The divergence sensitive monitor . . . . . . . . 63
5.5.10 DivPos monitor: The divergence-position sensitive monitor . . . . . 64
5.5.11 DivLambda monitor: The divergence-wavelength sensitive monitor . 64
5.5.12 Monitor nD: A general Monitor for 0D/1D/2D records . . . . . . . . 64
5.5.13 Res monitor: The resolution monitor . . . . . . . . . . . . . . . . . . 67
5.5.14 Adapt check: The simple adaptive importance sampling monitor . . 68
5.5.15 Monitor Optimizer: Optimization locations for the Source Optimiz-
er component . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
5.6 Bragg scattering single crystals, monochromators . . . . . . . . . . . . . . . 69
5.6.1 Mosaic simple: An innitely thin mosaic crystal with a single scat-
tering vector . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
5.6.2 Mosaic anisotropic: The crystal with anisotropic mosaic . . . . . . . 72
5.6.3 Single crystal: The single crystal component . . . . . . . . . . . . . 72
5.6.4 Monochromator: The monochromator crystal . . . . . . . . . . . . . 79
5.7 Powder-like sample components . . . . . . . . . . . . . . . . . . . . . . . . . 79
5.7.1 Weight transformation in samples; focusing . . . . . . . . . . . . . . 79
5.7.2 V sample: An incoherent scatterer, the V-sample . . . . . . . . . . . 81
5.7.3 Powder1: A general powder sample . . . . . . . . . . . . . . . . . . . 82
5.8 Inelastic scattering kernels . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84
5.8.1 Res sample: A uniform scatterer for resolution calculation . . . . . . 84
6 The instrument library 88
6.1 A test instrument for the component V sample . . . . . . . . . . . . . . . . 88
6.2 The triple axis spectrometer TAS1 . . . . . . . . . . . . . . . . . . . . . . . 88
6.3 The time-of-ight spectrometer PRISMA . . . . . . . . . . . . . . . . . . . 90
7 Planned expansions of McStas in the future 92
A Kernel calls and conversion constants 93
A.1 Kernel calls and functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93
A.2 Constants for unit conversion etc. . . . . . . . . . . . . . . . . . . . . . . . . 95
B McStas source code for the component library 96
B.1 Source components . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98
B.1.1 Source at . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98
B.1.3 Source ux lambda . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100
B.1.4 Source div . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
B.1.5 Moderator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104
B.1.6 Source adapt . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106
Ris{R{1175(EN) 5

B.2 Simple components . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110
B.2.1 Arm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110
B.2.2 Slit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111
B.2.6 Soller . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
B.2.7 Filter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
B.3 Beam optical components . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
B.3.3 Guide . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
B.3.4 Channeled Guide . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121
B.4 Chopper-like components . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126
B.4.1 V selector.comp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126
B.4.2 Chopper.comp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
B.5 Detectors and monitors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
B.5.1 Monitor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
B.5.3 PSD monitor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
B.5.4 PSD monitor 4PI . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135
B.5.6 TOF monitor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138
B.5.7 E monitor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140
B.5.13 Res monitor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142
B.5.14 Adapt check . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144
B.6 Crystals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 146
B.6.1 Mosaic simple . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 146
B.6.3 Single crystal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150
B.7 Powder-like samples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 162
B.7.2 V sample . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 162
B.7.3 Powder1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165
B.8 Inelastic samples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168
B.8.1 Res sample . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168
C McStas instrument denitions 172
C.1 Code for the instrument vanadium example.instr . . . . . . . . . . . . . . 172
C.2 Code for the instrument linup-7.instr . . . . . . . . . . . . . . . . . . . . 173
C.3 Code for the instrument prisma2 . . . . . . . . . . . . . . . . . . . . . . . . 177
D Test results 184
D.1 Scattering from the V-sample test instrument . . . . . . . . . . . . . . . . . 184
D.2 Simulated and measured resolution of TAS1 . . . . . . . . . . . . . . . . . . 184
D.3 Simple spectra from the PRISMA instrument . . . . . . . . . . . . . . . . . 186
E The McStas terminology 189
Bibliography 190
6 Ris{R{1175(EN)

Preface and acknowledgements
This document contains information on the Ris Monte Carlo neutron ray-tracing program
McStas version 1.4, an update to the initial release 1.0 as presented in Ref. [2]. The reader
of this document is supposed to have some knowledge of neutron scattering, whereas only
little knowledge about simulation techniques is required. In a few places, we also assume
familiarity with the use of C, UNIX and of the world wide web (WWW).
It is a pleasure to thank Prof. Kurt N. Clausen for his continuous support to this
project and for having initiated the work in the rst place. Both he and our other col-
laborators, Henrik M. Rnnow and Mark Hagen have made major contributions to the
project. Also the contributions from our test users, the students Asger Abrahamsen, Niels
Bech Christensen, and Erik Lauridsen, are gratefully acknowledged; they gave us an ex-
cellent opportunity to pinpoint a vast amount of serious errors in the test version. Useful
comments to this document itself have been given by Bella Lake and Alan Tennant. We
have also beneted from discussions with many other people in the neutron scattering
community, too numerous to mention here.
Philipp Bernhardt contributed the two chopper components in sections 5.4.2 and 5.4.3.
Emmanuel Farhi contributed the components in sections 5.1.7, 5.5.12, and 5.5.15. We
encourage other users to contribute components with manual entries for inclusion in future
versions of McStas.
This project has been supported by the European Union through the XENNI program
and the RTD \Cool Neutrons" and \SCANS" programs. This version of the project was
released July 28, 2000.
In case any errors, questions, suggestions, or other need for support should arise, do
not hesitate to contact the authors
Kristian Nielsen, Condensed Matter Physics and Chemistry Department,
Ris National Laboratory, 4000 Roskilde, Denmark.
phone +45 46 77 55 15, e-mail kristian.nielsen@risoe.dk
Kim Lefmann, Condensed Matter Physics and Chemistry Department,
Ris National Laboratory, 4000 Roskilde, Denmark.
phone +45 46 77 47 13, e-mail kim.lefmann@risoe.dk
or consult the McStas WWW home page [1].
Ris{R{1175(EN) 7

Chapter 1
Introduction to McStas
E∆cient design and optimization of neutron spectrometers is a formidable challenge.
Monte Carlo techniques are well matched to meeting this challenge. However, no existing
package oers a general framework for tackling the problems currently faced at reactor
and spallation sources. The McStas project is designed to provide such a framework.
McStas (Monte Carlo Simulations of Triple Axis Spectrometers) is a fast and versatile
software tool for neutron ray-tracing simulations. It is based on a meta-language specially
designed for neutron simulation. Specications are written in this language by users and
automatically translated into e∆cient simulations written in ANSI-C. The present version
supports both continuous and pulsed source type instruments, and includes a library
of standard components including single, position-sensitive, and time-of ight detectors,
supermirror guides, monochromators/analysers, a velocity selector and a disk chopper,
and powder and vanadium samples.
The McStas package is written in ANSI-C and is freely available for down-load from
the project home page [1]. The package is actively being developed and supported at Ris.
The system is well tested and is supplied with several examples and with documentation
in the form of this manual.
1.1 Background
The McStas project is the main part of a major eort in Monte Carlo simulations for
neutron scattering at Ris National Laboratory. Simulation tools are urgently needed,
not only to better utilize existing instruments (RITA [3, 4]), but also to design instrument
upgrades (TAS7), and to plan completely new instruments for new sources (European
Spallation Source, ESS [5]). Writing programs in C or FORTRAN for each of the dierent
cases involves a huge eort, with debugging presenting particularly di∆cult problems. A
higher level tool specially designed for the needs of simulating neutron instruments is
needed. As there was no existing simulation software that would fulll our needs, the
McStas project was initiated.
1.1.1 The goals of McStas
The McStas project has four main goals:
8 Ris{R{1175(EN)

Correctness It is essential to minimize the potential for bugs in computer simulations.
When a word processing program contains bugs, it will produce bad-looking output or may
even crash. This is a nuisance, but at least you know that something is wrong. However,
when a simulation contains bugs it produces wrong results, and unless the results are far
o, you may not know about it! Complex simulations involve hundreds or even thousands
of lines of formulae, and \to err is human". Thus the system should be designed from
the start to help minimize the potential for bugs to be introduced in the rst place, and
provide good tools for testing to maximize the chances of nding the bugs that do creep
in.
Flexibility When you commit yourself to using a tool for an important project, you
need to know if the tool will satisfy not only your present, but also your future needs.
The tool must not have fundamental limitations that restrict its potential usage. Thus
the McStas systems needs to be exible enough to simulate dierent kinds of instruments
(triple-axis, time-of-ight and possible hybrids) as well as many dierent kind of optical
components, and it must also be extensible so that future, as yet unforeseen, needs can
be satised.
Power \Simple things should be simple; complex things should be possible". New ideas
should be easy to try out; the time from thought to action should be as short as possible.
If you are faced with the prospect of programming for two weeks before getting any results
on a new idea, you will most likely drop it. Ideally, if you have a good idea at lunch, then
the simulation should be running in the afternoon.
E∆ciency Monte Carlo simulations are computationally intensive, hardware capacities
are nite (albeit impressive), and humans are impatient. Thus the system must assist in
producing simulations that run as fast as possible, without placing unreasonable burdens
on the user in order to achieve this.
1.2 The design of McStas
In order to meet its ambitious goals, it was decided that McStas should be based on
its own meta-language, specially designed for the needs of simulating neutron scattering
instruments. Simulations are written in this meta-language by the user, and the McStas
compiler automatically translates them into e∆cient simulation programs written in ANSI-
C.
In realizing the design of McStas, the task of doing simulations was separated into four
conceptual layers:
1. Modeling the physical processes of neutron scattering, i.e. the calculation of the
fate of a neutron that passes through the individual components of the instrument
(absorption, scattering at a particular angle, etc.)
2. Modeling of the overall instrument geometry, mainly consisting of the type and
position of the individual components.
Ris{R{1175(EN) 9

3. Accurate calculation, using Monte Carlo techniques, of instrument properties such
as resolution function from the result of ray tracing of a large number of neutrons.
This includes estimating the accuracy of the calculation.
4. Presentation of the calculations, graphical or otherwise.
Though obviously interrelated, these four layers can be usefully treated independently,
and this is reected in the overall system architecture of McStas. The user will in many
situations be interested in knowing the details only in some of the layers. For example,
one user may merely look at some results prepared by others, without worrying about the
details of the calculation. Another user might want to simulate a new instrument without
having to reinvent the code for simulating the individual components in the instrument.
A third user may write an intricate simulation of a complex analyser such as the one
in the RITA spectrometer, and expect other users to easily benet from his/her work,
and so on. McStas attempts to make it possible to work at any combination of layers in
isolation by separating the layers as much as possible in the design of the system and in
the meta-language in which simulations are written.
The usage of a special meta-language and an automatic compiler has several advan-
tages over writing a big monolithic program or a set of library functions in C, FORTRAN,
or another general-purpose programming language. The meta-language is more powerful ;
specications are much simpler to write and easier to read when the syntax of the speci-
cation language reects the problem domain. For example, the geometry of instruments
would be much more complex if it were specied in C code with static arrays and pointers.
The compiler can also take care of the low-level details of interfacing the various parts of
the specication with the underlying C implementation language and each other. This
way, users do not need to know about McStas internals to write new component or instru-
ment denitions, and even if those internals change in later versions of McStas, existing
denitions can be used without modication.
The McStas system also utilizes the meta-language to let the McStas compiler generate
as much code as possible automatically, letting the compiler handle some of the things
that would otherwise be the task of the user/programmer. Correctness is improved by
having a well-tested compiler generate code that would otherwise need to be specially
written and debugged by the user for every instrument or component. E∆ciency is also
improved by letting the compiler optimize the generated code in ways that would be
time-consuming or di∆cult for humans to do. And the compiler can generate several
dierent simulations from the same specication, for example to optimize the simulations
in dierent ways, to generate a simulation that graphically displays neutron trajectories,
and possibly other things in the future that were not even considered when the original
instrument specication was written.
The design of McStas makes it well suited for doing \what if. . . " types of simulations.
Once an instrument has been dened, questions such as \what if a slit was inserted", \what
if a focusing monochromator was used instead of a at one", \what if the sample was oset
2 mm from the center of the axis" and so on are easy to answer; in a matter of minutes
the instrument denition can be modied and a new simulation program generated. It
also makes it simple to debug new components in isolation. A test instrument denition is
written containing a neutron source, the component to be tested, and whatever detectors
10 Ris{R{1175(EN)

are useful, and the component can be thoroughly tested before being used in a complex
simulation with many dierent components.
The McStas system is based on ANSI-C, making it both e∆cient and portable. The
meta-language allows the user to embed arbitrary C code in the specications. Flexibility
is thus ensured since the full power of the C language is available if needed.
1.3 Overview
The McStas system consists of the following major parts:
 The McStas compiler. Section 2.3 explains how to compile and install the compiler
and associated les, while section 2.4 explains how to run the compiler to produce
simulations. Section 2.5 explains how to run the generated simulations.
 The McStas meta-language, described in chapter 3. This chapter also describes a
library of kernel functions and denitions that aid in the writing of simulations.
 The McStas component library. A collection of already written, well-tested optical
components that can be used in simulations. This library is documented in detail in
chapter 5. Code for the components can be found in appendix B.
 A collection of example instrument denitions, described in chapter 6, with source
code given in appendix C.
 A number of front-end programs that are used to run the generated simulations
and aid in the data collection and analysis from the results. These are described in
section 2.6
In addition, some of the results that have been obtained from simulations produced
with McStas are described in appendix D. An explanation of McStas terminology can be
found in appendix E. Some planned extensions are listed in chapter 7, and a list of library
calls that are used in component denitions appears in appendix A.
Ris{R{1175(EN) 11

Chapter 2
Running McStas
This chapter describes the installation and use of the McStas software. The software
should compile without problems on most Unix-like systems with an ANSI compliant C
compiler. It has also been successfully compiled on Windows and Macintosh systems, but
these platforms are currently not actively supported. In case of problems, the McStas
mailing list [1] or the authors should be contacted.
To use McStas one rst writes an instrument denition le which describes the in-
strument to be simulated (or obtains a denition from the examples/ directory in the
distribution or from another source). This is then compiled with the McStas compiler to
produce a C program. The C program can then be compiled with a C compiler and run in
combination with various front-end programs to for example output the intensity at the
detector as a motor position is varied.
2.1 Using the graphical user interface
This section gives an ultra-brief overview of how to use McStas once it has been prop-
erly installed. It is intended for those who do not read manuals if they can avoid
it. For details on the dierent steps, see the following sections. This section uses the
vanadium_example.instr le supplied in the examples/ directory of the McStas distri-
bution, see appendix C.1.
To start the graphical user interface of McStas, run the command mcgui. This will
open a window with some menus etc, see gure 2.1.
To load an instrument, select \Open instrument" from the \File" menu. Open the le
vanadium_example.instr in the McStas distribution. Select \Run simulation" from the
\Simulation" menu. McStas will translate the denition into an executable program and
pop up a dialog window. Type a value for the \ROT" parameter (eg. 90), check the \Plot
results" option, and select \Start". The simulation will run, and when it nishes after a
while the results will be plotted in a window.
To debug the simulation graphically, repeat the steps but check the \Trace" option
instead of the \Simulate" option. A window will pop up showing a sketch of the instrument.
The left mouse button starts a new neutron, the middle button zooms, and the right button
resets the zoom. The Q key quits.
For a slightly longer gentle introduction to McStas, see the McStas tutorial (available
12 Ris{R{1175(EN)

Figure 2.1: The graphical user interface mcgui.
from [1]).
2.2 Obtaining McStas
The source code for McStas may be obtained from Ris on a CD-Rom, or it may be
downloaded from the McStas WWW home page [1]. In either case, the source should
be available in a le named mcstas.tar.gz (the CD-Rom also contains this le under
the name mcstas.tgz for systems that do not understand long lenames, as well as the
unpacked sources in the directory mcstas/).
The conditions on the use of McStas can be read in the les LICENSE and LICENSE.LIB
in the distribution. Essentially, McStas may be used freely, but copies of McStas may not
be passed on to others. We are considering releasing future versions of McStas under a
more liberal license.
2.3 Compiling McStas from source
Compilation and installation of McStas proceeds in three simple steps. First, the sources
must be unpacked:
gunzip -c mcstas.tar.gz | tar xf -
cd mcstas/
Next, the configure script must be run to congure McStas for the particular machine
and operating system, and the software must be compiled:
./configure
make
Finally, McStas must be installed:
Ris{R{1175(EN) 13

make install
By default, McStas will be installed in the usr/local/ directory (this typically requires su-
peruser privileges). To install in another directory, the --prefix option of the configure
script can be used. For example, to install in /home/joe instead:
./configure --prefix=/home/joe
make
make install
Depending on which directory McStas is installed in, it may be necessary to add the bin/
subdirectory of the installation directory to the default path, or to run McStas with the
full pathname of the program (/usr/local/bin/mcstas by default).
The configure command will guess some reasonable defaults for the C compiler to
use. These will be used to compile McStas itself as well as the simulations produced
by McStas. To override 1 the defaults, the environment variables CC and CFLAGS can be
set to the le name of the compiler to use and any special compiler options needed (for
example to enable optimization), respectively. After installation, each user may override
the settings using the environment variables MCSTAS_CC and MCSTAS_CFLAGS.
McStas has been tested on x86 Linux, Digital Unix, and HPUX. It should run on most
other Unix-like systems without trouble. The main thing to ensure is that an ANSI-C
compliant compiler is available (GCC works well). In case any di∆culties arise, the authors
should be contacted so that the problems may be xed in a later release of McStas.
To use the McStas front-end programs (see section 2.6), certain auxiliary packages must
be installed, as described in the README le in the distribution. These packages are all
freely available, and have been included on the McStas CD-Rom and on the WWW home
page. Some of these packages may be supplied with the operating system; for example,
all needed packages are included with Debian/GNU Linux [6].
Note that the core parts of McStas, including the McStas compiler and any generated
simulations, can work with no additional software apart from an ANSI-C compiler.
2.4 Running the instrument compiler
This section describes how to run the McStas compiler manually. Often, it will be more
convenient to use the front-end program mcgui (section 2.6.1) or mcrun (section 2.6.2).
These front-ends will compile and run the simulations automatically.
The compiler for the McStas instrument denition is invoked by typing a command of
the form
mcstas name.instr
This will read the instrument denition name.instr which must be written in the McStas
meta-language. The compiler will translate the instrument denition into a Monte-Carlo
simulation program written in ANSI-C. The output is by default written to a le in the
current directory with the same name as the instrument le, but with extension .c rather
than .instr. This can be overridden using the -o option as follows:
1 It may be necessary to remove the le config.cache before re-installing McStas to have the new
settings take eect
14 Ris{R{1175(EN)

mcstas -o code.c name.instr
This writes the output to the le code.c. A single dash `-' may be used for both input
and output lename to represent standard input and standard output, respectively.
2.4.1 Code generation options
By default, the output les from the McStas compiler are in ANSI-C with some extensions
(currently the only extension is the creation of new directories, which is not possible in
pure ANSI-C). The use of extensions may be disabled with the -p or --portable option.
With this option, the output is strictly ANSI-C compliant, at the cost of some slight
reduction in capabilities.
The -t or --trace option puts special \trace" code in the output. This code makes it
possible to get a complete trace of the path of every neutron through the instrument, as
well as the position and orientation of every component. This option is mainly used with
the mcdisplay front-end, described in section 2.6.4.
The code generation options can also be controlled by using preprocessor macros in the
C compiler, without the need to re-run the McStas compiler. If the preprocessor macro
MC_PORTABLE is dened, the same result is obtained as with the --portable option of
the McStas compiler. The eect of the --trace option may be obtained by dening the
MC_TRACE_ENABLED macro. Most Unix-like C compilers allow preprocessor macros to be
dened using the -D option, eg.
cc -DMC_TRACE_ENABLED -DMC_PORTABLE ...
2.4.2 Specifying the location of les
The McStas compiler needs to be able to nd various les during compilation, some
explicitly requested by the user (such as component denitions and les referenced by
%include), and some used internally to generate the simulations. McStas looks for these
les in three places: rst in the current directory, then in a list of directories given by the
user, and nally in a special McStas directory. Usually, the user will not need to worry
about this as McStas will automatically nd the required les. But if users build their
own component library in a separate directory, or if McStas is installed in an unusual way,
it will be necessary to tell the compiler where to look for les.
The location of the special McStas directory is set when McStas is compiled. It defaults
to /usr/local/lib/mcstas, but it can be changed to something else if necessary, see
section 2.3 for details. The location can be overridden by setting the environment variable
MCSTAS:
setenv MCSTAS /home/joe/mcstas
for csh/tcsh users, or
export MCSTAS=/home/joe/mcstas
for bash/Bourne shell users.
To make McStas search additional directories for component denitions and include
les, use the -I switch for the McStas compiler:
Ris{R{1175(EN) 15

mcstas -I/home/joe/components -I/home/joe/neutron/include name.instr
Multiple -I options can be given, as shown.
2.4.3 Embedding the generated simulations in other programs
By default, McStas will generate a stand-alone C program, which is what is needed in
most cases. However, for advanced usage, such as embedding the generated simulation
in another program or even including two or more simulations in the same program, a
stand-alone program is not appropriate. For such usage, the McStas compiler provides
the following options:
 --no-main This option makes McStas omit the main() function in the generated
simulation program. The user must then arrange for the function mcstas_main()
to be called in some way.
 --no-runtime Normally, the McStas compiler copies into the generated simulation
program all the run-time C code necessary for declaring functions, variables, etc.
used during the simulation. This option makes McStas omit the run-time code from
the generated simulation program; the user must then explicitly link with the le
mcstas-r.c from the McStas distribution.
Users that need these options are encouraged to contact the authors for further help; see
page 7 for contact addresses.
2.4.4 Running the C compiler
After the source code for the simulation program has been generated with the McStas
compiler, it must be compiled with the C compiler to produce an executable. The gen-
erated C code obeys the ANSI-C standard, so it should be easy to compile it using any
ANSI-C (or C++) compiler. E.g. a typical Unix-style command would be
cc -O -o name.out name.c -lm
The -O option typically enables the optimization phase of the compiler, which can make
quite a dierence in speed of McStas generated simulations. The -o name.out sets the
name of the generated executable. The -lm options is needed on many systems to link in
the math runtime library (like the cos() and sin() functions).
Monte Carlo simulations are computationally intensive, and it is often desirable to
have them run as fast as possible. Some success can be had in this respect by adjusting
the compiler optimization options. Here are some example platform and compiler combi-
nations that have been found to perform well (up-to-date information will be available on
the McStas WWW home page [1]):
 Intel x86 (\PC") with Linux and GCC, using options gcc -O3.
 Intel x86 with Linux and EGCS (GCC derivate) using options egcc -O6.
 Intel x86 with Linux and PGCC (pentium-optimized GCC derivate), using options
gcc -O6 -mstack-align-double.
16 Ris{R{1175(EN)

 HPPA machines running HPUX with the optional ANSI-C compiler, using the op-
tions -Aa +Oall -Wl,-a,archive (the -Aa option is necessary to enable the ANSI-C
standard).
A warning is in place here: it is tempting to spend far more time ddling with compiler
options and benchmarking than is actually saved in computation times. Even worse,
compiler optimizations are notoriously buggy; the options given above for PGCC on Linux
and the ANSI-C compiler for HPUX have been known to generate incorrect code in some
compiler versions. McStas actually puts an eort into making the task of the C compiler
easier, by in-lining code and using variables in an e∆cient way. As a result, McStas
simulations generally run quite fast, often fast enough that further optimizations are not
worthwhile.
2.5 Running the simulations
Once the simulation program has been generated by the McStas compiler and an exe-
cutable has been obtained with the C compiler, the simulation can be run in various ways.
The simplest is to run it directly from the command line or shell:
./name.out
Note the leading dot, which is needed if the current directory is not in the path searched
by the shell. When used in this way, the simulation will prompt for the values of any
instrument parameters such as motor positions, and then run the simulation and output
the results. This will output only a single data point compared to the tens of points
usually needed in a scan (such as of motor positions in a triple-axis instrument). Often
the simulation will be run using one of several available front-ends, as described in the
next section. These front-ends help manage output from the potentially many detectors
in the instruments, as well as running the simulation for each data point in a scan.
The generated simulations accept a number of options and arguments. The full list
can be obtained using the --help option:
./name.out --help
The values of instrument parameters may be specied as arguments using the syntax
name=val. For example
./vanadium_example.out ROT=90
The number of neutron histories to simulate may be set using the --ncount or -n option,
for example --ncount=2e5. The initial seed for the random number generator is by default
chosen based on the current time so that it is dierent for each run. However, for debugging
purposes it is sometimes convenient to use the same seed for several runs, so that the same
sequence of random numbers is used each time. To achieve this, the random seed may be
set using the --seed or -s option.
By default, McStas simulations write their results into several data les in the current
directory, overwriting any previous les stored there. The --dir=dir or -ddir option
causes the les to be placed instead in a newly created directory dir ; to prevent overwriting
Ris{R{1175(EN) 17

-s seed
--seed=seed
Set the initial seed for the random number generator. This may
be useful for testing to make each run use the same random
number sequence.
-n count
--ncount=count
Set the number of neutron histories to simulate. The default is
1,000,000.
-d dir
--dir=dir
Create a new directory dir and put all data les in that direc-
tory.
-f le
--file=le
Write all data into a single le le
-a
--ascii-only
Do not put any headers in the data les.
-h
--help
Show a short help message with the options accepted, including
the names of the parameters of the instrument.
-i
--info
Show extensive information on the simulation and the instru-
ment denition it was generated from.
-t
--trace
This option makes the simulation output the state of every
neutron as it passes through every component. Requires that
the -t (or --trace) option is also given to the McStas compiler
when the simulation is generated.
--no-output-files This option disables the writing of data les (output to the
terminal, such as detector intensities, will still be written).
param=value Set the value of an instrument parameter, rather than having
to prompt for each one.
Table 2.1: Options accepted by McStas generated simulations
previous results it is an error if the directory already exists. Alternatively, all output may
be written instead to a single le le using the --file=le or -fle option.
By default, data les contain header lines with information about the simulation from
which they originate. In case the data must be analyzed with programs that cannot read
les with such headers, they may be turned o using the --ascii-only or -a option.
The format of the output les from McStas simulations is described in more detail in
section 2.7. The complete list of options and arguments accepted by McStas simulations
appears in table 2.1.
2.6 Using simulation front-ends
McStas includes a number of front-end programs that extend the functionality of the
generated simulations. The front-end programs sit between the user and the simulations,
running the simulations and presenting the output in various ways to the user.
An extended set of front-end programs is planned for future versions of McStas, in-
cluding a NeXus data format option [7].
18 Ris{R{1175(EN)

2.6.1 The graphical user interface
The front-end mcgui provides a graphical user interface that interfaces the various parts
of the McStas package. It is started using simply the command
mcgui
The program may optionally be given the name of a simulation denition to load.
When the front-end is started, a main window is opened. This window displays the
output from compiling and running simulations, and also contains a few menus and but-
tons. The main purpose of the front-end is to edit and compile instrument denitions, run
the simulations, and visualize the results.
The menus
The \File" menu has the following features:
Open instrument This selects the name of an instrument le to use for other operations.
Edit current This opens a simple editor window for editing the current instrument def-
inition. This function is also available from the \Edit" button to the right of the
name of the instrument denition in the main window.
Spawn editor This starts the editor dened in the environment variable VISUAL or
EDITOR on the current instrument le. It is also possible to start an external editor
manually; in any case mcgui will recompile instrument denitions as necessary based
on the modication dates of the les on the disk.
Compile instrument This forces a recompile of the instrument denition, regardless of
le dates. This is for example useful to pick up changes in component denitions,
which the front-end will not notice automatically. See section 2.3 for how to override
which C compiler and options are used to compile simulations.
Clear output This erases all text in the window showing output of compilations and
simulations.
Quit Exit the graphical user interface front-end.
The \Simulation" menu has the following features:
Read old simulation This prompts for the name of a le from a previous run of a McStas
simulation (usually called mcstas.sim). The le will be read and any detector data
plotted using the mcplot front-end. The parameters used in the simulation will also
be made the defaults for the next simulation run. This function is also available
using the \Read" button to the right of the name of the current simulation data.
Run simulation This opens the run dialog window, explained further below.
Plot results This plots (using mcplot) the results of the last simulation run or loaded.
The \Help" menu has a single menu point, \McStas web page", which attempts to open
a Netscape window with the McStas home page. This obviously requires that Netscape is
properly installed on the computer.
Ris{R{1175(EN) 19

The run dialog
Figure 2.2: The run dialog in mcgui.
The run dialog is used to run simulations. It allows the entry of instrument parameters
as well as the specications of options for running the simulation (see section 2.5 for
details). It also allows to run the mcdisplay (section 2.6.4) and mcplot (section 2.6.5)
front-ends together with the simulation.
The meaning of the dierent elds is as follows:
Instrument parameters This allows the setting of the values for the input parameters of
the instrument. The type of each instrument parameter is given in parenthesis after
each name. Floating point numbers are denoted by (D) (for the C type \double"),
(I) denotes integer parameters, and (S) denotes strings.
Output to This allows the entry of a directory to store the resulting data les in (like
the --dir option). If no name is given, the results are put in the current directory,
to be overwritten by the next simulation.
Neutron count This sets the number of neutron histories to simulate (the --ncount
option).
Plot results If checked, the mcplot front-end will be run after the simulation has nished,
and the plot dialog will pop up (see below).
Random seed/Set seed to This selects between using a random seed (dierent in each
simulation) for the random number generator, or using a xed seed (to reproduce
results for debugging).
Simulate/Trace This selects between running the simulation normally, or using the
mcdisplay front-end.
Start Run the simulation.
Cancel Abort the dialog.
Before running the simulation, the instrument denition is automatically compiled if it
is newer that the generated C le (or if the C le is newer than the executable simulation).
The executable simulation is assumed to have a .out su∆x in the lename.
20 Ris{R{1175(EN)

The plot dialog
Monitors and detectors This lists all the one- and two-dimensional detectors in the
instrument. Double-clicking one plots the data in the plot window.
Plot This plots the selected detector in the plot window, just like double-clicking its
name.
Overview plot This plots all the detectors together in the plot window.
B&W postscript This prompts for a le name and saves the current plot as a black and
white postscript le. This can subsequently be printed on a postscript printer.
Colour postscript This creates a colour postscript le of the current plot.
Close This ends the dialog.
The editor window
The editor window provides a simple editor for creating and modifying instrument deni-
tions. Apart from the usual editor functions, the \Insert" menu provides some functions
that aid in the construction of the instrument denitions:
Instrument template This inserts the text for a simple instrument skeleton in the editor
window.
Component. . . This opens up a dialog window with a list of all the components available
for use in McStas. Selecting a component will display a description. Double-clicking
will open up a dialog window allowing the entry of the values of all the parameters
for the component (gure 2.3). See section 3.3 for details of the meaning of the
dierent elds.
The dialog will also pick up those of the users own components that are present
in the current directory when mcgui is started. See section 3.4.8 for how to write
components to integrate well with this facility.
Type These menu entries give quick access to the entry dialog for the various components
available.
To use the mcgui front-end, the programs Perl, Perl/Tk, PGPLOT, PgPerl, and PDL
must all be properly installed on the system. It may be necessary to set the PGPLOT_DIR
environment variable; consult the documentation for PGPLOT on the local system in case
of di∆culty.
2.6.2 Running simulations with automatic compilation
The mcrun front-end provides a more convenient command-line interface for running sim-
ulations with the same automatic compilation features available in the mcgui front-end. It
also provides a facility for running a series of simulations while varying an input parameter,
thereby replacing the old gscan front-end.
The command
Ris{R{1175(EN) 21

Figure 2.3: Component parameter entry dialog.
mcrun sim args ...
will compile the instrument denition sim.instr (if necessary) into an executable simu-
lation sim.out. It will then run sim.out, passing the argument list args
The possible arguments are the same as those accepted by the simulations themselves
as described in section 2.5, with the following extensions:
 The -c or --force-compile option may be used to for the recompilation of the
instrument denition, regardless of le dates. This may be needed in case any
component denitions are changed (in which case mcrun does not automatically
recompile), or if a new version of McStas is installed.
 The -p le or --param=le option may be used to specify a le containing assign-
ment of values to the input parameters of the instrument denition. The le should
consist of specications of the form name=value separated by spaces or line breaks.
Multiple -p options may be given together with direct parameter specications on
the command line; if a parameter is assigned multiple times, later assignments over-
ride previous ones.
 The -N count or --numpoints=count option may be used to perform a series of count
simulations while varying one or more parameters within specied intervals. Such
a series of simulations is called a scan. To specify an interval for a parameter X, it
should be assigned two values separated with a comma. For example, the command
mcrun sim.instr -N4 X=2,8 Y=1
would run the simulation dened in sim.instr four times, with X having the values
2, 4, 6, and 8, respectively.
22 Ris{R{1175(EN)

After running the simulation, the results will be written to the le mcstas.dat by
default. This le contains one line for each simulation run giving the values of the
scanned input variables along with the intensity and estimated error in all detectors.
Additionally, a le mcstas.sim is written that can be read by the mcplot front-end
to plot the results on the screen or in a Postscript le, see section 2.6.5.
 When doing a scan, the -f le and --file=le options make mcrun write the output
to the les le.dat and le.sim instead of the default names.
 When doing a scan, the -d dir and --dir=dir options make mcrun put all output
in a newly created directory dir. Additionally, the directory will have subdirectories
1, 2, 3,. . . containing all data les output from the dierent simulations. When the
-d option is not used, no data les are written from the individual simulations (in
order to save disk space).
The mcrun front-end requires a working installation of Perl to run.
2.6.3 The gscan front-end
The front-end gscan is obsolete from version 1.3 of McStas, and is included only for
backwards compatibility. The front-end mcrun (sertion 2.6.2) includes all the functionality
of the old gscan front-end and may be used instead.
2.6.4 Graphical display of simulations
The front-end mcdisplay is a graphical debugging tool. It presents a schematic drawing
of the instrument denition, showing the position of the components and the paths of
the simulated neutrons through the instrument. It is thus very useful for debugging a
simulation, for example to spot components in the wrong position or to nd out where
neutrons are getting lost. The graphics is shown on an X Windows display.
To use the mcdisplay front-end with a simulation, run it as follows:
mcdisplay sim.out args . . .
where sim is the name of the simulation program generated with McStas and args . . . are
the normal command line arguments for the simulation, as explained under gscan. This
will view the instrument from above. A multi-display that shows the instrument from
three directions simultaneously can be shown using the --multi option:
mcdisplay --multi sim.out args . . .
The mcdisplay front-end can also be run from the mcgui front-end.
Click the left mouse button in the graphics window or hit the space key to see the
display of successive neutron trajectories. The `P' key saves a postscript le containing
the current display that can be sent to the printer to obtain a hardcopy; the `C' key
produces color postscript for those fortunate enough to have a color printer. To stop
the simulation prematurely, type `Q' or use control-C as normal in the window in which
mcdisplay was started.
To see details in the instrument, it is possible to zoom in on a part of the instrument
using the middle mouse button (or the `Z' key on systems with a one- or two-button
Ris{R{1175(EN) 23

mouse). The right mouse button (or the `X' key) resets the zoom. Note that after
zooming, the units on the dierent axes may no longer be equal, and thus the angles as
seen on the display may not match the actual angles.
Another way to see detail while maintaining an overview of the instrument is to use the
--zoom=factor option. This magnies the display of each component along selected axis
only, eg. a Soller collimator is magnied perpendicular to the neutron beam but not along
it. This option may produce rather strange visual eects as the neutron passes between
components with dierent coordinate magnications, but it is occationally useful.
When debugging, it is often the case that one is interested only in neutrons that reach
a particular component in the instrument. For example, if there is a problem with the
sample one may prefer not to see the neutrons that are absorbed in the monochromator
shielding. For these cases, the --inspect=comp option is useful. With this option, only
neutrons that reach the component named comp are shown in the graphics display.
See section 3.4.6 for how to make new components work with the mcdisplay front-end.
The mcdisplay front-end requires the Perl, the PGPLOT, and the PGPerl packages to
work.
2.6.5 Plotting the results of a simulation
The front-end mcplot is a program that produces plots of all the detectors in a simulation,
and it is thus useful to get a quick overview of the simulation results.
In the simplest case, the front-end is run simply by typing
mcplot
This will plot any simulation data stored in the current directory, which is where simu-
lations put their results by default. If the --dir or --file options have been used (see
section 2.5), the name of the le or directory should be passed to mcplot, eg. \mcplot
dir" or \mcplot le".
The initial display shows plots for each detector in the simulation. Clicking the left
mouse button on a plot produces a full-window version of that plot. The `P' key saves
a postscript le containing the current plot that can be sent to the printer to obtain a
hardcopy; the `C' key produces color postscript for those fortunate enough to have a color
printer. The `Q' key quits the program (or CTRL-C in the controlling terminal may be
used as normal).
To use the mcplot front-end, the programs Perl, PGPLOT, PgPerl, and PDL must all
be properly installed on the system.
2.6.6 Plotting resolution functions
The mcresplot front-end is used to plot the resolution function of a triple-axis or inverse
geometry time-of-ight spectrometer, as calculated by the Res sample component (see
section 5.8.1). This front-end is still experimental, however it has been included in the
release since it may be useful despite its somewhat rough user interface.
The mcresplot front-end is run with the command
mcresplot le
24 Ris{R{1175(EN)

Here, le is the name of a le output from a simulation using the Res monitor component
(section 5.5.13). The front-end will open two windows. One shows a three-dimensional
visualization of the resolution function using the two components of Q in the scattering
plane and !. The plot may be rotated using the mouse while pressing the left button, and
zoomed while pressing the right button.
The other window displays the covariance matrix of the resolution function and the re-
sulting resolution matrix. This is mainly useful for triple-axis spectrometers. The bottom
four plots visualize the covariance matrix using four dierent projections. The top left
corner shows histograms of the resolution function along the three axes of Q and along
the ! axis.
Pressing the \Q" key while the three-dimensional window is active switches to a com-
bined plot where the yellow dots show the resolution function and the red dots show the
covariance matrix. A second press of the \Q" key ends the front-end program.
To use the mcresplot front-end, the programs Perl, PGPLOT, PgPerl, and PDL must
all be properly installed on the system.
2.7 Analyzing and visualizing the simulation results
To analyze simulation results, one uses the same tools as for analyzing experimental data,
i.e. programs such as the MATLAB packages Mview and Mt [8] used at Ris. The output
les from simulations are simply columns of ASCII text that most programs should be
able to read. A future version of McStas will support output in the NeXus format [7].
One-dimensional histogram detectors (time-of-ight, energy-sensitive) write one line
for each histogram bin. Each line contains a number identifying the bin (i.e. the time-of-
ight) followed by three numbers: The simulated intensity, an estimate of the statistical
error as explained in section 4.1.1, and the number of neutron events for this bin.
Two-dimensional histogram detectors (position sensitive detectors) output M lines of
N numbers representing neutron intensities, where M and N are the number of bins in the
two dimensions. The two-dimentional detectors do not store any error estimates since this
is seldom useful, however if needed it can be obtained using MC_GETPAR in the FINALLY
section of the instrument denition, see section 3.4.2.
Single-point detectors output the neutron intensity, the estimated error, and the neu-
tron event count as numbers on the terminal. (The results from a series of simulations
may be combined in a data le using the gscan front-end as explained in section 2.6.3).
Both one- and two-dimentional detector output by default start with a header of com-
ment lines, all beginning with the `#' character. This header gives such information as the
name of the instrument used in the simulation, the values of any instrument parameters,
the name of the detector component for this data le, etc. The headers may be disabled
using the --ascii-only option in case the le must be read by a program that cannot
handle the headers.
In addition to the les written for each one- and two-dimensional detector component,
another le (by default named mcstas.sim) is also created. This le is in a special
McStas ASCII format. It contains all available information about the instrument denition
used for the simulation, the parameters and options used to run the simulation, and the
detector components present in the instrument. It is read by the mcplot front-end (see
Ris{R{1175(EN) 25

section 2.6.5). This le stores the results from single detectors, but by default contains
only pointers (in the form of le names) to data for one- and two-dimensional detectors.
By storing data in separate les, reading the data with programs that do not know the
special McStas le format is simplied. The --file option may be used to store all data
inside the mcstas.sim le instead of in separate les.
Note that the neutron event counts in detectors is typically not very meaningful except
as a way to measure the performance of the simulation. Use the simulated intensity instead
whenever analysing simulation data.
26 Ris{R{1175(EN)

Chapter 3
The McStas kernel and
meta-language
Instrument denitions are written in a special McStas meta-language which is translated
automatically by the McStas compiler into a C program that performs the simulation. The
meta-language is custom-designed for neutron scattering and serves two main purposes:
to specify the interaction of a single neutron with a single optical component, and to build
a simulation by constructing a complete instrument from individual components.
For maximum exibility and e∆ciency, the meta-language is based on C. Instrument
geometry, propagation of neutrons between the dierent components, parameters, data
input/output etc. is handled in the meta-language and by the McStas compiler. Com-
plex calculations are done by C code embedded in the meta-language description of the
components. It is possible to set up an instrument from existing components and run a
simulation without writing a single line of C code, working entirely in the meta-language.
On the other hand, the full power of the C language is available for special-purpose setups
in advanced simulations, and for computing neutron trajectories in the components.
Apart from the meta-language proper, McStas also includes a number of C library
functions and denitions that are useful for ray-tracing simulations, listed in appendix A.
This includes functions for computing the intersection between a neutron ight-path and
various objects (such as cylinders and spheres), functions for generating random numbers
with various distributions, convenient conversion factors between relevant units, etc.
The McStas meta-language was designed to be readable, with a verbose syntax and
explicit mention of otherwise implicit information. The recommended way to get started
with the meta-language is to start by looking at the examples supplied with McStas,
modifying them as necessary for the application at hand.
3.1 Notational conventions
Simulations generated by McStas use a semi-classical description of the neutron to com-
pute the neutron trajectory through the instrument and its interaction with the dierent
components. In the current version of McStas the eect of gravity is not taken into ac-
count by the existing components, though it is perfectly possible to handle gravity in
user-written components if so desired.
Ris{R{1175(EN) 27

z
x
y
Figure 3.1: conventions for the orientations of the axis in simulations.
An instrument consists of a list of components through which the neutron passes one
after the other. Thus the order of components is signicant; McStas does not automatically
check which component is the next to interact with the neutron at a given point in the
simulation.
The instrument is given a global, absolute coordinate system. In addition, every
component in the instrument has its own local coordinate system that can be given any
desired position and orientation (though the position and orientation must remain xed
for the duration of a single simulation). By convention, the z axis points in the direction
of the beam, the x axis is perpendicular to the beam in the horizontal plane pointing left
as seen from the source, and the y axis points upwards. See gure 3.1. Nothing in McStas
enforces this convention, but if every component used dierent conventions the user would
be faced with a severe headache! So it is recommended that the convention be followed if
at all possible.
In the instrument denitions, units of length (e.g. component positions) are given in
meters and units of angles (e.g. rotations) are given in degrees. The state of the neutron
is given by its position (x; y; z) in meters, its velocity (v x ; v y ; v z ) in meters per second,
the time t in seconds, and the spin 1 s 1 ; s 2 having no dimension. In addition, the outgoing
neutron has an associated weight p which is used to model fractional neutrons in the
Monte Carlo simulation (so p = 0:2 means that a neutron following this path has a 20%
chance of reaching the present position without being absorbed or scattered away from
the instrument).
3.2 Syntactical conventions
Comments follow the normal C syntax \/* ... */". C++ style comments \// ..." may
also be used.
Keywords are not case-sensitive, so for example \DEFINE", \define", and \dEfInE"
1 The spin is ignored in the current version 1.4 of McStas. However, while not documented in this
manual, preliminary support for components that handle the neutron spin is implemented using the PO-
LARISATION PARAMETER construct. We are currently working together with Trefor Roberts at the
ILL to get a correct handling of the spin.
28 Ris{R{1175(EN)

are all equivalent. However, by convention we always write keywords in uppercase to
distinguish them from identiers and C language keywords. In contrast, McStas identiers,
like C identiers and keywords, are case sensitive, another good reason to use a consistent
case convention for keywords.
It is possible, and usual, to split the input instrument denition across several dierent
les. For example, if a component is not explicitly dened in the instrument, McStas will
search for a le containing the component denition in the standard component library (as
well as in the current directory and any user-specied search directories, see section 2.4.2).
It is also possible to explicitly include another le using a line of the form
%include "file"
Beware of possible confusion with the C language \#include" statement, especially when
it is used in C code embedded within the McStas meta-language. Files referenced with
\%include" are read when the instrument is translated into C by the McStas compiler,
and must contain valid McStas meta-language input. Files referenced with \#include"
are read when the C compiler generates an executable from the generated C code, and
must contain valid C.
Embedded C code is used in several instances in the McStas meta-language. Such code
is copied by the McStas compiler into the generated simulation C program. Embedded C
code is written by putting it between the special symbols %{ and %}, as follows:
%{
. . . Embedded C code . . .
%}
The \%{" and \%}" must appear on a line by themselves.
3.3 Writing instrument denitions
The purpose of the instrument denition is to specify a sequence of components, along with
their position and parameters, which together make up an instrument. Each component
is given its own local coordinate system, the position and orientation of which may be
specied by its translation and rotation relative to another component. Some complete
examples of instrument denitions can be found in appendix C.
An instrument denition looks as follows:
3.3.1 The instrument denition head
DEFINE INSTRUMENT name (a 1 ; a 2 ; : : :)
This marks the beginning of the denition. It also gives the name of the instrument
and the list of instrument parameters. Instrument parameters describe the conguration
of the instrument, and usually correspond to setting parameters of the components. A
motor position is a typical example of an instrument parameter. The input parameters of
the instrument constitute the input that the user (or possibly a front-end program) must
supply when the generated simulation is run.
Ris{R{1175(EN) 29

By default, the parameters will be oating point numbers, and will have the C type
double (double precision oating point). The type of each parameter may optionally be
declared to be int for the C integer type or char * for the C string type. The name string
may be used as a synonym for char *, and oating point parameters may be explicitly
declared using the name double. The following example illustrates all possibilities:
DEFINE INSTRUMENT tst(d1, double d2, int i, char *s1, string s2)
Here d1 and d2 will be oating point parameters of C type double, i will be an integer
parameter of C type int, and s1 and s2 will be string parameters of C type char *.
3.3.2 The DECLARE section
DECLARE
%{
. . . C declarations of global variables etc. . . .
%}
This gives C declarations that may be referred in the rest of the instrument denition. A
typical use is to declare global variables or small functions that are used elsewhere in the
instrument. This section is optional.
3.3.3 The INITIALIZE section
INITIALIZE
%{
. . . C initializations. . . .
%}
This gives code that is executed when the simulation starts. This section is optional.
3.3.4 The TRACE section
The TRACE keyword starts a section giving the list of components that constitute the
instrument. Components are declared like this:
COMPONENT name = comp(p 1 = e 1 ; p 2 = e 2 ; : : :)
This declares a component named name that is an instance of the component denition
named comp. The parameter list gives the setting and denition parameters for the
component. The expressions e 1 ; e 2 ; : : : dene the values of the parameters. For setting
parameters arbitrary ANSI C expressions may be used, while for denition parameters
only constant numbers, strings, names of instrument parameters, or names of C identiers
are allowed (see section 3.4.1 for details of the dierence between denition and setting
parameters). To assign the value of a general expression to a denition parameter, it is
necessary to declare a variable in the DECLARE section, assign the value to the variable in
the INITIALIZE section, and use the variable as the value for the parameter.
The McStas program takes care to rename parameters appropriately in the output so
that no conicts occur between dierent component denitions or between component and
30 Ris{R{1175(EN)

instrument denitions. It is thus quite possible (and usual) to use a component denition
multiple times in an instrument description.
The McStas compiler will automatically search for a le containing a denition of the
component if it has not been previously declared. The denition is searched for in a le
called \name.comp", \name.cmp", or \name.com". See section 2.4.2 for details on which
directories are searched. This facility is often used to refer to existing component deni-
tions in standard component libraries. It is also possible to write component denitions in
the main le before the instrument denitions, or to explicitly read denitions from other
les using %include.
The position of a component is specied using an AT modier following the component
declaration:
AT (x; y; z) RELATIVE name
This places the component at position (x; y; z) in the coordinate system of the previ-
ously declared component name. Placement may also be absolute (not relative to any
component) by writing
AT (x; y; z) ABSOLUTE
Any C expression may be used for x, y, and z. The AT modier is required.
Rotation is achieved similarly by writing
ROTATED ( x ;  y ;  z ) RELATIVE name
This will result in a coordinate system that is rotated rst the angle  x (in degrees) around
the x axis, then  y around the y axis, and nally  z around the z axis. Rotation may also
be specied using ABSOLUTE rather than RELATIVE. If no rotation is specied, the default
is (0; 0; 0) using the same relative or absolute specication used in the AT modier.
3.3.5 The FINALLY section
FINALLY
%{
. . . C code to execute at end of simulation . . .
%}
This gives code that will be executed when the simulation has ended.
3.3.6 The end of the instrument denition
The end of the instrument denition is marked using the keyword
END
Ris{R{1175(EN) 31

3.4 Writing component denitions
The purpose of a component denition is to model the interaction of a neutron with the
component. Given the state of the incoming neutron, the component denition calculates
the state of the neutron when it leaves the component. The calculation of the eect of
the component on the neutron is performed by a block of embedded C code. Complete
examples of component denitions can be found in appendix B.
A component denition looks as follows:
3.4.1 The component denition header
DEFINE COMPONENT name
This marks the beginning of the denition, and denes the name of the component.
DEFINITION PARAMETERS (d 1 ; d 2 ; : : :)
SETTING PARAMETERS (s 1 ; s 2 ; : : :)
This declares the denition and setting parameters of the component. The parame-
ters dene the characteristics of the component, and can be accessed from the DECLARE,
INITIALIZE, TRACE, FINALLY, and MCDISPLAY sections (see below).
Setting parameters are translated into C variables of type double in the generated
simulation program, so they can only be numbers. Denition parameters are translated
into #define macro denitions, and so can have any type, including strings, arrays, and
function pointers.
However, because of the use of #define, denition parameters suer from the usual
problems with C macro denitions. Also, it is not possible to use a general C expression
for the value of a denition parameter in the instrument denition, only constants and
variable names may be used. For this reason, setting parameters should be used whenever
possible.
There are a few cases where the use of denition parameters instead of setting pa-
rameters makes sense. If the parameter is not numeric (ie. a string for a le name, for
example), a setting parameter cannot be used. Also, because of the use of #define, the
C compiler can treat denition parameters as constants when the simulation is compiled.
For example, if the array sizes of a multidetector are denition parameters, the arrays
can be statically allocated in the component DECLARE section (see eg. appendix B.5.3). If
setting parameters were used, it would be necessary to allocate the arrays dynamically
using eg. malloc().
OUTPUT PARAMETERS (s 1 ; s 2 ; : : :)
This declares a list of C identiers that are output parameters for the component. Output
parameters are used to hold values that are computed by the component itself, rather than
being passed as input. This could for example be a count of neutrons in a detector or a
constant that is precomputed to speed up computation. Output parameters will typically
be declared as C variables in the DECLARE section, see section 3.4.2 below for an example.
The OUTPUT PARAMETERS section is optional.
32 Ris{R{1175(EN)

STATE PARAMETERS (x; y; z; v x ; v y ; v z ; t; s 1 ; s 2 ; p)
This declares the parameters that dene the state of the incoming neutron. The task of
the component code is to assign new values to these parameters based on the old values
and the values of the denition and setting parameters.
Optional component parameters
The denition and setting parameters of a component may be given a default value.
Parameters with default values are called optional parameters, and need not be given an
explicit value when the component is used in an instrument denition. A parameter is
given a default value using the syntax \param = value". For example
SETTING PARAMETERS (radius, height, pack = 1)
Here pack is an optional parameter; if no value is given explicitly, \1" will be used 2 . In
the present version of McStas, only numbers can be given as default values.
Optional parameters can greatly increase the convenience for users of components with
many parameters that have natural default values which are seldom changed. Optional
parameters are also very useful to preserve backwards compatibility with old instrument
denitions when a component is updated; new parameters can be added with default
values that correspond to the old behavior, and existing instrument denitions can be
used with the new component without changes.
However, optional parameters should not be used in cases where no general natural
default value exists. For example, the lengt of a guide or the size of a slit should not be
given default values. This would prevent the error messages that should be given in the
common case of a user forgetting to set an important parameter.
3.4.2 The DECLARE section
DECLARE
%{
. . . C code declarations . . .
%}
This gives C declarations of global variables etc. that are used by the component code.
This may for instance be used to declare a neutron counter for a detector component.
This section is optional.
Note that any variables declared in a DECLARE section are global. Thus a name conict
may occur if two instances of a component are used in the same instrument. To avoid this,
variables declared in the DECLARE section should be output parameters of the component;
McStas will then take care to rename variables as necessary to avoid conicts. For example,
a simple detector might be dened as follows:
DEFINE COMPONENT Detector
OUTPUT PARAMETERS (counts)
DECLARE
2 In contrast, if no value is given for radius or height, an error message will result.
Ris{R{1175(EN) 33

%{
int counts;
%}
...
The idea is that the counts variable counts the number of neutrons detected. In the
instrument denition, the counts parameter may be referenced using the MC_GETPAR C
macro, as in the following example instrument fragment:
COMPONENT d1 = Detector()
...
COMPONENT d2 = Detector()
...
FINALLY
%{
printf("Detector counts: d1 = %d, d2 = %d\n",
MC_GETPAR(d1,counts), MC_GETPAR(d2,counts));
%}
3.4.3 The INITIALIZE section
INITIALIZE
%{
. . . C code initialization . . .
%}
This gives C code that will be executed once at the start of the simulation, usually to
initialize any variables declared in the DECLARE section. This section is optional.
3.4.4 The TRACE section
TRACE
%{
. . . C code to compute neutron interaction with component . . .
%}
This performs the actual computation of the interaction between the neutron and the com-
ponent. The C code should perform the appropriate calculations and assign the resulting
new neutron state to the state parameters.
The C code may also execute the special macro ABSORB to indicate that the neutron
has been absorbed in the component; the simulation of that neutron will then be aborted.
If the component simulates multiple events (for example multiple reections in a guide,
or multiple scattering in a powder sample), the special macro SCATTER should be called.
This does not aect the results of the simulation in any way, but it allows the front-end
programs to visualize the scattering events properly. The SCATTER macro should be called
with the state parameters set to the proper calues for the scattering event. For an example
of SCATTER, see the Channeled guide component (section 5.3.4).
34 Ris{R{1175(EN)

3.4.5 The FINALLY section
FINALLY
%{
. . . C code to execute at end of simulation . . .
%}
This gives code that will be executed when the simulation has ended. This might be used
to print out results from components, e.g. the simulated intensity in a detector.
In order to work properly with the common output le format used in McStas, all
monitor/detector components should use standard macros for outputting data in the FI-
NALLY section, as explained below. In the following, we use p =
P
i p i to denote the sum
of the weights of detected neutrons, N =
P
i p 0
i to denote the count of detected neutron
events, and p2 =
P
i p 2
i to denote the sum of the squares of the weights, as explained in
section 4.1.1.
Single detectors/monitors The results of a single detector/monitor is output using
the following macro:
DETECTOR OUT 0D(t, N, p, p2)
Here, t is a string giving a short descriptive title for the results, eg. \Single monitor".
One-dimensional detectors/monitors The results of a one-dimensional detector/
monitor are output using the following macro:
DETECTOR OUT 1D(t, xlabel, ylabel, xvar, x min , x max , m,
&N [0], &p[0], &p2 [0], lename)
Here,
 t is a string giving a descriptive title (eg. \Energy monitor"),
 xlabel is a string giving a descriptive label for the X axis in a plot (eg. \Energy
[meV]"),
 ylabel is a string giving a descriptive label for the Y axis of a plot (eg. \Intensity"),
 xvar is a string giving the name of the variable on the X axis (eg. \E"),
 x min is the lower limit for the X axis,
 x max is the upper limit for the X axis,
 m is the number of elements in the detector arrays,
 &N [0] is a pointer to the rst element in the array of N values for the detector
component (or NULL, in which case no error bars will be computed),
 &p[0] is a pointer to the rst element in the array of p values for the detector
component,
Ris{R{1175(EN) 35

 &p2 [0] is a pointer to the rst element in the array of p2 values for the detector
component (or NULL, in which case no error bars will be computed),
 lename is a string giving the name of the le in which to store the data.
Two-dimensional detectors/monitors The results of a two-dimensional detector/
monitor are output using the following macro:
DETECTOR OUT 2D(t, xlabel, ylabel, x min , x max , y min , y max , m, n,
&N [0][0], &p[0][0], &p2 [0][0], lename)
Here,
 t is a string giving a descriptive title (eg. \PSD monitor"),
 xlabel is a string giving a descriptive label for the X axis in a plot (eg. \X position
[cm]"),
 ylabel is a string giving a descriptive label for the Y axis of a plot (eg. \Y position
[cm]"),
 x min is the lower limit for the X axis,
 x max is the upper limit for the X axis,
 y min is the lower limit for the Y axis,
 y max is the upper limit for the Y axis,
 m is the number of elements in the detector arrays along the X axis,
 n is the number of elements in the detector arrays along the Y axis,
 &N [0][0] is a pointer to the rst element in the array of N values for the detector
component,
 &p[0][0] is a pointer to the rst element in the array of p values for the detector
component,
 &p2 [0][0] is a pointer to the rst element in the array of p2 values for the detector
component,
 lename is a string giving the name of the le in which to store the data.
Note that for a two-dimensional detector array, the rst dimension is along the X axis
and the second dimension is along the Y axis. This means that element (i x ; i y ) can be
obtained as p[i x  n + i y ] if p is a pointer to the rst element.
36 Ris{R{1175(EN)

3.4.6 The MCDISPLAY section
MCDISPLAY
%{
. . . C code to draw a sketch of the component . . .
%}
This gives C code that draws a sketch of the component in the plots produced by the
mcdisplay front-end (see section 2.6.4). The section can contain arbitrary C code and may
refer to the parameters of the component, but usually it will consist of a short sequence of
the special commands described below that are only available in the MCDISPLAY section.
When drawing components, all distances and positions are in meters and specied in the
local coordinate system of the component.
The MCDISPLAY section is optional. If it is omitted, mcdisplay will use a default
symbol (a small circle) for drawing the component.
The magnify command This command, if present, must be the rst in the section. It
takes a single argument: a string containing zero or more of the letters \x", \y" and \z".
It causes the drawing to be enlarged along the specied axis in case mcdisplay is called
with the --zoom option. For example:
magnify("xy");
The line command The line command takes the following form:
line(x 1 , y 1 , z 1 , x 2 , y 2 , z 2 )
It draws a line between the points (x 1 ; y 1 ; z 1 ) and (x 2 ; y 2 ; z 2 ).
The multiline command The multiline command takes the following form:
multiline(n, x 1 , y 1 , z 1 , ..., x n , y n , z n )
It draws a series of lines through the n points (x 1 ; y 1 ; z 1 ), (x 2 ; y 2 ; z 2 ), . . . , (x n ; y n ; z n ). It
thus accepts a variable number of arguments depending on the value of n. This exposes it
to one of the nasty quirks of C, in that no type checking is performed by the C compiler.
It is thus very important that all arguments to multiline (except n) are valid numbers
of type double. A common mistake is to write
multiline(3, x, y, 0, ...)
which will silently produce garbage output. This must instead be written as
multiline(3, (double)x, (double)y, 0.0, ...)
The circle command The circle command takes the following form:
circle(plane, x, y, z, r)
Here plane should be either "xy", "xz", or "yz". The command draws a circle in the
specied plane with the center at (x; y; z) and the radius r.
Ris{R{1175(EN) 37

3.4.7 The end of the component denition
END
This marks the end of the component denition.
3.4.8 McDoc, the McStas component documentation tool
From version 1.3, McStas includes a facility called McDoc to help maintain good docu-
mentation of components. In the component source code, comments may be written that
follow a particular format understood by McDoc. The McDoc facility will read these com-
ments and automatically produce output documentation in various forms. By using the
source code itself as the source of documentation, the documentation is much more likely
to be a faithful and up-to-date description of how the component actually works.
In McStas version 1.4, two forms of documentation can be generated. One is the
component entry dialog in the mcgui front-end, see section 2.6.1. The other is a collection
web pages documenting the component; the complete documentation in this form for all
available McStas components may be found at [9].
Note that McDoc-complient comments in the source code are no substitute for a good
reference manual entry. The mathematical equations describing the physics and algorithms
of the component should still be written up carefully, possibly for inclusion in this manual.
The McDoc comments are useful for describing the general behaviour of the component,
the meaning and units of the input parameters, etc.
The format of the comments in the component source code
The format of the comments understood by McDoc is mostly straight-forward, and is
designed to be easily readable both by humans and by automatic tools. McDoc has been
written to be quite tolerant in terms of how the comments may be formatted and broken
across lines. A good way to get a feel for the format is to study some of the examples in
the various components in appendix B. Below appear a few notes on the requirements for
the comment headers:
The comment syntax uses %IDENTIFICATION, %DESCRIPTION, %PARAMETERS, %LINKS,
and %END keywords to mark dierent sections of the documentation. Keywords may be
abbreviated, eg as %IDENT or %I.
 In the %IDENTIFICATION section, author: (or written by: for backwards compat-
ibility with old comments) denote author; date:, version:, and origin: are also
supported. Any number of Modified by: entries may be used to give the revision
history. The author:, date:, etc. entries must all appear on a single line of their
own. Everything else in the identication section is part of a "short description" of
the component.
 In the %PARAMETERS section, descriptions have the form \name: [unit] text" or
\name: text [unit]". These may span multiple lines; subsequent lines must be
indented by at least four spaces. Note that square brackets [] should be used for
units. Normal parenthesis are also supported for backwards compatibility, but nested
parenthesis do not work well.
38 Ris{R{1175(EN)

 The %DESCRIPTION section contains text in free format. The text may contain HTML
tags like <IMG> (to include pictures) and <A>. . . </A> (for links to other web pages,
but see also the %LINK section). In the generated web documentation pages, the text
is set in <PRE>. . . </PRE>, so that the line breaks in the source will be obeyed.
 Any number of %LINK sections may be given; each one contains HTML code that
will be put in a list item in the link section of the description web page. This
usually consists of an <A HREF="..."> ... </A> pointer to some other source of
information.
 After %END, no more comment text is read by McDoc.
Ris{R{1175(EN) 39

Chapter 4
Monte Carlo Techniques and
simulation strategy
This chapter explains the simulation strategy and the Monte Carlo techniques used in
McStas. We rst explain the concept of the neutron weight factor, and discuss the statis-
tical errors in dealing with sums of neutron weights. After, we give an expression for how
the weight factor should transform under a Monte Carlo choice and specialize this to the
concept of focusing components. Finally, we present a way of generating random numbers
with arbitrary distributions.
4.1 The neutron weight, p
A totally realistic semi-classical simulation will require that each neutron is at any time
either present or not (it might be ABSORB'ed or lost in another way). In many set-
ups, e.g. triple axis spectrometers, only a small fraction of the initial neutrons will ever
be detected, and simulations of this kind will therefore waste much time in dealing with
neutrons that get lost.
A very important means of speeding up calculations is to introduce a neutron weight
for each simulated neutron and to adjust this weight according to the path of the neutron.
If e.g. the reectivity of a certain optical component is 10%, and only reected neutrons
are considered in the simulations, the neutron weight will be multiplied by 0.10 by passage
of this component, but every neutron is allowed to reect in the component. In contrast,
the totally realistic simulation of the component would require in average ten incoming
neutrons for each reected one.
Let the initial neutron weight be p 0 and let us denote the weight multiplication factor
in the j'th component by  j . The resulting weight factor for the neutron after passage of
the whole instrument must eventually be equal to the product of all the contributions
p = p 0
n
Y
j=1
 j : (4.1)
For convenience, the value of p is updated within each component.
Simulation by weight adjustment is performed whenever possible. This includes
40 Ris{R{1175(EN)

 Transmission through lter.
 Transmission through Soller blade collimator (in the approximation which does not
take each blade into account).
 Reection from monochromator (and analyser) crystals with nite reectivity and
mosaicity.
 Scattering from samples.
4.1.1 Statistical errors of non-integer counts
In a typical simulation, the result will consist of a count of neutrons with dierent weights. 1
One may write the counting result as
I =
X
i
p i = Np; (4.2)
where N is the number of neutrons in the detector and the vertical bar denote averaging.
By performing the weight transformations, the (statistical) mean value of I is unchanged.
However, N will in general be enhanced, and this will improve the statistics of the simu-
lation.
To give some estimate of the statistical error, we proceed as follows: Let us rst for
simplicity assume that all the counted neutron weights are almost equal, p i  p, and
that we observe a large number of neutrons, N  10. Then N almost follows a normal
distribution with the uncertainty (N) =
p
N 2 . Hence, the statistical uncertainty of the
observed intensity becomes
(I) =
p
Np = I=
p
N ; (4.3)
as is used in real neutron experiments (where p  1). For a better approximation we
return to (4.2). Allowing variations in both N and p, we calculate the variance of the
resulting intensity, assuming that the two variables are independent and both follow a
Gaussian distribution.
 2 (I) =  2 (N)p 2 +N 2  2 (p) = Np 2 +N 2  2 (p): (4.4)
Assuming that the individual weights, p i , follow a Gaussian distribution (which in many
cases is far from the truth) we have N 2  2 (p) =  2 (
P
i p i ) = N 2 (p i ) and reach
 2 (I) = N p 2 +  2 (p i )
 : (4.5)
The statistical variance of the p i 's is estimated by  2 (p i )  (N 1) 1 (
P
i p 2
i Np 2 ). The
resulting variance then reads
 2 (I) = N
N 1
  X
i
p 2
i p 2
!
: (4.6)
1 The sum of these weights is an estimate of the mean number of neutrons hitting the monitor (or
detector) in a \real" experiment where the number of neutrons emitted from the source is the same as the
number of simulated neutrons.
2 This is not correct in a situation where the detector counts a large fraction of the neutrons in the
simulation, but we will neglect that for now.
Ris{R{1175(EN) 41

For large values of N , this is very well approximated by the simple expression
 2 (I) 
X
i
p 2
i : (4.7)
In order to compute the intensities and uncertainties, the detector components in
McStas thus must keep track of N =
P
i p 0
i ; I =
P
i p 1
i , and M 2 =
P
i p 2
i .
4.2 Weight factor transformations during a Monte Carlo
choice
When a Monte Carlo choice must be performed, e.g. when the initial energy and direction
of the neutron is decided at the source, it is important to adjust the neutron weight so
that the combined eect of neutron weight change and Monte Carlo probability equals the
actual physical properties of the component.
Let us follow up on the example of a source. In the \real" semi-classical world, there is a
distribution (probability density) for the neutrons in the six dimensional (energy, direction,
position) space of
(E;
 ; r) =
dP=(dEd
 d 3 r) depending upon the source temperature,
geometry etc. In the Monte Carlo simulations, the six coordinates are for e∆ciency reasons
in general picked from another distribution: f MC
(E;
 ; r) 6=
(E;
 ; r), since one would
e.g. often generate only neutrons within a certain parameter interval. However, we must
then require that the weights are adjusted by a factor  j (in this case: j = 1) so that
f MC
(E;
 ; r) j
(E;
 ; r) =
(E;
 ; r): (4.8)
For the sources present in version 1.4, only the
(
 ; r) dependence of the correction factors
are taken into account.
The weight factor transformation rule (4.8) is of course also valid for other types of
Monte Carlo choices, although the probability distributions may depend upon dierent
parameters. An important example is elastic scattering from a powder sample, where
the Monte-Carlo choices are the scattering position and the nal neutron direction. See
subsection 5.7.
It should be noted that the  j 's found in the weight factor transformation are multiplied
by the  j 's found by the weight adjustments described in subsection 4.1 to yield the nal
neutron weight given by Eq. (4.1).
4.3 Focusing components
An important application of weight transformation is focusing. Assume that the sample
scatters the neutrons in many directions. In general, only neutrons ying in some of
these directions will stand any chance of being detected. These directions we call the
interesting directions. The idea in focusing is to avoid wasting computation time on
neutrons scattered in the uninteresting directions. This trick is an instance of what in
Monte Carlo terminology is known as importance sampling.
If e.g. a sample scatters isotropically over the whole 4 solid angle, and all interesting
directions are known to be contained within a certain solid angle interval

 , only these
42 Ris{R{1175(EN)

solid angles are used for the Monte Carlo choice of scattering direction. According to (4.8),
the weight factor will then have to be changed by the (xed) amount  j =
j
 j=(4). One
thus ensures that the mean simulated intensity is unchanged during a "correct" focusing,
while a too narrow focusing will result in a lower (i.e. wrong) intensity, since one cuts
away neutrons that would otherwise have counted..
One could also think of using adaptive importance sampling, so that McStas during
the simulations will determine the most interesting directions and gradually change the
focusing according to that. A rst implementation of this idea is found in the Source adapt
component, described in section 5.1.6.
4.4 Transformation of random numbers
In order to perform the Monte Carlo choices, one needs to be able to pick a random
number from a given distribution. However, most random number generators only give
uniform distributions over a certain interval. We thus need to be able to transform between
probability distributions, and we here give a short explanation on how to do this.
Assume that we pick a random number, x, from a distribution (x). We are now
interested in the shape of the distribution of the transformed y = f(x), assuming f(x) is
monotonous. All random numbers lying in the interval [x; x + dx] are transformed to lie
within the interval [y; y+f 0 (x)dx], so the resulting distribution must be (y) = (x)=f 0 (x).
If the random number generator selects numbers uniformly in the interval [0; 1], we
have (x) = 1, and one may evaluate the above expression further
(y) = 1
f 0 (x) = d
dy
f 1 (y): (4.9)
By indenite integration we reach
Z
(y)dy = f 1 (y) = x; (4.10)
which is the essential formula for nding the right transformation of the initial random
numbers. Let us illustrate with a few examples of transformations used within the McStas
components.
The circle For nding a random point within the circle of radius R, one would like
to choose the polar angle from a uniform distribution in [0; 2] and the radius from the
normalised distribution (r) = 2r=R 2 . The polar angle is found simply by multiplying a
random number with 2. For the radius, we like to nd r = f(x), where again x is the
generated random number. Left side of Eq. (4.10) gives
R (r)dr =
R 2r=R 2 dr = r 2 =R 2 ,
which should equal x. Hence r = R
p
x.
Exponential decay In a simple time-of-ight source, the neutron ux decays expo-
nentially after the initial activation at t = 0. We thus want to pick an initial neutron
emission time from the normalised distribution (t) = exp( t=)= . Use of Eq. (4.10)
gives x = exp( t= ), which is a number in the interval [ 1; 0]. If we want to pick a
positive random number instead, we will have to change sign by x 1 = x and thus reach
t =  ln(x 1 ).
Ris{R{1175(EN) 43

The sphere For nding a random point on the surface of the unit sphere, one needs to
determine the two angles, (;  ). As for a circle,   is chosen from a uniform distribution
in [0; 2]. The probability distribution of  should be () = sin() (for  2 [0; =2]),
whence  = cos 1 (x).
44 Ris{R{1175(EN)

Chapter 5
The component library
This section is devoted to a description of components included in the component library.
The component library is maintained by the Ris group. All components were written at
Ris except the chopper components in sections 5.4.2 and 5.4.3 which have been kindly
contributed by Philipp Bernhardt, Lehrstuhl fur Kristallographie und Strukturphysik;
and the Source Optimizer (section 5.1.7), Monitor Optimizer (section 5.5.15), and Mon-
itor nD (section 5.5.12) components which were written by Emmanuel Farhi, Institute
Laue-Langevin. Users are encouraged to send contributions to us for inclusion in future
releases.
In the explanations of the individual components we will use the usual symbols r for
the position (x; y; z) of the particle (unit m), and v for the particle velocity (v x ; v y ; v z )
(unit m/s). Another frequently used symbol is the wave vector k = mNv=~ , where mN is
the neutron mass. k is usually given in  A 1 , while neutron energies are given in meV. In
general, vectors are denoted by boldface symbols. Subscripts "i" and "f" denotes "initial"
and "nal", respectively, and are used in connection with the neutron state before and
after a scattering event. Note that all mentioning of component geometry refer to the
local coordinate system of the individual component.
The source code for components is listed in Appendix B. The components follow the
same numbering in the Appendix as in the main text, e.g. component Arm, subsection
5.2.1, appears in the Appendix as B.2.1. Source code for many of the more trivial com-
ponents are not included in this manual. All sources may be found in the lib/mcstas/
subdirectory of the McStas installation; the default is /usr/local/lib/mcstas/.
5.1 Source components
The main function of the source components is to determine a set of initial parameters
(r; v), or equivalent (r;
v;
 ), for each neutron. This is done by Monte Carlo choices. In
the current sources no polarization dependence is implemented, whence we let s = (0; 0).
The sources to be presented in the following all make their Monte Carlo choices on the
basis of simple analytical expressions (e.g. the energy distribution). More realistic sources
would require that (at least) the Monte-Carlo choice for the initial energy was made on
basis of a measured, tabulated energy spectrum. This is planned to be implemented in a
later version of McStas.
Ris{R{1175(EN) 45

5.1.1 Source at: A circular continuous source with a at energy spec-
trum
This component Source at is a simple continous source with a at energy distribution.
The time-of-ight aspect is not relevant for this component, so we put t = 0 for all
neutrons.
The initial neutron position is chosen randomly from within a circle of radius r s in the
z = 0 plane. This is a fair approximation of a cylindrical cold source with the beam going
out along the cylinder axis, like the one at Ris.
The initial neutron velocity direction is focused within a solid angle, dened by a
rectangular target of width w, height h, parallel to the xy plane placed at (0; 0; z f ). A
small angle approximation is used, assuming that w; h  z f .
The weight multiplier of the created neutron,  1 , is set to the solid angle of the focusing
opening divided by 4, see discussion in 4.3
The input parameters of Source at are the source radius, r s , the distance to the
target, z f , the dimensions of the target, w and h, and the centre and spread of the energy
distribution, E 0 and E.
5.1.2 Source at lambda: A continous source with at wavelength spec-
trum
The component Source at lambda is similar to the Source at component, except that
the spectrum is at in wavelength, rather than in energy.
The input parameters for Source at lambda are radius to set the source radius in
meters; dist, xw, and yh to set the focusing as for Source at; and lambda 0 and d lambda
to set the range of wavelength emitted (the range will be from lambda 0 d lambda to
lambda 0 + d lambda).
5.1.3 Source ux lambda: A continuous source with absolute ux
The component Source ux lambda is a variation on the Source at lambda compo-
nent. The only dierence is the possibility to specify the absolute ux of the source. The
specied ux is used to adjust the initial neutron weight so that the intensity in the de-
tectors is directly comparable to a measurement of one second on a real source with the
same ux. This also makes the simulated detector intensities independent of the number
of neutron histories simulated, easing the comparison between dierent simulation runs
(though of course more neutron histories will give better statistics).
The ux  is the number of neutrons emitted per second from a one cm 2 area on the
source surface, with direction within a a one steradian solid angle, and with wavelength
within a one  Angstrm interval. The total number of neutrons emitted towards a given
diaframe in one second is therefore
N total = A
 
where A is the source
area,
 is the solid angle of the diaframe as seen from the source
surface, and  is the width of the wavelength interval in which neutrons are emitted (as-
suming a uniform wavelength spectrum). If N sim denotes the number of neutron histories
46 Ris{R{1175(EN)

to simulate, the initial neutron weight p 0 must be set to
p 0 = N total
N sim
= 
N sim
A
 
The input parameters for Source ux lambda are radius to set the source radius in
meters; dist, xw, and yh to set the focusing as for Source at; lambda 0 and d lambda
to set the range of wavelength emitted (the range will be from lambda 0 d lambda to
lambda 0 + d lambda); and ux to set the source ux in units of cm 2 st 1  A.
5.1.4 Source div: A divergent source
Source div is a rectangular source which emits a beam of a certain divergence around the
main exit direction (the direction of the z axis). The beam intensity and divergence are
uniform over the whole of the source, and the energy distribution of the beam is uniform.
This component may be used as a simple model of the beam prole at the end of a
guide or at the sample position.
The input parameters for Source div are the source dimensions w and h (in m), the
divergencies ∆ h and ∆ v (FWHM in degrees), and the mean energy E 0 and the energy spread
dE (both in meV). The neutron energy range is (E 0 dE; E 0 + dE).
5.1.5 Moderator: A time-of-ight source
The simple time-of-ight source component Moderator resembles the source component
Source at described in 5.1.1. Like Source at, Moderator is circular and focuses on
a rectangular target. Further, the initial velocity is chosen with a linear distribution within
an interval, dened by the minimum and maximum energies, E 0 and E 1 , respectively.
The initial time of the neutron is determined on basis of a simple heuristical model for
the time dependence of the neutron intensity from a time-of-ight source. For all neutron
energies, the ux decay is assumed to be exponential,
	(E; t) = exp( t=(E)); (5.1)
where the decay constant is given by
(E) =

 0 ; E < E c
 0 =[1 + (E E c ) 2 = 2 ] ; E  E c
(5.2)
The input parameters for Moderator are the source radius, r s , the minimum and
maximum energies, E 0 and E 1 (in meV), the distance to the target, z f , the dimensions of
the target, w and h, and the decay parameters  0 (in s), E c , and  (both in meV).
5.1.6 Source adapt: A neutron source with adaptive importance sam-
pling
The Source adapt component is a neutron source that uses adaptive importance sam-
pling to improve the e∆ciency of the simulations. It works by changing on-the-y the
probability distributions from which the initial neutron state is sampled so that samples
in regions that contribute much to the accuracy of the overall result are preferred over
Ris{R{1175(EN) 47

samples that contribute little. The method can achive improvements of a factor of ten
or sometimes several hundred in simulations where only a small part of the initial phase
space contains useful neutrons.
The physical characteristics of the source are similar to those of Source at (see sec-
tion 5.1.1). The source is a thin rectangle in the X-Y plane with a at energy spectrum
in a user-specied range. The ux per area per steradian per  Angstrm per second is
specied by the user; the total weight of neutrons emitted from the source will then be
the same irrespectively of the number of neutron histories simulated, corresponding to one
second of measurements.
The initial neutron weight is given by (see section 5.1.3 for details)
p 0 = N total
N sim
= 
N sim
A
 
Here  is the total wavelength range of the source; since the spectrum is at in energy
(but not in wavelength), the ux will actually be dierent for dierent energies. A later
version of this component will probably adapt (in a backward-compatible way) a more sen-
sible way to specify the ux. For now, an energy or wavelength monitor (see sections 5.5.7
and 5.5.8) placed just after the source will show the actual energy-dependent ux.
The adaption algorithm
The adaptive importance sampling works by subdividing the initial neutron phase space
into a number of equal-sized bins. The division is done on the three dimensions of energy,
horizontal position, and horizontal divergence, using N eng , N pos , and N div number of bins
in each dimension, respectively. The total number of bins is therefore
N bin = N eng N pos N div
Each bin i is assigned a sampling weight w i ; the probability of emitting a neutron within
bin i is
P (i) = w i
P N bin
j=1 w j
In order to avoid false learning, the sampling weight of a bin is kept larger than w min ,
dened as
w min = 
N bin
N bin
X
j=1
w j ; 0    1
This way a (small) fraction  of the neutrons are sampled uniformly from all bins, while
the fraction (1 ) are sampled in an adaptive way.
Compared to a uniform sampling of the phase space (where the probability of each bin
is 1=N bin ), the neutron weight must be adjusted by the amount
 i = 1=N bin
P (i) =
P N bin
j=1 w j
N bin w i
In order to set the criteria for adaption, the Adapt check component is used (see
section 5.5.14). The source attemps to sample only from bins from which neutrons are
48 Ris{R{1175(EN)

not absorbed prior to the position in the instrument at which the Adapt check component
is placed. Among those bins, the algorithm attemps to minimize the variance of the
neutron weights at the Adapt check position. Thus bins that would give high weights at
the Adapt check position are sampled more often (lowering the weights), while those with
low weights are sampled less often.
Let  = p 1 =p 0 denote the ratio between the neutron weight p 1 at the Adapt check
position and the initial weight p 0 just after the source. For each bin, the component keeps
track of the sum   of 's as well as of the total number of neutrons n i from that bin. The
average weight at the Adapt source position of bin i is thus   i =n i .
We now distribute a total sampling weight of  uniformly among all the bins, and
a total weight of (1 ) among bins in proportion to their average weight   i =n i at the
Adapt source position:
w i =

N bin
+ (1 )
  i =n i
P N bins
j=1   j =n j
After each neutron event originating from bin i, the sampling weight w i is updated.
This basic idea can be improved with a small modication. The problem is that until
the source has had the time to learn the right sampling weights, neutrons may be emitted
with high neutron weights (but low probability). These low probability neutrons may
account for a large fraction of the total intensity in detectors, causing large variances in
the result. To avoid this, the component emits early neutrons with a lower weight, and
later neutrons with a higher weight to compensate. This way the neutrons that are emitted
with the best adaption contribute the most to the result.
The factor with which the neutron weights are adjusted is given by a logistic curve
F (j) = C
y 0
y 0 + (1 y 0 )e r0 j (5.3)
where j is the index of the particular neutron history, 1  j  N hist . The constants y 0 ,
r 0 , and C are given by
y 0 =
2
N bin
(5.4)
r 0 =
1

1
N hist
log
 1 y 0
y 0

(5.5)
C = 1 + log

y 0 +
1 y 0
N hist
e r0 N hist

(5.6)
The number  is given by the user and species (as a fraction between zero and one) the
point at which the adaption is considered good. The initial fraction  of neutron histories
are emitted with low weight; the rest are emitted with high weight:
p 0 (j) =

N sim
A
 
P N bin
j=1 w j
N bin w i
F (j)
The choice of the constants y 0 , r 0 , and C ensure that
Z N hist
t=0
F (j) = 1
Ris{R{1175(EN) 49

so that the total intensity over the whole simulation will be correct
Similarly, the adjustment of sampling weights is modied so that the actual formula
used is
w i (j) = 
N bin
+ (1 ) y 0
y 0 + (1 y 0 )e r0 j
  i =n i
P N bins
j=1   j =n j
The implementation
The heart of the algorithm is a discrete distribution p. The distribution has N bins,
1 : : : N . Each bin has a value v i ; the probability of bin i is then v i =(
P N
j=1 v j ).
Two basic operations are possible on the distribution. An update adds a number a to
a bin, setting v new
i = v old
i + a. A search nds, for given input b, the minimum i such that
b 
i
X
j=1
v j :
The search operation is used to sample from the distribution p. If r is a uniformly dis-
tributed random number on the interval [0;
P N
j=1 v j ] then i = search(r) is a random
number distributed according to p. This is seen from the inequality
i 1
X
j=1
v j < r 
i
X
j=1
v j ;
from which r 2 [
P i 1
j=1 v j ; v i +
P i 1
j=1 v j ] which is an interval of length v i . Hence the
probability of i is v i =(
P N
j=1 v j ). The update operation is used to adapt the distribution
to the problem at hand during a simulation. Both the update and the add operation can
be performed very e∆ciently; how this is achieved will be described elsewhere.
The input parameters for Source adapt are xmin, xmax, ymin, and ymax in meters
to set the source dimensions; dist, xw, and yh to set the focusing as for Source at (sec-
tion 5.1.1); E0 and dE to set the range of energies emitted, in meV (the range will be
from E0 dE to E0+dE); ux to set the source ux  in cm 2 st 1  As 1 ; N eng , N pos , and
N div to set the number of bins in each dimensions; alpha and beta to set the parameters 
and  as described above; and lename to give the name of a le in which to output the
nal sampling destribution.
A good general-purpose value for  and  is  =  = 0:25. The number of bins
to choose will depend on the application. More bins will allow better adaption of the
sampling, but will require more neutron histories to be simulated before a good adaption
is obtained. The output of the sampling distribution is only meant for debugging, and the
units on the axis are not necessarily meaningful. Setting the lename to NULL disables the
output of the sampling distribution.
5.1.7 Source Optimizer: A general Optimizer for McStas
This component was contributed by Emmanuel Farhi, Institute Laue-Langevin.
The component Source Optimizer optimizes the whole neutron ux in order to
achieve better statistics at each Monitor Optimizer location(s) (see section 5.5.15 for
50 Ris{R{1175(EN)

this latter component). It can act on any incoming neutron beam (from any source type),
and more than one optimization criteria location can be placed along the instrument.
The usage of the optimizer is very simple, and usually does not require any congura-
tion parameter. Anyway the user can still customize the optimization via various options.
The optimizer e∆ciency makes it easy to increase the number of events at optimization
criteria locations by a factor of 20, and thus decreases the signal error bars by a factor
4.5. Higher factors can often be achieved in practise. Of course, the overall ux remains
the same as without optimizer.
The optimization algorithm
When a neutron reaches the Monitor Optimizer location(s), the component records its
position (x, y) and speed (v x ; v y ; v z ) when it passed in the Source Optimizer. Some
distribution tables of good neutrons characteristics are then built.
When a bad neutron comes to the Source Optimizer (it would then have few chances
to reach Monitor Optimizer), it is changed into a better one. That means that its
position and velocity coordinates are translated to better values according to the good
neutrons distribution tables. Anyway, the neutron energy (
p
v 2
x + v 2
y + v 2
z ) is kept as far
as possible.
The Source Optimizer works as follow:
1. First of all, the Source Optimizer determines some limits (min and max) for vari-
ables x; y; v x ; v y ; v z .
2. Then the component records the non-optimized ux distributions in arrays with bins
cells (default is 10 cells). This constitutes the Reference source.
3. The Monitor Optimizer records the good neutrons (that reach it) and communi-
cate an Optimized source to the Source Optimizer. However, 'keep' percent of the
original Reference source is sent unmodied (default is 10 %). The Optimized source
is thus:
Optimized = keep * Reference
+ (1 - keep) [Neutrons that will reach monitor].
4. The Source Optimizer transforms the bad neutrons into good ones from the Op-
timized source. The resulting optimised ux is normalised to the non-optimized
one:
p optimized = p initial
Reference
Optimized ; (5.7)
and thus the overall ux at Monitor Optimizer location is the same as without
the optimizer. Usually, the process sends more good neutrons from the Optimized
source than than in the Reference one. The energy (and velocity) spectra of neutron
beam is also kept, as far as possible. For instance, an optimization of v z will induce
a modication of v x or v y to try to keep j~vj constant.
5. When the continuous optimization option is activated (by default), the process loops
to Step (3) every 'step' percent of the simulation. This parameter is computed
automatically (usually around 10 %) in auto mode, but can also be set by user.
Ris{R{1175(EN) 51

During steps (1) and (2), some non-optimized neutrons with original weight p initial may
lead to spikes on detector signals. This is greatly improved by lowering the weight p during
these steps, with the smooth option. The component optimizes the neutron parameters on
the basis of independant variables. Howver, it usually does work ne when these variables
are correlated (which is often the case in the course of the instrument simulation). The
memory requirements of the component are very low, as no big n-dimensional array is
needed.
Using the Source Optimizer
To use this component, just install the Source Optimizer after a source (but any location
is possible in principle), and use the Monitor Optimizer at a location where you want
to have better statistics.
/* where to act on neutrons */
COMPONENT optim_s = Source_Optimizer(options="")
...
/* where to have better statistics */
COMPONENT optim_m = Monitor_Optimizer(
xmin = -0.05, xmax = 0.05,
ymin = -0.05, ymax = 0.05,
optim_comp = optim_s)
...
/* using more than one Monitor_Optimizer is possible */
The input parameter for Source Optimizer is a single options string that can contain
some specic optimizer conguration settings in clear language. The formatting of the
options parameter is free, as long as it contains some specic keywords, that can be
sometimes followed by values.
The default conguration (equivalent to options = "") is
options = "continuous optimization, auto setting, keep = 10, bins = 10,
smooth spikes, and do not free energy during optimization".
The keyword modiers no or not revert the next option. Other options not shown here
are:
verbose displays optimization process (debug purpose).
unactivate to unactivate the Optimizer.
file=[name] Filename where to save optimized source distributions
The le option will save the source distributions at the end of the optimization. If no
name is given the component name will be used, and a '.src' extension will be added. By
default, no le is generated. The le format is in a McStas 2D record style.
5.2 Simple optical components: Arms, slits, collimators, l-
ters
Below we list a number of simple optical components which require only a minimum of
explanation.
52 Ris{R{1175(EN)

5.2.1 Arm: The generic component
The component Arm is empty; is resembles an optical bench and has no eect on the
neutron. The function of this component is only to set up a local frame of reference within
the instrument denition. Other components of the same arm/optical bench may then
be positioned relative to the arm component using the McStas meta-language. The use
of arm components in the instrument denitions is not required but is recommended for
clarity.
Arm has no input parameters. For more about the use of this component, see the
sample instrument denitions listed in Appendix C.
5.2.2 Slit: The rectangular slit
The component Slit is a very simple construction. It sets up a rectangular opening at
z = 0, and propagates the neutrons onto the plane of this rectangle by the kernel call
PROP Z0.
Neutrons within the slit opening are unaected, while all other neutrons (no matter
how far from the opening their paths intersect the plane) are discarded by the kernel call
ABSORB. By this simplication, some neutrons contributing to the background in a real
experiment will be neglected. These are the ones that scatter o the inner side of the slit,
penetrates the slit material, or that clear one of the outer edges of the slit.
The input parameters of Slit are the four coordinates, (x min ; x max ; y min ; y max ) dening
the opening of the rectangle.
5.2.3 Circular slit: The circular slit
The component Circular slit denes a circle in the z = 0 plane, centered in the origin.
In analogy with Slit, neutrons are propagated to this plane, and those which intersect the
plane outside the circle are ABSORB'ed.
The only input parameter of Circular slit is the radius, r, of the circle.
5.2.4 Beamstop rectangular: The rectangular beam stop
The component Beamstop rectangular models a thin, innitely absorbing rectangle in
the X-Y plane, centered on the origin. The input parameters are xmin, xmax, ymin, and
ymax dening the edges of the slit in meters.
5.2.5 Beamstop circular: The circular beam stop
The component Beamstop circular models a thin, innitely absorbing circular disk in
the X-Y plane, centered on the origin. It takes a single input parameter radius to dene
the circle radius in meters.
5.2.6 Soller: The simple Soller blade collimator
The component Soller denes two rectangular openings like the one in Slit. Neutrons not
clearing both these openings are ABSORB'ed, see the discussion in 5.2.2. The collimating
eect is taken care of by employing an ideal triangular transmission through the collimator,
Ris{R{1175(EN) 53

x
y
z
L
d
L
PSfrag replacements
x min x max
y min
y max
∆
Figure 5.1: The geometry of a simple Soller blade collimators: The real Soller collimator,
seen from the top (left), and a sketch of the component Soller (right). The symbols are
dened in the text.
as explained below. For a more detailed Soller collimator simulation the Channeled guide
component can be employed, see section 5.3.4.
Let the collimation angle be ∆ = tan 1 (d=L), where L is the length of the collimator
and d is the distance between the blades, and let  be the divergence angle between the
neutron path and a vertical plane along the collimator axis, see Fig. 5.1. Neutrons with a
large divergence angle jj  ∆ will always hit at least one collimator blade and will thus
be absorbed. For smaller divergence angles, jj < ∆, the fate of the neutron depends on
its exact entry point. Assuming that a typical collimator has many blades, the absolute
position of each blade perpendicular to the collimator axis is somewhat uncertain (and
also unimportant). A simple statistical consideration now shows that the transmission
probability is T = 1 tan jj= tan ∆.
We simulate the collimator by transmitting all neutrons with jj < ∆, but adjusting
their weight with the amount
 i = T = 1 tan jj= tan ∆; (5.8)
while all others are discarded by the kernel call ABSORB.
The input parameters for Soller are the coordinates (x min ; x max ; y min ; y max ), dening
the identical entry and exit apertures, the length, l, between the slits, and the collimator
54 Ris{R{1175(EN)

divergence ∆. If ∆ = 0, the collimating eect is disabled, so that  i = 1 whenever the
neutron clears the two apertures.
5.2.7 Filter: A transmission lter
A neutron transmission lter act in much of the same way as two identical slits, one after
the other. The only dierence is that the transmission of the lter varies with the neutron
energy.
In the simple component Filter, we have not tried to simulate the details of the trans-
mission process (which includes absorption, incoherent scattering, and Bragg scattering
in a polycrystalline sample, e.g. Be). Instead, the transmission is parametrised to be
 i = T 0 when E  E min ,  i = T 1 when E  E max , and linearly interpolated between the
two values in the intermediate interval.
 i =
8 <
:
T 0 E  E min
T 1 + (T 0 T 1 ) Emax E
Emax E min
E min < E < E max
T 1 EE max
(5.9)
If T 1 = 0, the neutrons with E > E max are ABSORB'ed.
The input parameters are the four slit coordinates, (x min ; x max ; y min ; y max ), the dis-
tance, l, between the slits, and the transmission parameters T 0 , T 1 , E min , and E max . The
energies are given in meV.
5.3 Advanced optical components: mirrors and guides
This section describes advanced neutron optical components such as supermirrors and
guides. The rst subsection, however, contains only a description of the reectivity of a
supermirror.
5.3.1 Mirror reectivity
To compute the reectivity of the supermirrors, we use an empirical formula derived from
experimental data (see gure 5.2). The reectivity is given by the following formula
R =
 R 0 if Q  Q c
1
2 R 0 (1 tanh[(Q mQ c )=W ])(1 (Q Q c )) if Q > Q c
(5.10)
Here Q is the length of the scattering vector (in  A 1 ) dened by
Q = jk i k f j = m n
~
jv i v f j; (5.11)
m n being the neutron mass. The value m is a parameter determined by the mirror materi-
als, the bilayer sequence, and the number of bilayers. As can be seen, R = R 0 for Q < Q c ,
which is the critical scattering wave vector for a single layer of the mirror material. At
higher values of Q, the reectivity starts falling linearly with a slope  until a cut-o at
Q = mQ c . The width of the cut-o is denoted W . For the curve in gure 5.2, the values
are
m = 4 R 0 = 1 Q c = 0:02  A 1  = 6:49  A W = 1=300  A 1
Ris{R{1175(EN) 55

0 0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.1
0
0.2
0.4
0.6
0.8
1
1.2
1.4
Momentum transfer Q [≈ -1
Reflectivity
p
Supermirror reflectivity, m = 4
Figure 5.2: A typical reectivity curve for a supermirror, Eq. (5.11).
As a special case, if m = 0 then the reectivity is zero for all Q, ie. the surface is
completely absorbing.
In the components, the neutron weight is adjusted with the amount  i = R. To avoid
spending large amounts of computation time on very low-weight neutrons, neutrons for
which the reectivity is lower than about 10 10 are ABSORB'ed.
5.3.2 Mirror: The single mirror
The component Mirror models a single rectangular neutron mirror plate. It can be
used to e.g. assemble a complete neutron guide by putting multiple mirror components at
appropriate locations and orientations in the instrument denition, much like a real guide
is build from individual mirrors.
The mirror is assumed to lie in the rst quadrant of the x-y plane, with one corner
at (0; 0; 0). If the neutron trajectory intersects the mirror plate, it is reected, otherwise
it is left untouched. Since the mirror lies in the x-y plane, an incoming neutron with
velocity v i = (v x ; v y ; v z ) is reected with velocity v f = (v x ; v y ; v z ). The computation of
the reectivity is handled as detailed in section 5.3.1.
The input parameters of this component are the rectangular mirror dimensions (l; h)
and the values of R 0 ; m;Q c ; W , and  for the mirror.
5.3.3 Guide: The guide section
The component Guide models a guide tube consisting of four at mirrors. The guide
is centered on the z axis with rectangular entrance and exit openings parallel to the x-y
plane. The entrance has the dimensions (w 1 ; h 1 ) and placed at z = 0. The exit is of
dimensions (w 2 ; h 2 ) and is placed at z = l where l is the guide length. See gure 5.3.
56 Ris{R{1175(EN)

h 1
w 1
h 2
w 2 Z
Y
X
Figure 5.3: The geometry used for the guide component.
Neutrons not clearing the guide entrance are ABSORB'ed. For a more general guide
simulation, see the Channeled guide component in section 5.3.4.
For computations on the guide geometry, we dene the planes of the four guide sides
by giving their normal vectors (pointing into the guide) and a point lying in the plane:
n v
1 = (l; 0; (w 2 w 1 )=2) O v
1 = ( w 1 =2; 0; 0)
n v
2 = ( l; 0; (w 2 w 1 )=2) O v
2 = (w 1 =2; 0; 0)
n h
1 = (0; l; (h 2 h 1 )=2) O h
1 = (0; h 1 =2; 0)
n h
2 = (0; l; (h 2 h 1 )=2) O h
2 = (0; h 1 =2; 0)
In the following, we refer to an arbitrary guide side by its origin O and normal n.
With these denitions, the time of intersection of the neutron with a guide side can be
computed by considering the projection onto the normal:
t 1 = (O r 0 )  n
v  n (5.12)
For a neutron that leaves the guide through the guide exit we have
t 2 =
l z 0
v z
(5.13)
To compute the interaction of the neutron with the guide, the neutron is initially propa-
gated to the z = 0 plane of the guide entrance. If it misses the entrance, it is ABSORB'ed.
Otherwise, we repeatedly compute the time of intersection with the four mirror sides and
the guide exit. The smallest positive t thus found gives the time of the next intersection
with the guide (or in the case of the guide exit, the time when the neutron leaves the
guide). The neutron is propagated to this point, the reection from the side is computed
and the process is repeated until the neutron leaves the guide.
The reected velocity v f of the neutron with incoming velocity v i is computed by the
formula
v f = v i 2
n  v i
jnj 2
n (5.14)
Ris{R{1175(EN) 57

n
n
n 2
n v
≠ . i
i
v
v f
Figure 5.4: Neutron reecting from mirror. v i and v f are the initial and nal velocities,
respectively, and n is a vector normal to the mirror surface.
This expression is arrived at by again considering the projection onto the mirror nor-
mal (see gure 5.4). The reectivity of the mirror is taken into account as explained in
section 5.3.1.
There are a few optimizations possible here to avoid redundant computations. Since the
neutron is always inside the guide during the computations, we always have (O r 0 )n  0.
Thus t  0 if v  n  0, so in this case there is no need to actually compute t. Some
redundant computations are also avoided by utilizing symmetry and the fact that many
components of n and O are zero.
The input parameters of this component are the opening sizes of the entry and exit
point of the guide, (w 1 ; h 1 ) and (w 2 ; h 2 ), respectively, the guide length, l, and the values
of R 0 ; m;Q c ; W , and  for the mirror.
5.3.4 Channeled guide: A guide section component with multiple chan-
nels
The component Channeled guide is a more exible variation of the Guide component
described in the previous section. It allows the specication of dierent supermirror pa-
rameters for the horizontal and vertical mirrors, and also implements guides with multiple
channels as used in neutron bender devices. By setting the m value of the supermirror
coatings to zero, nonreecting walls are simulated; this may be used to simulate a Soller
collimator.
The channel walls are assumed to be innitely absorbing. The implementation is
basen on that of the Guide component. Initially, the channel which the neutron will enter
is computed. The x coordinate is then shifted so that the channel can be simulated as
a single instance of the Guide component. Finally the coordinates are restored when the
neutron exits the guide or is absorbed.
The input parameters are w1, h1, w2, h2, and l to set the guide dimensions in meters
as for the Guide component (entry window, exit window, and length); k to set the number
of channels; d to set the thickness of the channel walls, in meters; and R0, W, Qcx, Qcy,
alphax, alphay, mx, and my to set the supermirror parameters as described above (the
names with x denote the vertical mirrors, and those with y denote the horizontal ones).
58 Ris{R{1175(EN)

5.4 Chopper-like components
In this section, we will present rotating components such as chopppers, velocity selectors,
etc.
5.4.1 V selector: The rotating velocity selector
The component V selector models a rotating velocity selector constructed from a number
of collimator blades arranged radially on an axis. Two identical slits at a 12 o'clock position
allow neutron passage at the position of the blades. The blades are "twisted" on the axis
so that a stationary velocity selector does not transmit any neutrons; the total twist angle
is denoted . By rotating the selector you allow transmittance of neutrons around certain
velocities, given by
V 0 = !L=; (5.15)
which means that the selector has turned the twist angle  during the neutron ight time
L=V 0 .
Neutrons having a velocity slightly smaller or larger than V 0 will either be transmitted
or absorbed depending on the exact position of the rotator blades when the neutron enters
the selector. Assuming this position to be unknown (and assuming innitely thin blades),
we arrive at
T =
 1 (N=2)j !L=V j if 1 < (N=2)( !L=V ) < 1
0 otherwise (5.16)
where N is the number of collimator blades.
A horisontal divergence changes the above formula because of the angular dierence
between the entry and exit points of the neutron. The resulting transmittance resembles
the one above, only with V replaced by V z and  replaced by (+ ), where   is the angular
dierence due to the divergence. An additional vertical divergence does not change this
formula, but it may contribute to  . (We have here ignored the very small non-linearity
of   along the neutron path in case of both vertical and horisontal divergence).
Adding the eect of a nite blade thickness, t, reduces the transmission by the overall
amount
dT = (N t)=(2r); (5.17)
where r is the distance from the rotation axis. We ignore the variation of r along the
neutron path and use just the average value.
The input parameters for V selector are the slit dimensions, width, height (in m), the
distance between apertures, L 0 (in m), the length of the collimator blades, L 1 (in m), the
height from rotation axix to the slit centre, r 0 (in m), the rotation speed ! (in rpm) the
twist angle  (in degrees), the blade thickness t (in m), and the number of blades, N .
The local coordinate system is centered at the slit centre.
5.4.2 Chopper: The disc chopper
This component was contributed by Philipp Bernhardt, Lehrstuhl fur Kristallographie
und Strukturphysik.
Ris{R{1175(EN) 59

To cut a continuous neutron beam into short pulses, you can use a disc chopper (g-
ure 5.5). This is a fast rotating disc with the rotating axis parallel to the neutron beam.
The disk consists of neutron absorbing materials. To form the pulses there are slits through
which the neutrons can pass.
disc
R
y
x
≠f
+f
slit
coordinate system of the chopper
w
Figure 5.5: disc chopper
This component simulates choppers with more than one slit. The slits are symmetri-
cally disposed on the disc. You can set the direction of rotation, which allows to simulate
double choppers. You can also dene the phase by setting the time at which one slit is
positioned at the top. The sides of the slits are pointing towards the center of the disc.
The thickness of the disc is neglected. There is no parameter for the height of the slits,
so if you like to limit the neutrons in the y-direction, just use a slit component in front of
the chopper.
If you use a rectangular shaped beam and the beam has nearly the same size as the
slit, you will get an almost triangular shape of the transmission curve (gure 5.6).
The input parameters for this component are the width w of the slit at the radius R
of the disc, the phase pha, the number of slits n and the angular frequency f . The sign of
f denes the direction of rotation, as can be seen in gure 5.5.
5.4.3 First chopper: The rst disc chopper
This component was contributed by Philipp Bernhardt, Lehrstuhl fur Kristallographie
und Strukturphysik.
The disadvantage of the component `Chopper' is the bad statistic, because most of the
neutrons of a continuous beam are absorbed. Furthermore TOF-instruments dene the
starting time of the neutrons at the position of the rst chopper and not at the source.
Therefore this component is useful. This `rst disc chopper` has the same geometrical and
60 Ris{R{1175(EN)

time
transmission
Figure 5.6: example transmission curve for the disc chopper
physical attributes as the normal disc chopper before. But it does not check if the neutron
can pass the disc chopper, it instead gives the neutron a time at which it is possible to
pass. There is no absorption in this component, all neutrons will be used.
Because the value t of the incoming neutron will be overwritten, this chopper can only
be used as a rst chopper.
The input parameters are, again, the width w of the slit at the radius R of the disc,
the phase pha of the chopper, the number of slits n and the angular frequency f (sign
denes direction of rotation). With the additional parameter a you can set the number of
pulses. This is useful if you want to investigate frame overlaps.
5.5 Detectors and monitors
In real neutron experiments, detectors and monitors play quite dierent roles. One wants
the detectors to be as e∆cient as possible, counting all neutrons (and absorbing them in
the process), while the monitors measure the intensity of the incoming beam, and must
as such be almost transparent, interacting only with (roughly) 0.1-1% of the neutrons
passing by. In computer simulations, it is of course possible to detect every neutron
without absorbing it or disturbing any of its parameters. Hence, the two components
have very similar functions in the simulations, and we do not distinguish between them.
For simplicity, they are from here on just called monitors, since they do not absorb the
neutron.
Another dierence between computer simulations and real experiments is that one may
Ris{R{1175(EN) 61

allow the monitor to be sensitive to any neutron property, as e.g. direction, energy, and
polarization, in addition to what is found in advanced existing monitors (space and time).
One may, in fact, let the monitor have several of these properties at the same time, as
seen for example in the energy sensitive monitor in section 5.5.7.
5.5.1 Monitor: The single monitor
The component Monitor consists of a rectangular opening | like that for slit. The
neutron is propagated to the plane of the monitor by the kernel call PROP Z0. Any
neutron that passes within the opening is counted | the number counting variable is
incremented: N i = N i 1 +1, the neutron weight p i is added to the weight counting variable:
I i = I i 1 + p i , and the second moment of the weight is updated: M 2;i = M 2;i 1 + p 2
i . The
input parameters for Monitor are the opening coordinates x min ; x max ; y min , y max , and the
output parameters are the three count numbers, N; I, and M 2 .
5.5.2 Monitor 4PI: The 4 monitor
The component Monitor 4PI does not model any physical monitor but may be thought of
as a spherical monitor completely surrounding the previous component. It simply detects
all neutrons that have not been absorbed at the position in the instrument in which it
is placed. If this monitor is placed in the instrument le after another component, e.g.
a sample, it will count any neutron scattered from this component. This may be useful
during tests.
The output parameters for Monitor 4PI are the three count numbers, N; I, and M 2 .
5.5.3 PSD monitor: The PSD monitor
The component PSD monitor closely resembles Monitor. In the PSD monitor, though,
the rectangular monitor window is divided into n  m pixels, each of which acts like a
single monitor.
The input parameters for PSDmonitor are the opening coordinates x min ; x max ; y min ,
y max , the array dimensions (n; m), and a name of a le in which to store I(x; y). The
output parameters are three two-dimensional arrays of counts: N(x; y); I(x; y); M 2 (x; y).
5.5.4 PSD monitor 4PI: The 4 PSD monitor
The component PSD monitor 4PI represents a PSD monitor shaped as a sphere, much
like Monitor 4PI. It subdivides the surface of the sphere into pixels of equal area (using
a projection onto a cylinder with an axis which is vertical in the local coordinate system)
and distributes the incoming neutron counts into the respective pixels.
The 4 PSD monitor is typically placed around another component. Used in this way,
the 4 PSD monitor is very useful for debugging components.
The input parameters for PSD monitor 4PI are the monitor radius, the number
of pixels, (n x ; n y ) { where y is the vertical direction, and the name of the le in which
to store I(x; y). The output parameters of the component are the three count arrays
N(x; y); I(x; y), and M 2 (x; y).
62 Ris{R{1175(EN)

5.5.5 PSD monitor 4PI log: The 4 PSD monitor with log scale
The component PSD monitor 4PI log is the same as PSD monitor 4PI described in
the previous section, except that the output histograms contain the base-10 logarithm of
the intensities rather than the intensities themselves. Currently, this does not work well
together with the McStas mechanism to output detector results (see section 3.4.5), so the
total intensity as output by McStas from this detector component will be wrong. However,
the component was su∆ciently useful in Laue-type diraction instruments to be included
here nevertheless. A future version of McStas may implement a better way to get log-scale
in output les.
The input parameters for PSD monitor 4PI log are the same as for PSD monitor 4PI.
5.5.6 TOF monitor: The time-of-ight monitor
TOF monitor is a rectangular single monitor which is sensitive to the absolute time,
where the neutron is hits the component. Like in a real time-of-ight detector, the time
dimension is binned into small time intervals of length dt, whence this monitor updates a
one-dimensional array of counts.
The input parameters for TOF monitor are the opening coordinates x min ; x max ; y min ,
y max , the number of time bins (beginning from t = 0), n chan , the time spacing between
bins, dt (in s), and the name of the output le. Output parameters of the component
are the three count arrays N(i); I(i), and M 2 (i), where i is the bin number.
5.5.7 E monitor: The energy sensitive monitor
The component E monitor resembles TOF monitor to a very large extent. Only this
monitor is sensitive to the neutron energy, which in binned in nchan bins between E min
and E max .
The input parameters for E monitor are the opening coordinates x min ; x max ; y min ,
y max , the total energy interval given by E min and E max (in meV), and nchan and the
name of the output le. Output parameters of the component are the three count arrays
N(i); I(i), and M 2 (i), i being the bin number.
5.5.8 L monitor: The wavelength sensitive monitor
The component L monitor is a rectangular monitor with an opening in the x-y plane
which is sensitive to the neutron wavelength. The wavelength spectrum is output in a
one-dimensional histogram. Only neutrons with wavelength  0 <  <  1 are detected.
The input parameters for L monitor are the opening coordinates xmin, xmax, ymin,
and ymax dening the edges of the slit in meters; the lower and upper wavelength limit
Lmin and Lmax in  Angstrm; the number of histogram bins nchan; and lename, a string
giving the name of the le to store the data in.
5.5.9 Divergence monitor: The divergence sensitive monitor
The component Divergence monitor is a rectangular monitor with an opening in the
x-y plane, which is sensitive to the neutron divergence, i.e. the angle between the neutron
path and the monitor surface normal.
Ris{R{1175(EN) 63

The divergence is divided into horisontal and vertical divergencies, which are calcu-
lated as ∆ h = tan 1 (v x =v z ) and ∆ v = tan 1 (v y =v z ), respectively. Only neutrons within
a divergence window of ∆ h = ( ∆ h;max ; ∆ h;max ), ∆ v = ( ∆ v;max ; ∆ v;max ) are detected. The
counts are binned in an array of n h  n v pixels.
The input parameters for the Divergence monitor component are the opening coordi-
nates (x min ; x max ; y min ; y max ), the number of pixels (n h ; n v ), the parameters (∆ h;max ; ∆ v;max )
dening the divergence interval, and a name of the le in which to store the detected in-
tensities.
Note that a divergence sensitive monitor with a small opening may be thought of as a
non-reversing pinhole camera.
5.5.10 DivPos monitor: The divergence-position sensitive monitor
The component DivPos monitor is a rectangular monitor with an opening in the x-y
plane, which is sensitive to both the horizontal neutron divergence and the horizontal
neutron position. The neutron intensity as a function of position and divergence is output
in a two-dimensional histogram. This output may be directly compared to an accep-
tance diagram, an analytical technique that is sometimes used to calculate neutron guide
performances.
The horizontal divergence is calculated as ∆ h = tan 1 (v x =v z ) . Only neutrons within
a divergence window of ∆ h = ( ∆ h;max ; ∆ h;max ) are detected.
The input parameters for the DivPos monitor component are the opening coordinates
xmin, xmax, ymin, and ymax in meters; the number of histogram bins npos and ndiv
in position and divergence; the maximum divergence maxdiv to detect, in degrees; and
lename, a string giving the name of the le to store the data in.
5.5.11 DivLambda monitor: The divergence-wavelength sensitive mon-
itor
The component DivLambda monitor is a rectangular monitor with an opening in the x-
y plane, which is sensitive to both the horizontal neutron divergence and the wavelength.
The neutron intensity as a function of wavelength and divergence is output in a two-
dimensional histogram.
The horizontal divergence is calculated as ∆ h = tan 1 (v x =v z ) . Only neutrons within
a divergence window of ∆ h = ( ∆ h;max ; ∆ h;max ) and with wavelength  0 <  <  1 are
detected.
The input parameters for the DivLambda monitor component are the opening coor-
dinates xmin, xmax, ymin, and ymax in meters; the number of histogram bins nlam and
ndiv in wavelength and divergence; the maximum divergence maxdiv to detect, in degrees;
lambda 0 and lambda 1 to dene the wavelength window, in  Angstrm; and lename, a
string giving the name of the le to store the data in.
5.5.12 Monitor nD: A general Monitor for 0D/1D/2D records
This component was contributed by Emmanuel Farhi, Institute Laue-Langevin.
The component Monitor nD is a general Monitor that can output any set of physical
parameters concerning the passing neutrons. The generated les are either a set of 1D
64 Ris{R{1175(EN)

signals ([Intensity] vs. [Variable]), or a single 2D signal ([Intensity] vs. [Variable 1] vs.
[Variable 1]), and possibly a simple long list of the selected physical parameters for each
neutron.
The input parameters for Monitor nD are its dimensions x min ; x max ; y min , y max (in
meters) and an options string describing what to detect, and what to do with the signals, in
clear language. The formatting of the options parameter is free, as long as it contains some
specic keywords, that can be sometimes followed by values. The no or not option modier
will revert next option. The all option can also aect a set of monitor conguration
parameters (see below).
The Monitor nD geometry
The monitor shape can be selected among four geometries:
1. (square) The default geometry is at rectangular in (xy) plane with dimensions
x min ; x max ; y min , y max .
2. (disk) When choosing this geometry, the detector is a at disk in (xy) plane. The
radius is then
radius = max(abs [x min ; x max ; y min ; y max ]): (5.18)
3. (sphere) The detector is a sphere with the same radius as for the disk geometry.
4. (cylinder) The detector is a cylinder with revolution axis along y (vertical). The
radius in (xz) plane is
radius = max(abs [x min ; x max ]); (5.19)
and the height along y is
height = jy max y max j: (5.20)
By default, the monitor is at, rectangular. Of course, you can choose the orientation
of the Monitor nD in the instrument description le with the usual ROTATED modier.
For the sphere and cylinder, the incoming neutrons are monitored by default, but you
can choose to monitor outgoing neutron with the outgoing option.
At last, the slit or absorb option will ask the component to absorb the neutrons that
do not intersect the monitor.
The neutron parameters that can be monitored
There are 25 dierent variables that can be monitored at the same time and position.
Some can have more than one name (e.g. energy or omega).
kx ky kz k wavevector (Angs-1) Wavevector norm or coordinates
vx vy vz v (m/s) Velocity norm or coordinates
x y z radius (m) Position and radius in (xy) plane
t time (s) Time of Flight
energy omega (meV) Neutron energy
lambda wavelength (Angs) Neutron wavelength
Ris{R{1175(EN) 65

p intensity flux (n/s) or (n/cm^2/s) The neutron weight
ncounts (1) The number of events detected
sx sy sz (1) Spin of the neutron
vdiv (deg) vertical divergence
hdiv divergence (deg) horizontal divergence
angle (deg) divergence from <z> direction
theta longitude (deg) longitude (x/z)
phi lattitude (deg) lattitude (y/z)
To tell the component what you want to monitor, just add the variable names in the
options parameter. The data will be sorted into bins cells (default is 20), between some
default limits, that can also be set by user. The auto option will automatically determine
what limits should be used to have a good sampling of signals.
The with borders option will monitor variables that are outside the limits. These values
are then accumulated on the 'borders' of the signal.
Each monitoring will record the ux (sum of weights p) versus the given variables. The
per cm2 option will ask to normalize the ux to the monitor section surface.
Some examples ?
1. options="x bins=30 limits=[-0.05 0.05] ; y"
will set the monitor to look at x and y. For y, default bins and limits values (monitor
dimensions) are used.
2. options="x y, all bins=30, all limits=[-0.05 0.05]"
will do the same, but set limits and bins for x and y.
3. options="x y, auto limits"
will determine itself the required limits for x and y to monitor passing neutrons with
default bins=20.
The output les
By default, the le names will be the component name, followed by automatic extensions
showing what was monitored (such as MyMonitor.x). You can also set the lename in
options with the le keyword followed by the le name that you want. The extension will
then be added if the name does not contain a dot (.).
The output les format are standard 1D or 2D McStas detector les. The no le option
will unactivate monitor, and make it a single 0D monitor detecting integrated ux and
counts. The verbose option will display the nature of the monitor, and the names of the
generated les.
The 2D output
When you ask the Monitor nD to monitor only two variables (e.g. options = "x y"), a
single 2D le of intensity versus these two correlated variables will be created.
66 Ris{R{1175(EN)

The 1D output
The Monitor nD can produce a set of 1D les, one for each monitored variable, when
using 1 or more than 2 variables, or when specifying the multiple keyword option.
The List output
The Monitor nD can additionally produce a list of variable values for neutrons that pass
into the monitor. This feature is additive to the 1D or 2D output. By default only 1000
events will be recorded in the le, but you can specify for instance "list 3000 neutrons"
or "list all neutrons". This last option might require a lot of memory and generate huge
les.
Usage examples
 COMPONENT MyMonitor = Monitor_nD(
xmin = -0.1, xmax = 0.1,
ymin = -0.1, ymax = 0.1,
options = "energy auto limits")
will monitor the neutron energy in a single 1D le (a kind of E monitor)
 options="x y, all bins=50"
will monitor the neutron x and y in a single 2D le (same as PSD monitor)
 options="multiple x bins=30, y limits=[-0.05 0.05]"
will monitor the neutron x and y in two 1D les
 options="x y z kx ky kz, auto limits"
will monitor theses variables in six 1D les
 options="x y z kx ky kz, list all, auto limits"
will monitor all theses neutron variables in one long list
 options="multiple x y z kx ky kz, and list 2000, auto limits"
will monitor all theses neutron variables in one list of 2000 events and in six 1D les
5.5.13 Res monitor: The resolution monitor
The component Res monitor is used together with the Res sample component (de-
scribed in section 5.8.1) and the mcresplot front-end (described in section 2.6.6). It
works like a normal single detector, but also records all scattering events in the resolution
sample and writes them to a le that can later be read by mcresplot.
The instrument denition should contain an instance of the Res sample component,
the name of which should be passed as an input parameter to Res monitor. For example
COMPONENT mysample = Res_sample( ... )
...
COMPONENT det = Res_monitor(res_sample_comp = mysample, ...)
...
Ris{R{1175(EN) 67

The output le is in ASCII format, one line per scattering event, with the following
columns:
 k i , the three components of the initial wave vector.
 k f , the three components of the nal wave vector.
 r, the three components of the position of the scattering event in the sample.
 p i , the neutron weight just after the scattering event.
 p f , the relative neutron weight adjustment from sample to detector (so the total
weight in the detector is p i p f ).
From k i and k f , we may compute Q = k i k f and ! = (2.072 meV  A 2 )(k 2
i k 2
f ).
The vectors are given in the local coordinate system of the resolution sample compo-
nent. The wave vectors are in units of  A 1 , the scattering position in units of meters.
The input parameters for Res monitor are the opening coordinates x min ; x max ; y min ,
y max as for the single monitor component, the name of the le to write in lename, and
res sample comp which should be set to the name of the resolution sample component used
in the instrument. The output parameters are the three count numbers, Nsum, psum, and
p2sum, and the handle le of the output le.
5.5.14 Adapt check: The simple adaptive importance sampling monitor
The component Adapt check is used together with the Source adapt component | see
section 5.1.6 for details. When placed somewhere in an instrument using Source adapt, the
source will optimize for neutrons that reach that point without being absorbed (regardless
of neutron position, direction, wavelength, etc).
The Adapt check component takes a single input parameter source comp. This should
be set to the name given to the Source adapt component in the instrument, for example
...
COMPONENT mysource = Source_adapt( ... )
...
COMPONENT mycheck = Adapt_check(source_comp = mysource)
...
5.5.15 Monitor Optimizer: Optimization locations for the Source Opti-
mizer component
This component was contributed by Emmanuel Farhi, Institute Laue-Langevin.
The Monitor Optimizer component works with the Source Optimizer component.
See section 5.1.7 for usage.
The input parameters for Monitor Optimizer are the rectangular shaped opening
coordinates x min ; x max ; y min , y max (in meters), and the name of the associated instance
of the Source Optimizer component used in the instrument description le (one word,
without quotes).
68 Ris{R{1175(EN)

5.6 Bragg scattering single crystals, monochromators
In this class of components, we are concerned with elastic Bragg scattering from single
crystals. The Mosaic anisotropic component models a thin mosaic crystal with a single
scattering vector perpendicular to the surface. It is a replacement for the Monochromator
component from previous releases; it uses a better algorithm that works in some cases
where the old component would give wrong results. The Mosaic simple component is
similar, but has an isotropic mosaic and allows a scattering vector that is not perpendicular
to the surface. The Single crystal component is a general single crystal sample that allows
the input of an arbitrary unit cell and a list of structure factors, and also allows anisotropic
mosaic and d=d lattice space variation.
5.6.1 Mosaic simple: An innitely thin mosaic crystal with a single scat-
tering vector
The component Mosaic simple simulates an innitely thin single crystal with a single
scattering vector and a mosaic spread. A typical use for this component is to simulate a
monochromator or an analyzer.
The physical model used in the component is a rectangular piece of material composed
of a large number of small micro-crystals. The orientation of the micro-crystals deviates
from the nominal crystal orientation so that the probability of a given micro-crystal ori-
entation is proportional to a Gaussian in the angle between the given and the nominal
orientation. The width of the Gaussian is given by the mosaic spread of the crystal. The
mosaic spread is assumed to be large compared to the Bragg width of the scattering vector.
As a further simplication, the crystal is assumed to be innitely thin. This means
that multiple scattering eects are not simulated. It also means that the total reectivity
can be used as a parameter for the model rather than the atomic scattering cross section.
The variance of the lattice spacing (d=d) is assumed to be zero, so this component is
not suitable for simulating backscattering instruments (use the component Single crystal
in section 5.6.3 for that).
When a neutron trajectory intersects the crystal, the rst step in the computation is
to determine the probability of scattering. This probability is then used in a Monte Carlo
choice deciding whether to scatter or transmit the neutron. The scattering probability is
the sum of the probabilities of rst-order scattering, second-order, . . . , up to the highest
order that permits Bragg scattering at the given neutron wave length. However, in most
cases at most one order will have a signicant scattering probability, and the computation
thus considers only the order that best matches the neutron wavelength. Bragg's law is
nQ 0 = 2k i sin 
Thus, the scattering order is obtained simply as the integer multiple n of the nominal
scattering vector Q 0 which is closest to the projection of 2k i onto Q 0 (see gure 5.7).
Once n has been determined, the Bragg angle  can be computed. The angle d that the
nominal scattering vector Q 0 makes with the closest scattering vector q that admits Bragg
scattering is then used to compute the probability of reection from the mosaic
p reect = R 0 e d 2 =2 2
;
Ris{R{1175(EN) 69

PSfrag replacements

2k i
Q 0
2Q 0
3Q 0
4Q 0
Figure 5.7: Selection of the Bragg order (\2" in this case).
PSfrag replacements

2k i
2k f
Q 0
d
q
Figure 5.8: Computing the deviation d from the nominal scattering direction.
where R 0 is the reectivity at the Bragg angle (see gure 5.8). The probability p reect is
used in a Monte Carlo choice to decide whether the neutron is transmitted or reected.
In the case of reection, the neutron will be scattered into the Debye-Scherrer cone,
with the probability of each point on the cone being determined by the mosaic. The
Debye-Scherrer cone can be described by the equation
k f = k i cos 2 + sin 2(c cos ' + b sin '); ' 2 [ ; ]; (5.21)
where b is a vector perpendicular to k i and Q 0 , c is perpendicular to k i and b, and both
b and c have the same length as k i (see gure 5.9). When choosing ' (and thereby k f ),
only a small part of the full [ ; ] range will have appreciable scattering probability in
non-backscattering congurations. The best statistics is thus obtained by sampling ' only
from a suitably narrow range.
The (small) deviation angle  of q from the nominal scattering vector nQ 0 corresponds
to a q of
q  2k sin :
70 Ris{R{1175(EN)

PSfrag replacements
2
2k i
2k f
nQ 0
q 2k sin(2)
Figure 5.9: Scattering into the part of the Debye-Scherrer cone covered by the mosaic.
The angle ' corresponds to a k f (and hence q) of
q  'k sin(2)
(see gure 5.9). Hence we may sample ' from a Gaussian with standard deviation

2k sin 
k sin(2)
= 
2k sin 
2k sin  cos 
= 
cos 
to get good statistics.
What remains is to get the neutron weight right. The distribution from which the
scattering event is sampled is a Gaussian in ' of width 
cos  ,
f MC (') =
1
p
2(= cos )
e ' 2 =2(= cos ) 2
In the physical model, the probability of the scattering event is proportional to a Gaussian
in the angle between the nominal scattering vector Q 0 and the actual scattering vector
q. The normalization condition is that the integral over all ' should be 1. Thus the
probability of the scattering event in the physical model is
(') = e
d(') 2
2 2 =
Z 

e
d(') 2
2 2 d' (5.22)
where d(') denotes the angle between the nominal scattering vector and the actual scat-
tering vector corresponding to '. According to equation (4.8), the weight adjustment  j
is then given by
 j = (')=fMC ('):
Ris{R{1175(EN) 71

In the implementation, the integral in (5.22) is computed using a 15-order Gaussian
quadrature formula, with the integral restricted to an interval of width 5= cos  for the
same reasons discussed above on the sampling of '.
The input parameters for Mosaic simple are zmin, zmax, ymin, and ymax to dene the
surface of the crystal in the Y-Z plane; mosaic to give the FWHM of the mosaic spread;
R0 to give the reectivity at the Bragg angle, and Qx, Qy, and Qz to give the scattering
vector.
5.6.2 Mosaic anisotropic: The crystal with anisotropic mosaic
The component Mosaic anisotropic is a modied version of the Mosaic simple com-
ponent, intended to replace the Monocromator component from previous releases. It
restricts the scattering vector to be perpendicular to the crystal surface, but extends
the Mosaic simple component by allowing dierent mosaics in the horizontal and vertical
direction.
The code is largely similar to that for Mosaic simple, and the documentation for the
latter should be consulted for details. The dierences are mainly due to two reasons:
 Some simplications have been done since two of the components of the scattering
vector are known to be zero.
 The computation of the Gaussian for the mosaic is done done using dierent mosaics
for the two axes.
The input parameters for the component Mosaic anisotropic are zmin, zmax, ymin,
and ymax to dene the size of the crystal (in meters); mosaich and mosaicv to dene the
mosaic (in minutes of arc); r0 to dene the reectivity (no unit); and Q to set the length
of the scattering vector (in  A 1 ).
5.6.3 Single crystal: The single crystal component
The physical model
The textbook expression for the scattering cross-section of a crystal is [10]:
 d
d
 
coh:el:
= N
(2) 3
V 0
X

∆( )jF  j 2
Here jF  j 2 is the structure factor, N is the number of unit cells, V 0 is the volume of an
individual unit cell, and  = k i k f is the scattering vector. ∆(x) is a 3-dimensional
delta function in reciprocal space, so for given incoming wave vector k i and lattice vector
 , only a single nal wave vector k f is allowed. In a real crystal, however, reections are
not perfectly sharp. Because of imperfection and nite-size eects, there will be a small
region around  in reciprocal space of possible scattering vectors.
The Single crystal component simulates a crystal with a mosaic spread  and a lattice
plane spacing uncertainty d=d. In such crystals the reections will not be completely
sharp; there will be a small region around each reciprocal lattice point of the crystal that
contains valid scattering vectors.
72 Ris{R{1175(EN)

PSfrag replacements
k i
k f


d=d
Ewald
Sphere
Figure 5.10: Ewald sphere construction for a single neutron showing the Gaussian broad-
ening of reciprocal lattice points in their local coordinate system.
We model the mosaicity and d=d of the crystal with 3-dimensional Gaussian functions
in reciprocal space (see gure 5.10). Two of the axes of the Gaussian are perpendicular to
the reciprocal lattice vector  and model the mosaicity. The third one is parallel to  and
models d=d. We assume that the mosaicity is small so that the possible directions of the
scattering vector may be approximated with a Gaussian in rectangular coordinates.
If the mosaic is isotropic (the same in all directions), the two Gaussian axes perpen-
dicular to  are simply arbitrary normal vectors of equal length given by the mosaic. But
if the mosaic is anisotropic, the two perpendicular axes will in general be dierent for each
scattering vector. In the absence of anything better, the Single crystal component uses
a model which is at least mathematically plausible and which works as expected in the
two common cases: (1) isotropic mosaic, and (2) two mosaic directions (\horizontal and
vertical mosaic") perpendicular to a scattering vector.
The basis for the model is a three-dimensional Gaussian distribution in Euler angles
giving the orientation probability distribution for the micro-crystals; that is, the misorien-
tation is given by small rotations around the X, Y , and Z axes, with the rotation angles
having (in general dierent) Gaussian probability distributions. For given scattering vec-
tor  , a rotation of the micro-crystals around an axis parallel to  has no eect on the
direction of the scattering vector. Suppose we form the intersection between the three-
dimensional Gaussian in Euler angles and a plane through the origin perpendicular to  .
This gives a two-dimensional Gaussian, say with axes dened by unit vectors g 1 and g 2
and mosaic widths  1 and  2 .
Ris{R{1175(EN) 73

We now let the mosaic for  be dened by rotations around g 1 and g 2 with angles
having Gaussian distributions of widths  1 and  2 . Since g 1 , g 2 , and  are perpendicular,
a small rotation of  around g 1 will change  in the direction of g 2 . The two axes of
the Gaussian mosaic in reciprocal space that are perpendicular to  will thus be given by
 2 g 1 and  1 g 2 .
We now derive a quantitative expression for the scattering cross-section of the crystal
in the model. For this, we introduce a local coordinate system for each reciprocal lattice
point  and use x for vectors written in local coordinates. The origin is  , the rst axis
is parallel to  and the other two axes are perpendicular to  . In the local coordinate
system, the 3-dimensional Gaussian is given by
G(x 1 ; x 2 ; x 3 ) =
1
(
p
2) 3
1
 1  2  3
e
1
2 ( x 2 1
 2 1
+ x 2 2
 2 2
+ x 2 3
 2
3
)
(5.23)
The axes of the Gaussian are  1 = d=d and  2 =  3 =  . Here we used the assumption
that  is small, so that tan    (with  given in radians). By introducing the diagonal
matrix
D =
0
@
1
2  2
1 0 0
0 1
2  2
2 0
0 0 1
2  2
3
1
A
equation (5.23) can be written as
G(x) =
1
(
p
2) 3
1
 1  2  3
e x T Dx (5.24)
again with x = (x 1 ; x 2 ; x 3 ) written in local coordinates.
To get an expression in the coordinates of the reciprocal lattice of the crystal, we
introduce a matrix U such that if y = (y 1 ; y 2 ; y 3 ) are the global coordinates of a point in
the crystal reciprocal lattice, then U(y +  ) are the coordinates in the local coordinate
system for  . The matrix U is given by
U T = (^u 1 ; ^
u 2 ; ^
u 3 );
where ^
u 1 , ^
u 2 , and ^
u 3 are the axes of the local coordinate system, written in the global
coordinates of the reciprocal lattice. Thus ^
u 1 =  = , and ^
u 2 and ^ u 3 are unit vectors
perpendicular to ^
u 1 and to each other. The matrix U is unitarian, that is U 1 = U T . The
translation between global and local coordinates is
x = U(y +  ) y = U T x 
The expression for the 3-dimensional Gaussian in global coordinates is
G(y) =
1
(
p
2) 3
1
 1  2  3
e (U(y+ )) T D(U(y+ )) (5.25)
The elastic coherent cross-section is then given by
 d
d
 
coh:el:
= N
(2) 3
V 0
X

G( )jF  j 2 (5.26)
74 Ris{R{1175(EN)

The user must specify a list of reciprocal lattice vectors  to consider along with their
structure factors jF  j 2 . The user must also specify the coordinates (in direct space) of the
unit cell axes a, b, and c, from which the reciprocal lattice will be computed.
In addition to coherent scattering, the Single crystal component also handles incoher-
ent scattering amd absorption. The incoherent scattering cross-section is supplied by the
user as a constant  inc . The absorption cross-section is supplied by the user at 2200 m/s,
so the actual cross-section for a neutron of velocity v is  abs =  2200
2200 m=s
v .
The algorithm
The overview of the algorithm used in the Single crystal component is as follows:
1. Check if the neutron intersects the crystal. If not, no action is taken.
2. Search through a list of reciprocal lattice points of interest, selecting those that
are close enough to the Ewald sphere to have a non-vanishing scattering probability.
From these, compute the total coherent cross-section  coh (see below), the absorption
cross-section  abs =  2200
2200 m=s
v , and the total cross-section  tot =  coh + inc + abs .
3. The transmission probability is exp(  tot
V 0
`) where ` is the length of the ight path
through the crystal. A Monte Carlo choice is made whether the neutron is trans-
mitted or not. Optionally, the user may set a xed Monte Carlo probability for the
rst scattering event, for example to boost the statistics for a weak reection.
4. For non-transmission, the position at which the neutron will interact is selected from
an exponential distribution. A Monte Carlo choice is made of whether to scatter
coherently or incoherently. Absorption is treated by weight adjustment (see below).
5. For incoherent scattering, the outgoing wave vector k f is selected with a random
direction.
6. For coherent scattering, a reciprocal lattice vector is selected by Monte Carlo choice,
and k f is found (see below).
7. Adjust the neutron weight as dictated by the Monte Carlo choices made.
8. Repeat from (2) until the neutron is transmitted (to simulate multiple scattering).
For point 2, the distance dist between a reciprocal lattice point and the Ewald sphere
is considered small enough to allow scattering if it is less than ve times the maximum
axis of the Gaussian, dist  5 max( 1 ;  2 ;  3 ).
Choosing the outgoing wave vector The nal wave vector k f must lie on the in-
tersection between the Ewald sphere and the Gaussian ellipsoid. Since  and d=d are
assumed small, the intersection can be approximated with a plane tangential to the sphere,
see gure 5.11. The tangential point is taken to lie on the line between the center of the
Ewald sphere k i and the reciprocal lattice point  . Since the radius of the Ewald sphere
is k i , this point is
o = (1 k i =) 
Ris{R{1175(EN) 75

PSfrag replacements
k i
k f


x
Ewald
Sphere
Tangential
plane
Figure 5.11: The scattering triangle in the single crystal.
where  = k i  .
The equation for the plane is
P (t) = o +Bt; t 2 R
2 (5.27)
Here B = (b 1 ; b 2 ) is a 32 matrix with the two generators for the plane b 1 and b 2 . These
are (arbitrary) unit vectors in the plane, being perpendicular to each other and to the
plane normal n = =.
Each t denes a potential nal wave vector k f (t) = k i + P (t). The value of the
3-dimensional Gaussian for this k f is
G(x(t)) = 1
(
p
2) 3
1
 1  2  3
e x(t) T Dx(t) (5.28)
where x(t) =  (k i k f (t)) is given in local coordinates for  . It can be shown that
equation (5.28) can be re-written as
G(x(t)) = 1
(
p
2) 3
1
 1  2  3
e  e (t t0 ) T M(t t0 ) (5.29)
where M = B T DB is a 22 symmetric and positive denite matrix, t 0 = M 1 B T Do is
a 2-vector, and  = t T
0 Mt 0 +o T Do is a real number. Note that this is a two-dimensional
Gaussian (not necessarily normalized) in t with center t 0 and axis dened by M .
To choose k f we sample t from the 2-dimensional Gaussian distribution (5.29). To do
this, we rst construct the Cholesky decomposition of the matrix ( 1
2 M 1 ). This gives a
2  2 matrix L such that LL T = 1
2 M 1 and is possible since M is symmetric and positive
denite. It is given by
L =
  p  11 0
 12
p  11
q
 22
 2
12
 11
!
where 1
2 M 1 =
  11  12
 12  22

76 Ris{R{1175(EN)

Now let g = (g 1 ; g 2 ) be two random numbers drawn form a Gaussian distribution with
mean 0 and standard deviation 1, and let t = Lg + t 0 . The probability of a particular t
is then
P (t)dt = 1
2 e 1
2 g T g dg (5.30)
= 1
2
1
det L
e 1
2 (L 1 (t t 0 )) T (L 1 (t t0 )) dt (5.31)
= 1
2
1
det L
e (t t 0 ) T M(t t 0 ) dt (5.32)
where we used that g = L 1 (t t 0 ) so that dg = 1
det L dt. This is just the normalized form
of (5.29). Finally we set k 0
f = k i + P (t) and k f = (k i =k 0
f )k 0
f to normalize the length of
k f to correct for the (small) error introduced by approximating the Ewald sphere with a
plane.
Computing the total coherent cross-section To get the total coherent scattering
cross-section, the dierential cross-section must be integrated over the Ewald sphere:
 coh =
Z
Ewald
 d
d
 
coh:el:
d

For small mosaic we may approximate the sphere with the tangential plane, and we thus
get from (5.26) and (5.29):
 coh; =
Z
N
(2) 3
V 0
G( )jF  j 2
d
 (5.33)
= 1
k 2
i
N
(2) 3
V 0
1
(
p
2) 3
e 
 1  2  3
jF  j 2
Z
e (t t 0 ) T M(t t 0 ) dt (5.34)
= det(L) 1
k 2
i
N (2) 3=2
V 0
e 
 1  2  3
jF  j 2
Z
e 1
2 g T g dg (5.35)
= 2 det(L) 1
k 2
i
N
(2) 3=2
V 0
e 
 1  2  3
jF  j 2 (5.36)
=
det(L)
k 2
i
N
(2) 5=2
V 0
e 
 1  2  3
jF  j 2 (5.37)
 coh =
X

 coh; (5.38)
As before, we let g = L 1 (t t 0 ) so that dt = det(L)dg.
Adjusting the neutron weight We now calculate the correct neutron weight adjust-
ment for the Monte Carlo choices made. In three cases is a Monte Carlo choice made with
a probability dierent from the probability of the corresponding physical event: When
deciding whether to transmit the neutron or not, when simulating absorption, and when
selecting the reciprocal lattice vector  to scatter from.
Ris{R{1175(EN) 77

If the user has choosen a xed transmission probability f(transmit) = p transmit , the
neutron weight must be adjusted by
(transmit) =
(transmit)
f(transmit)
where (transmit) = exp(  tot
V0 `) is the physical transmission probability. Likewise, for
non-transmission the adjustment is
(no transmission) =
1 (transmit)
1 f(transmit)
:
Absorption is never explicitly simulated, so the Monte Carlo probability of coherent or
incoherent scattering is f(cohjinc) = 1. The physical probability of coherent or incoherent
scattering is
(cohjinc) =  coh +  inc
 tot
;
so again a weight adjustment (cohjinc) = (cohjinc)=f(cohjinc) is needed.
When choosing the reciprocal lattice vector  to scatter from, the relative probability
for  is r  =  coh; =jF  j 2 . This is done to get better statistics for weak reections. The
Monte Carlo probability for the reciprocal lattice vector  is thus
f( ) = r 
P

r 
whereas the physical probability is ( ) =  coh; = coh . A weight adjustment is thus
needed of
( ) = ( )
f( )
=  coh;
P

r 
 coh r 
:
The implementation
The equations describing the Single crystal simulation are quite complex, and consequently
the code is fairly sizeable. Most of it is just the expansion of the vector and matrix
equations in individual coordinates, and should thus be straightforward to follow.
The implementation pre-computes a lot of the necessary values in the INITIALIZE
section. It is thus actually very e∆cient despite the complexity. If the list of reciprocal
lattice points is big, however, the search through the list will be slow. The precomputed
data is stored in the structures hkl info and in an array of hkl data structures (one for
each reciprocal lattice point in the list). In addition, for every neutron event an array
of tau data is computed with one element for each reciprocal lattice point close to the
Ewald sphere. Except for the search for possible  vectors, all computations are done in
local coordinates using the matrix U to do the necessary transformations.
The list of reciprocal lattice points is specied in an ASCII data le. Each line contains
seven numbers, separated by white space. The rst three numbers are the (h; k; l) indices
of the reciprocal lattice point, and the last number is the value of the structure factor
jF  j 2 , in barns. The middle three numbers are not used; they are nevertheless required
since this makes the le format compatible with the output from the Crystallographica
program [11].
78 Ris{R{1175(EN)

The input parameters for the component are xwidth, yheight, and zthick to dene
the dimensions of the crystal in meters; delta d d to give the value of d=d (no unit);
(ax; ay; az), (bx; by; bz), and (cx; cy; cz) to dene the axes of the direct lattice of the crystal
(the sides of the unit cell) in units of  Angstrm; and reections, a string giving the
name of the le with the list of structure factors to consider. The mosaic is specied
either isotropically as mosaic, or anisotropically as mosaic h (rotation around the Y
axis), mosaic v (rotation around the Z axis), and mosaic n (rotation around the X axis);
in all cases in units of full-width-half-maximum minutes of arc.
Optionally, the absorption cross-section at 2200 m/s and the incoherent cross-section
may be given as absorbtion and incoherent (in barns), with default of zero; and p transmit
may be assigned a xed Monte Carlo probability for transmission through the crystal
without any interaction.
5.6.4 Monochromator: The monochromator crystal
The component Monochromator is obsolete as from McStas version 1.2. Use the com-
ponent Mosaic anisotropic instead.
5.7 Powder-like sample components
In this section, we consider elastic coherent and incoherent scattering from polycrystalline
samples. We have chosen to simulate the correct physical processes within the powder
samples on a quite detailed level.
Within many samples, the incident beam is attenuated by scattering and absorption,
so that the illumination varies considerably throughout the sample. For single crystals,
this phenomenon is known as secondary extinction [12], but the eect is also important
in powders. In analytical treatments, attenuation is di∆cult to deal with, and is thus
often ignored, making a thin sample approximation. In Monte Carlo simulations, the
beam attenuation is easily taken care of, as will be shown below. For simplicity we ignore
multiple scattering, which will be implemented in a later version of McStas.
5.7.1 Weight transformation in samples; focusing
Let us look in detail on how to simulate the physics of the scattering process within the
powder. The sample has an absorption cross section per unit cell of  a c and a scatter-
ing cross section per unit cell of  s
c . The neutron path length in the sample before the
scattering event is denoted by l 1 , and the path length within the sample after the scat-
tering is denoted by l 2 , see gure 5.12. We then dene the inverse penetration lengths as
 s =  s
c =V c and  a =  a
c =V c , where V c is the volume of a unit cell. Physically, the beam
along this path is attenuated according to
P (l) = exp( l( s +  a )); (5.39)
where the normalization is taken to be P (0) = 1.
The probability for a neutron to be scattered from within the interval [l 1 ; l 1 + dl] will
be
(l 1 )dl =  s P (l 1 )dl; (5.40)
Ris{R{1175(EN) 79

PSfrag replacements
l 1
l 2
l full
Figure 5.12: The geometry of a scattering event within a powder sample.
while the probability for a neutron to be scattered from within this interval into the solid
angle
 and not being scattered further or absorbed on the way out of the sample is
(l 1 ;
dld
 =  s P (l 1 )P (l 2
)(

d
 dl; (5.41)
where
(
 is the directional distribution of the scattered neutrons, and l 2 is determined
by l 1 , 
 and the sample geometry, see gure 5.12.
In our Monte-Carlo simulations, we will often choose the scattering parameters by
making a Monte-Carlo choice of l 1
and
 from a distribution dierent from (l 1
;
5 By
doing this, we must adjust  i according to the probability transformation rule (4.8). If
we e.g. choose the scattering depth, l 1 , from a at distribution in [0; l full ], and choose the
directional dependence from
g(
5 we have a Monte Carlo probability
f(l 1 ; =
g(
 =l full ; (5.42)
l full is here the path length through the sample as taken by a non-scattered neutron
(although we here assume that all simulated neutrons are being scattered). According to
(4.8), the neutron weight factor is now adjusted by the amount
 i (l 1 ; 
 =  s l full exp [ (l 1 + l 2 )( a +  s )]
(

g(

: (5.43)
In analogy with the source components, it is possible to dene interesting directions for
the scattering. One will then try to focus the scattered neutrons, choosing a
g(
8 which
peaks around these directions. To do this, one uses (5.43), where the fraction
(
 =g
(

corrects for the focusing. One must choose a proper distribution so that
g(
 > 0 in every
interesting direction. If this is not the case, the Monte Carlo simulation gives incorrect
results.
All samples of the powder type have been constructed with a focusing and a non-
focusing option.
80 Ris{R{1175(EN)

PSfrag replacements
r i r o
h
Figure 5.13: The geometry of the hollow-cylinder vanadium sample.
5.7.2 V sample: An incoherent scatterer, the V-sample
A vanadium sample is frequently being used for calibration purposes, as almost all of the
scattering from the sample occurs incoherently.
In the component V sample, shown in B.7.2 we assume only absorption and incoherent
scattering. For the sample geometry, we have assumed the shape of a hollow cylinder
(which has the solid cylinder as a limiting case). The sample dimensions are: Inner radius
r i , outer radius r o , and height h, see gure 5.13.
When calculating the neutron path length within the sample material, the kernel func-
tion CYLINDER_INTERSECT is used twice, once for the outer radius and once for the inner
radius.
The incoherent scattering gives a completely uniform angular distribution of the scat-
tered neutrons from each V-nucleus:
(
 = 1=4. For the focusing we choose to have a
uniform distribution on a target sphere of radius r t , at the position (x t ; y t ; z t ) in the local
coordinate system. This gives an angular distribution (in a small angle approximation) of
g(
 = 1
4
x 2
t + y 2
t + z 2
t
(r 2
t )
: (5.44)
The input parameters for the component V sample are the sample dimensions (r i , r o ,
and h), the packing factor for the V-sample (pack), and the focusing parameters (x t ; y t ; z t ,
and r t ) for the target sphere. The relevant material parameters for V ( s
c ,  a
c , and the
unit cell volume V c ) are contained within the component.
Note: When simulating a realistic V-sample of this geometry one nds that the result-
ing direction dependence of the scattered intensity is not isotropic. This is explained by
the variation of attenuation with scattering angle. One test result is shown in Appendix
D.
Ris{R{1175(EN) 81

PSfrag replacements
2
Figure 5.14: The scattering geometry of a powder sample showing the Debye-Scherrer
cone and the Debye-Scherrer circle.
5.7.3 Powder1: A general powder sample
General considerations
An ideal powder sample consists of many small crystallites, although each crystallite is
su∆ciently large not to cause size broadening. The orientation of the crystallites is evenly
distributed, and there is thus always a certain number of crystallites oriented to fulll the
Bragg condition
n = 2d sin ; (5.45)
where n is the order of the scattering (an integer),  is the neutron wavelength, d is
the lattice spacing of the sample, and 2 is the scattering angle, see gure 5.14. As all
crystal orientations are realised in a powder sample, the neutrons are scattered within a
Debye-Scherrer cone of opening angle 4 [12].
Equation (5.45) may be cast into the form
jQj = 2jkj sin ; (5.46)
where Q is a vector of the reciprocal lattice, and k is the wave vector of the neutron.
It is seen that only reciprocal vectors fullling jQj < 2jkj contribute to the scattering.
For a complete treatment of the powder sample, one needs to take into account all these
Q-values, since each of them contribute to the attenuation.
The textbook expression for the scattering intensity from one reection in a slab-shaped
powder sample, much larger than the beam cross section, reads [12]
P
P 0
=  3 l s
4r
 0

tjN 2
c jF (Q)j 2 exp( 2W ) exp(  a t=cos)
sin 2 (2)
(5.47)
82 Ris{R{1175(EN)

jF (Q)j 2 =
     
X
j
b j exp(R j  Q)
     
2
; (5.48)
where the sum in the structure factor runs over all atoms in one unit cell. The meanings
and units of the symbols are
P 0 s 1 Incoming intensity of neutrons
P s 1 Detected intensity of neutrons
l s m Height of detector
r m Distance from sample to detector
 0 = 1 Packing factor of the powder
t m Slab thickness
j 1 Multiplicity of the reection
N c m 3 Density of unit cells in bulk material
jF (Q)j 2 m 2 Structure factor
exp( 2W ) 1 Debye-Waller factor
 a m 1 Linear attenuation factor due to absorption.
In analogy with this, the textbook expression for a cylinder shaped powder sample, com-
pletely illuminated by the beam, reads [12]
P
	 0
= V  0
 N 2
c jF (Q)j 2 j exp( 2W ) A hkl
sin() sin(2)
l s
2r
 3
4 ; (5.49)
where the new symbols are
	 0 s 1 m 2 Incoming beam ux
V m 3 Sample volume
A hkl 1 Attenuation factor.
Eq. (5.47) for a slab shaped sample may be cast into the form of the cylinder expression
above by using the substitutions
Incoming ux P 0 =(wh cos ) ! 	 0
Sample volume wht ! V
Absorption factor exp(  a t= cos ) ! A hkl ,
where h and w are the height and width of the sample, respectively. Often, one denes
the scattering power as
Q  N 2 jF (Q)j 2  3
V sin(2)
= N 2
c V
 0

jF (Q)j 2  3
sin(2) ; (5.50)
where N is the number of unit cells.
A cut though the Debye-Scherrer cone perpendicular to its axis is a circle. At the
distance r from the sample, the radius of this circle is r sin(2). Thus, the detector (in a
small angle approximation) only counts a fraction f d = l s =(2r sin(2)) of the scattered
neutrons. One may now calculate the linear attenuation coe∆cient in the material due to
scattering (from one Q-value only):
 s 
1
P 0
d(P=f d )
dl
= Q
V
j exp( 2W ) cos(): (5.51)
Ris{R{1175(EN) 83

A powder sample will in general have several allowed reections Q j , which will all con-
tribute to the attenuation. These reections will have dierent values of jF (Q j )j 2 (and
hence of Q j ), j j , exp( 2W j ), and  j . The total attenuation through the sample due to
scattering is given by  s =  s
inc +
P
j  s
j , where  s
inc represents the incoherent scattering.
This implementation
For component Powder1, we assume that the sample has the shape of a solid cylinder.
Further, the incoherent scattering is only taken into account by the attenuation of the
beam, given by (5.51) and  a
c . The incoherently scattered neutrons are not propagated
through to the detector, but rather not generated at all. Focusing is performed by only
scattering into one angular interval, d of the Debye-Scherrer circle. The center of this
interval is located at the point where the Debye-Scherrer circle intersects the half-plane
dened by the initial velocity, v i , and a user-specied vector, f. Multiple scattering is not
implemented.
The input parameters for this component are
r m Radius of cylinder
h m Height of cylinder
 a
c fm 2 Absorption cross section per unit cell (at 2200 m/s)
 s
i;c (fm) 2 Incoherent scattering cross section per unit cell
 0 = 1 Packing factor
V c  A 3 Volume of unit cell
Q  A 1 The reciprocal lattice vector under consideration
jF (Q j )j 2 (fm) 2 Structure factor
j 1 Multiplicity of reection
exp( 2W ) 1 Debye-Waller factor
d deg Angular interval of focusing
f x m
f y m Focusing vector
f z m
The source text for the component is shown in Appendix B.7.3.
In a later version, more reciprocal lattice vectors will be allowed. Further, we intent
to include the eect of multiple scattering.
5.8 Inelastic scattering kernels
In this section, samples with inelastic scattering are described. Currently, only a single
sample is available that scatters uniformly in (Q; !) and is used for computing resolution
functions in tripple-axis instruments.
5.8.1 Res sample: A uniform scatterer for resolution calculation
The component Res sample models an inelastic sample that scatters completely homoge-
neous in position and energy; regardless of the state of the incoming neutron, all directions
and energies for the scattered neutron have the same probability. This clearly does not
84 Ris{R{1175(EN)

correspond any physically realizable samples, but the component is very useful for com-
putation of the resolution function and may also be used for test and debugging purposes.
The component is designed to be used together with the Res monitor component, de-
scribed in section 5.5.13.
The shape of the sample is either a hollow cylinder (like the vanadium sample described
in section 5.7.2) or a rectangular box. The hollow cylinder shape is specied with inner
and outer radius radius i and radius o and height h. If radius o is negative, the shape is
instead a box of width radius i along the X axis, height h, and thickness radius o along
the Z axis, centered on the Z axis and with the front face in the X-Y plane. See gure 5.15.
PSfrag replacements
radius i radius o
h
radius i
radius o
h X
Y
Z
Figure 5.15: The two possible shapes of the Res sample component.
The component only propagates the neutrons that are scattered; neutrons that would
pass through or miss the sample are absorbed. There is no modeling of the cross section
of the sample, secondary extinction etc.; the scattering probability is proportional to
the neutron ight path length inside the sample, with the constant of proportionality
arbitrarily set to 1=(2jradius oj). The reason for this is that the component is designed
for computing the resolution function of an instrument, including the sample size but
independent of any sample properties such as scattering and absorbtion cross sections.
The point of scattering in the sample is chosen at a random position along the neutron
ight path inside the sample, and the scattered neutron is given a random energy and
direction. The energy is selected in a user-specied interval [E 0 E;E 0 +E] which must
be chosen large enough to cover all interesting neutrons, but preferably not excessively
large for reasons of e∆ciency. Similarly, the direction is chosen in a user-specied range;
the range is such that a sphere of given center and radius is fully illuminated.
A special feature, used when computing resolution functions, is that the component
stores complete information about the scattering event in the output parameter res struct.
The information includes initial and nal wave vectors, the coordinates of the scattering
point, and the neutron weight after the scattering event. From this information the scatter-
ing parameters (Q i ; ! i ) for every scattering event i may be recorded and used to compute
the resolution function of an instrument, as explained below. For an example of how to
Ris{R{1175(EN) 85

use the information in the output parameter, see the description of the Res monitor
component in section 5.5.13.
The input parameters to the Res sample components are the sample dimensions
radius i, radius o, and h, all in meters; the center of the scattered energy range E0 and
the energy spread dE in meV; and the target sphere position in the local coordinate system
target x, target y, target z, and radius focus r, in meters. The only output parameter is
res struct containing information about the scattering event, with all vectors given in the
local coordinate system of the component in units of meter.
Background
In an experiment, as well as in the simulation, the expected intensity is by denition of
the resolution function given by
I =
Z
R(Q;!)(Q;!)dQd!
Here I(Q 0 ; ! 0 ) is the measured or simulated intensity in the detector, R is the resolution
function for the instrument in a given setup,  is the scattering cross section of the sample,
and (Q; !) denote the scattering vector and energy transfer in the sample. For the uniform
scatterer, (Q; !) = 1=V 0 is a constant, so we have
I = 1=V 0
Z
R(Q;!)dQd!
If we instead consider only the intensity contributed by scattering with parameters (Q; !)
that lie within a small
part
 of the total phase space and has volume V ,
I
 = 1=V 0
Z

R(Q;!)dQd! =
V
V 0
R(

(where
R(
 denotes the average value of R
over
3 we get a good approximation of
the value of R provided
that
 is su∆ciently small. This is useful with the output from
the simulations, since
I
 is approximated by
I
 
X
(Q i
;! i
)2
 p i
This can be used to histogram the resolution function or visualize it in dierent ways.
The 3D visualization of the resolution function produced by the mcresplot program for
example uses this by displaying a cloud of dots, the local density of which is proportional
to the resolution function.
The mcresplot program also computes the covariance and resolution matrices. Let-
ting (x 1
i ; x 2
i ; x 3
i ; x 4
i ) denote the (Q i ; ! i ) values obtained from the scattering events in the
simulation and  j = (
P
i p i x j
i )=(
P
i p i ) the mean value of x j
i , the covariance matrix is
computed as
C jk =
 X
i
p i (x j
i  j )(x k
i  k )

=
 X
i
p i

This covariance matrix is given in the local coordinate system of the sample component.
The mcresplot program actually outputs the covariance matrix in another coordinate
86 Ris{R{1175(EN)

system which is rotated around the Y axis so that the projection to the X-Z plane of the
average scattering vector Q avg = (
P
i p i Q i )=(
P
i p i ) is parallel to the X axis.
The resolution matrix M is the inverse of the covariance matrix and is also output in
the rotated coordinate system by mcresplot. The 4-dimensional gaussian distribution,
dened by
f(X) = e 1
2 X T MX (5.52)
where X = (Q; !), has covariance matrix C and thus denes the gaussian resolution
function with the same covariance as the resolution computed by the simulation.
The mcresplot program provides for the simultaneous visualization of the computed
and the gaussian resolution function by obtaining an appropriate number of random points
with the statistical distribution (5.52). Each point X is obtained as follows: A vector Y is
generated of four individually gaussian distributed random numbers with mean zero and
variance one. Using the Cholesky decomposition of C, C = LL T , we have
X = LY:
Ris{R{1175(EN) 87

Chapter 6
The instrument library
Here, we give a short description of three selected instruments. We present the McStas
versions of the Ris triple axis spectrometer TAS1 (6.2) and the ISIS time-of-ight spec-
trometer PRISMA (6.3). Before that, however, we present one example of a component
test instrument: the instrument to test the component V sample (6.1).
The source text for the three instrument denitions is listed in Appendix C. These
les are also included in the McStas distribution in the examples/ directory.
6.1 A test instrument for the component V sample
This instrument is one of many test instruments written with the purpose of testing the
individual components. We have picked this instrument both because we would like to
present an example test instrument and because it despite its simplicity has produced
quite non-trivial results, also giving rise to the McStas logo, see Appendix D.
The instrument consists of a narrow source, a 60' collimator, a V-sample shaped as a
hollow cylinder with height 15 mm, inner diameter 16 mm, and outer diameter 24 mm at
a distance of 1 m from the source. The sample is in turn surrounded by an unphysical
4-PSD monitor with 50  100 pixels and a radius of 10 6 m. The set-up is shown in
gure 6.1.
6.2 The triple axis spectrometer TAS1
With this instrument denition, we have tried to create a very detailed model of the con-
ventional cold source triple axis spectrometer TAS1 at Ris National Laboratory. Except
for the cold source itself, all components used have quite realistic properties. Further, the
overall geometry of the instrument has been adapted from the detailed technical drawings
of the real spectrometer. The TAS 1 simulations are by far the most extensive work yet
performed with the McStas package, and a few of the simulation results are shown in
Appendix D. For further details see reference [13].
At the spectrometer, the channel from the cold source to the monochromator is asym-
metric, since the rst part of the channel is shared with other instruments. In the instru-
ment denition, this is represented by three slits. For the cold source, we use one with a
at energy distribution (component Source at) focusing on the third slit.
88 Ris{R{1175(EN)

PSfrag replacements
Source
Collimator Vanadium
4 PSD
Figure 6.1: A sketch of the test instrument for the component V sample.
The real monochromator consist of seven blades, vertically focusing on the sample.
The angle of curvature is constant so that the focusing is perfect at 5.0 meV (20.0 meV
for 2nd order reections) for a 1 cm by 1 cm sample. This is modeled directly in the
instrument denition using seven Monochromator components. The mosaicity of the
pyrolytic graphite crystals is nominally 30' in both directions. However, the simulations
indicated that the horisontal mosaicities of both monochromator and analyser were more
likely 45'. This was used for all mosaicities in the nal instrument denition.
The monochromator scattering angle, in eect determining the incoming neutron en-
ergy, is for the real spectrometer xed by four holes in the shielding, corresponding to the
energies 3.6, 5.0, 7.2, and 13.7 meV for rst order neutrons. In the instrument denition,
we have adapted the angle corresponding to 5.0 meV in order to test the simulations
against measurements performed on the spectrometer.
The exit channel from the monochromator may on the spectrometer be narrowed down
from initially 40 mm to 20 mm by an insert piece. In the simulations, we have chosen the
narrow option and modeled the channel with two slits to match the experimental set-up.
In the test experiments, we used two standard samples: An Al 2 O 3 powder sample and
a vanadium sample. The instrument denitions use either of these samples of the correct
size. Both samples are chosen to focus on the opening aperture of collimator 2 (the one
between the sample and the analyser). Two slits, one before and one after the sample, are
in the instrument denition set to the opening values which were used in the experiments.
The analyser of the spectrometer is at and made from pyrolytic graphite. It is placed
between an entry and an exit channel, the latter leading to a single detector. All this has
been copied into the instrument denition, where the graphite mosaicity has been set to
45'.
On the spectrometer, Soller collimators may be inserted at three positions: Between
monochromator and sample, between sample and analyser, and between analyser and
detector. In our instrument denition, we have used 30', 28', and 67' collimators on these
three positions, respectively.
An illustration of the TAS1 instrument is shown in gure 6.2. Test results and data
from the real spectrometer are shown in Appendix D.2.
Ris{R{1175(EN) 89

Source
Slits
Focusing
monochromator
Slits
Sample
Collimator 2
Analyser
Collimator 3 Detector
Collimator 1
Slits
Figure 6.2: A sketch of the TAS1 instrument.
6.3 The time-of-ight spectrometer PRISMA
In order to test the time-of-ight aspect of McStas, we have in collaboration with Mark
Hagen, ISIS, written a simple simulation of a time-of-ight instrument loosely based on
the ISIS spectrometer PRISMA. The simulation was used to investigate the eect of using
a RITA-style analyser instead of the normal PRISMA backend.
We have used the simple time-of-ight source Tof source, as described under the
component library. The neutrons pass through a beam channel and scatter o from a
vanadium sample, pass through a collimator on to the analyser.
The RITA-style analyser consists of seven analyser crystals that can be rotated in-
dependently around a vertical axis. After the analysers we have placed a PSD and a
time-of-ight detector.
To illustrate some of the things that can be done in a simulation as opposed to a
real-life experiment, this example instrument further discriminates between the scattering
o each individual analyser crystal when the neutron hits the detector. The analyser
component is modied so that a global variable neu_color keeps track of which crystal
scatters the neutron. The detector component is then modied to construct seven dierent
time-of-ight histograms, one for each crystal (see the source code for the instrument in
appendix C for details). One way to think of this is that the analyser blades paint a color
on each neutron which is then observed in the detector.
An illustration of the instrument is shown in gure 6.3. Test results are shown in
Appendix D.3.
90 Ris{R{1175(EN)

7≠blade
analyser
Collimator
Moderator
Slit Slit
Monitor
Slit
Sample
PSD
Detector
Figure 6.3: A sketch of the PRISMA instrument.
Ris{R{1175(EN) 91

Chapter 7
Planned expansions of McStas in
the future
During the work so far on McStas, we have run across a number of points we would like
to include in McStas in the future.
For the McStas meta-language itself, these points include:
 Facilities for making a Monte-Carlo choice on the basis of tabulated values. This
would be useful in source and lter components.
 Facilities for assembling a number of existing components into one compound com-
ponent, like a multi-bladed analyser.
We also would like to improve on the component and instrument libraries:
 Output in NeXus format.
 Allow multiple scattering in sample components.
 More samples for inelastic scattering.
 A powder sample with more than one reection.
 Handle gravitation.
 The RITA spectrometer.
 The new Ris TAS7 spectrometer.
 A detailed version of the ISIS PRISMA spectrometer.
Further, we would like to make improvements on the interface software:
 Interface to existing control software (e.g. the Ris program TASCOM)
92 Ris{R{1175(EN)

Appendix A
Kernel calls and conversion
constants
The McStas kernel contains a number of built-in functions and conversion constants which
are useful when constructing components. Here, we bring a short list of these additional
features.
A.1 Kernel calls and functions
Here we list a number of preprogrammed macros which may ease the task of writing
components
 ABSORB. This macro issues an order to the overall McStas simulator to interrupt
the simulation of the current neutron history and to start a new one.
 DETECTOR OUT 0D(). Used to output the results from a single detector. The
name of the detector is output together with the simulated intensity and estimated
statistical error. The output is produced in a format that can be read by McStas
front-end programs. See section 3.4.5 for details.
 DETECTOR OUT 1D(). Used to output the results from a one-dimentional
detector. See section 3.4.5 for details.
 DETECTOR OUT 2D(). Used to output the results from a two-dimentional
detector. See section 3.4.5 for details.
 MC GETPAR(). This may be used in the nally section of an instrument deni-
tion to reference the output parameters of a component. See page 34 for details.
 NORM(x; y; z). Normalizes the vector (x; y; z) to have length 1.
 PROP Z0. Propagates the neutron to the z = 0 plane, by adjusting (x; y; z) and t.
If the neutron velocity points away from the z = 0 plane, the neutron is absorbed.
 PROP DT(dt). Propagates the neutron through the time interval dt, adjusting
(x; y; z) and t.
Ris{R{1175(EN) 93

 SCATTER. This macro is used to denote a scattering event inside a component,
see section 3.4.4.
 scalar prod(a x ; a y ; a z ; b x ; b y ; b z ). Returns the scalar product of the two vectors
(a x ; a y ; a z ) and (b x ; b y ; b z ).
 vecprod(a x ; a y ; a z ; b x ; b y ; b z ; c x ; c y ; c z ). Sets (a x ; a y ; a z ) equal to the vector product
(b x ; b y ; b z )  (c x ; c y ; c z ).
 rotate(x; y; z; v x ; v y ; v z ; '; a x ; a y ; a z ). Set (x; y; z) to the result of rotating the vector
(v x ; v y ; v z ) the angle ' (in radians) around the vector (a x ; a y ; a z ).
And here we list a number of preprogrammed C functions.
 box intersect(&t 1 , &t 2 , x, y, z, v x , v y , v z , d x , d y , d z ). Calculates the (0, 1, or
2) intersections between the neutron path and a box of dimensions d x , d y , and d z ,
centered at the origin for a neutron with the parameters (x; y; z; v x ; v y ; v z ). The
times of intersection are returned in the variables t 1 and t 2 , with t 1 < t 2 . In the
case of less than two intersections, t 1 (and possibly t 2 ) are set to zero. The function
returns true if the neutron intersects the box, false otherwise.
 cylinder intersect(&t 1 , &t 2 , x, y, z, v x , v y , v z , r, h). Calculates the (0, 1, or
2) intersections between the neutron path and a cylinder of height h and radius
r, centered at the origin for a neutron with the parameters (x; y; z; v x ; v y ; v z ). The
times of intersection are returned in the variables t 1 and t 2 , with t 1 < t 2 . In the
case of less than two intersections, t 1 (and possibly t 2 ) are returned with a negative
value.
 extend list(n, &arr, &len, elemsize). Given an array arr with len elements each of
size elemsize, make sure that the array is big enough to hold at least n elements, by
extending arr and len if necessary. Typically used when reading a list of numbers
from a data le when the length of the le is not known in advance.
 mcget ncount(). Returns the number of neutron histories to simulate.
 normal vec(&n x , &n y , &n z , x, y, z). Computes a unit vector (n x ; n y ; n z ) normal
to the vector (x; y; z).
 rand01(). Returns a random number distributed uniformly between 0 and 1.
 randnorm(). Returns a random number from a normal distribution centered around
0 and with  = 1. The algorithm used to get the normal distribution is explained
in [14], chapter 7.
 randpm1(). Returns a random number distributed uniformly between -1 and 1.
 randvec target sphere(&v x , &v y , &v z , &d
 aim x , aim y , aim z , r f ). Generates
a random vector (v x ; v y ; v z ), of the same length as (aim x , aim y , aim z ), which is
targeted at a sphere centered at (aim x , aim y , aim z ) with radius r f . All directions
that intersect the sphere are chosen with equal probability. The solid angle of the
sphere as seen from the position of the neutron is returned in d

94 Ris{R{1175(EN)

 sphere intersect(&t 1 , &t 2 , x, y, z, v x , v y , v z , r). Similar to cylinder intersect,
but using a sphere of radius r.
A.2 Constants for unit conversion etc.
The following predened constants are useful for conversion between units
Name Value Conversion from Conversion to
DEG2RAD 2=360 Degrees radians
RAD2DEG 360=(2) Radians degrees
MIN2RAD 2=(360  60) Minutes of arc radians
RAD2MIN (360  60)=(2) Radians minutes of arc
V2K 10 10  mN =~ Velocity (m/s) k-vector (  A 1 )
K2V 10 10  ~=mN k-vector (  A 1 ) Velocity (m/s)
VS2E mN =(2e) Velocity squared (m 2 s 2 ) Neutron energy (meV)
SE2V
p
2e=mN Square root of neutron en-
ergy (meV 1=2 )
Velocity (m/s)
FWHM2RMS 1=
p 8 log(2) Full width half maximum Root mean square
(standard deviation)
RMS2FWHM
p 8 log(2) Root mean square (stan-
dard deviation)
Full width half maxi-
mum
Further, we have dened the constants PI=  and HBAR= ~.
Ris{R{1175(EN) 95

Appendix B
McStas source code for the
component library
List of component input and output parameters
Before listing the source code for the components, we bring a list of the components with
their input and output parameters.
Source at Input: (radius, dist, xw, yh, E0, dE)
Output: (hdiv, vdiv, p in)
Source at lambda Input: (radius, dist, xw, yh, lambda 0, d lambda)
Output: (hdiv, vdiv, p in)
Source ux lambda Input: (radius, dist, xw, yh, lambda 0, d lambda, ux)
Output: (hdiv, vdiv, p in)
Source div Input: (width, height, hdiv, vdiv, E0, dE)
Moderator Input: (radius, E0, E1, dist, xw, yh, t0, Ec, gam)
Source adapt Input: (xmin, xmax, ymin, ymax, dist, xw, yh, E0, dE, ux)
(n E, N xpos, N xdiv, alpha, beta, lename)
Arm Input: ()
Slit Input: (xmin, xmax, ymin, ymax)
Circular slit Input: (radius)
Beamstop rectangular Input: (xmin, xmax, ymin, ymax)
Beamstop circular Input: (radius)
Soller Input: (xmin, xmax, ymin, ymax, len, divergence)
Filter Input: (xmin, xmax, ymin, ymax, len, T0, T1, Emin, Emax)
Mirror Input: (xlength, yheight, R0, Qc, alpha, m, W)
Guide Input: (w1, h1, w2, h2, l, R0, Qc, alpha, m, W)
Channeled Guide Input: (w1, h1, w2, h2, l, d, k)
(R0, Qcx, Qcy, alphax, alphay, mx, my, W)
96 Ris{R{1175(EN)

V selector Input: (width, height, l0, r0, phi, l1, tb, rot, nb)
Chopper Input: (w, R, f, n, pha)
Output: (Tg, To)
First Chopper Input: (w, R, f, n, pha, a)
Output: (Tg, To)
Monitor Input: (xmin, xmax, ymin, ymax)
Output: (Nsum, psum, p2sum)
Monitor 4PI Output: (Nsum, psum, p2sum)
PSD monitor Input: (xmin, xmax, ymin, ymax, nx, ny, lename)
Output: (PSD N, PSD p, PSD p2)
PSD monitor 4PI Input: (radius, nx, ny, lename)
Output: (PSD N, PSD p, PSD p2)
PSD monitor 4PI log Input: (radius, nx, ny, lename)
Output: (PSD N, PSD p, PSD p2)
TOF monitor Input: (xmin, xmax, ymin, ymax, nchan, dt, lename)
Output: (TOF N, TOF p, TOF p2)
E monitor Input: (xmin, xmax, ymin, ymax, Emin, Emax, nchan, lename)
Output: (E N, E p, E p2)
L monitor Input: (xmin, xmax, ymin, ymax, Lmin, Lmax, nchan, lename)
Output: (L N, L p, L p2)
Divergence monitor Input: (xmin, xmax, ymin, ymax, nh, nv)
(h maxdiv, v maxdiv, lename)
Output: (Div N, Div p, Div p2)
DivPos monitor Input: (xmin, xmax, ymin, ymax, npos, ndiv, maxdiv, lename)
Output: (Div N, Div p, Div p2)
DivLambda monitor Input: (xmin, xmax, ymin, ymax, nlam, ndiv, maxdiv)
(lambda 0, lambda 1, lename)
Output: (Div N, Div p, Div p2)
Res monitor Input: (xmin, xmax, ymin, ymax, lename, res sample comp)
Output: (Nsum, psum, p2sum, le)
Adapt check Input: (source comp)
Mosaic simple Input: (zmin, zmax, ymin, ymax, mosaic, R0, Qx, Qy, Qz)
Mosaic anisotropic Input: (zmin, zmax, ymin, ymax, mosaich, mosaicv, r0, Q)
Single crystal Input: (xwidth, yheight, zthick, delta d d, mosaic)
(ax, ay, az, bx, by, bz, cx, cy, cz, reections)
V sample Input: (radius i,radius o,h,pack,focus r)
(target x, target y, target z)
Powder1 Input: (d phi0, radius, h, pack, Vc, sigma a, j, q, F2, DW)
(target x, target y, target z)
Output: (my s v2, my a v, q v)
Res sample Input: (radius i, radius o, h, focus r, E0, dE)
(target x, target y, target z)
Output: (res struct)
Ris{R{1175(EN) 97

B.1 Source components
B.1.1 Source at
/*******************************************************************************
*
* McStas, the neutron ray-tracing package
* Maintained by Kristian Nielsen and Kim Lefmann,
* Copyright 1997-2000 Risoe National Laboratory, Roskilde, Denmark
*
* %I
* Written by: KL
* Modified by: KL, KN, October 5, 1998
* Date: October 30, 1997
* Version: $Revision: 1.2 $
* Origin: McStas release
*
* Neutron source with flat energy spectrum and arbitrary flux
*
* %D
* The routine is a circular neutron source, which aims at a square target
* centered at the beam (in order to improve MC-acceptance rate). The angular
* divergence is then given by the dimensions of the target. The neutron energy is
* uniformly distrubuted between E0-dE and E0+dE.
*
* ToDo: More flexible specification of E distribution.
*
* %P
* radius: (m) Radius of circle in (x,y,0) plane where neutrons
* are generated.
* dist: (m) Distance to target along z axis.
* xw: (m) Width(x) of target
* yh: (m) Height(y) of target
* E0: (meV) Mean energy of neutrons.
* dE: (meV) Energy spread of neutrons.
*
* %L
* <A HREF="http://neutron.risoe.dk/mcstas/components/tests/source/">
* Test results</A> (not up-to-date).
*
* %E
*******************************************************************************/
DEFINE COMPONENT Source_flat
DEFINITION PARAMETERS ()
SETTING PARAMETERS (radius, dist, xw, yh, E0, dE)
OUTPUT PARAMETERS (hdiv, vdiv, p_in)
STATE PARAMETERS (x,y,z,vx,vy,vz,t,s1,s2,p)
DECLARE
%{
double hdiv,vdiv;
double p_in;
%}
INITIALIZE
%{
hdiv = atan(xw/(2.0*dist));
vdiv = atan(yh/(2.0*dist));
98 Ris{R{1175(EN)

p_in = (4*hdiv*vdiv)/(4*PI); /* Small angle approx. */
%}
TRACE
%{
double theta0,phi0,chi,theta,phi,E,v,r;
p=p_in;
z=0;
chi=2*PI*rand01(); /* Choose point on source */
r=sqrt(rand01())*radius; /* with uniform distribution. */
x=r*cos(chi);
y=r*sin(chi);
theta0= -atan(x/dist); /* Angles to aim at target centre */
phi0= -atan(y/dist);
theta=theta0+hdiv*randpm1(); /* Small angle approx. */
phi=phi0+vdiv*randpm1();
E=E0+dE*randpm1(); /* Assume linear distribution */
v=sqrt(E)*SE2V;
vz=v*cos(phi)*cos(theta);
vy=v*sin(phi);
vx=v*cos(phi)*sin(theta);
%}
MCDISPLAY
%{
magnify("xy");
circle("xy",0,0,0,radius);
%}
END
Ris{R{1175(EN) 99

B.1.3 Source ux lambda
/*******************************************************************************
*
* McStas, the neutron ray-tracing package
* Maintained by Kristian Nielsen and Kim Lefmann,
* Copyright 1997-2000 Risoe National Laboratory, Roskilde, Denmark
*
* %I
* Written by: KN
* Date: 1998
* Version: $Revision: 1.2 $
* Origin: McStas release
* Modified by: KN, 1998 from Source_flat.comp
*
* Neutron source with flat wavelength spectrum and user-specified flux.
*
* %D
* The routine is a circular neutron source, which aims at a square target
* centered at the beam (in order to improve MC-acceptance rate). The angular
* divergence is then given by the dimensions of the target. The neutron
* wavelength is uniformly distrubuted between lambda_0 - d_lambda and
* lambda_0 + d_lambda. The source flux is specified in neutrons per steradian
* per square cm per AAngstroem.
*
* %P
* radius: (m) Radius of circle in (x,y,0) plane where neutrons
* are generated.
* dist: (m) Distance to target along z axis.
* xw: (m) Width(x) of target
* yh: (m) Height(y) of target
* lambda_0: (AA) Mean wavelength of neutrons.
* d_lambda: (AA) Wavelength spread of neutrons.
* flux: (1/(cm**2*st*AA)) Source flux
*
* %E
*******************************************************************************/
DEFINE COMPONENT Source_flux_lambda
DEFINITION PARAMETERS ()
SETTING PARAMETERS (radius, dist, xw, yh, lambda_0, d_lambda, flux)
OUTPUT PARAMETERS (hdiv, vdiv, p_in)
STATE PARAMETERS (x,y,z,vx,vy,vz,t,s1,s2,p)
DECLARE
%{
double hdiv,vdiv;
double p_in;
%}
INITIALIZE
%{
double factor, delta_lambda, source_area;
hdiv = atan(xw/(2.0*dist));
vdiv = atan(yh/(2.0*dist));
delta_lambda = 2*d_lambda;
source_area = radius*radius*PI*1e4; /* cm^2 */
100 Ris{R{1175(EN)

factor = flux/mcget_ncount()*delta_lambda*source_area;
p_in = (4*hdiv*vdiv)*factor; /* Small angle approx. */
%}
TRACE
%{
double theta0,phi0,chi,theta,phi,lambda,v,r;
p=p_in;
z=0;
chi=2*PI*rand01(); /* Choose point on source */
r=sqrt(rand01())*radius; /* with uniform distribution. */
x=r*cos(chi);
y=r*sin(chi);
theta0= -atan(x/dist); /* Angles to aim at target centre */
phi0= -atan(y/dist);
theta=theta0+hdiv*randpm1(); /* Small angle approx. */
phi=phi0+vdiv*randpm1();
lambda = lambda_0+d_lambda*randpm1();
v = K2V*(2*PI/lambda);
vz=v*cos(phi)*cos(theta);
vy=v*sin(phi);
vx=v*cos(phi)*sin(theta);
%}
MCDISPLAY
%{
magnify("xy");
circle("xy",0,0,0,radius);
%}
END
Ris{R{1175(EN) 101

B.1.4 Source div
/*******************************************************************************
*
* McStas, The neutron ray-tracing package
* Maintained by Kristian Nielsen and Kim Lefmann,
* Copyright 1997-2000 Risoe National Laboratory, Roskilde, Denmark
*
* %I
* Written by: KL
* Date: November 20, 1998
* Version: $Revision: 1.2 $
* Origin: McStas release
*
* Neutron source with Gaussian divergence
*
* %D
* The routine is a rectangular neutron source, which has a gaussian
* divergent output in the forward direction.
* The neutron energy is uniformly distrubuted between E0-dE and E0+dE.
*
* ToDo: More flexible specification of E distribution.
*
* %P
* width: (m) Width of source
* height: (m) Height of source
* hdiv: (deg) FWHM of horizontal divergence
* vdiv: (deg) FWHM of vertical divergence
* E0: (meV) Mean energy of neutrons.
* dE: (meV) Energy spread of neutrons.
*
* %E
*******************************************************************************/
DEFINE COMPONENT Source_div
DEFINITION PARAMETERS ()
SETTING PARAMETERS (width, height, hdiv, vdiv, E0, dE)
OUTPUT PARAMETERS ()
STATE PARAMETERS (x,y,z,vx,vy,vz,t,s1,s2,p)
DECLARE
%{
double thetah, thetav, sigmah, sigmav, tan_h, tan_v;
%}
INITIALIZE
%{
sigmah = DEG2RAD*hdiv/(2.0*sqrt(2.0*log(2.0)));
sigmav = DEG2RAD*vdiv/(2.0*sqrt(2.0*log(2.0)));
%}
TRACE
%{
double E,v;
p=1;
z=0;
t=0;
x=randpm1()*width/2.0;
102 Ris{R{1175(EN)

y=randpm1()*height/2.0;
E=E0+dE*randpm1(); /* Assume linear distribution */
v=sqrt(E)*SE2V;
thetah = randnorm()*sigmah;
thetav = randnorm()*sigmav;
tan_h = tan(thetah);
tan_v = tan(thetav);
/* Perform the correct treatment - no small angle approx. here! */
vz = v / sqrt(1 + tan_v*tan_v + tan_h*tan_h);
vy = tan_v * vz;
vx = tan_h * vz;
%}
MCDISPLAY
%{
magnify("xy");
multiline(5, -width/2.0, -height/2.0, 0.0,
width/2.0, -height/2.0, 0.0,
width/2.0, height/2.0, 0.0,
-width/2.0, height/2.0, 0.0,
-width/2.0, -height/2.0, 0.0);
%}
END
Ris{R{1175(EN) 103

B.1.5 Moderator
/*******************************************************************************
*
* McStas, the neutron ray-tracing package
* Maintained by Kristian Nielsen and Kim Lefmann,
* Copyright 1997-2000 Risoe National Laboratory, Roskilde, Denmark
*
* %I
* Written by: KN, M.Hagen
* Date: August 1998
* Version: $Revision: 1.2 $
* Origin: McStas release
*
* A simple pulsed source for time-of-flight.
*
* %D
* Produces a simple time-of-flight spectrum, with a flat energy distribution
*
* %P
* Input parameters:
*
* radius: (m) Radius of source
* E0: (meV) Lower edge of energy distribution
* E1: (meV) Upper edge of energy distribution
* dist: (m) Distance from source to the focusing rectangle
* xw: (m) Width of focusing rectangle
* yh: (m) Height of focusing rectangle
* t0: (mus) decay constant for low-energy neutrons
* Ec: (meV) Critical energy, below which the flux decay is constant
* gam: (meV) energy dependence of decay time
*
* %E
*******************************************************************************/
DEFINE COMPONENT Moderator
DEFINITION PARAMETERS ()
SETTING PARAMETERS (radius, E0, E1, dist, xw, yh, t0, Ec, gam)
OUTPUT PARAMETERS (hdiv,vdiv,p_in)
STATE PARAMETERS (x,y,z,vx,vy,vz,t,s1,s2,p)
DECLARE
%{
double hdiv,vdiv;
double p_in;
%}
INITIALIZE
%{
hdiv = atan(xw/(2.0*dist));
vdiv = atan(yh/(2.0*dist));
p_in = (4*hdiv*vdiv)/(4*PI);
%}
TRACE
%{
double theta0,phi0,chi,theta,phi,v,r,tauv,E;
p=p_in;
z=0;
104 Ris{R{1175(EN)

chi = 2*PI*rand01(); /* Choose point on source */
r = sqrt(rand01())*radius; /* with uniform distribution. */
x = r*cos(chi);
y = r*sin(chi);
theta0 = -atan(x/dist); /* Angles to aim at target centre */
phi0 = -atan(y/dist);
theta = theta0 + hdiv*randpm1(); /* Small angle approx. */
phi = phi0 + vdiv*randpm1();
E = E0+(E1-E0)*rand01(); /* Assume linear distribution */
v = SE2V*sqrt(E);
vz = v*cos(phi)*cos(theta); /* Small angle approx. */
vy = v*sin(phi);
vx = v*cos(phi)*sin(theta);
if(E < Ec)
{
tauv = t0;
}
else
{
double tmp = ((E - Ec) / gam);
tauv = t0 / (1 + (tmp*tmp));
}
t = -tauv*log(rand01())*1E-6;
%}
MCDISPLAY
%{
magnify("xy");
circle("xy",0,0,0,radius);
%}
END
Ris{R{1175(EN) 105

B.1.6 Source adapt
/*******************************************************************************
*
* McStas, the neutron ray-tracing Monte-Carlo software.
* Copyright(C) 1999 Risoe National Laboratory.
*
* %I
* Written by: Kristian Nielsen
* Date: 1999
* Version: $Revision: 1.2 $
* Origin: McStas release
*
* Neutron source with adaptive importance sampling
*
* %D
* Rectangular source with flat energy distribution that uses adaptive
* importance sampling to improve simulation efficiency. Works
* together with the Adapt_check component.
*
* The source divides the three-dimensional phase space of (energy,
* horizontal position, horizontal divergence) into a number of
* rectangular bins. The probability for selecting neutrons from each
* bin is adjusted so that neutrons that reach the Adapt_check
* component with high weights are emitted more frequently than those
* with low weights. The adjustment is made so as to attemt to make
* the weights at the Adapt_check components equal.
*
* Focosing is achieved by only emitting neutrons towards a rectangle
* perpendicular to and placed at a certain distance along the Z axis.
* Focusing is only approximate (for simplicity); neutrons are also
* emitted to pass slightly above and below the focusing rectangle,
* more so for wider focusing.
*
* In order to prevent false learning, a parameter beta sets a
* fraction of the neutrons that are emitted uniformly, without regard
* to the adaptive distribution. The parameter alpha sets an initial
* fraction of neutrons that are emitted with low weights; this is
* done to prevent early neutrons with rare initial parameters but
* high weight to ruin the statistics before the component adapts its
* distribution to the problem at hand. Good general-purpose values
* for these parameters are alpha = beta = 0.25.
*
* %P
* INPUT PARAMETERS:
*
* xmin: (m) Left edge of rectangular source
* xmax: (m) Right edge
* ymin: (m) Lower edge
* ymax: (m) Upper edge
* dist: (m) Distance to target rectangle along z axis
* xw: (m) Width(x) of target
* yh: (m) Height(y) of target
* E0: (meV) Mean energy of neutrons
* dE: (meV) Energy spread (energy range is from E0-dE to E0+dE)
* flux: (1/(cm**2*AA**st)) Absolute source flux
* N_E: (1) Number of bins in energy dimension
106 Ris{R{1175(EN)

* N_xpos: (1) Number of bins in horizontal position
* N_xdiv: (1) Number of bins in horizontal divergence
* alpha: (1) Learning cut-off factor (0 < alpha <= 1)
* beta: (1) Aggressiveness of adaptive algorithm (0 < beta <= 1)
* filename: (string) Optional filename for adaptive distribution output
*
* OUTPUT PARAMETERS:
*
* p_in: Internal, holds initial neutron weight
* y_0: Internal
* C: Internal
* r_0: Internal
* count: Internal, counts neutrons emitted
* adpt: Internal structure shared with the Adapt_check component
*
* %E
*******************************************************************************/
DEFINE COMPONENT Source_adapt
DEFINITION PARAMETERS (N_E, N_xpos, N_xdiv, alpha, beta, filename)
SETTING PARAMETERS (xmin,xmax,ymin,ymax, dist, xw, yh, E0, dE, flux)
OUTPUT PARAMETERS (p_in, y_0, C, r_0, count, adpt)
STATE PARAMETERS (x,y,z,vx,vy,vz,t,s1,s2,p)
DECLARE
%{
struct source_adapt
{
struct adapt_tree *atree; /* Adaptive search tree */
int idx; /* Index of current bin */
double *psi, *n; /* Arrays of weight sums, neutron counts */
double psi_tot; /* Total weight sum */
double pi, num; /* Initial p, number of bins in tree */
double factor; /* Adaption quality factor */
double a_beta; /* Adaption agression factor */
} adpt;
double count; /* Neutron counter */
double y_0, C, r_0;
double p_in;
%}
INITIALIZE
%{
int i;
double a, lambda_min, lambda_max, delta_lambda, source_area;
adpt.num = N_E*N_xpos*N_xdiv;
adpt.a_beta = beta;
lambda_min = sqrt(81.81/(E0+dE)); /* AAngstroem */
lambda_max = sqrt(81.81/(E0-dE));
delta_lambda = lambda_max - lambda_min;
source_area = (xmax - xmin)*(ymax - ymin)*1e4; /* cm^2 */
p_in = flux/mcget_ncount()*delta_lambda*source_area;
adpt.atree = adapt_tree_init(adpt.num);
adpt.psi = malloc(adpt.num*sizeof(*adpt.psi));
adpt.n = malloc(adpt.num*sizeof(*adpt.n));
if(!(adpt.psi && adpt.n))
{
Ris{R{1175(EN) 107

fprintf(stderr, "Fatal error: out of memory.\n");
exit(1);
}
for(i = 0; i < adpt.num; i++)
{
adapt_tree_add(adpt.atree, i, 1.0/adpt.num);
adpt.psi[i] = adpt.n[i] = 0;
}
adpt.psi_tot = 0;
count = 0;
y_0 = adpt.num > 8 ? 2.0/adpt.num : 0.25;
r_0 = 1/(double)alpha*log((1 - y_0)/y_0)/(double)mcget_ncount();
C = 1/(1 + log(y_0 + (1 - y_0)*exp(-r_0*mcget_ncount()))/(r_0*mcget_ncount()));
%}
TRACE
%{
double thmin,thmax,phmin,phmax,theta,phi,E,v,r;
double new_v;
int i_E, i_xpos, i_xdiv;
/* Randomly select a bin in the current distribution */
r = rand01();
adpt.idx = adapt_tree_search(adpt.atree, adpt.atree->total*r);
if(adpt.idx >= adpt.num)
{
fprintf(stderr,
"Hm, idx is %d, num is %d, r is %g, atree->total is %g\n",
adpt.idx, (int)adpt.num, r, adpt.atree->total);
adpt.idx = adpt.num - 1;
}
/* Now find the bin coordinates. */
i_xdiv = adpt.idx % (int)N_xdiv;
i_xpos = (adpt.idx / (int)N_xdiv) % (int)N_xpos;
i_E = (adpt.idx / (int)N_xdiv) / (int)N_xpos;
/* Compute the initial neutron parameters, selecting uniformly randomly
within each bin dimension. */
x = xmin + (i_xpos + rand01())*((xmax - xmin)/(double)N_xpos);
y = ymin + rand01()*(ymax - ymin);
z=0;
thmin = atan2(-xw/2.0 - x, dist);
thmax = atan2( xw/2.0 - x, dist);
theta = thmin + (i_xdiv + rand01())*((thmax - thmin)/(double)N_xdiv);
phmin = atan2(-yh/2.0 - y, dist);
phmax = atan2( yh/2.0 - y, dist);
phi = phmin + rand01()*(phmax - phmin);
E = E0 - dE + (i_E + rand01())*(2.0*dE/(double)N_E);
v = sqrt(E)*SE2V;
vy = v*sin(phi);
vx = v*cos(phi)*sin(theta);
vz = v*cos(phi)*cos(theta);
t = 0;
/* Adjust neutron weight. */
p = p_in;
adpt.factor = y_0/(y_0 + (1 - y_0)*exp(-r_0*count));
count++;
p /= adpt.atree->v[adpt.idx]/(adpt.atree->total/adpt.num);
108 Ris{R{1175(EN)

p *= C*adpt.factor*(thmax - thmin)*(sin(phmax) - sin(phmin));
/* Update distribution, assuming absorbtion. */
if(adpt.n[adpt.idx] > 0)
adpt.psi_tot -= adpt.psi[adpt.idx]/
(adpt.n[adpt.idx]*(adpt.n[adpt.idx] + 1));
adpt.n[adpt.idx]++;
if(adpt.psi_tot != 0)
{
new_v = (1 - adpt.a_beta)*adpt.factor*adpt.psi[adpt.idx]/
(adpt.n[adpt.idx]*adpt.psi_tot) +
adpt.a_beta/adpt.num;
adapt_tree_add(adpt.atree, adpt.idx, new_v - adpt.atree->v[adpt.idx]);
}
/* Remember initial neutron weight. */
adpt.pi = p;
%}
FINALLY
%{
double *p1 = NULL;
int i;
if(filename)
{
p1 = malloc(adpt.num*sizeof(double));
if(!p1)
fprintf(stderr, "Warning: Source_adapt: "
"not enough memory to write distribution.\n");
}
if(p1)
{
for(i = 0; i < adpt.num; i++)
p1[i] = adpt.atree->v[i]/adpt.atree->total;
DETECTOR_OUT_1D("Adaptive source energy distribution",
"Energy [meV]",
"Probability",
"E", E0 - dE, E0 + dE, adpt.num,
NULL, p1, NULL, filename);
free(p1);
}
adapt_tree_free(adpt.atree);
%}
MCDISPLAY
%{
magnify("xy");
multiline(5, (double)xmin, (double)ymin, 0.0,
(double)xmax, (double)ymin, 0.0,
(double)xmax, (double)ymax, 0.0,
(double)xmin, (double)ymax, 0.0,
(double)xmin, (double)ymin, 0.0);
%}
END
Ris{R{1175(EN) 109

B.2 Simple components
B.2.1 Arm
/*******************************************************************************
*
* McStas, the neutron ray-tracing package
* Maintained by Kristian Nielsen and Kim Lefmann,
* Copyright 1997-2000 Risoe National Laboratory, Roskilde, Denmark
*
* %I
*
* Written by: KL, KN
* Date: September 1997
* Version: $Revision: 1.2 $
* Origin: McStas release
*
* Arm/optical bench
*
* %D
* An arm does not actually do anything, it is just there to set
* up a new coordinate system.
*
* %P
* Input parameters:
*
* (none)
*
* %E
*******************************************************************************/
DEFINE COMPONENT Arm
DEFINITION PARAMETERS ()
SETTING PARAMETERS ()
STATE PARAMETERS ()
TRACE
%{
%}
MCDISPLAY
%{
/* A bit ugly; hard-coded dimensions. */
magnify("");
line(0,0,0,0.2,0,0);
line(0,0,0,0,0.2,0);
line(0,0,0,0,0,0.2);
%}
END
110 Ris{R{1175(EN)

B.2.2 Slit
/*******************************************************************************
*
* McStas, the neutron ray-tracing package
* Maintained by Kristian Nielsen and Kim Lefmann,
* Copyright 1997-2000 Risoe National Laboratory, Roskilde, Denmark
*
* %I
* Written by: KL, HMR
* Date: June 16, 1997
* Version: $Revision: 1.2 $
* Origin: McStas release
*
* Rectangular slit.
*
* %D
* A simple rectangular slit. No transmission around the slit is allowed.
*
* %P
* INPUT PARAMETERS
*
* xmin: Lower x bound (m)
* xmax: Upper x bound (m)
* ymin: Lower y bound (m)
* ymax: Upper y bound (m)
*
* %E
*******************************************************************************/
DEFINE COMPONENT Slit
DEFINITION PARAMETERS ()
SETTING PARAMETERS (xmin, xmax, ymin, ymax)
STATE PARAMETERS (x,y,z,vx,vy,vz,t,s1,s2,p)
TRACE
%{
PROP_Z0;
if (x<xmin || x>xmax || y<ymin || y>ymax)
ABSORB;
%}
MCDISPLAY
%{
double xw, yh;
magnify("xy");
xw = (xmax - xmin)/2.0;
yh = (ymax - ymin)/2.0;
multiline(3, xmin-xw, (double)ymax, 0.0,
(double)xmin, (double)ymax, 0.0,
(double)xmin, ymax+yh, 0.0);
multiline(3, xmax+xw, (double)ymax, 0.0,
(double)xmax, (double)ymax, 0.0,
(double)xmax, ymax+yh, 0.0);
multiline(3, xmin-xw, (double)ymin, 0.0,
(double)xmin, (double)ymin, 0.0,
(double)xmin, ymin-yh, 0.0);
Ris{R{1175(EN) 111

multiline(3, xmax+xw, (double)ymin, 0.0,
(double)xmax, (double)ymin, 0.0,
(double)xmax, ymin-yh, 0.0);
%}
END
112 Ris{R{1175(EN)

B.2.6 Soller
/*******************************************************************************
*
* McStas, the neutron ray-tracing package
* Maintained by Kristian Nielsen and Kim Lefmann,
* Copyright 1997-2000 Risoe National Laboratory, Roskilde, Denmark
*
* %I
* Written by: KN
* Date: August 1998
* Version: $Revision: 1.2 $
* Origin: McStas release
*
* A simple analytical Soller collimator.
*
* %D
* Soller collimator with rectangular opening and specified length. The
* transmission function is an average and does not utilize knowledge of the
* actual neutron trajectory.
* A zero divergence disables collimation (then the component works as a double slit).
*
* %P
* INPUT PARAMETERS:
*
* xmin: (m) Lower x bound on slits
* xmax: (m) Upper x bound on slits
* ymin: (m) Lower y bound on slits
* ymax: (m) Upper y bound on slits
* len: (m) Distance between slits
* divergence: (minutes of arc) Divergence angle (calculated as atan(d/len),
* where d is the blade spacing)
*
* %E
*******************************************************************************/
DEFINE COMPONENT Soller
DEFINITION PARAMETERS ()
SETTING PARAMETERS (xmin, xmax, ymin, ymax, len, divergence)
OUTPUT PARAMETERS (slope)
STATE PARAMETERS (x,y,z,vx,vy,vz,t,s1,s2,p)
DECLARE
%{
double slope;
%}
INITIALIZE
%{
slope = tan(MIN2RAD*divergence);
%}
TRACE
%{
double phi, dt;
PROP_Z0;
if (x<xmin || x>xmax || y<ymin || y>ymax)
ABSORB;
Ris{R{1175(EN) 113

dt = len/vz;
PROP_DT(dt);
if (x<xmin || x>xmax || y<ymin || y>ymax)
ABSORB;
if(slope > 0.0)
{
phi = fabs(vx/vz);
if (phi > slope)
ABSORB;
else
p *= 1.0 - phi/slope;
}
%}
MCDISPLAY
%{
double x;
int i;
magnify("xy");
for(x = xmin, i = 0; i <= 3; i++, x += (xmax - xmin)/3.0)
multiline(5, x, (double)ymin, 0.0, x, (double)ymax, 0.0,
x, (double)ymax, (double)len, x, (double)ymin, (double)len,
x, (double)ymin, 0.0);
line(xmin, ymin, 0, xmax, ymin, 0);
line(xmin, ymax, 0, xmax, ymax, 0);
line(xmin, ymin, len, xmax, ymin, len);
line(xmin, ymax, len, xmax, ymax, len);
%}
END
114 Ris{R{1175(EN)

B.2.7 Filter
/*******************************************************************************
*
* McStas, the neutron ray-tracing package
* Maintained by Kristian Nielsen and Kim Lefmann,
* Copyright 1997-2000 Risoe National Laboratory, Roskilde, Denmark
*
* %I
* Written by: KL, KN
* Date: Sept. 14 1998
* Version: $Revision: 1.2 $
* Origin: McStas release
*
* A simple neutron filter.
*
* %D
* Be-type filter defined by two identical rectangular opening apertures.
* The transmission is interpolated liniearly between the high- and low-energy
* transmissions beyond the upper and lower cut-off energies.
*
* %P
* INPUT PARAMETERS:
*
* xmin: Lower x bound (m)
* xmax: Upper x bound (m)
* ymin: Lower y bound (m)
* ymax: Upper y bound (m)
* len: Distance between apertures (m)
* T0: Transmittance of low energy neutrons (1)
* T1: Transmittance of high energy neutrons (1)
* Emin: Lower cut-off energy (meV)
* Emax: Upper cut-off energy (meV)
*
* %E
*******************************************************************************/
DEFINE COMPONENT Filter
DEFINITION PARAMETERS ()
SETTING PARAMETERS (xmin, xmax, ymin, ymax, len, T0, T1, Emin, Emax)
STATE PARAMETERS (x,y,z,vx,vy,vz,t,s1,s2,p)
TRACE
%{
double E;
double dt;
PROP_Z0;
E=VS2E*(vx*vx+vy*vy+vz*vz);
if (x<xmin || x>xmax || y<ymin || y>ymax)
ABSORB;
dt = len/vz;
PROP_DT(dt);
if (x<xmin || x>xmax || y<ymin || y>ymax)
ABSORB;
if(E>=Emax)
Ris{R{1175(EN) 115

if(T1==0)
ABSORB;
else
p*=T1;
else if(E<=Emin)
if(T0==0)
ABSORB;
else
p*=T0;
else
p*= T1+(T0-T1)*(Emax-E)/(Emax-Emin);
%}
MCDISPLAY
%{
magnify("xy");
multiline(5, (double)xmin, (double)ymin, 0.0,
(double)xmax, (double)ymin, 0.0,
(double)xmax, (double)ymax, 0.0,
(double)xmin, (double)ymax, 0.0,
(double)xmin, (double)ymin, 0.0);
multiline(5, (double)xmin, (double)ymin, (double)len,
(double)xmax, (double)ymin, (double)len,
(double)xmax, (double)ymax, (double)len,
(double)xmin, (double)ymax, (double)len,
(double)xmin, (double)ymin, (double)len);
line(xmin, ymin, 0.0, xmin, ymin, len);
line(xmax, ymin, 0.0, xmax, ymin, len);
line(xmin, ymax, 0.0, xmin, ymax, len);
line(xmax, ymax, 0.0, xmax, ymax, len);
%}
END
116 Ris{R{1175(EN)

B.3 Beam optical components
B.3.3 Guide
/*******************************************************************************
*
* McStas, the neutron ray-tracing package
* Maintained by Kristian Nielsen and Kim Lefmann,
* Copyright 1997-2000 Risoe National Laboratory, Roskilde, Denmark
*
* %I
* Written by: KN
* Date: September 2 1998
* Version: $Revision: 1.2 $
* Origin: McStas release
* Modified by: KL, October 6, 1998
*
* Neutron guide.
*
* %D
* Models a rectangular guide tube centered on the Z axis. The entrance lies
* in the X-Y plane.
* For details on the geometry calculation see the description in the McStas
* reference manual.
*
* %P
* INPUT PARAMETERS:
*
* w1: (m) Width at the guide entry
* h1: (m) Height at the guide entry
* w2: (m) Width at the guide exit
* h2: (m) Height at the guide exit
* l: (m) length of guide
* R0: (1) Low-angle reflectivity
* Qc: (AA-1) Critical scattering vector
* alpha: (AA) Slope of reflectivity
* m: (1) m-value of material. Zero means completely absorbing.
* W: (AA-1) Width of supermirror cut-off
*
* %D
* Example values: m=4 Qc=0.02 W=1/300 alpha=6.49 R0=1
*
* %E
*******************************************************************************/
DEFINE COMPONENT Guide
DEFINITION PARAMETERS ()
SETTING PARAMETERS (w1, h1, w2, h2, l, R0, Qc, alpha, m, W)
STATE PARAMETERS (x,y,z,vx,vy,vz,t,s1,s2,p)
TRACE
%{
double t1,t2; /* Intersection times. */
double av,ah,bv,bh,cv1,cv2,ch1,ch2,d; /* Intermediate values */
double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2; /* Dot products. */
int i; /* Which mirror hit? */
double q; /* Q [1/AA] of reflection */
Ris{R{1175(EN) 117

double vlen2,nlen2; /* Vector lengths squared */
/* ToDo: These could be precalculated. */
double ww = .5*(w2 - w1), hh = .5*(h2 - h1);
double whalf = .5*w1, hhalf = .5*h1;
double lwhalf = l*whalf, lhhalf = l*hhalf;
/* Propagate neutron to guide entrance. */
PROP_Z0;
if(x <= -whalf || x >= whalf || y <= -hhalf || y >= hhalf)
ABSORB;
for(;;)
{
/* Compute the dot products of v and n for the four mirrors. */
av = l*vx; bv = ww*vz;
ah = l*vy; bh = hh*vz;
vdotn_v1 = bv + av; /* Left vertical */
vdotn_v2 = bv - av; /* Right vertical */
vdotn_h1 = bh + ah; /* Lower horizontal */
vdotn_h2 = bh - ah; /* Upper horizontal */
/* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
cv1 = -whalf*l - z*ww; cv2 = x*l;
ch1 = -hhalf*l - z*hh; ch2 = y*l;
/* Compute intersection times. */
t1 = (l - z)/vz;
i = 0;
if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
{
t1 = t2;
i = 1;
}
if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
{
t1 = t2;
i = 2;
}
if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
{
t1 = t2;
i = 3;
}
if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
{
t1 = t2;
i = 4;
}
if(i == 0)
break; /* Neutron left guide. */
PROP_DT(t1);
switch(i)
{
case 1: /* Left vertical mirror */
nlen2 = l*l + ww*ww;
q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
d = 2*vdotn_v1/nlen2;
vx = vx - d*l;
118 Ris{R{1175(EN)

vz = vz - d*ww;
break;
case 2: /* Right vertical mirror */
nlen2 = l*l + ww*ww;
q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
d = 2*vdotn_v2/nlen2;
vx = vx + d*l;
vz = vz - d*ww;
break;
case 3: /* Lower horizontal mirror */
nlen2 = l*l + hh*hh;
q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
d = 2*vdotn_h1/nlen2;
vy = vy - d*l;
vz = vz - d*hh;
break;
case 4: /* Upper horizontal mirror */
nlen2 = l*l + hh*hh;
q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
d = 2*vdotn_h2/nlen2;
vy = vy + d*l;
vz = vz - d*hh;
break;
}
/* Now compute reflectivity. */
if(m == 0)
ABSORB;
if(q > Qc)
{
double arg = (q-m*Qc)/W;
if(arg < 10)
p *= .5*(1-tanh(arg))*(1-alpha*(q-Qc));
else
ABSORB; /* Cutoff ~ 1E-10 */
}
p *= R0;
SCATTER;
}
%}
MCDISPLAY
%{
double x;
int i;
magnify("xy");
multiline(5,
-w1/2.0, -h1/2.0, 0.0,
w1/2.0, -h1/2.0, 0.0,
w1/2.0, h1/2.0, 0.0,
-w1/2.0, h1/2.0, 0.0,
-w1/2.0, -h1/2.0, 0.0);
multiline(5,
-w2/2.0, -h2/2.0, (double)l,
w2/2.0, -h2/2.0, (double)l,
w2/2.0, h2/2.0, (double)l,
Ris{R{1175(EN) 119

-w2/2.0, h2/2.0, (double)l,
-w2/2.0, -h2/2.0, (double)l);
line(-w1/2.0, -h1/2.0, 0, -w2/2.0, -h2/2.0, (double)l);
line( w1/2.0, -h1/2.0, 0, w2/2.0, -h2/2.0, (double)l);
line( w1/2.0, h1/2.0, 0, w2/2.0, h2/2.0, (double)l);
line(-w1/2.0, h1/2.0, 0, -w2/2.0, h2/2.0, (double)l);
%}
END
120 Ris{R{1175(EN)

B.3.4 Channeled Guide
/*******************************************************************************
*
* McStas, the neutron ray-tracing package
* Maintained by Kristian Nielsen and Kim Lefmann,
* Copyright 2000 Risoe National Laboratory, Roskilde, Denmark
*
* %I
* Written by: KN
* Date: 1999
* Version: $Revision: 1.2 $
* Origin: McStas release
*
* Neutron guide with channels (bender section).
*
* %D
* Models a rectangular guide tube centered on the Z axis. The entrance lies
* in the X-Y plane.
* The guide may be tapered, and may have vertical subdivisions (used for
* bender devices).
*
* %P
* INPUT PARAMETERS:
*
* w1: (m) Width at the guide entry
* h1: (m) Height at the guide entry
* w2: (m) Width at the guide exit
* h2: (m) Height at the guide exit
* l: (m) Length of guide
* d: (m) Thickness of subdividing walls
* k: (1) Number of channels in the guide (>= 1)
* R0: (1) Low-angle reflectivity
* Qcx: (AA-1) Critical scattering vector for left and right vertical
* mirrors in each channel
* Qcy: (AA-1) Critical scattering vector for top and bottom mirrors
* alphax: (AA) Slope of reflectivity for left and right vertical
* mirrors in each channel
* alphay: (AA) Slope of reflectivity for top and bottom mirrors
* mx: (1) m-value of material for left and right vertical mirrors
* in each channel. Zero means completely absorbing.
* my: (1) m-value of material for top and bottom mirrors. Zero
* means completely absorbing.
* W: (AA-1) Width of supermirror cut-off for all mirrors
*
* %D
* Example values: mx=4 my=2 Qcx=Qcy=0.02 W=1/300 alphax=alphay=6.49 R0=1
*
* %E
*******************************************************************************/
DEFINE COMPONENT Channeled_guide
DEFINITION PARAMETERS ()
SETTING PARAMETERS (w1, h1, w2, h2, d, k, l,
R0, Qcx, Qcy, alphax, alphay, mx, my, W)
OUTPUT PARAMETERS (w1c,w2c,ww,hh,whalf,hhalf,lwhalf,lhhalf)
STATE PARAMETERS (x,y,z,vx,vy,vz,t,s1,s2,p)
Ris{R{1175(EN) 121

DECLARE
%{
double w1c;
double w2c;
double ww, hh;
double whalf, hhalf;
double lwhalf, lhhalf;
%}
INITIALIZE
%{
w1c = (w1 + d)/(double)k;
w2c = (w2 + d)/(double)k;
ww = .5*(w2c - w1c);
hh = .5*(h2 - h1);
whalf = .5*(w1c - d);
hhalf = .5*h1;
lwhalf = l*whalf;
lhhalf = l*hhalf;
%}
TRACE
%{
double t1,t2; /* Intersection times. */
double av,ah,bv,bh,cv1,cv2,ch1,ch2,dd; /* Intermediate values */
double vdotn_v1,vdotn_v2,vdotn_h1,vdotn_h2; /* Dot products. */
int i; /* Which mirror hit? */
double q; /* Q [1/AA] of reflection */
double vlen2,nlen2; /* Vector lengths squared */
double edge;
double hadj; /* Channel displacement */
/* Propagate neutron to guide entrance. */
PROP_Z0;
if(x <= w1/-2.0 || x >= w1/2.0 || y <= -hhalf || y >= hhalf)
ABSORB;
/* Shift origin to center of channel hit (absorb if hit dividing walls) */
x += w1/2.0;
edge = floor(x/w1c)*w1c;
if(x - edge > w1c - d)
{
x -= w1/2.0; /* Re-adjust origin */
ABSORB;
}
x -= (edge + (w1c - d)/2.0);
hadj = edge + (w1c - d)/2.0 - w1/2.0;
for(;;)
{
/* Compute the dot products of v and n for the four mirrors. */
av = l*vx; bv = ww*vz;
ah = l*vy; bh = hh*vz;
vdotn_v1 = bv + av; /* Left vertical */
vdotn_v2 = bv - av; /* Right vertical */
vdotn_h1 = bh + ah; /* Lower horizontal */
vdotn_h2 = bh - ah; /* Upper horizontal */
122 Ris{R{1175(EN)

/* Compute the dot products of (O - r) and n as c1+c2 and c1-c2 */
cv1 = -whalf*l - z*ww; cv2 = x*l;
ch1 = -hhalf*l - z*hh; ch2 = y*l;
/* Compute intersection times. */
t1 = (l - z)/vz;
i = 0;
if(vdotn_v1 < 0 && (t2 = (cv1 - cv2)/vdotn_v1) < t1)
{
t1 = t2;
i = 1;
}
if(vdotn_v2 < 0 && (t2 = (cv1 + cv2)/vdotn_v2) < t1)
{
t1 = t2;
i = 2;
}
if(vdotn_h1 < 0 && (t2 = (ch1 - ch2)/vdotn_h1) < t1)
{
t1 = t2;
i = 3;
}
if(vdotn_h2 < 0 && (t2 = (ch1 + ch2)/vdotn_h2) < t1)
{
t1 = t2;
i = 4;
}
if(i == 0)
break; /* Neutron left guide. */
PROP_DT(t1);
switch(i)
{
case 1: /* Left vertical mirror */
nlen2 = l*l + ww*ww;
q = V2Q*(-2)*vdotn_v1/sqrt(nlen2);
dd = 2*vdotn_v1/nlen2;
vx = vx - dd*l;
vz = vz - dd*ww;
break;
case 2: /* Right vertical mirror */
nlen2 = l*l + ww*ww;
q = V2Q*(-2)*vdotn_v2/sqrt(nlen2);
dd = 2*vdotn_v2/nlen2;
vx = vx + dd*l;
vz = vz - dd*ww;
break;
case 3: /* Lower horizontal mirror */
nlen2 = l*l + hh*hh;
q = V2Q*(-2)*vdotn_h1/sqrt(nlen2);
dd = 2*vdotn_h1/nlen2;
vy = vy - dd*l;
vz = vz - dd*hh;
break;
case 4: /* Upper horizontal mirror */
nlen2 = l*l + hh*hh;
q = V2Q*(-2)*vdotn_h2/sqrt(nlen2);
dd = 2*vdotn_h2/nlen2;
Ris{R{1175(EN) 123

vy = vy + dd*l;
vz = vz - dd*hh;
break;
}
/* Now compute reflectivity. */
if((i <= 2 && mx == 0) || (i > 2 && my == 0))
{
x += hadj; /* Re-adjust origin */
ABSORB;
}
if((i <= 2 && q > Qcx) || (i > 2 && q > Qcy))
{
if (i <= 2)
{
double arg = (q - mx*Qcx)/W;
if(arg < 10)
p *= .5*(1-tanh(arg))*(1-alphax*(q-Qcx));
else
{
x += hadj; /* Re-adjust origin */
ABSORB; /* Cutoff ~ 1E-10 */
}
} else {
double arg = (q - my*Qcy)/W;
if(arg < 10)
p *= .5*(1-tanh(arg))*(1-alphay*(q-Qcy));
else
{
x += hadj; /* Re-adjust origin */
ABSORB; /* Cutoff ~ 1E-10 */
}
}
}
p *= R0;
x += hadj; SCATTER; x -= hadj;
}
x += hadj; /* Re-adjust origin */
%}
MCDISPLAY
%{
double x;
int i;
magnify("xy");
for(i = 0; i < k; i++)
{
multiline(5,
i*w1c - w1/2.0, -h1/2.0, 0.0,
i*w2c - w2/2.0, -h2/2.0, (double)l,
i*w2c - w2/2.0, h2/2.0, (double)l,
i*w1c - w1/2.0, h1/2.0, 0.0,
i*w1c - w1/2.0, -h1/2.0, 0.0);
multiline(5,
(i+1)*w1c - d - w1/2.0, -h1/2.0, 0.0,
(i+1)*w2c - d - w2/2.0, -h2/2.0, (double)l,
124 Ris{R{1175(EN)

(i+1)*w2c - d - w2/2.0, h2/2.0, (double)l,
(i+1)*w1c - d - w1/2.0, h1/2.0, 0.0,
(i+1)*w1c - d - w1/2.0, -h1/2.0, 0.0);
}
line(-w1/2.0, -h1/2.0, 0.0, w1/2.0, -h1/2.0, 0.0);
line(-w2/2.0, -h2/2.0, (double)l, w2/2.0, -h2/2.0, (double)l);
%}
END
Ris{R{1175(EN) 125

B.4 Chopper-like components
B.4.1 V selector.comp
/*******************************************************************************
*
* McStas, the neutron ray-tracing package
* Maintained by Kristian Nielsen and Kim Lefmann,
* Copyright 1997-2000 Risoe National Laboratory, Roskilde, Denmark
*
* %I
* Written by: KL
* Date: Nov 25, 1998
* Version: $Revision: 1.2 $
* Origin: McStas release
* Modified by: KL, Jan 22, 1999
*
* Velocity selector.
*
* %D
* Velocity selector consisting of rotating Soller-like blades
* defining a helically twisted passage.
* Geometry defined by two identical, centered apertures at 12 o'clock
* position, Origo is at the centre of the selector.
* Transmission is analytical assuming a continuous source.
*
* %P
* INPUT PARAMETERS:
*
* width: (m) Width of aperture
* height: (m) Height of aperture
* l0: (m) Distance between apertures
* r0: (m) Height from aperture centre to rotation axis
* phi: (rad) Twist angle along the cylinder
* l1: (m) Length of cylinder (less than l0)
* tb: (m) Thickness of blades
* rot: (rpm) Cylinder rotation speed, counter-clockwise
* nb: (1) Number of Soller blades
*
* %E
*******************************************************************************/
DEFINE COMPONENT V_selector
DEFINITION PARAMETERS ()
SETTING PARAMETERS (width, height, l0, r0, phi, l1, tb, rot, nb)
STATE PARAMETERS (x,y,z,vx,vy,vz,t,s1,s2,p)
DECLARE
%{
double RPM2OM, omega, phi_rad, dt0, dt1, r_i, r_f, r_mean, theta_i, theta_f, A, d_s_phi;
%}
INITIALIZE
%{
RPM2OM = 2*PI/60.0;
omega=rot*RPM2OM;
phi_rad = phi*DEG2RAD;
%}
126 Ris{R{1175(EN)

TRACE
%{
if (vz == 0)
ABSORB;
dt1= (-l0/2.0 - z)/vz;
PROP_DT(dt1); /* Propagate to the entry aperture */
if (x<(-width/2.0) || x>(width/2.0) || y<(-height/2.0) || y>(height/2.0))
ABSORB;
dt0 = (l0-l1)/(2.0*vz); /* Propagate to the cylinder start */
PROP_DT(dt0);
r_i = sqrt(x*x+(y+r0)*(y+r0));
theta_i = atan2(x,y+r0);
dt1 = l1/vz; /* Propagate along the cylinder length */
PROP_DT(dt1);
r_f = sqrt(x*x+(y+r0)*(y+r0));
theta_f = atan2(x,y+r0);
dt0 = (l0-l1)/(2.0*vz); /* Propagate to the exit aperture */
PROP_DT(dt0);
if (x<(-width/2.0) || x>(width/2.0) || y<(-height/2.0) || y>(height/2.0))
ABSORB;
/* Calculate analytical transmission assuming continuous source */
r_mean = (r_i + r_f)/2.0; /* Approximation using mean radius */
d_s_phi = theta_f-theta_i;
A = nb/(2*PI)*( tb/r_mean + fabs(phi_rad+d_s_phi-omega*l1/vz) );
if (A >= 1)
ABSORB;
p*= (1-A);
%}
MCDISPLAY
%{
double r = r0 + height;
double x0 = -width/2.0;
double x1 = width/2.0;
double y0 = -height/2.0;
double y1 = height/2.0;
double z0 = -l0/2.0;
double z1 = -l1/2.0;
double z2 = l1/2.0;
double z3 = l0/2.0;
double a;
double xw, yh;
magnify("xy");
xw = width/2.0;
yh = height/2.0;
/* Draw apertures */
for(a = z0;;)
{
multiline(3, x0-xw, (double)y1, a,
(double)x0, (double)y1, a,
Ris{R{1175(EN) 127

(double)x0, y1+yh, a);
multiline(3, x1+xw, (double)y1, a,
(double)x1, (double)y1, a,
(double)x1, y1+yh, a);
multiline(3, x0-xw, (double)y0, a,
(double)x0, (double)y0, a,
(double)x0, y0-yh, a);
multiline(3, x1+xw, (double)y0, a,
(double)x1, (double)y0, a,
(double)x1, y0-yh, a);
if(a == z3)
break;
else
a = z3;
}
/* Draw cyulinder. */
circle("xy", 0, -r0, z1, r);
circle("xy", 0, -r0, z2, r);
line(0, -r0, z1, 0, -r0, z2);
for(a = 0; a < 2*PI; a += PI/8)
{
multiline(4,
0.0, -r0, z1,
r*cos(a), r*sin(a) - r0, z1,
r*cos(a + DEG2RAD*phi), r*sin(a + DEG2RAD*phi) - r0, z2,
0.0, -r0, z2);
}
%}
END
128 Ris{R{1175(EN)

B.4.2 Chopper.comp
/*******************************************************************************
* %I
* Written by: Philipp Bernhardt
* Date: Januar 22 1999
* Version: $Revision: 1.2 $
* Origin: McStas release
*
* Disk chopper.
*
* %D
* Models a disc chopper with n identical slits, which are symmetrically disposed on the disc.
*
* %P
* INPUT PARAMETERS:
*
* w: (m) Width of the slits at the bottom side
* R: (m) Radius of the disc
* f: (rad/s) angular frequency of the Chopper (algebraic sign defines the direction
* of rotation
* n: (1) Number of slits
* pha: (s) Phase
*
* %D
* Example values: w=0.05 R=0.5 f=2500 n=3 pha=0
*
* %E
*******************************************************************************/
DEFINE COMPONENT Chopper
DEFINITION PARAMETERS ()
SETTING PARAMETERS (w, R, f, n, pha)
OUTPUT PARAMETERS (Tg, To)
STATE PARAMETERS (x, y, z, vx, vy, vz, t, s1, s2, p)
DECLARE
%{
double Tg,To;
%}
INITIALIZE
%{
/* time between two pulses */
Tg=2*PI/fabs(f)/n;
/* how long can neutrons pass the Chopper at a single point */
To=2*atan(w/R/2.0)/fabs(f);
%}
TRACE
%{
double toff;
PROP_Z0;
toff=fabs(t-atan2(x,y+R)/f-pha)+To/2.0;
Ris{R{1175(EN) 129

/* does neutron hit the slit? */
if (fmod(toff,Tg)>To)
ABSORB;
%}
END
130 Ris{R{1175(EN)

B.5 Detectors and monitors
B.5.1 Monitor
/*******************************************************************************
*
* McStas, the neutron ray-tracing package
* Maintained by Kristian Nielsen and Kim Lefmann,
* Copyright 1997-2000 Risoe National Laboratory, Roskilde, Denmark
*
* %I
* Written by: KL
* Date: October 4, 1997
* Version: $Revision: 1.2 $
* Origin: McStas release
*
* Simple single detector/monitor.
*
* %D
* Sums neutrons (0th, 1st, and 2nd moment of p) flying through
* the rectangular monitor opening. May also be used as detector.
*
* %P
* INPUT PARAMETERS:
*
* xmin: Lower x bound of opening [m]
* xmax: Upper x bound of opening [m]
* ymin: Lower y bound of opening [m]
* ymax: Upper y bound of opening [m]
*
* OUTPUT PARAMETERS:
*
* Nsum: Number of neutron hits
* psum: Sum of neutron weights
* p2sum: 2nd moment of neutron weights
*
* %E
*******************************************************************************/
DEFINE COMPONENT Monitor
DEFINITION PARAMETERS ()
SETTING PARAMETERS (xmin, xmax, ymin, ymax)
OUTPUT PARAMETERS (Nsum, psum, p2sum)
STATE PARAMETERS (x,y,z,vx,vy,vz,t,s1,s2,p)
DECLARE
%{
int Nsum;
double psum, p2sum;
%}
INITIALIZE
%{
psum = 0;
p2sum = 0;
Nsum = 0;
%}
TRACE
%{
Ris{R{1175(EN) 131

PROP_Z0;
if (x>xmin && x<xmax && y>ymin && y<ymax)
{
Nsum++;
psum += p;
p2sum += p*p;
}
%}
FINALLY
%{
DETECTOR_OUT_0D("Single monitor", Nsum, psum, p2sum);
%}
MCDISPLAY
%{
magnify("xy");
multiline(5, (double)xmin, (double)ymin, 0.0,
(double)xmax, (double)ymin, 0.0,
(double)xmax, (double)ymax, 0.0,
(double)xmin, (double)ymax, 0.0,
(double)xmin, (double)ymin, 0.0);
%}
END
132 Ris{R{1175(EN)

B.5.3 PSD monitor
/*******************************************************************************
*
* McStas, the neutron ray-tracing package
* Maintained by Kristian Nielsen and Kim Lefmann,
* Copyright 1997-2000 Risoe National Laboratory, Roskilde, Denmark
*
* %I
* Written by: KL
* Date: Feb 3, 1998
* Version: $Revision: 1.2 $
* Origin: McStas release
*
* Position-sensitive monitor.
*
* %D
* An (n times m) pixel PSD monitor. This component may also be used as a beam
* detector.
*
* %P
* INPUT PARAMETERS:
*
* xmin: Lower x bound of detector opening (m)
* xmax: Upper x bound of detector opening (m)
* ymin: Lower y bound of detector opening (m)
* ymax: Upper y bound of detector opening (m)
* nx: Number of pixel columns (1)
* ny: Number of pixel rows (1)
* filename: Name of file in which to store the detector image (text)
*
* OUTPUT PARAMETERS:
*
* PSD_N: Array of neutron counts
* PSD_p: Array of neutron weight counts
* PSD_p2: Array of second moments
*
* %E
*******************************************************************************/
DEFINE COMPONENT PSD_monitor
DEFINITION PARAMETERS (nx, ny, filename)
SETTING PARAMETERS (xmin, xmax, ymin, ymax)
OUTPUT PARAMETERS (PSD_N, PSD_p, PSD_p2)
STATE PARAMETERS (x,y,z,vx,vy,vz,t,s1,s2,p)
DECLARE
%{
int PSD_N[nx][ny];
double PSD_p[nx][ny];
double PSD_p2[nx][ny];
%}
INITIALIZE
%{
int i,j;
for (i=0; i<nx; i++)
Ris{R{1175(EN) 133

for (j=0; j<ny; j++)
{
PSD_N[i][j] = 0;
PSD_p[i][j] = 0;
PSD_p2[i][j] = 0;
}
%}
TRACE
%{
int i,j;
PROP_Z0;
if (x>xmin && x<xmax && y>ymin && y<ymax)
{
i = floor((x - xmin)*nx/(xmax - xmin));
j = floor((y - ymin)*ny/(ymax - ymin));
PSD_N[i][j]++;
PSD_p[i][j] += p;
PSD_p2[i][j] += p*p;
}
%}
FINALLY
%{
DETECTOR_OUT_2D(
"PSD monitor",
"X position [cm]",
"Y position [cm]",
xmin*100.0, xmax*100.0, ymin*100.0, ymax*100.0,
nx, ny,
&PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
filename);
%}
MCDISPLAY
%{
magnify("xy");
multiline(5, (double)xmin, (double)ymin, 0.0,
(double)xmax, (double)ymin, 0.0,
(double)xmax, (double)ymax, 0.0,
(double)xmin, (double)ymax, 0.0,
(double)xmin, (double)ymin, 0.0);
%}
END
134 Ris{R{1175(EN)

B.5.4 PSD monitor 4PI
/*******************************************************************************
*
* McStas, the neutron ray-tracing package
* Maintained by Kristian Nielsen and Kim Lefmann,
* Copyright 1997-2000 Risoe National Laboratory, Roskilde, Denmark
*
* %I
* Written by: KL and KN
* Date: April 17, 1998
* Version: $Revision: 1.2 $
* Origin: McStas release
*
* Spherical position-sensitive detector.
*
* %D
* An (n times m) pixel spherical PSD monitor using a cylindrical projection.
* Mostly for test and debugging purposes.
*
* %P
* INPUT PARAMETERS:
*
* radius: Radius of detector (m)
* nx: Number of pixel columns (1)
* ny: Number of pixel rows (1)
* filename: Name of file in which to store the detector image (text)
*
* OUTPUT PARAMETERS:
*
* PSD_N: Array of neutron counts
* PSD_p: Array of neutron weight counts
* PSD_p2: Array of second moments
*
* %L
* <A HREF="http://neutron.risoe.dk/mcstas/components/tests/powder/">Test
* results</A> (not up-to-date).
*
* %E
*******************************************************************************/
DEFINE COMPONENT PSD_monitor_4PI
DEFINITION PARAMETERS (nx, ny, filename)
SETTING PARAMETERS (radius)
OUTPUT PARAMETERS (PSD_N, PSD_p, PSD_p2)
STATE PARAMETERS (x,y,z,vx,vy,vz,t,s1,s2,p)
DECLARE
%{
int PSD_N[nx][ny];
double PSD_p[nx][ny];
double PSD_p2[nx][ny];
%}
INITIALIZE
%{
int i,j;
Ris{R{1175(EN) 135

for (i=0; i<nx; i++)
for (j=0; j<ny; j++)
{
PSD_N[i][j] = 0;
PSD_p[i][j] = 0;
PSD_p2[i][j] = 0;
}
%}
TRACE
%{
double t0, t1, phi;
int i,j;
if(sphere_intersect(&t0, &t1, x, y, z, vx, vy, vz, radius) && t1 > 0)
{
if(t0 < 0)
t0 = t1;
/* t0 is now time of intersection with the sphere. */
PROP_DT(t0);
phi = atan2(z,x);
i = floor(nx*(phi/(2*PI) + 0.5));
if(i == nx)
i--; /* Special case for phi = PI. */
else if(i < 0)
y = 0;
j = floor(ny*(y/(2*radius) + 0.5));
if(j == ny)
j--; /* Special case for y = radius. */
else if(j < 0)
j = 0;
PSD_N[i][j]++;
PSD_p[i][j] += p;
PSD_p2[i][j] += p*p;
}
%}
FINALLY
%{
DETECTOR_OUT_2D(
"4PI PSD monitor",
"Longitude [deg]",
"Lattitude [deg]",
-180, 180, -90, 90,
nx, ny,
&PSD_N[0][0],&PSD_p[0][0],&PSD_p2[0][0],
filename);
%}
MCDISPLAY
%{
magnify("");
circle("xy",0,0,0,radius);
circle("xz",0,0,0,radius);
circle("yz",0,0,0,radius);
%}
136 Ris{R{1175(EN)

END
Ris{R{1175(EN) 137

B.5.6 TOF monitor
/*******************************************************************************
*
* McStas, the neutron ray-tracing package
* Maintained by Kristian Nielsen and Kim Lefmann,
* Copyright 1997-2000 Risoe National Laboratory, Roskilde, Denmark
*
* %I
* Written by: KN, M. Hagan
* Date: August 1998
* Version: $Revision: 1.2 $
* Origin: McStas release
* Modified by: KL, October 7, 1998
*
* Rectangular Time-of-flight monitor.
*
* %P
* INPUT PARAMETERS:
*
* xmin: Lower x bound of detector opening (m)
* xmax: Upper x bound of detector opening (m)
* ymin: Lower y bound of detector opening (m)
* ymax: Upper y bound of detector opening (m)
* nchan: Number of time bins (1)
* dt: Length of each time bin (mu-s)
* filename: Name of file in which to store the detector image (text)
*
* OUTPUT PARAMETERS:
*
* TOF_N: Array of neutron counts
* TOF_p: Array of neutron weight counts
* TOF_p2: Array of second moments
*
* %E
*******************************************************************************/
DEFINE COMPONENT TOF_monitor
DEFINITION PARAMETERS (nchan, filename)
SETTING PARAMETERS (xmin, xmax, ymin, ymax, dt)
OUTPUT PARAMETERS (TOF_N, TOF_p, TOF_p2)
STATE PARAMETERS (x,y,z,vx,vy,vz,t,s1,s2,p)
DECLARE
%{
int TOF_N[nchan];
double TOF_p[nchan];
double TOF_p2[nchan];
%}
INITIALIZE
%{
int i;
for (i=0; i<nchan; i++)
{
TOF_N[i] = 0;
TOF_p[i] = 0;
TOF_p2[i] = 0;
138 Ris{R{1175(EN)

}
%}
TRACE
%{
int i;
PROP_Z0;
if (x>xmin && x<xmax && y>ymin && y<ymax)
{
i = floor(1E6*t/dt); /* Bin number */
if(i >= nchan) i = nchan - 1;
if(i < 0)
{
printf("FATAL ERROR: negative time-of-flight.\n");
exit(1);
}
TOF_N[i]++;
TOF_p[i] += p;
TOF_p2[i] += p*p;
}
%}
FINALLY
%{
DETECTOR_OUT_1D(
"Time-of-flight monitor",
"Time-of-flight [\\gms]",
"Intensity",
"t", 0.0, nchan*(double)dt, nchan,
&TOF_N[0],&TOF_p[0],&TOF_p2[0],
filename);
%}
MCDISPLAY
%{
magnify("xy");
multiline(5, (double)xmin, (double)ymin, 0.0,
(double)xmax, (double)ymin, 0.0,
(double)xmax, (double)ymax, 0.0,
(double)xmin, (double)ymax, 0.0,
(double)xmin, (double)ymin, 0.0);
%}
END
Ris{R{1175(EN) 139

B.5.7 E monitor
/*******************************************************************************
*
* McStas, the neutron ray-tracing package
* Maintained by Kristian Nielsen and Kim Lefmann,
* Copyright 1997-2000 Risoe National Laboratory, Roskilde, Denmark
*
* %I
* Written by: KN,KL
* Date: April 20, 1998
* Version: $Revision: 1.2 $
* Origin: McStas release
* Modified by: KL, Octorber 7, 1998
*
* Energy-sensitive monitor.
*
* %D
* A square single monitor that measures the energy of the incoming neutrons.
*
* %P
* INPUT PARAMETERS:
*
* xmin: Lower x bound of detector opening (m)
* xmax: Upper x bound of detector opening (m)
* ymin: Lower y bound of detector opening (m)
* ymax: Upper y bound of detector opening (m)
* Emin: Minimum energy to detect (meV)
* Emax: Maximum energy to detect (meV)
* nchan: Number of energy channels (1)
* filename: Name of file in which to store the detector image (text)
*
* OUTPUT PARAMETERS:
*
* E_N: Array of neutron counts
* E_p: Array of neutron weight counts
* E_p2: Array of second moments
*
* %E
*******************************************************************************/
DEFINE COMPONENT E_monitor
DEFINITION PARAMETERS (nchan, filename)
SETTING PARAMETERS (xmin, xmax, ymin, ymax, Emin, Emax)
OUTPUT PARAMETERS (E_N, E_p, E_p2)
STATE PARAMETERS (x,y,z,vx,vy,vz,t,s1,s2,p)
DECLARE
%{
int E_N[nchan];
double E_p[nchan], E_p2[nchan];
%}
INITIALIZE
%{
int i;
for (i=0; i<nchan; i++)
{
140 Ris{R{1175(EN)

E_N[i] = 0;
E_p[i] = 0;
E_p2[i] = 0;
}
%}
TRACE
%{
int i;
double E;
PROP_Z0;
if (x>xmin && x<xmax && y>ymin && y<ymax)
{
E = VS2E*(vx*vx + vy*vy + vz*vz);
i = floor((E-Emin)*nchan/(Emax-Emin));
if(i >= 0 && i < nchan)
{
E_N[i]++;
E_p[i] += p;
E_p2[i] += p*p;
}
}
%}
FINALLY
%{
DETECTOR_OUT_1D(
"Energy monitor",
"Energy [meV]",
"Intensity",
"E", Emin, Emax, nchan,
&E_N[0],&E_p[0],&E_p2[0],
filename);
%}
MCDISPLAY
%{
magnify("xy");
multiline(5, (double)xmin, (double)ymin, 0.0,
(double)xmax, (double)ymin, 0.0,
(double)xmax, (double)ymax, 0.0,
(double)xmin, (double)ymax, 0.0,
(double)xmin, (double)ymin, 0.0);
%}
END
Ris{R{1175(EN) 141

B.5.13 Res monitor
/*******************************************************************************
*
* McStas, the neutron ray-tracing package
* Maintained by Kristian Nielsen and Kim Lefmann,
* Copyright 1997-2000 Risoe National Laboratory, Roskilde, Denmark
*
* Component: Res_monitor
*
* %I
* Written by: KN
* Date: 1999
* Version: $Revision: 1.2 $
* Origin: McStas release
*
* Monitor for resolution calculations
*
* %D
* A single detector/monitor, used together with the Res_sample component to
* compute instrument resolution functions. Outputs a list of neutron
* scattering events in the sample along with their intensities in the
* detector. The output file may be analyzed with the mcresplot front-end.
*
* %P
* INPUT PARAMETERS:
*
* xmin: Lower x bound of detector opening (m)
* xmax: Upper x bound of detector opening (m)
* ymin: Lower y bound of detector opening (m)
* ymax: Upper y bound of detector opening (m)
* filename: Name of output file (string)
* res_sample_comp: Name of Res_sample component in the instrument definition
*
* OUTPUT PARAMETERS:
*
* Nsum: Number of neutron hits
* psum: Sum of neutron weights
* p2sum: 2nd moment of neutron weights
*
* %E
*******************************************************************************/
DEFINE COMPONENT Res_monitor
DEFINITION PARAMETERS (filename, res_sample_comp)
SETTING PARAMETERS (xmin, xmax, ymin, ymax)
OUTPUT PARAMETERS (Nsum, psum, p2sum, file)
STATE PARAMETERS (x,y,z,vx,vy,vz,t,s1,s2,p)
DECLARE
%{
int Nsum;
double psum, p2sum;
FILE *file;
%}
INITIALIZE
%{
psum = 0;
142 Ris{R{1175(EN)

p2sum = 0;
Nsum = 0;
file = filename ? fopen(filename, "w") : 0;
if(!file && filename)
fprintf(stderr, "Warning: could not open output file '%s'\n", filename);
%}
TRACE
%{
PROP_Z0;
if (x>xmin && x<xmax && y>ymin && y<ymax)
{
Nsum++;
psum += p;
p2sum += p*p;
/* Now fetch data from the Res_sample. */
if(p != 0 && file)
{
struct Res_sample_struct *s =
&(MC_GETPAR(res_sample_comp, res_struct));
if(s->pi != 0)
fprintf(file, "%g %g %g %g %g %g %g %g %g %g %g\n",
s->ki_x, s->ki_y, s->ki_z, s->kf_x, s->kf_y, s->kf_z,
s->rx, s->ry, s->rz, s->pi, p/s->pi);
}
}
%}
FINALLY
%{
if(file)
fclose(file);
DETECTOR_OUT_0D("Single monitor", Nsum, psum, p2sum);
%}
MCDISPLAY
%{
magnify("xy");
multiline(5, (double)xmin, (double)ymin, 0.0,
(double)xmax, (double)ymin, 0.0,
(double)xmax, (double)ymax, 0.0,
(double)xmin, (double)ymax, 0.0,
(double)xmin, (double)ymin, 0.0);
%}
END
Ris{R{1175(EN) 143

B.5.14 Adapt check
/*******************************************************************************
*
* McStas, the neutron ray-tracing Monte-Carlo software.
* Copyright(C) 1999,2000 Risoe National Laboratory.
*
* %I
* Written by: Kristian Nielsen
* Date: 1999
* Version: $Revision: 1.2 $
* Origin: McStas release
*
* Optimization specifier for the Source_adapt component.
*
* %D
* This components works together with the Source_adapt component, and
* is used to define the criteria for selecting which neutrons are
* considered "good" in the adaptive algorithm. The name of the
* associated Source_adapt component in the instrument definition is
* given as parameter. The component is special in that its position
* does not matter; all neutrons that have not been absorbed prior to
* the component are considered "good".
*
* %P
* INPUT PARAMETERS:
*
* source_comp: The name of the Source_adapt component in the
* instrument definition.
*
* %E
*******************************************************************************/
DEFINE COMPONENT Adapt_check
DEFINITION PARAMETERS (source_comp)
SETTING PARAMETERS ()
STATE PARAMETERS (x,y,z,vx,vy,vz,t,s1,s2,p)
TRACE
%{
double new_v, psi;
struct source_adapt *adpt = &(MC_GETPAR(source_comp, adpt));
if(p == 0)
ABSORB;
psi = p/adpt->pi;
adpt->psi[adpt->idx] += psi;
adpt->psi_tot += psi/adpt->n[adpt->idx];
new_v = (1 - adpt->a_beta)*adpt->factor*adpt->psi[adpt->idx]/
(adpt->n[adpt->idx]*adpt->psi_tot) +
adpt->a_beta/adpt->num;
adapt_tree_add(adpt->atree, adpt->idx, new_v - adpt->atree->v[adpt->idx]);
%}
MCDISPLAY
%{
magnify("");
144 Ris{R{1175(EN)

%}
END
Ris{R{1175(EN) 145

B.6 Crystals
B.6.1 Mosaic simple
/*******************************************************************************
*
* McStas, the neutron ray-tracing package
* Maintained by Kristian Nielsen and Kim Lefmann,
* Copyright (C) Risoe National Laboratory 1999
*
* %I
* Written by: Kristian Nielsen
* Date: 1999
* Version: $Revision: 1.2 $
* Origin: McStas release
*
* Mosaic crystal, possibly off-cut.
*
* %D
* Flat, infinitely thin mosaic crystal, useful as a monochromator or analyzer.
* The mosaic is isotropic gaussian, with a given FWHM perpendicular to the
* scattering vector.
* For an unrotated monochromator component, the crystal plane lies in the y-z
* plane (ie. parallel to the beam).
*
* %P
* INPUT PARAMETERS:
*
* zmin: Lower z-bound of crystal (m)
* zmax: Upper z-bound of crystal (m)
* ymin: Lower y-bound of crystal (m)
* ymax: Upper y-bound of crystal (m)
* mosaic: Mosaic (FWHM) (arc minutes)
* R0: Maximum reflectivity (1)
* Qx: X coordinate of scattering vector (AA-1)
* Qy: X coordinate of scattering vector (AA-1)
* Qz: X coordinate of scattering vector (AA-1)
*
* %E
*******************************************************************************/
DEFINE COMPONENT Mosaic_simple
DEFINITION PARAMETERS ()
SETTING PARAMETERS (zmin, zmax, ymin, ymax, mosaic, R0, Qx, Qy, Qz)
OUTPUT PARAMETERS (X,W,Q,mos_rms)
STATE PARAMETERS (x,y,z,vx,vy,vz,t,s1,s2,p)
DECLARE
%{
/* ToDo: Define these arrays only once for all instances. */
/* Values for Gauss quadrature. Taken from Brice Carnahan, H. A. Luther and
James O Wilkes, "Applied numerical methods", Wiley, 1996, page 103. */
double X[] = {-0.987992518020485, 0.937273392400706, 0.848206583410427,
0.724417731360170, 0.570972172608539, 0.394151347077563,
0.201194093997435, 0, 0.201194093997435,
0.394151347077563, 0.570972172608539, 0.724417731360170,
0.848206583410427, 0.937273392400706, 0.987992518020485};
146 Ris{R{1175(EN)

double W[] = {0.030753241996117, 0.070366047488108, 0.107159220467172,
0.139570677926154, 0.166269205816994, 0.186161000115562,
0.198431485327111, 0.202578241925561, 0.198431485327111,
0.186161000115562, 0.166269205816994, 0.139570677926154,
0.107159220467172, 0.070366047488108, 0.030753241996117};
double Q; /* Length of scattering vector */
double q0ux, q0uy, q0uz; /* Unit vector parrallel to nominal Q */
double mos_rms; /* root-mean-square of mosaic, in radians */
#define GAUSS(x,mean,rms) \
(exp(-((x)-(mean))*((x)-(mean))/(2*(rms)*(rms)))/(sqrt(2*PI)*(rms)))
%}
INITIALIZE
%{
Q = sqrt(Qx*Qx + Qy*Qy + Qz*Qz);
q0ux = Qx/Q;
q0uy = Qy/Q;
q0uz = Qz/Q;
mos_rms = MIN2RAD*mosaic/sqrt(8*log(2));
%}
TRACE
%{
double y1,z1,t1,dt,kix,kiy,kiz,ratio,order,q0x,q0y,q0z,k,q0,theta;
double bx,by,bz,kux,kuy,kuz,ax,ay,az,phi;
double cos_2theta,k_sin_2theta,cos_phi,sin_phi,kfx,kfy,kfz,q_x,q_y,q_z;
double delta,p_reflect,total,c1x,c1y,c1z,width,tmp,ds_factor;
int i;
if(vx != 0.0 && (dt = -x/vx) >= 0.0)
{ /* Moving towards crystal? */
y1 = y + vy*dt; /* Propagate to crystal plane */
z1 = z + vz*dt;
t1 = t + dt;
if (z1>zmin && z1<zmax && y1>ymin && y1<ymax)
{ /* Intersect the crystal? */
kix = V2K*vx; /* Initial wave vector */
kiy = V2K*vy;
kiz = V2K*vz;
/* Get reflection order and corresponding nominal scattering vector q0
of correct length and direction. Only the order with the closest
scattering vector is considered */
ratio = -2*(kix*Qx + kiy*Qy + kiz*Qz)/(Q*Q);
order = floor(ratio + .5);
if(order == 0.0)
order = ratio < 0 ? -1 : 1;
/* Order will be negative when the neutron enters from the back, in
which case the direction of Q0 is flipped. */
if(order < 0)
order = -order;
/* Make sure the order is small enough to allow Bragg scattering at the
given neutron wavelength */
k = sqrt(kix*kix + kiy*kiy + kiz*kiz);
kux = kix/k; /* Unit vector along ki */
kuy = kiy/k;
kuz = kiz/k;
Ris{R{1175(EN) 147

if(order > 2*k/Q)
order--;
if(order > 0) /* Bragg scattering possible? */
{
q0x = order*Qx;
q0y = order*Qy;
q0z = order*Qz;
if(ratio < 0)
{
q0x = -q0x; q0y = -q0y; q0z = -q0z;
}
q0 = order*Q;
theta = asin(q0/(2*k)); /* Actual bragg angle */
/* Make MC choice: reflect or transmit? */
delta = asin(-(kux*q0x + kuy*q0y + kuz*q0z)/q0) - theta;
p_reflect = R0*exp(-delta*delta/(2*mos_rms*mos_rms));
if(rand01() < p_reflect)
{ /* Reflect */
cos_2theta = cos(2*theta);
k_sin_2theta = k*sin(2*theta);
/* Get unit normal to plane containing ki and most probable kf */
vec_prod(bx, by, bz, kix, kiy, kiz, q0x, q0y, q0z);
NORM(bx,by,bz);
bx *= k_sin_2theta;
by *= k_sin_2theta;
bz *= k_sin_2theta;
/* Get unit vector normal to ki and b */
vec_prod(ax, ay, az, bx, by, bz, kux, kuy, kuz);
/* Compute the total scattering probability at this ki */
total = 0;
/* Choose integration limits, using Gaussian tail cut-off at 5 times
* sigma. The radius of the Debye-Scherrer cone is smaller by a
* factor 1/cos(theta) than the radius of the (partial) sphere
* describing the possible orientations of Q due to mosaicity, so we
* must use an integration width 1/cos(theta) greater than 5 times
* the mosaic. */
ds_factor = 1/cos(theta);
width = 5*mos_rms*ds_factor;
c1x = kix*(cos_2theta-1);
c1y = kiy*(cos_2theta-1);
c1z = kiz*(cos_2theta-1);
for(i = 0; i < (sizeof(X)/sizeof(double)); i++)
{
phi = width*X[i];
cos_phi = cos(phi);
sin_phi = sin(phi);
q_x = c1x + cos_phi*ax + sin_phi*bx;
q_y = c1y + cos_phi*ay + sin_phi*by;
q_z = c1z + cos_phi*az + sin_phi*bz;
tmp = (q_x*q0x + q_y*q0y + q_z*q0z)/
(sqrt(q_x*q_x + q_y*q_y + q_z*q_z)*q0);
delta = tmp < 1 ? acos(tmp) : 0; /* Avoid rounding errors */
p_reflect = GAUSS(delta,0,mos_rms);
total += W[i]*p_reflect;
}
total *= width;
148 Ris{R{1175(EN)

/* Choose point on Debye-Scherrer cone. Sample from a Gaussian of
* width 1/cos(theta) greater than the mosaic and correct for any
* error by adjusting the neutron weight later. */
phi = ds_factor*mos_rms*randnorm();
/* Compute final wave vector kf and scattering vector q = ki - kf */
cos_phi = cos(phi);
sin_phi = sin(phi);
q_x = c1x + cos_phi*ax + sin_phi*bx;
q_y = c1y + cos_phi*ay + sin_phi*by;
q_z = c1z + cos_phi*az + sin_phi*bz;
tmp = (q_x*q0x + q_y*q0y + q_z*q0z)/
(sqrt(q_x*q_x + q_y*q_y + q_z*q_z)*q0);
delta = tmp < 1 ? acos(tmp) : 0; /* Avoid rounding errors */
p_reflect = GAUSS(delta,0,mos_rms);
x = 0;
y = y1;
z = z1;
t = t1;
vx = K2V*(kix+q_x);
vy = K2V*(kiy+q_y);
vz = K2V*(kiz+q_z);
p *= p_reflect/(total*GAUSS(phi,0,ds_factor*mos_rms));
} /* End MC choice to reflect or transmit neutron */
} /* End bragg scattering possible */
} /* End intersect the crystal */
} /* End neutron moving towards crystal */
%}
MCDISPLAY
%{
double len = 0.5*sqrt((ymax-ymin)*(ymax-ymin) + (zmax-zmin)*(zmax-zmin));
magnify("zy");
multiline(5, 0.0, (double)ymin, (double)zmin,
0.0, (double)ymax, (double)zmin,
0.0, (double)ymax, (double)zmax,
0.0, (double)ymin, (double)zmax,
0.0, (double)ymin, (double)zmin);
line(0, 0, 0, /* Draw Q0 vector */
(double)Qx/Q*len, (double)Qy/Q*len, (double)Qz/Q*len);
%}
END
Ris{R{1175(EN) 149

B.6.3 Single crystal
/*******************************************************************************
*
* McStas, the neutron ray-tracing package
* Maintained by Kristian Nielsen and Kim Lefmann,
* Copyright 1997-2000 Risoe National Laboratory, Roskilde, Denmark
*
* %I
* Written by: KN
* Date: December 1999
* Version: $Revision: 1.2 $
* Origin: McStas release
*
* Mosaic single crystal with multiple scattering vectors.
*
* %D
* Single crystal with mosaic. Delta-D/D option for finite-size effects.
* Rectangular geometry. Multiple scattering and secondary extinction included.
* The mosaic may EITHER be specified isotropic by setting the mosaic input
* parameter, OR anisotropic by setting the mosaic_h, mosaic_v, and mosaic_n
* parameters.
* Crystal structure is specified with an ascii data file. Each line
* contains seven numbers, separated by white space. The first three numbers
* are the (h,k,l) indices of the reciprocal lattice point, and the last
* number is the value of the structure factor |F|**2, in barns. (The rest of
* the numbers are not used; the file is in the format output by the
* Crystallographica program).
*
* %P
* INPUT PARAMETERS:
*
* xwidth : Width of crystal (m)
* yheight : Height of crystal (m)
* zthick : Thichness of crystal (no extinction simulated) (m)
* delta_d_d : Lattice spacing variance, gaussian RMS (1)
* mosaic : Crystal mosaic (isotropic), gaussian RMS (arc minutes)
* mosaic_h : Horizontal (rotation around Y) mosaic (anisotropic),
* gaussian RMS (arc minutes)
* mosaic_v : Vertical (rotation around Z) mosaic (anisotropic),
* gaussian RMS (arc minutes)
* mosaic_n : Out-of-plane (Rotation around X) mosaic (anisotropic),
* gaussian RMS (arc minutes)
* ax,ay,az : Coordinates of first unit cell vector (AA)
* bx,by,bz : Coordinates of second unit cell vector (AA)
* cx,cy,cz : Coordinates of third unit cell vector (AA)
* reflections : File name containing structure factors of reflections (string)
*
* Optional input parameters:
*
* p_transmit : Monte Carlo probability for neutrons to be transmitted
* without any scattering. Used to improve statistics from
* weak reflections [1]
* absorbtion : Absorbtion cross-section per unit cell at 2200 m/s [barns]
* incoherent : Incoherent scattering cross-section per unit cell [barns]
*
* OUTPUT PARAMETERS:
150 Ris{R{1175(EN)

*
* hkl_info : Internal
*
*******************************************************************************/
/*
%D
Overview of algorithm:
(1). The neutron intersects the crystal at (x,y,z) with given
incoming wavevector ki=(kix,kiy,kiz).
(2). Every reciprocal lattice point tau of magnitude less than 2*ki
is considered for scattering. The scattering probability is the
area of the intersection of the Ewald sphere (approximated by
the tangential plane) with the 3-D Gaussian mosaic of the point
tau.
(3). The total coherent scattering cross section is computed as the
sum over all tau. Together with the absorption and incoherent
scattering cross section and known potential flight-length
l_full through the sample, we can compute the probability of
the four events absorption, coherent scattering, incoherent
scattering, and transmission.
(4). Absorption is never simulated explicitly, just incorporated in
the neutron weight.
(5). Transmission in the first event is selected with the Monte
Carlo probability p_transmit, which defaults to the actual
transmission probability. After the first event, transmission
is selected with the correct Monte Carlo probability.
(6). Incoherent scattering is done simply by selecting a random
direction for the outgoing wave vector kf.
(7). For coherent scattering, a reciprocal lattice point is selected
using the relative probabilities computed in (2), and the
weight is adjusted with the contribution from the structure
factors (this way all reflections will get equally good
statistics in the detector).
(8). The outgoing wave vector direction is picked at random using
the intersecting 2-D Gauss computed in (2). The vector is
normalized to the length of ki (elastic scattering) to account
for the error caused by the planar approximation of the Ewald
sphere.
(9). The process is repeated from (2) with kf as new initial wave
vector ki.
%E
*/
DEFINE COMPONENT Single_crystal
DEFINITION PARAMETERS(reflections)
Ris{R{1175(EN) 151

SETTING PARAMETERS(xwidth, yheight, zthick, delta_d_d, mosaic = -1,
mosaic_h = -1, mosaic_v = -1, mosaic_n = -1,
ax, ay, az, bx, by, bz, cx, cy, cz,
p_transmit = -1, absorbtion = 0, incoherent = 0)
OUTPUT PARAMETERS(hkl_info)
STATE PARAMETERS (x,y,z,vx,vy,vz,t,s1,s2,p)
DECLARE
%{
/* Declare structures and functions only once in each instrument. */
#ifndef SINGLE_CRYSTAL_DECL
#define SINGLE_CRYSTAL_DECL
struct hkl_info_struct
{
struct hkl_data *list; /* Reflection array */
int count; /* Number of reflections */
struct tau_data *tau_list; /* Reflections close to Ewald Sphere */
double m_delta_d_d; /* Delta-d/d FWHM */
double m_ax,m_ay,m_az; /* First unit cell axis (direct space, AA) */
double m_bx,m_by,m_bz; /* Second unit cell axis */
double m_cx,m_cy,m_cz; /* Third unit cell axis */
double asx,asy,asz; /* First reciprocal lattice axis (1/AA) */
double bsx,bsy,bsz; /* Second reciprocal lattice axis */
double csx,csy,csz; /* Third reciprocal lattice axis */
double V0; /* Unit cell volume (AA**3) */
};
struct hkl_data
{
int h,k,l; /* Indices for this reflection */
double F2; /* Value of structure factor */
double tau_x, tau_y, tau_z; /* Coordinates in reciprocal space */
double tau; /* Length of (tau_x, tau_y, tau_z) */
double u1x, u1y, u1z; /* First axis of local coordinate system */
double u2x, u2y, u2z; /* Second axis of local coordinate system */
double u3x, u3y, u3z; /* Third axis of local coordinate system */
double sig1, sig2, sig3; /* RMSs of Gauss axis */
double sig123; /* The product sig1*sig2*sig3 */
double m1, m2, m3; /* Diagonal matrix representation of Gauss */
double cutoff; /* Cutoff value for Gaussian tails */
};
struct tau_data
{
int index; /* Index into reflection table */
double refl;
double xsect;
double sigma_1, sigma_2;
/* The following vectors are in local koordinates. */
double kix, kiy, kiz; /* Initial wave vector */
double rho_x, rho_y, rho_z; /* The vector ki - tau */
double rho; /* Length of rho vector */
double ox, oy, oz; /* Origin of Ewald sphere tangent plane */
double nx, ny, nz; /* Normal vector of Ewald sphere tangent */
double b1x, b1y, b1z; /* Spanning vectors of Ewald sphere tangent */
152 Ris{R{1175(EN)

double b2x, b2y, b2z;
double l11, l12, l22; /* Cholesky decomposition L of 2D Gauss */
double det_L; /* Determinant of L */
double y0x, y0y; /* 2D Gauss center in tangent plane */
};
void
read_hkl_data(char *file, struct hkl_info_struct *info)
{
struct hkl_data *list = NULL;
int size = 0;
FILE *f;
int i;
f = fopen(file, "r");
if(!f)
{
fprintf(stderr, "Single crystal: Error: file '%s' cannot be opened.\n",
file);
exit(1);
}
i = 0;
while(!feof(f))
{
double h, k, l, multiplicity, d, ttheta, F2;
double b1[3], b2[3];
int ret;
ret = fscanf(f, "%lf %lf %lf %lf %lf %lf %lf\n",
&h, &k, &l, &multiplicity, &d, &ttheta, &F2);
if(ret == EOF)
break;
if(ret != 7)
{
fprintf(stderr,
"Single crystal: Error reading from file '%s', line %d\n",
file, i + 1);
exit(1);
}
/* Extend list if not large enough. */
extend_list(i, (void **)&list, &size, sizeof(*list));
list[i].h = h;
list[i].k = k;
list[i].l = l;
list[i].F2 = F2;
/* Precompute some values */
list[i].tau_x = h*info->asx + k*info->bsx + l*info->csx;
list[i].tau_y = h*info->asy + k*info->bsy + l*info->csy;
list[i].tau_z = h*info->asz + k*info->bsz + l*info->csz;
list[i].tau = sqrt(list[i].tau_x*list[i].tau_x +
list[i].tau_y*list[i].tau_y +
list[i].tau_z*list[i].tau_z);
list[i].u1x = list[i].tau_x/list[i].tau;
list[i].u1y = list[i].tau_y/list[i].tau;
list[i].u1z = list[i].tau_z/list[i].tau;
list[i].sig1 = FWHM2RMS*info->m_delta_d_d*list[i].tau;
/* Find two arbitrary axes perpendicular to tau and each other. */
Ris{R{1175(EN) 153

normal_vec(&b1[0], &b1[1], &b1[2],
list[i].u1x, list[i].u1y, list[i].u1z);
vec_prod(b2[0], b2[1], b2[2],
list[i].u1x, list[i].u1y, list[i].u1z,
b1[0], b1[1], b1[2]);
/* Find the two mosaic axes perpendicular to tau. */
if(mosaic > 0) {
/* Use isotropic mosaic. */
list[i].u2x = b1[0];
list[i].u2y = b1[1];
list[i].u2z = b1[2];
list[i].sig2 = FWHM2RMS*list[i].tau*MIN2RAD*mosaic;
list[i].u3x = b2[0];
list[i].u3y = b2[1];
list[i].u3z = b2[2];
list[i].sig3 = FWHM2RMS*list[i].tau*MIN2RAD*mosaic;
} else if(mosaic_h > 0 && mosaic_v > 0 && mosaic_n > 0) {
/* Use anisotropic mosaic. */
double mos_D[3][3];
double mos_a, mos_b, mos_c, mos_det, mos_l1, mos_l2;
double mos_e1_x, mos_e1_y, mos_e1_len, mos_e2_x, mos_e2_y, mos_e2_len;
int j1, j2;
/* Define the 3D Gaussian for the mosaic in Euler coordinates. */
mos_D[0][0] = 1/((FWHM2RMS*MIN2RAD*mosaic_n)*(FWHM2RMS*MIN2RAD*mosaic_n));
mos_D[0][1] = 0;
mos_D[0][2] = 0;
mos_D[1][0] = 0;
mos_D[1][1] = 1/((FWHM2RMS*MIN2RAD*mosaic_h)*(FWHM2RMS*MIN2RAD*mosaic_h));
mos_D[1][2] = 0;
mos_D[2][0] = 0;
mos_D[2][1] = 0;
mos_D[2][2] = 1/((FWHM2RMS*MIN2RAD*mosaic_v)*(FWHM2RMS*MIN2RAD*mosaic_v));
/* ToDo: This is the place to apply a rotation U to the mosaic Gaussian,
by setting D := U^T D U. */
/* Now compute the 2D intersection Gauss (B^T D B) between the 3D mosaic
Gauss D and the plane spanned by b1 and b2 (matrix B). The matrix
(B^T D B) is 2x2 symmetric and positive definite.*/
mos_a = mos_b = mos_c = 0;
for(j1 = 0; j1 < 3; j1++) {
for(j2 = 0; j2 < 3; j2++) {
mos_a += b1[j1]*b1[j2]*mos_D[j1][j2];
mos_b += b1[j1]*b2[j2]*mos_D[j1][j2];
mos_c += b2[j1]*b2[j2]*mos_D[j1][j2];
}
}
/* Compute the eigenvalues of the 2D Gaussian. */
if(mos_b*mos_b < 1e-20*(mos_a*mos_a + mos_c*mos_c)) {
/* Matrix is diagonal. */
mos_l1 = mos_a;
mos_e1_x = 1;
mos_e1_y = 0;
mos_l2 = mos_c;
mos_e2_x = 0;
mos_e2_y = 1;
} else { /* Not diagonal */
mos_det = (mos_a - mos_c)*(mos_a - mos_c) + 4*mos_b*mos_b;
154 Ris{R{1175(EN)

mos_l1 = 0.5*(mos_a + mos_c - sqrt(mos_det));
mos_l2 = 0.5*(mos_a + mos_c + sqrt(mos_det));
/* Compute the eigenvectors. */
mos_e1_x = -mos_b;
mos_e1_y = mos_a - mos_l1;
mos_e1_len = sqrt(mos_e1_x*mos_e1_x + mos_e1_y*mos_e1_y);
mos_e1_x /= mos_e1_len;
mos_e1_y /= mos_e1_len;
mos_e2_x = -mos_c - mos_l2;
mos_e2_y = -mos_b;
mos_e2_len = sqrt(mos_e2_x*mos_e2_x + mos_e2_y*mos_e2_y);
mos_e2_x /= mos_e2_len;
mos_e2_y /= mos_e2_len;
}
/* Now finally compute the axes (in reciprocal space) and RMSs of the
reciprocal lattice point Gaussian that are perpendicular to tau. */
list[i].u2x = b1[0]*mos_e2_x + b2[0]*mos_e2_y;
list[i].u2y = b1[1]*mos_e2_x + b2[1]*mos_e2_y;
list[i].u2z = b1[2]*mos_e2_x + b2[2]*mos_e2_y;
list[i].sig2 = list[i].tau/sqrt(mos_l1);
list[i].u3x = b1[0]*mos_e1_x + b2[0]*mos_e1_y;
list[i].u3y = b1[1]*mos_e1_x + b2[1]*mos_e1_y;
list[i].u3z = b1[2]*mos_e1_x + b2[2]*mos_e1_y;
list[i].sig3 = list[i].tau/sqrt(mos_l2);
} else {
fprintf(stderr,
"Single_crystal: Error: EITHER mosaic OR (mosaic_h, mosaic_v, mosaic_n)\n"
"must be given and be >0.\n");
exit(1);
}
list[i].sig123 = list[i].sig1*list[i].sig2*list[i].sig3;
list[i].m1 = 1/(2*list[i].sig1*list[i].sig1);
list[i].m2 = 1/(2*list[i].sig2*list[i].sig2);
list[i].m3 = 1/(2*list[i].sig3*list[i].sig3);
/* Set Gauss cutoff to 5 times the maximal sigma. */
if(list[i].sig1 > list[i].sig2)
if(list[i].sig1 > list[i].sig3)
list[i].cutoff = 5*list[i].sig1;
else
list[i].cutoff = 5*list[i].sig3;
else
if(list[i].sig2 > list[i].sig3)
list[i].cutoff = 5*list[i].sig2;
else
list[i].cutoff = 5*list[i].sig3;
i++;
}
fclose(f);
printf("Single_crystal: Read %d reflections from file '%s'\n", i, file);
info->list = list;
info->count = i;
info->tau_list = malloc(i*sizeof(*info->tau_list));
if(!info->tau_list)
{
fprintf(stderr, "Single_crystal: Error: Out of memory!\n");
exit(1);
Ris{R{1175(EN) 155

}
}
#endif /* !SINGLE_CRYSTAL_DECL */
struct hkl_info_struct hkl_info;
%}
INITIALIZE
%{
double tmp_x, tmp_y, tmp_z;
hkl_info.m_delta_d_d = delta_d_d;
hkl_info.m_ax = ax;
hkl_info.m_ay = ay;
hkl_info.m_az = az;
hkl_info.m_bx = bx;
hkl_info.m_by = by;
hkl_info.m_bz = bz;
hkl_info.m_cx = cx;
hkl_info.m_cy = cy;
hkl_info.m_cz = cz;
/* Compute reciprocal lattice vectors. */
vec_prod(tmp_x, tmp_y, tmp_z, bx, by, bz, cx, cy, cz);
hkl_info.V0 = fabs(scalar_prod(ax, ay, az, tmp_x, tmp_y, tmp_z));
hkl_info.asx = 2*PI/hkl_info.V0*tmp_x;
hkl_info.asy = 2*PI/hkl_info.V0*tmp_y;
hkl_info.asz = 2*PI/hkl_info.V0*tmp_z;
vec_prod(tmp_x, tmp_y, tmp_z, cx, cy, cz, ax, ay, az);
hkl_info.bsx = 2*PI/hkl_info.V0*tmp_x;
hkl_info.bsy = 2*PI/hkl_info.V0*tmp_y;
hkl_info.bsz = 2*PI/hkl_info.V0*tmp_z;
vec_prod(tmp_x, tmp_y, tmp_z, ax, ay, az, bx, by, bz);
hkl_info.csx = 2*PI/hkl_info.V0*tmp_x;
hkl_info.csy = 2*PI/hkl_info.V0*tmp_y;
hkl_info.csz = 2*PI/hkl_info.V0*tmp_z;
/* Read in structure factors, and do some pre-calculations. */
read_hkl_data(reflections, &hkl_info);
%}
TRACE
%{
double t1, t2; /* Entry and exit times in sample */
struct hkl_data *L; /* Structure factor list */
int i; /* Index into structure factor list */
struct tau_data *T; /* List of reflections close to Ewald sphere */
int j; /* Index into reflection list */
int firstevent; /* True for the first scattering event only */
double kix, kiy, kiz, ki; /* Initial wave vector [1/AA] */
double kfx, kfy, kfz; /* Final wave vector */
double v; /* Neutron velocity */
double tau_max; /* Max tau allowing reflection at this ki */
double rho_x, rho_y, rho_z; /* the vector ki - tau */
double rho;
double diff; /* Deviation from Bragg condition */
double ox, oy, oz; /* Origin of Ewald sphere tangent plane */
double b1x, b1y, b1z; /* First vector spanning tangent plane */
156 Ris{R{1175(EN)

double b2x, b2y, b2z; /* Second vector spanning tangent plane */
double n11, n12, n22; /* 2D Gauss description matrix N */
double det_N; /* Determinant of N */
double inv_n11, inv_n12, inv_n22; /* Inverse of N */
double l11, l12, l22; /* Cholesky decomposition L of 1/2*inv(N) */
double det_L; /* Determinant of L */
double Bt_D_O_x, Bt_D_O_y; /* Temporaries */
double y0x, y0y; /* Center of 2D Gauss in plane coordinates */
double alpha; /* Offset of 2D Gauss center from 3D center */
int tau_count; /* Number of reflections within cutoff */
double V0; /* Volume of unit cell */
double l_full; /* Neutron path length for transmission */
double l; /* Path length to scattering event */
double abs_xsect, abs_xlen; /* Absorbtion cross section and length */
double inc_xsect, inc_xlen; /* Incoherent cross section and length */
double coh_xsect, coh_xlen; /* Coherent cross section and length */
double tot_xsect, tot_xlen; /* Total cross section and length */
double z1, z2, y1, y2; /* Temporaries to choose kf from 2D Gauss */
double adjust, coh_refl; /* Temporaries */
double r, sum; /* Temporaries */
double xsect_factor; /* Common factor in coherent cross-section */
double p_trans; /* Transmission probability */
double mc_trans, mc_interact; /* Transmission, interaction MC choices */
if(box_intersect(&t1, &t2, x, y, z, vx, vy, vz,
xwidth, yheight, zthick) && t2 > 0)
{ /* Neutron intersects crystal */
if(t1 > 0)
PROP_DT(t1); /* Move to crystal surface if not inside */
v = sqrt(vx*vx + vy*vy + vz*vz);
ki = V2K*v;
firstevent = 1;
for(;;) /* Loop over multiple scattering events */
{
/* Compute intersection between neutron flight path and sample. */
if(!box_intersect(&t1, &t2, x, y, z, vx, vy, vz,
xwidth, yheight, zthick) || t2*v < -1e-9 || t1*v > 1e-9)
{
fprintf(stderr,
"Single_crystal: Warning: neutron was outside crystal!\n");
break;
}
l_full = t2*v;
/* (1). Compute incoming wave vector ki */
kix = V2K*vx;
kiy = V2K*vy;
kiz = V2K*vz;
/* (2). Intersection of Ewald sphere with recipprocal lattice points */
L = hkl_info.list;
T = hkl_info.tau_list;
/* Max possible tau with 5*sigma delta-d/d cutoff. */
tau_max = 2*ki/(1 - 5*delta_d_d);
abs_xsect = absorbtion*2200/v;
inc_xsect = incoherent;
Ris{R{1175(EN) 157

coh_xsect = 0;
coh_refl = 0;
V0 = hkl_info.V0;
xsect_factor = pow(2*PI, 5.0/2.0)/(V0*ki*ki);
for(i = j = 0; i < hkl_info.count; i++)
{
/* Assuming reflections are sorted, stop search when max tau exceeded. */
if(L[i].tau > tau_max)
break;
/* Check if this reciprocal lattice point is close enough to the
Ewald sphere to make scattering possible. */
rho_x = kix - L[i].tau_x;
rho_y = kiy - L[i].tau_y;
rho_z = kiz - L[i].tau_z;
rho = sqrt(rho_x*rho_x + rho_y*rho_y + rho_z*rho_z);
diff = fabs(rho - ki);
/* Check if scattering is possible (cutoff of Gaussian tails). */
if(diff <= L[i].cutoff)
{
/* Store reflection. */
T[j].index = i;
/* Get ki vector in local coordinates. */
T[j].kix = kix*L[i].u1x + kiy*L[i].u1y + kiz*L[i].u1z;
T[j].kiy = kix*L[i].u2x + kiy*L[i].u2y + kiz*L[i].u2z;
T[j].kiz = kix*L[i].u3x + kiy*L[i].u3y + kiz*L[i].u3z;
T[j].rho_x = T[j].kix - L[i].tau;
T[j].rho_y = T[j].kiy;
T[j].rho_z = T[j].kiz;
T[j].rho = rho;
/* Compute the tangent plane of the Ewald sphere. */
T[j].nx = T[j].rho_x/T[j].rho;
T[j].ny = T[j].rho_y/T[j].rho;
T[j].nz = T[j].rho_z/T[j].rho;
ox = (ki - T[j].rho)*T[j].nx;
oy = (ki - T[j].rho)*T[j].ny;
oz = (ki - T[j].rho)*T[j].nz;
T[j].ox = ox;
T[j].oy = oy;
T[j].oz = oz;
/* Compute unit vectors b1 and b2 that span the tangent plane. */
normal_vec(&b1x, &b1y, &b1z, T[j].nx, T[j].ny, T[j].nz);
vec_prod(b2x, b2y, b2z, T[j].nx, T[j].ny, T[j].nz, b1x, b1y, b1z);
T[j].b1x = b1x;
T[j].b1y = b1y;
T[j].b1z = b1z;
T[j].b2x = b2x;
T[j].b2y = b2y;
T[j].b2z = b2z;
/* Compute the 2D projection of the 3D Gauss of the reflection. */
/* The symmetric 2x2 matrix N describing the 2D gauss. */
n11 = L[i].m1*b1x*b1x + L[i].m2*b1y*b1y + L[i].m3*b1z*b1z;
n12 = L[i].m1*b1x*b2x + L[i].m2*b1y*b2y + L[i].m3*b1z*b2z;
n22 = L[i].m1*b2x*b2x + L[i].m2*b2y*b2y + L[i].m3*b2z*b2z;
/* The (symmetric) inverse matrix of N. */
det_N = n11*n22 - n12*n12;
inv_n11 = n22/det_N;
158 Ris{R{1175(EN)

inv_n12 = -n12/det_N;
inv_n22 = n11/det_N;
/* The Cholesky decomposition of 1/2*inv_n (lower triangular L). */
l11 = sqrt(inv_n11/2);
l12 = inv_n12/(2*l11);
l22 = sqrt(inv_n22/2 - l12*l12);
T[j].l11 = l11;
T[j].l12 = l12;
T[j].l22 = l22;
det_L = l11*l22;
T[j].det_L = det_L;
/* The product B^T D o. */
Bt_D_O_x = b1x*L[i].m1*ox + b1y*L[i].m2*oy + b1z*L[i].m3*oz;
Bt_D_O_y = b2x*L[i].m1*ox + b2y*L[i].m2*oy + b2z*L[i].m3*oz;
/* Center of 2D Gauss in plane coordinates. */
y0x = -(Bt_D_O_x*inv_n11 + Bt_D_O_y*inv_n12);
y0y = -(Bt_D_O_x*inv_n12 + Bt_D_O_y*inv_n22);
T[j].y0x = y0x;
T[j].y0y = y0y;
/* Factor alpha for the distance of the 2D Gauss from the origin. */
alpha = L[i].m1*ox*ox + L[i].m2*oy*oy + L[i].m3*oz*oz -
(y0x*y0x*n11 + y0y*y0y*n22 + 2*y0x*y0y*n12);
T[j].refl = xsect_factor*det_L*exp(-alpha)/L[i].sig123;
coh_refl += T[j].refl;
T[j].xsect = T[j].refl*L[i].F2;
coh_xsect += T[j].xsect;
j++;
}
}
tau_count = j;
/* (3). Probabilities of the different possible interactions. */
tot_xsect = abs_xsect + inc_xsect + coh_xsect;
/* Cross-sections are in barns = 10**-28 m**2, and unit cell volumes are
in AA**3 = 10**-30 m**2. Hence a factor of 100 is used to convert
scattering lengths to m**-1 */
abs_xlen = 1e2*abs_xsect/V0;
inc_xlen = 1e2*inc_xsect/V0;
coh_xlen = 1e2*coh_xsect/V0;
tot_xlen = 1e2*tot_xsect/V0;
/* (5). Transmission */
p_trans = exp(-tot_xlen*l_full);
if(firstevent && p_transmit >= 0) {
mc_trans = p_transmit;
} else {
mc_trans = p_trans;
}
firstevent = 0;
if(rand01() < mc_trans) /* Transmit */
{
p *= p_trans/mc_trans;
break;
}
if(tot_xlen <= 0)
ABSORB;
Ris{R{1175(EN) 159

mc_interact = 1 - mc_trans;
if(mc_interact <= 0) /* Protect against rounding errors */
break;
p *= fabs(1 - p_trans)/mc_interact;
/* Select a point at which to scatter the neutron, taking
secondary extinction into account. */
/* dP(l) = exp(-tot_xlen*l)dl
P(l<l_0) = [-1/tot_xlen*exp(-tot_xlen*l)]_0^l_0
= (1 - exp(-tot_xlen*l0))/tot_xlen
l = -log(1 - tot_xlen*rand0max(P(l<l_full)))/tot_xlen
*/
if(tot_xlen*l_full < 1e-6)
/* For very weak scattering, use simple uniform sampling of scattering
point to avoid rounding errors. */
l = rand0max(l_full);
else
l = -log(1 - rand0max((1 - exp(-tot_xlen*l_full))))/tot_xlen;
PROP_DT(l/v);
/* (4). Account for the probability of absorbtion */
p *= (coh_xlen + inc_xlen)/tot_xlen;
/* Choose between coherent and incoherent scattering */
if(rand0max(coh_xlen + inc_xlen) <= inc_xlen)
{
/* (6). Incoherent scattering */
randvec_target_sphere(&kix, &kiy, &kiz, NULL, 0, 0, 0, 0);
kix *= ki;
kiy *= ki;
kiz *= ki;
vx = K2V*kix;
vy = K2V*kiy;
vz = K2V*kiz;
continue; /* Go for next scattering event */
}
/* 7. Coherent scattering. Select reciprocal lattice point. */
if(coh_refl <= 0)
ABSORB;
r = rand0max(coh_refl);
sum = 0;
for(j = 0; j < tau_count; j++)
{
sum += T[j].refl;
if(sum > r)
break;
}
if(j >= tau_count)
{
fprintf(stderr, "Single_crystal: Error: Illegal tau search "
"(r = %g, sum = %g).\n", r, sum);
j = tau_count - 1;
}
i = T[j].index;
/* (8). Pick scattered wavevector kf from 2D Gauss distribution. */
z1 = randnorm();
z2 = randnorm();
y1 = T[j].l11*z1 + T[j].y0x;
160 Ris{R{1175(EN)

y2 = T[j].l12*z1 + T[j].l22*z2 + T[j].y0y;
kfx = T[j].rho_x + T[j].ox + T[j].b1x*y1 + T[j].b2x*y2;
kfy = T[j].rho_y + T[j].oy + T[j].b1y*y1 + T[j].b2y*y2;
kfz = T[j].rho_z + T[j].oz + T[j].b1z*y1 + T[j].b2z*y2;
/* Normalize kf to length of ki, to account for planer
approximation of the Ewald sphere. */
adjust = ki/sqrt(kfx*kfx + kfy*kfy + kfz*kfz);
kfx *= adjust;
kfy *= adjust;
kfz *= adjust;
/* Adjust neutron weight (see manual for explanation). */
p *= T[j].xsect*coh_refl/(coh_xsect*T[j].refl);
SCATTER;
vx = K2V*(L[i].u1x*kfx + L[i].u2x*kfy + L[i].u3x*kfz);
vy = K2V*(L[i].u1y*kfx + L[i].u2y*kfy + L[i].u3y*kfz);
vz = K2V*(L[i].u1z*kfx + L[i].u2z*kfy + L[i].u3z*kfz);
/* Repeat loop for next scattering event. */
}
}
%}
MCDISPLAY
%{
double xmin = -0.5*xwidth;
double xmax = 0.5*xwidth;
double ymin = -0.5*yheight;
double ymax = 0.5*yheight;
double zmin = -0.5*zthick;
double zmax = 0.5*zthick;
magnify("xyz");
multiline(5, xmin, ymin, zmin,
xmax, ymin, zmin,
xmax, ymax, zmin,
xmin, ymax, zmin,
xmin, ymin, zmin);
multiline(5, xmin, ymin, zmax,
xmax, ymin, zmax,
xmax, ymax, zmax,
xmin, ymax, zmax,
xmin, ymin, zmax);
line(xmin, ymin, zmin, xmin, ymin, zmax);
line(xmax, ymin, zmin, xmax, ymin, zmax);
line(xmin, ymax, zmin, xmin, ymax, zmax);
line(xmax, ymax, zmin, xmax, ymax, zmax);
%}
END
Ris{R{1175(EN) 161

B.7 Powder-like samples
B.7.2 V sample
/*******************************************************************************
*
* McStas, the neutron ray-tracing package
* Maintained by Kristian Nielsen and Kim Lefmann,
* Copyright 1997-2000 Risoe National Laboratory, Roskilde, Denmark
*
* %I
* Written by: KL, KN
* Date: 15.4.98
* Version: $Revision: 1.2 $
* Origin: McStas release
*
* Vanadium sample.
*
* %D
* A Double-cylinder shaped incoherent scatterer (a V-sample)
* No multiple scattering. Absorbtion included.
*
* %P
* INPUT PARAMETERS:
*
* radius_i : Inner radius of sample in (x,z) plane (m)
* radius_o : Outer radius of sample in (x,z) plane (m)
* h : Height of sample y direction (m)
* pack : Packing factor (1)
* focus_r : Radius of sphere containing target. (m)
* target_x :
* target_y : position of target to focus at (m)
* target_z :
*
* Variables calculated in the component
*
* V_my_s : Attenuation factor due to scattering (m^-1)
* V_my_a : Attenuation factor due to absorbtion (m^-1)
*
* %L
* <A HREF="http://neutron.risoe.dk/mcstas/components/tests/v_sample/">Test
* results</A> (not up-to-date).
*
* %E
*******************************************************************************/
DEFINE COMPONENT V_sample
DEFINITION PARAMETERS ()
SETTING PARAMETERS (radius_i,radius_o,h,pack,focus_r,
target_x, target_y, target_z)
STATE PARAMETERS (x,y,z,vx,vy,vz,t,s1,s2,p)
DECLARE
%{
/* ToDo: Should be component local names. */
#define V_sigma_a 5.08 /* Absorption cross section per atom (barns) */
#define V_sigma_i 4.935 /* Incoherent scattering cross section per atom (barns) */
#define V_rho (2*pack/(3.024*3.024*3.024)) /* Density of atoms (AA-3) */
162 Ris{R{1175(EN)

#define V_my_s (V_rho * 100 * V_sigma_i)
#define V_my_a_v (V_rho * 100 * V_sigma_a * 2200)
%}
INITIALIZE
%{
%}
TRACE
%{
double t0, t3; /* Entry/exit time for outer cylinder */
double t1, t2; /* Entry/exit time for inner cylinder */
double v; /* Neutron velocity */
double dt0, dt1, dt2, dt; /* Flight times through sample */
double l_full; /* Flight path length for non-scattered neutron */
double l_i, l_o; /* Flight path lenght in/out for scattered neutron */
double my_a; /* Velocity-dependent attenuation factor */
double solid_angle; /* Solid angle of target as seen from scattering point */
double aim_x, aim_y, aim_z; /* Position of target relative to scattering point */
if(cylinder_intersect(&t0, &t3, x, y, z, vx, vy, vz, radius_o, h))
{
if(t0 < 0)
ABSORB;
/* Neutron enters at t=t0. */
if(!cylinder_intersect(&t1, &t2, x, y, z, vx, vy, vz, radius_i, h))
t1 = t2 = t3;
dt0 = t1-t0; /* Time in sample, ingoing */
dt1 = t2-t1; /* Time in hole */
dt2 = t3-t2; /* Time in sample, outgoing */
v = sqrt(vx*vx + vy*vy + vz*vz);
l_full = v * (dt0 + dt2); /* Length of full path through sample */
dt = rand01()*(dt0+dt2); /* Time of scattering (relative to t0) */
l_i = v*dt; /* Penetration in sample */
if (dt > dt0)
dt += dt1;
PROP_DT(dt+t0); /* Point of scattering */
aim_x = target_x-x; /* Vector pointing at target (anal./det.) */
aim_y = target_y-y;
aim_z = target_z-z;
randvec_target_sphere(&vx, &vy, &vz, &solid_angle, aim_x, aim_y, aim_z, focus_r);
NORM(vx, vy, vz);
vx *= v;
vy *= v;
vz *= v;
if(!cylinder_intersect(&t0, &t3, x, y, z, vx, vy, vz, radius_o, h))
{
/* ??? did not hit cylinder */
printf("FATAL ERROR: Did not hit cylinder from inside.\n");
exit(1);
}
dt = t3;
if(cylinder_intersect(&t1, &t2, x, y, z, vx, vy, vz, radius_i, h) &&
t2 > 0)
Ris{R{1175(EN) 163

dt -= (t2-t1); /* Subtract hollow part */
l_o = v*dt;
my_a = V_my_a_v/v;
p *= l_full*V_my_s*exp(-(my_a+V_my_s)*(l_i+l_o));
p /= 4*PI/solid_angle;
}
else
ABSORB;
%}
MCDISPLAY
%{
magnify("xyz");
circle("xz", 0, h/2.0, 0, radius_i);
circle("xz", 0, h/2.0, 0, radius_o);
circle("xz", 0, -h/2.0, 0, radius_i);
circle("xz", 0, -h/2.0, 0, radius_o);
line(-radius_i, -h/2.0, 0, -radius_i, +h/2.0, 0);
line(+radius_i, -h/2.0, 0, +radius_i, +h/2.0, 0);
line(0, -h/2.0, -radius_i, 0, +h/2.0, -radius_i);
line(0, -h/2.0, +radius_i, 0, +h/2.0, +radius_i);
line(-radius_o, -h/2.0, 0, -radius_o, +h/2.0, 0);
line(+radius_o, -h/2.0, 0, +radius_o, +h/2.0, 0);
line(0, -h/2.0, -radius_o, 0, +h/2.0, -radius_o);
line(0, -h/2.0, +radius_o, 0, +h/2.0, +radius_o);
%}
END
164 Ris{R{1175(EN)

B.7.3 Powder1
/*******************************************************************************
*
* McStas, the neutron ray-tracing package
* Maintained by Kristian Nielsen and Kim Lefmann,
* Copyright 1997-2000 Risoe National Laboratory, Roskilde, Denmark
*
* %I
* Written by: E.M.Lauridsen, N.B.Christensen, A.B.Abrahamsen
* Date: 4.2.98
* Version: $Revision: 1.2 $
* Origin: McStas release
* Modified by: KL, KN 20.3.98 (rewrite)
*
* General powder sample with a single scattering vector.
*
* %P
*
* INPUT PARAMETERS
*
* d_phi0 : Focussing angle corresponding to the vertical dimensions
* of the detector placed at the right distance (deg)
* radius : Radius of sample in (x,z) plane (m)
* h : Height of sample y direction (m)
* pack : Packing factor (1)
* Vc : Volume of unit cell (AA^3)
* sigma_a : Absorption cross section per unit cell at 2200 m/s (fm^2)
*
* q : Scattering vector of reflection (AA^-1)
* j : Multiplicity of reflection (1)
* F2 : Structure factor of reflection (fm^2)
* DW : Debye-Waller factor of reflection (1)
* target_x :
* target_y : position of target to focus at (m)
* target_z :
*
* Variables calculated in the component
*
* my_s : Attenuation factor due to scattering (m^-1)
* my_a : Attenuation factor due to absorbtion (m^-1)
*
* %L
* <A HREF="http://neutron.risoe.dk/mcstas/components/Powder1/">Old
* description</A>, with explanation of focusing.
* %L
* <A HREF="http://neutron.risoe.dk/mcstas/components/tests/powder/">
* Test results</A> (not up-to-date).
*
* %E
*******************************************************************************/
DEFINE COMPONENT Powder1
DEFINITION PARAMETERS ()
SETTING PARAMETERS (d_phi0, radius, h, pack, Vc, sigma_a, j, q, F2, DW,
target_x, target_y, target_z)
OUTPUT PARAMETERS (my_s_v2, my_a_v, q_v)
Ris{R{1175(EN) 165

STATE PARAMETERS (x,y,z,vx,vy,vz,t,s1,s2,p)
DECLARE
%{
double my_s_v2, my_a_v, q_v;
%}
INITIALIZE
%{
my_a_v = sigma_a/Vc*2200; /* Is not yet divided by v */
my_s_v2 = PI*PI*PI*pack*j*F2*DW/(Vc*Vc*V2K*V2K*q);
/* Is not yet divided by v^2 */
q_v = q*K2V;
%}
TRACE
%{
double t0, t1, v, l_full, l, l_1, dt, d_phi, theta, my_s;
double aim_x, aim_y, aim_z, axis_x, axis_y, axis_z;
double arg, tmp_vx, tmp_vy, tmp_vz, vout_x, vout_y, vout_z;
if(cylinder_intersect(&t0, &t1, x, y, z, vx, vy, vz, radius, h))
{
if(t0 < 0)
ABSORB;
/* Neutron enters at t=t0. */
v = sqrt(vx*vx + vy*vy + vz*vz);
l_full = v * (t1 - t0); /* Length of full path through sample */
dt = rand01()*(t1 - t0) + t0; /* Time of scattering */
PROP_DT(dt); /* Point of scattering */
l = v*dt; /* Penetration in sample */
/* Choose point on Debye-Scherrer cone */
d_phi = d_phi0*DEG2RAD/2.0*randpm1();
p *= d_phi0/360.0;
arg = q_v/(2.0*v);
if(arg > 1)
ABSORB; /* No bragg scattering possible*/
theta = asin(arg); /* Bragg scattering law */
aim_x = target_x-x; /* Vector pointing at target (anal./det.) */
aim_y = target_y-y;
aim_z = target_z-z;
vec_prod(axis_x, axis_y, axis_z, vx, vy, vz, aim_x, aim_y, aim_z);
rotate(tmp_vx, tmp_vy, tmp_vz, vx, vy, vz, 2*theta, axis_x, axis_y, axis_z);
rotate(vout_x, vout_y, vout_z, tmp_vx, tmp_vy, tmp_vz, d_phi, vx, vy, vz);
vx = vout_x;
vy = vout_y;
vz = vout_z;
if(!cylinder_intersect(&t0, &t1, x, y, z,
vout_x, vout_y, vout_z, radius, h))
{
/* Strange error: did not hit cylinder */
printf("FATAL ERROR: Did not hit cylinder from inside.\n");
exit(1);
}
l_1 = v*t1;
166 Ris{R{1175(EN)

my_s = my_s_v2/(v*v);
p *= l_full*my_s*exp(-(my_a_v/v+my_s)*(l+l_1));
}
else
ABSORB;
%}
MCDISPLAY
%{
magnify("xyz");
circle("xz", 0, h/2.0, 0, radius);
circle("xz", 0, -h/2.0, 0, radius);
line(-radius, -h/2.0, 0, -radius, +h/2.0, 0);
line(+radius, -h/2.0, 0, +radius, +h/2.0, 0);
line(0, -h/2.0, -radius, 0, +h/2.0, -radius);
line(0, -h/2.0, +radius, 0, +h/2.0, +radius);
%}
END
Ris{R{1175(EN) 167

B.8 Inelastic samples
B.8.1 Res sample
/*******************************************************************************
*
* McStas, the neutron ray-tracing package
* Maintained by Kristian Nielsen and Kim Lefmann,
* Copyright 1977-2000 Risoe National Laboratory, Roskilde, Denmark
*
* %I
* Written by: KN
* Date: 1999
* Version: $Revision: 1.2 $
* Origin: McStas release
*
* Sample for resolution function calculation.
*
* %D
* An inelastic sample with completely uniform scattering in both Q and
* energy. This sample is used together with the Res_monitor component and
* (optionally) the mcresplot front-end to compute the resolution function of
* triple-axis or inverse-geometry time-of-flight instruments.
*
* The shape of the sample is either a hollow cylinder or a rectangular box. The
* hollow cylinder shape is specified with an inner and outer radius. If the
* outher radius is negative, the shape is instead a box.
*
* The scattered neutrons will have directions towards a given sphere and
* energies betweed E0-dE and E0+dE.
*
* %P
* INPUT PARAMETERS:
*
* radius_i : Inner radius of hollow cylinder in (x,z) plane, or width of
* box along X (m)
* radius_o : Outer radius of hollow cylinder, or negative box depth along Z (m)
* h : Height of box or cylinder along Y (m)
* focus_r : Radius of sphere containing target. (m)
* target_x :
* target_y : position of target to focus at (m)
* target_z :
* E0 : Center of scattered energy range [meV]
* dE : half width of scattered energy range [meV]
*
* %E
*******************************************************************************/
DEFINE COMPONENT Res_sample
DEFINITION PARAMETERS ()
SETTING PARAMETERS (radius_i,radius_o,h,focus_r,E0,dE,
target_x, target_y, target_z)
OUTPUT PARAMETERS (res_struct)
STATE PARAMETERS (x,y,z,vx,vy,vz,t,s1,s2,p)
DECLARE
%{
struct Res_sample_struct
168 Ris{R{1175(EN)

{
double ki_x,ki_y,ki_z,kf_x,kf_y,kf_z;
double rx,ry,rz,pi;
} res_struct;
%}
INITIALIZE
%{
%}
TRACE
%{
double t0, t3; /* Entry/exit time for outer cylinder */
double t1, t2; /* Entry/exit time for inner cylinder */
double v; /* Neutron velocity */
double E;
double l_full; /* Flight path length for non-scattered neutron */
double dt0, dt1, dt2, dt; /* Flight times through sample */
double solid_angle; /* Solid angle of target as seen from scattering point */
double aim_x, aim_y, aim_z; /* Position of target relative to scattering point */
double scat_factor; /* Simple cross-section model */
if(radius_o < 0.0)
{ /* Flat sample */
PROP_Z0;
if(x <= -0.5*radius_i || x >= 0.5*radius_i ||
y <= -0.5*h || y >= 0.5*h)
ABSORB;
t0 = 0;
t1 = t2 = t3 = (-radius_o)/vz;
scat_factor = -2*radius_o;
}
else
{ /* Hollow cylinder sample */
if(!cylinder_intersect(&t0, &t3, x, y, z, vx, vy, vz, radius_o, h))
ABSORB;
if(t0 < 0)
ABSORB;
/* Neutron enters at t=t0. */
if(!cylinder_intersect(&t1, &t2, x, y, z, vx, vy, vz, radius_i, h))
t1 = t2 = t3;
scat_factor = 2*radius_o;
}
dt0 = t1-t0; /* Time in sample, ingoing */
dt1 = t2-t1; /* Time in hole */
dt2 = t3-t2; /* Time in sample, outgoing */
v = sqrt(vx*vx + vy*vy + vz*vz);
l_full = v * (dt0 + dt2); /* Length of full path through sample */
p *= l_full/scat_factor; /* Scattering probability */
dt = rand01()*(dt0+dt2); /* Time of scattering (relative to t0) */
if (dt > dt0)
dt += dt1;
PROP_DT(dt+t0); /* Point of scattering */
/* Store initial neutron state. */
if(p == 0) ABSORB;
res_struct.pi = p;
Ris{R{1175(EN) 169

res_struct.ki_x = V2K*vx;
res_struct.ki_y = V2K*vy;
res_struct.ki_z = V2K*vz;
res_struct.rx = x;
res_struct.ry = y;
res_struct.rz = z;
aim_x = target_x-x; /* Vector pointing at target (anal./det.) */
aim_y = target_y-y;
aim_z = target_z-z;
randvec_target_sphere(&vx, &vy, &vz, &solid_angle, aim_x, aim_y, aim_z, focus_r);
NORM(vx, vy, vz);
E=E0+dE*randpm1();
v=sqrt(E)*SE2V;
vx *= v;
vy *= v;
vz *= v;
/* Store final neutron state. */
res_struct.kf_x = V2K*vx;
res_struct.kf_y = V2K*vy;
res_struct.kf_z = V2K*vz;
%}
MCDISPLAY
%{
magnify("xyz");
if(radius_o < 0.0)
{ /* Flat sample. */
double xmin = -0.5*radius_i;
double xmax = 0.5*radius_i;
double ymin = -0.5*h;
double ymax = 0.5*h;
double len = -radius_o;
multiline(5, xmin, ymin, 0.0,
xmax, ymin, 0.0,
xmax, ymax, 0.0,
xmin, ymax, 0.0,
xmin, ymin, 0.0);
multiline(5, xmin, ymin, len,
xmax, ymin, len,
xmax, ymax, len,
xmin, ymax, len,
xmin, ymin, len);
line(xmin, ymin, 0.0, xmin, ymin, len);
line(xmax, ymin, 0.0, xmax, ymin, len);
line(xmin, ymax, 0.0, xmin, ymax, len);
line(xmax, ymax, 0.0, xmax, ymax, len);
}
else
{
circle("xz", 0, h/2.0, 0, radius_i);
circle("xz", 0, h/2.0, 0, radius_o);
circle("xz", 0, -h/2.0, 0, radius_i);
circle("xz", 0, -h/2.0, 0, radius_o);
line(-radius_i, -h/2.0, 0, -radius_i, +h/2.0, 0);
170 Ris{R{1175(EN)

line(+radius_i, -h/2.0, 0, +radius_i, +h/2.0, 0);
line(0, -h/2.0, -radius_i, 0, +h/2.0, -radius_i);
line(0, -h/2.0, +radius_i, 0, +h/2.0, +radius_i);
line(-radius_o, -h/2.0, 0, -radius_o, +h/2.0, 0);
line(+radius_o, -h/2.0, 0, +radius_o, +h/2.0, 0);
line(0, -h/2.0, -radius_o, 0, +h/2.0, -radius_o);
line(0, -h/2.0, +radius_o, 0, +h/2.0, +radius_o);
}
%}
END
Ris{R{1175(EN) 171

Appendix C
McStas instrument denitions
In this appendix is listed the source code for the instrument denitions presented in sec-
tion 6.
C.1 Code for the instrument vanadium example.instr
DEFINE INSTRUMENT test_v_sample(ROT)
DECLARE
%{
double coll_div = 60;
%}
TRACE
COMPONENT arm = Arm() AT (0,0,0) ABSOLUTE
COMPONENT source = Source_flat(radius = 0.015, dist = 1,
xw=0.024, yh=0.015, E0=5, dE=0.2)
AT (0,0,0) RELATIVE arm
COMPONENT collimator = Soller(len = 0.2, divergence = coll_div,
xmin = -0.02, xmax = 0.02, ymin = -0.03, ymax = 0.03)
AT (0, 0, 0.4) RELATIVE arm
COMPONENT target = V_sample(radius_i = 0.008, radius_o = 0.012,
h = 0.015, focus_r = 0, pack = 1,
target_x = 0, target_y = 0, target_z = 1)
AT (0,0,1) RELATIVE arm
COMPONENT PSD_4pi = PSD_monitor_4PI(radius=1e6, nx=101, ny=51,
filename="vanadium.psd")
AT (0,0,0) RELATIVE target ROTATED (ROT,0,0) RELATIVE arm
END
172 Ris{R{1175(EN)

C.2 Code for the instrument linup-7.instr
DEFINE INSTRUMENT TAS1(PHM,TTM,TT,OMA,TTA,C1,OMC1,C2,C3)
DECLARE
%{
/* Mosaicity used on monochromator and analysator */
double tas1_mono_mosaic = 45; /* Measurements indicate its really 45' */
double tas1_ana_mosaic = 45; /* Measurements indicate its really 45' */
/* Q vector for bragg scattering with monochromator and analysator */
double tas1_mono_q = 2*1.87325; /* Fake 2nd order scattering for 20meV */
double tas1_mono_r0 = 0.6;
double tas1_ana_q = 1.87325; /* 20meV */
double tas1_ana_r0 = 0.6;
double OMC1_d;
double alu_focus_x;
double mpos0, mpos1, mpos2, mpos3, mpos4, mpos5, mpos6, mpos7;
double mrot0, mrot1, mrot2, mrot3, mrot4, mrot5, mrot6, mrot7;
%}
INITIALIZE
%{
double d = 0.0125; /* 12.5 mm between slab centers. */
double phi = 0.5443; /* Rotation between adjacent slabs. */
mpos0 = -3.5*d; mrot0 = -3.5*phi;
mpos1 = -2.5*d; mrot1 = -2.5*phi;
mpos2 = -1.5*d; mrot2 = -1.5*phi;
mpos3 = -0.5*d; mrot3 = -0.5*phi;
mpos4 = 0.5*d; mrot4 = 0.5*phi;
mpos5 = 1.5*d; mrot5 = 1.5*phi;
mpos6 = 2.5*d; mrot6 = 2.5*phi;
mpos7 = 3.5*d; mrot7 = 3.5*phi;
OMC1_d = OMC1/60.0;
alu_focus_x = TT >= 0 ? 1000 : -1000;
%}
TRACE
COMPONENT a1 = Arm()
AT (0,0,0) ABSOLUTE
COMPONENT source = Source_flat(
radius = 0.060,
dist = 3.288,
xw = 0.042, yh = 0.082,
E0 = 20,/* 20 meV */
dE = 0.82) /* Sufficient for TAS1 geometry */
AT (0,0,0) RELATIVE a1 ROTATED (0,0,0) RELATIVE a1
COMPONENT slit1 = Slit(
xmin=-0.020, xmax=0.065,
ymin = -0.075, ymax = 0.075)
AT (0, 0, 1.1215) RELATIVE a1 ROTATED (0,0,0) RELATIVE a1
Ris{R{1175(EN) 173

COMPONENT slit2 = Slit(
xmin = -0.020, xmax = 0.020,
ymin = -0.040, ymax = 0.040)
AT (0,0,1.900) RELATIVE a1 ROTATED (0,0,0) RELATIVE a1
COMPONENT slit3 = Slit(
xmin = -0.021, xmax = 0.021,
ymin = -0.041, ymax = 0.041)
AT (0,0,3.288) RELATIVE a1 ROTATED (0,0,0) RELATIVE a1
COMPONENT focus_mono = Arm()
AT (0, 0, 3.56) RELATIVE a1 ROTATED (0, PHM, 0) RELATIVE a1
COMPONENT m0 = Monochromator(
zmin=-0.0375,zmax=0.0375,ymin=-0.006,ymax=0.006,
mosaich=tas1_mono_mosaic,mosaicv=tas1_mono_mosaic,
r0=tas1_mono_r0, Q=tas1_mono_q)
AT (0, mpos0, 0) RELATIVE focus_mono
ROTATED (0, 0, mrot0) RELATIVE focus_mono
COMPONENT m1 = Monochromator(
zmin=-0.0375,zmax=0.0375,ymin=-0.006,ymax=0.006,
mosaich=tas1_mono_mosaic,mosaicv=tas1_mono_mosaic,
r0=tas1_mono_r0, Q=tas1_mono_q)
AT (0, mpos1, 0) RELATIVE focus_mono
ROTATED (0, 0, mrot1) RELATIVE focus_mono
COMPONENT m2 = Monochromator(
zmin=-0.0375,zmax=0.0375,ymin=-0.006,ymax=0.006,
mosaich=tas1_mono_mosaic,mosaicv=tas1_mono_mosaic,
r0=tas1_mono_r0, Q=tas1_mono_q)
AT (0, mpos2, 0) RELATIVE focus_mono
ROTATED (0, 0, mrot2) RELATIVE focus_mono
COMPONENT m3 = Monochromator(
zmin=-0.0375,zmax=0.0375,ymin=-0.006,ymax=0.006,
mosaich=tas1_mono_mosaic,mosaicv=tas1_mono_mosaic,
r0=tas1_mono_r0, Q=tas1_mono_q)
AT (0, mpos3, 0) RELATIVE focus_mono
ROTATED (0, 0, mrot3) RELATIVE focus_mono
COMPONENT m4 = Monochromator(
zmin=-0.0375,zmax=0.0375,ymin=-0.006,ymax=0.006,
mosaich=tas1_mono_mosaic,mosaicv=tas1_mono_mosaic,
r0=tas1_mono_r0, Q=tas1_mono_q)
AT (0, mpos4, 0) RELATIVE focus_mono
ROTATED (0, 0, mrot4) RELATIVE focus_mono
COMPONENT m5 = Monochromator(
zmin=-0.0375,zmax=0.0375,ymin=-0.006,ymax=0.006,
mosaich=tas1_mono_mosaic,mosaicv=tas1_mono_mosaic,
r0=tas1_mono_r0, Q=tas1_mono_q)
AT (0, mpos5, 0) RELATIVE focus_mono
ROTATED (0, 0, mrot5) RELATIVE focus_mono
174 Ris{R{1175(EN)

COMPONENT m6 = Monochromator(
zmin=-0.0375,zmax=0.0375,ymin=-0.006,ymax=0.006,
mosaich=tas1_mono_mosaic,mosaicv=tas1_mono_mosaic,
r0=tas1_mono_r0, Q=tas1_mono_q)
AT (0, mpos6, 0) RELATIVE focus_mono
ROTATED (0, 0, mrot6) RELATIVE focus_mono
COMPONENT m7 = Monochromator(
zmin=-0.0375,zmax=0.0375,ymin=-0.006,ymax=0.006,
mosaich=tas1_mono_mosaic,mosaicv=tas1_mono_mosaic,
r0=tas1_mono_r0, Q=tas1_mono_q)
AT (0, mpos7, 0) RELATIVE focus_mono
ROTATED (0, 0, mrot7) RELATIVE focus_mono
COMPONENT a2 = Arm()
AT (0,0,0) RELATIVE focus_mono ROTATED (0, TTM, 0) RELATIVE a1
COMPONENT slitMS1 = Slit(
xmin = -0.0105, xmax = 0.0105, ymin = -0.035, ymax = 0.035)
AT (0,0,0.565) RELATIVE a2 ROTATED (0,0,0) RELATIVE a2
COMPONENT slitMS2 = Slit(
xmin = -0.0105, xmax = 0.0105, ymin = -0.035, ymax = 0.035)
AT (0,0,0.855) RELATIVE a2 ROTATED (0,0,0) RELATIVE a2
COMPONENT c1 = Soller(
xmin = -0.02, xmax = 0.02, ymin = -0.0375, ymax = 0.0375,
len = 0.250, divergence = C1)
AT (0, 0, 0.87) RELATIVE a2 ROTATED (0,OMC1_d,0) RELATIVE a2
COMPONENT slitMS3 = Circular_slit(radius = 0.025)
AT (0,0,1.130) RELATIVE a2 ROTATED (0,0,0) RELATIVE a2
COMPONENT slitMS4 = Circular_slit(radius = 0.025)
AT (0,0,1.180) RELATIVE a2 ROTATED (0,0,0) RELATIVE a2
COMPONENT slitMS5 = Circular_slit(radius = 0.0275)
AT (0,0,1.230) RELATIVE a2 ROTATED (0,0,0) RELATIVE a2
COMPONENT mon = Monitor(
xmin = -0.025, xmax = 0.025, ymin = -0.0375, ymax = 0.0375)
AT (0, 0, 1.280) RELATIVE a2 ROTATED (0,0,0) RELATIVE a2
COMPONENT emon1 = E_monitor(
xmin = -0.01, xmax = 0.01, ymin = -0.1, ymax = 0.1,
Emin = 19.25, Emax = 20.75, nchan = 35,
filename = "linup_7_1.vmon")
AT(0, 0, 1.5) RELATIVE a2 ROTATED (0,0,0) RELATIVE a2
COMPONENT sample = Powder1(
radius = 0.007,
h = 0.015,
q = 1.8049,
d_phi0 = 4,
pack = 1, j = 6, DW = 1,
F2 = 56.8,
Ris{R{1175(EN) 175

Vc = 85.0054, sigma_a = 0.463,
target_x = alu_focus_x, /* ToDo: GET_X(ana) */
target_y = 0, target_z = 1000)
AT (0, 0, 1.565) RELATIVE a2 ROTATED (0,0,0) RELATIVE a2
COMPONENT a3 = Arm()
AT (0,0,0) RELATIVE sample ROTATED (0, TT, 0) RELATIVE a2
COMPONENT c2 = Soller(
xmin = -0.02, xmax = 0.02, ymin = -0.0315, ymax = 0.0315,
len = 0.300, divergence = C2)
AT (0, 0, 0.370) RELATIVE a3 ROTATED (0,0,0) RELATIVE a3
COMPONENT ana = Monochromator(
zmin = -0.0375, zmax = 0.0375,
ymin = -0.024, ymax = 0.024,
mosaich = tas1_ana_mosaic, mosaicv = tas1_ana_mosaic,
r0 = tas1_ana_r0, Q = tas1_ana_q)
AT (0, 0, 0.770) RELATIVE a3 ROTATED (0, OMA, 0) RELATIVE a3
COMPONENT a4 = Arm()
AT (0, 0, 0) RELATIVE ana ROTATED (0, TTA, 0) RELATIVE a3
COMPONENT c3 = Soller(
xmin = -0.02, xmax = 0.02, ymin = -0.05, ymax = 0.05,
len = 0.270, divergence = C3)
AT (0,0,0.104) RELATIVE a4 ROTATED (0,0,0) RELATIVE a4
COMPONENT sng = Monitor(
xmin = -0.01, xmax = 0.01, ymin = -0.045, ymax = 0.045)
AT(0, 0, 0.43) RELATIVE a4 ROTATED (0,0,0) RELATIVE a4
COMPONENT emon2 = E_monitor(
xmin = -0.0125, xmax = 0.0125, ymin = -0.05, ymax = 0.05,
Emin = 19.25, Emax = 20.75, nchan = 35,
filename = "linup_7_2.vmon")
AT(0, 0, 0.430001) RELATIVE a4 ROTATED (0,0,0) RELATIVE a4
END
176 Ris{R{1175(EN)

C.3 Code for the instrument prisma2
/*******************************************************************************
* Simple simulation of PRISMA2 with RITA-style analyser backend.
*
* Written by Kristian Nielsen and Mark Hagen August 1998.
*
* Demonstrates how the standard components from the component library
* may be easily modified for special purposes; in this case to have
* the individual analyser blades paint a "color" on the neutrons to
* differentiate them in the detector.
*
* Output is in the file "prisma2.tof". The format is ASCII; each
* line consists of the time-of-flight in microseconds followed by seven
* intensities of neutrons from each individual analyser blade.
*
* Examples:
*
* prisma2 --ncount=2e6 TT=-30 PHA=22 PHA1=-3 PHA2=-2 PHA3=-1 PHA4=0 PHA5=1 PHA6=2 PHA7=3 TTA=44
* prisma2 --ncount=2e6 TT=-30 PHA=22 PHA1=3 PHA2=2 PHA3=1 PHA4=0 PHA5=-1 PHA6=-2 PHA7=-3 TTA=44
*******************************************************************************/
/* Modified from Monochromator.comp to paint a "color" on the neutron
if it is scattered. */
DEFINE COMPONENT Monochromator_color
DEFINITION PARAMETERS (zmin, zmax, ymin, ymax, mosaich, mosaicv, r0, Q, color)
SETTING PARAMETERS ()
STATE PARAMETERS (x,y,z,vx,vy,vz,t,s1,s2,p)
DECLARE
%{
#define DIV_CUTOFF 2 /* ~ 10^-5 cutoff. */
%}
TRACE
%{
double dphi,tmp1,tmp2,tmp3,vratio,phi,theta0,theta,v,cs,sn;
double old_x = x, old_y = y, old_z = z, old_t = t;
double dt;
if(vx != 0.0 && (dt = -x/vx) >= 0.0)
{
y += vy*dt; z += vz*dt; t += dt; x = 0.0;
if (z>zmin && z<zmax && y>ymin && y<ymax)
{
/* First: scattering in plane */
theta0 = atan2(vx,vz); /* neutron angle to slab */
v = sqrt(vx*vx+vy*vy+vz*vz);
theta = asin(Q2V*Q/(2.0*v)); /* Bragg's law */
if(theta0 < 0)
theta = -theta;
tmp3 = (theta-theta0)/(MIN2RAD*mosaich);
if(tmp3 > DIV_CUTOFF)
{
x = old_x; y = old_y; z = old_z; t = old_t;
Ris{R{1175(EN) 177

}
else
{
p *= r0*exp(-tmp3*tmp3*4*log(2)); /* Use mosaics */
tmp1 = 2*theta;
cs = cos(tmp1);
sn = sin(tmp1);
tmp2 = cs*vx - sn*vz;
vy = vy;
vz = cs*vz + sn*vx;
vx = tmp2;
/* Second: scatering out of plane.
Approximation is that Debye-Scherrer cone is a plane */
phi = atan2(vy,vz); /* out-of plane angle */
dphi = (MIN2RAD*mosaicv)/(2*sqrt(2*log(2)))*randnorm(); /* MC choice: */
/* Vertical angle of the crystallite */
vy = vz*tan(phi+2*dphi*sin(theta));
vratio = v/sqrt(vx*vx+vy*vy+vz*vz);
vz = vz*vratio;
vy = vy*vratio; /* Renormalize v */
vx = vx*vratio;
neu_color = color;
}
}
else
{
x = old_x; y = old_y; z = old_z; t = old_t;
}
}
%}
MCDISPLAY
%{
magnify("zy");
multiline(5, 0.0, (double)ymin, (double)zmin,
0.0, (double)ymax, (double)zmin,
0.0, (double)ymax, (double)zmax,
0.0, (double)ymin, (double)zmax,
0.0, (double)ymin, (double)zmin);
%}
END
/* Modified from TOF_monitor.comp to bin neutrons according to their
"color". */
DEFINE COMPONENT TOF_monitor_color
DEFINITION PARAMETERS (xmin, xmax, ymin, ymax, nchan, dt, filename, maxcolor)
SETTING PARAMETERS ()
OUTPUT PARAMETERS (TOF_N, TOF_p, TOF_p2)
STATE PARAMETERS (x,y,z,vx,vy,vz,t,s1,s2,p)
DECLARE
%{
int TOF_N[maxcolor+1][nchan];
double TOF_p[maxcolor+1][nchan];
double TOF_p2[maxcolor+1][nchan];
178 Ris{R{1175(EN)

%}
INITIALIZE
%{
int i,c;
for (i=0; i<nchan; i++)
for (c=0; c<=maxcolor; c++)
{
TOF_N[c][i] = 0;
TOF_p[c][i] = 0;
TOF_p2[c][i] = 0;
}
%}
TRACE
%{
int i;
PROP_Z0;
if (x>xmin && x<xmax && y>ymin && y<ymax)
{
i = floor(1E6*t/dt); /* Bin number */
if(i >= nchan) i = nchan;
if(i < 0)
{
printf("FATAL ERROR: negative time-of-flight.\n");
exit(1);
}
if(neu_color < 0 || neu_color > maxcolor)
{
printf("FATAL ERROR: wrong color neutron.\n");
exit(1);
}
TOF_N[neu_color][i]++;
TOF_p[neu_color][i] += p;
TOF_p2[neu_color][i] += p*p;
}
%}
FINALLY
%{
DETECTOR_OUT_2D(
"Time-of-flight monitor",
"Neutron \"color\"",
"Time-of-flight [us]",
0, maxcolor+1, 0, nchan*10,
maxcolor+1, nchan,
&TOF_N[0][0],&TOF_p[0][0],&TOF_p2[0][0],
filename);
%}
MCDISPLAY
%{
magnify("xy");
multiline(5, (double)xmin, (double)ymin, 0.0,
(double)xmax, (double)ymin, 0.0,
(double)xmax, (double)ymax, 0.0,
(double)xmin, (double)ymax, 0.0,
Ris{R{1175(EN) 179

(double)xmin, (double)ymin, 0.0);
%}
END
DEFINE INSTRUMENT
prisma2(TT,PHA,PHA1,PHA2,PHA3,PHA4,PHA5,PHA6,PHA7,TTA)
DECLARE
%{
int neu_color; /* "Color" of current neutron */
/* 30' mosaicity used on analysator */
double prisma_ana_mosaic = 30;
/* Q vector for bragg scattering with monochromator and analysator */
double prisma_ana_q = 1.87325;
double prisma_ana_r0 = 0.6;
double focus_x,focus_z;
double apos1, apos2, apos3, apos4, apos5, apos6, apos7;
%}
INITIALIZE
%{
focus_x = 0.52 * sin(TT*DEG2RAD);
focus_z = 0.52 * cos(TT*DEG2RAD);
/* Rita-style analyser. */
{
double l = 0.0125;
apos1 = -3*l;
apos2 = -2*l;
apos3 = -1*l;
apos4 = 0*l;
apos5 = 1*l;
apos6 = 2*l;
apos7 = 3*l;
}
%}
TRACE
COMPONENT mod = Moderator(
radius = 0.0707,
dist = 9.035,
xw = 0.021,
yh = 0.021,
E0 = 10, E1 = 15,
Ec = 9.0, t0 = 37.15, gam = 39.1)
AT (0,0,0) ABSOLUTE
/* Use a slit to get the effect of a rectangular source. */
COMPONENT modslit = Slit(xmin = -0.05, xmax = 0.05,
ymin = -0.05, ymax = 0.05)
AT(0,0,0.000001) RELATIVE mod
COMPONENT tof_test = TOF_monitor(xmin = -0.05, xmax = 0.05,
180 Ris{R{1175(EN)

ymin = -0.05, ymax = 0.05,
nchan = 500, dt = 1,
filename = "prisma2.mon")
AT (0,0,0.005) RELATIVE mod
COMPONENT mon1 = Monitor(xmin = -0.1, xmax = 0.1, ymin = -0.1, ymax = 0.1)
AT(0,0,0.01) RELATIVE mod ROTATED (0,0,0) RELATIVE mod
COMPONENT slit1 = Slit(xmin = -0.05, xmax = 0.05,
ymin = -0.05, ymax = 0.05)
AT(0,0,1.7) RELATIVE mod
COMPONENT slit2 = Slit(xmin = -0.02, xmax = 0.02,
ymin = -0.03, ymax = 0.03)
AT(0,0,7) RELATIVE slit1
COMPONENT mon2 = Monitor(xmin = -0.1, xmax = 0.1, ymin = -0.1, ymax = 0.1)
AT(0,0,9) RELATIVE mod
COMPONENT sample = V_sample(
radius_i = 0.00001, radius_o = 0.01,
h = 0.02,
focus_r = 0.03,
pack = 1,
target_x = focus_x, target_y = 0, target_z = focus_z)
AT (0, 0, 9.035) RELATIVE mod
COMPONENT a2 = Arm() AT (0,0,0) RELATIVE sample ROTATED (0,TT,0) RELATIVE sample
COMPONENT mon3 = Monitor(xmin = -0.1, xmax = 0.1, ymin = -0.1, ymax = 0.1)
AT(0,0,0.39) RELATIVE a2
COMPONENT coll2 = Soller(xmin = -0.015, xmax = 0.015,
ymin = -0.025, ymax = 0.025,
len = 0.12, divergence = 120)
AT(0,0,0.40) RELATIVE a2
COMPONENT mon4 = Monitor(xmin = -0.1, xmax = 0.1, ymin = -0.1, ymax = 0.1)
AT(0,0,0.521) RELATIVE a2
COMPONENT rita_ana = Arm()
AT(0, 0, 0.58) relative a2 ROTATED (0, PHA, 0) RELATIVE a2
COMPONENT ana1 = Monochromator_color(
ymin=-0.0375,ymax=0.0375,zmin=-0.006,zmax=0.006,
mosaich=prisma_ana_mosaic,mosaicv=prisma_ana_mosaic,
r0=prisma_ana_r0, Q=prisma_ana_q, color = 0)
AT (0, 0, apos1) RELATIVE rita_ana
ROTATED (0, PHA1, 0) RELATIVE rita_ana
COMPONENT ana2 = Monochromator_color(
ymin=-0.0375,ymax=0.0375,zmin=-0.006,zmax=0.006,
mosaich=prisma_ana_mosaic,mosaicv=prisma_ana_mosaic,
r0=prisma_ana_r0, Q=prisma_ana_q, color = 1)
AT (0, 0, apos2) RELATIVE rita_ana
ROTATED (0, PHA2, 0) RELATIVE rita_ana
Ris{R{1175(EN) 181

COMPONENT ana3 = Monochromator_color(
ymin=-0.0375,ymax=0.0375,zmin=-0.006,zmax=0.006,
mosaich=prisma_ana_mosaic,mosaicv=prisma_ana_mosaic,
r0=prisma_ana_r0, Q=prisma_ana_q, color = 2)
AT (0, 0, apos3) RELATIVE rita_ana
ROTATED (0, PHA3, 0) RELATIVE rita_ana
COMPONENT ana4 = Monochromator_color(
ymin=-0.0375,ymax=0.0375,zmin=-0.006,zmax=0.006,
mosaich=prisma_ana_mosaic,mosaicv=prisma_ana_mosaic,
r0=prisma_ana_r0, Q=prisma_ana_q, color = 3)
AT (0, 0, apos4) RELATIVE rita_ana
ROTATED (0, PHA4, 0) RELATIVE rita_ana
COMPONENT ana5 = Monochromator_color(
ymin=-0.0375,ymax=0.0375,zmin=-0.006,zmax=0.006,
mosaich=prisma_ana_mosaic,mosaicv=prisma_ana_mosaic,
r0=prisma_ana_r0, Q=prisma_ana_q, color = 4)
AT (0, 0, apos5) RELATIVE rita_ana
ROTATED (0, PHA5, 0) RELATIVE rita_ana
COMPONENT ana6 = Monochromator_color(
ymin=-0.0375,ymax=0.0375,zmin=-0.006,zmax=0.006,
mosaich=prisma_ana_mosaic,mosaicv=prisma_ana_mosaic,
r0=prisma_ana_r0, Q=prisma_ana_q, color = 5)
AT (0, 0, apos6) RELATIVE rita_ana
ROTATED (0, PHA6, 0) RELATIVE rita_ana
COMPONENT ana7 = Monochromator_color(
ymin=-0.0375,ymax=0.0375,zmin=-0.006,zmax=0.006,
mosaich=prisma_ana_mosaic,mosaicv=prisma_ana_mosaic,
r0=prisma_ana_r0, Q=prisma_ana_q, color = 6)
AT (0, 0, apos7) RELATIVE rita_ana
ROTATED (0, PHA7, 0) RELATIVE rita_ana
COMPONENT a3 = Arm()
AT (0,0,0) relative rita_ana ROTATED (0,TTA,0) RELATIVE a2
COMPONENT mon5 = Monitor(xmin = -0.05, xmax = 0.05, ymin = -0.05, ymax = 0.05)
AT(0,0,0.06) RELATIVE a3
COMPONENT mon6 = Monitor(xmin = -0.1, xmax = 0.1, ymin = -0.1, ymax = 0.1)
AT(0,0,0.161) RELATIVE a3
COMPONENT psd = PSD_monitor(xmin = -0.05, xmax = 0.05,
ymin = -0.05, ymax = 0.05,
nx = 100, ny = 100,
filename = "prisma2.psd")
AT(0,0,0.20) RELATIVE a3
COMPONENT detector = TOF_monitor_color(xmin = -0.05, xmax = 0.05,
ymin = -0.05, ymax = 0.05,
nchan = 10000, dt = 10, maxcolor = 6,
filename = "prisma2.tof")
182 Ris{R{1175(EN)

AT (0,0,0.20) RELATIVE a3
COMPONENT mon9 = Monitor(xmin = -0.1, xmax = 0.1, ymin = -0.1, ymax = 0.1)
AT(0,0,0.01) RELATIVE detector
END
Ris{R{1175(EN) 183

Appendix D
Test results
In this Appendix, we present a few illustrative results from the three instruments presented
in section 6. A more thorough presentation may be found on the McStas home page [1].
D.1 Scattering from the V-sample test instrument
In gure D.1, we present the radial distribution of the scatting from an evenly illuminated
V-sample, as seen by a spherical PSD. It is interesting to note that the variation in the
scattering intensity is as large as 10%. This is an eect of attenuation of the beam in the
cylindrical sample.
D.2 Simulated and measured resolution of TAS1
In order to test the McStas package on a qualitative level, we have performed a very
detailed simulation of the conventional triple axis spectrometer TAS1, Ris. The mea-
surement series constitutes a complete alignment of the spectrometer, using the direct
beam and scattering from V and Al 2 O 3 samples at an incoming energy of 20.0 meV, using
the second order scattering from the monochromator. In the instrument denitions, we
have used all available information about the spectrometer. However, the mosaicities of
the monochromator and analyser are set to 45' in stead of the quoted 30', since we from
our analysis believe this to be much closer to the truth.
In these simulations, we have tried to reproduce every alignment scan with respect to
position and width of the peaks, whereas we have not tried to compare absolute intensities.
Below, we show a few comparisons of the simulations and the measurements.
Figure D.2 shows a scan of 2 s on the collimated direct beam in two-axis mode. A
1 mm slit is placed on the sample position. Both the measured width and non-Gaussian
peak shape are well reproduced by the McStas simulations.
In contrast, a simulated 2 a scan in triple-axis mode on a V-sample showed a surprising
oset from zero, see Figure D.3. However, a simulation with a PSD on the sample position
showed that the beam center was 1.5 mm o from the center of the sample, and this was
important since the beam was no wider than the sample itself. A subsequent centering
of the beam resulted in a nice agreement between simulation and measurements. For a
184 Ris{R{1175(EN)

0
50
100
0
20
40
60
1.4
1.45
1.5
1.55
1.6
Figure D.1: Scattering from a V-sample, measured by a spherical PSD. The sphere has
been transformed onto a plane and the intensity is plotted as the third dimension. A
colour version of this picture is found on the title page of this manual.
-1.5 -1 -0.5 0 0.5 1 1.5 2
0
2
4
6
8
10
12 x 10 4
2T [deg]
intensity
2T scan on 1 mm slit
Figure D.2: Scans of 2 s in the direct beam with 1 mm slit on the sample position. "":
measurements, "o": simulations Collimations: open-30'-open-open.
Ris{R{1175(EN) 185

-4 -3 -2 -1 0 1 2 3 4
-0.5
0
0.5
1
1.5
2
2.5
3 x 10 -6
2TA [deg]
intensity
Figure D.3: First simulated 2 a scan on a vanadium sample. Collimations: open-30'-28'-
open.
comparison on a slightly dierent instrument (analyser-detector collimator inserted), see
Figure D.4.
The result of a 2 s scan on an Al 2 O 3 powder sample in two-axis mode is shown in
Figure D.5. Both for the scan in focusing mode (+ +) and for the one in defocusing
mode (+ + +) (not shown), the agreement between simulation and experiment is excellent.
As a nal result, we present a scan of the energy transfer E a = ~! on a V-sample. The
data are shown in Figure D.6.
D.3 Simple spectra from the PRISMA instrument
A plot from the detector in the PRISMA simulation is shown in Figure D.7. These results
were obtained with each analyser blade rotated one degree relative to the previous one.
The separation of the spectra of the dierent analyser blades is caused by dierent energy
of scattered neutrons and dierent ight path length from source to detector. We have
not performed any quantitative analysis of the data at this time.
186 Ris{R{1175(EN)

-3 -2 -1 0 1 2 3
0
100
200
300
400
500
600
700
2TA [deg]
intensity
Figure D.4: Corrected 2 a scan on a V-sample. Collimations: open-30'-28'-67'. "":
measurements, "o": simulations.
32 32.5 33 33.5 34 34.5 35 35.5
100
200
300
400
500
600
700
800
2T [deg]
intensity
Figure D.5: 2 s scans on Al 2 O 3 in two-axis, focusing mode. Collimations: open-30'-28'-67'.
"": measurements, "o": simulations. A constant background is added to the simulated
data.
Ris{R{1175(EN) 187

-2 -1.5 -1 -0.5 0 0.5 1 1.5 2
0
20
40
60
80
100
120
140
EA [meV]
intensity
Figure D.6: Scans of the analyser energy on a V-sample. Collimations: open-30'-28'-67'.
"": measurements, "o": simulations.
5500 6000 6500 7000 7500
0
1
2
3
4
5
6
7 x 10 -9
time [usec]
Intensity
PRISMA with RITA backend
Figure D.7: Test result from PRISMA instrument using \coloured neutrons". Each graph
shows the neutrons scattered from one analyser blade.
188 Ris{R{1175(EN)

Appendix E
The McStas terminology
This is a short explanation of phrases and terms which have a specic meaning within
McStas. We have tried to keep the list as short as possible with the risk that the reader
may occasionally miss an explanation. In this case, you are more than welcome to contact
the authors.
 Arm A generic McStas component which denes a frame of reference for other
components.
 Component One unit (e.g. optical element) in a neutron spectrometer.
 Denition parameter An input parameter for a component. For example the
radius of a sample component or the divergence of a collimator.
 Input parameter For a component, either a denition parameter or a setting
parameter. These parameters are supplied by the user to dene the characteristics of
the particular instance of the component denition. For an instrument, a parameter
that can be changed at simulation run-time.
 Instrument An assembly of McStas components dening a neutron spectrometer.
 McStas Monte Carlo Simulation of Triple Axis Spectrometers (the name of this
project).
 Output parameter An output parameter for a component. For example the counts
in a monitor. An output parameter may be accessed from the instrument in which
the component is used using MC_GETPAR.
 Run-time C code, contained in the les mcstas-r.c and mcstas-r.h included in
the McStas distribution, that declare functions and variables used by the generated
simulations.
 Setting parameter Similar to a denition parameter, but with the restriction that
the value of the parameter must be a number.
Ris{R{1175(EN) 189

Bibliography
[1] McStas WWW home page:
http://neutron.risoe.dk/mcstas/.
[2] K. Lefmann and K. Nielsen, McStas, a general software package for neutron ray-
tracing simulations, Newtron News 10/3 (1999), 20{24
[3] T.E. Mason et al., RITA: The reinvented triple axis spectrometer, Can. J. Phys. 73
(1995) 697{702
[4] K.N. Clausen et al., The Rita spectrometer at Ris | design considerations and recent
results, Physica B 241{243 (1998) 50{55.
[5] ESS WWW home page:
http://www.kfa-juelich.de/ess/ess.html
[6] Debian GNU/Linux WWW home page:
http://www.debian.org/.
[7] NeXus WWW home page:
http://www.neutron.anl.gov/nexus/.
[8] MFit WWW home page:
http://www.risoe.dk/fys/Manuals/Matlab/Mfit/index.html.
[9] Internet address http://neutron.risoe.dk/mcstas/mcdoc/index.html.
[10] G. L. Squires, Introduction to the Theory of Thermal Neutron Scattering, Dover Pub-
lications (1996)
[11] Crystallographica v1.50b, Oxford Cryosystems, 1998
[12] G. E. Bacon, Neutron Diraction, Oxford University Press (1975)
[13] A. Abrahamsen, N. B. Christensen, and E. Lauridsen, McStas simulations of the
TAS1 spectrometer, Students Report, Niels Bohr Institute, University of Copenhagen
(1998)
[14] William H. Press, Saul A. Teukolsky, William T. Vetterling, Brian P. Flannery, Nu-
merical Recipes in C, Cambridge University Press (1996)
190 Ris{R{1175(EN)

Ris{R{1175(EN) 191

Bibliographic Data Sheet Ris{R{1175(EN)
Title and author(s)
User and Programmers Guide to the Neutron Ray-Tracing Package McStas, Version 1.4
Kristian Nielsen, Kim Lefmann
ISBN
87{550{2683{4; 87{550{2684{2 (Internet)
ISSN
0106{2840
Dept. or group
Condensed Matter Physics and Chemistry Department
Date
July 2000
Groups own reg. number(s)
|
Project/contract No.
|
Pages
192
Tables
1
Illustrations
19
References
13
Abstract (Max. 2000 char.)
The software package McStas is a tool for writing Monte Carlo ray-tracing simulations of
neutron scattering instruments with very high complexity and precision. The simulations
can compute all aspects of the performance of instruments and can thus be used to opti-
mize the use of existing equipment as well as the design of new instrumentation. McStas
is based on a unique design where an automatic compilation process translates high-level
textual instrument descriptions into e∆cient ANSI C code. This design makes it simple
to set up typical simulations and also give essentially unlimited freedom to handle more
unusual needs.
This report constitutes the reference manual for McStas, and contains full documentation
for all ascpects of the program. It covers the various ways to compile and run simulations;
a description of the metalanguage used to dene simulations; a full description of all
algorithms used to calculate the eects of the various optical components in instruments;
and some example simulations performed with the program.
Descriptors
Neutron Instrumentation; Monte Carlo Simulation; Software
Available on request from:
Information Service Department, Ris National Laboratory
(Afdelingen for Informationsservice, Forskningscenter Ris)
P.O. Box 49, DK{4000 Roskilde, Denmark
Phone +45 4677 4004, Telefax +45 4677 4013

