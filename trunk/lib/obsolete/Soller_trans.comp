/*******************************************************************************
*
* McStas, version 1.0, released October 26, 1998
*         Maintained by Kristian Nielsen and Kim Lefmann,
*         Risoe National Laboratory, Roskilde, Denmark
*
* Component: Soller_trans
*
* %Identification
* Written by: KN
* Date: August 1998
* Release: McStas 1.0 (1998) (Obsolete)
* Origin: Risoe
* Version: $Revision: 1.3 $
* Modified by: GA, June 1999
* Modified by: EF, 2004. Merged with Soller
*
* Soller collimator with rectangular opening and specified length.
*
* %Description
* Soller collimator with rectangular opening and specified length.
* The transmission function is an average and does not utilize knowledge of the
* actual neutron trajectory.
* A zero divergence disables collimation (then the component works as a double slit).
* Added is an additional parameter transmission to take into account the
* transmission probability. See <b>Soller</b> component.
* OBSOLETE: rather use Soller or Guide_gravity/Guide_channeled
*
* %Parameters
* INPUT PARAMETERS:
*
* xmin:       (m)              Lower x bound on slits
* xmax:       (m)              Upper x bound on slits
* ymin:       (m)              Lower y bound on slits
* ymax:       (m)              Upper y bound on slits
* len:        (m)              Distance between slits
* divergence: (minutes of arc) Divergence angle (calculated as atan(d/len),
*                              where d is the blade spacing)
* transmission: (1)            0<=transmission<=1)
*
* %End
*******************************************************************************/


DEFINE COMPONENT Soller_trans
DEFINITION PARAMETERS (xmin, xmax, ymin, ymax, len, divergence, transmission)
SETTING PARAMETERS ()
OUTPUT PARAMETERS (slope)
STATE PARAMETERS (x,y,z,vx,vy,vz,t,s1,s2,p)
DECLARE
%{
  double slope;
%}
INITIALIZE
%{
  slope = tan(MIN2RAD*divergence);
%}
TRACE
%{
    double phi, dt;

    PROP_Z0;
    if (x<xmin || x>xmax || y<ymin || y>ymax)
      ABSORB;
    dt = len/vz;
    PROP_DT(dt);
    if (x<xmin || x>xmax || y<ymin || y>ymax)
      ABSORB;

    if(slope > 0.0)
    {
      phi = fabs(vx/vz);
      if (phi > slope)
        ABSORB;
      else
        p *= transmission*(1.0 - phi/slope);
    }
%}

MCDISPLAY
%{
  double x;
  int i;

  magnify("xy");
  for(x = xmin, i = 0; i <= 3; i++, x += (xmax - xmin)/3.0)
    multiline(5, x, (double)ymin, 0.0, x, (double)ymax, 0.0,
              x, (double)ymax, (double)len, x, (double)ymin, (double)len,
              x, (double)ymin, 0.0);
  line(xmin, ymin, 0,   xmax, ymin, 0);
  line(xmin, ymax, 0,   xmax, ymax, 0);
  line(xmin, ymin, len, xmax, ymin, len);
  line(xmin, ymax, len, xmax, ymax, len);
%}

END

