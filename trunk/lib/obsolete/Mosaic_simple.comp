DEFINE COMPONENT Mosaic_simple
DEFINITION PARAMETERS (zmin, zmax, ymin, ymax, mosaic, R0, Qx, Qy, Qz)
SETTING PARAMETERS ()
OUTPUT PARAMETERS (Q,mos_rms)
STATE PARAMETERS (x,y,z,vx,vy,vz,t,s1,s2,p)

DECLARE
%{
  double Q;			/* Length of scattering vector */
  double mos_rms;		/* root-mean-square of mosaic, in radians */
  double m0;			/* Mosaic at zero angle */
#define GAUSS(x,mean,rms) \
  (exp(-((x)-(mean))*((x)-(mean))/(2*(rms)*(rms)))/sqrt(2*PI*(rms)))
%}

INITIALIZE
%{
  Q = sqrt(Qx*Qx + Qy*Qy + Qz*Qz);
  mos_rms = MIN2RAD*mosaic/sqrt(8*log(2));
  m0 = GAUSS(0,0,mos_rms);
%}

TRACE
%{
  double y1,z1,t1,dt,kix,kiy,kiz,ratio,order,q0x,q0y,q0z,k,q0,theta,bx,by,bz,kux,kuy,kuz,ax,ay,az,phi,cos_2theta,sin_2theta,cos_phi,sin_phi,kfx,kfy,kfz,q_x,q_y,q_z,delta,p_reflect;

  if(vx != 0.0 && (dt = -x/vx) >= 0.0)
  {				/* Moving towards crystal? */
    y1 = y + vy*dt;		/* Propagate to crystal plane */
    z1 = z + vz*dt;
    t1 = t + dt;
    if (z1>zmin && z1<zmax && y1>ymin && y1<ymax)
    {				/* Intersect the crystal? */
      kix = V2K*vx;		/* Initial wave vector */
      kiy = V2K*vy;
      kiz = V2K*vz;
      /* Get reflection order and corresponding nominal scattering vector q0
         of correct length and direction. Only the order with the closest
         scattering vector is considered */
      ratio = -2*(kix*Qx + kiy*Qy + kiz*Qz)/(Q*Q);
      order = floor(ratio + .5);
      if(order == 0.0)
	order = ratio < 0 ? -1 : 1;
      /* Order will be negative when the neutron enters from the back, in
         which case the direction of Q0 is flipped. */
      q0x = order*Qx;
      q0y = order*Qy;
      q0z = order*Qz;
      if(order < 0)
	order = -order;
      /* Make sure the order is small enough to allow Bragg scattering at the
         given neutron wavelength */
      k = sqrt(kix*kix + kiy*kiy + kiz*kiz);
      if(order > 2*k/Q)
	order--;
      if(order > 0)		/* Bragg scattering possible? */
      {
	q0 = order*Q;
	theta = asin(q0/(2*k));	/* Actual bragg angle */
	/* Get unit normal to plane containing ki and most probable kf */
	vec_prod(bx, by, bz, kix, kiy, kiz, q0x, q0y, q0z);
	NORM(bx,by,bz);
	/* Get unit vector normal to ki and b */
	kux = kix/k;		/* Unit vector along ki */
	kuy = kiy/k;
	kuz = kiz/k;
	vec_prod(ax, ay, az, bx, by, bz, kux, kuy, kuz);
	/* Choose point on Debye-Scherrer cone. Use simply the crystal mosaic,
           and correct for any error by adjusting the neutron weight later */
	phi = mos_rms*randnorm();
	/* Compute final wave vector kf and scattering vector q = ki - kf */
	cos_2theta = cos(2*theta);
	sin_2theta = sin(2*theta);
	cos_phi = cos(phi);
	sin_phi = sin(phi);
	kfx = kix*cos_2theta + k*sin_2theta*(cos_phi*ax + sin_phi*bx);
	kfy = kiy*cos_2theta + k*sin_2theta*(cos_phi*ay + sin_phi*by);
	kfz = kiz*cos_2theta + k*sin_2theta*(cos_phi*az + sin_phi*bz);
	q_x = kfx - kix;
	q_y = kfy - kiy;
	q_z = kfz - kiz;
	/* Compute reflectivity at this q. */
	delta = acos((q_x*q0x + q_y*q0y + q_z*q0z)/
		     (sqrt(q_x*q_x + q_y*q_y + q_z*q_z)*q0));
	p_reflect = R0*GAUSS(delta,0,mos_rms)/m0;
	/* Make MC choice: reflect or transmit? */
	if(rand01() < p_reflect)
	{			/* Reflect */
	  x = 0;
	  y = y1;
	  z = z1;
	  t = t1;
	  vx = K2V*kfx;
	  vy = K2V*kfy;
	  vz = K2V*kfz;
	  p /= GAUSS(phi,0,mos_rms);
	}
	else
	{			/* Transmit */
	  p /= GAUSS(phi,0,mos_rms);
	} /* End MC choice to reflect or transmit neutron */
      }	/* End bragg scattering possible */
    } /* End intersect the crystal */
  } /* End neutron moving towards crystal */
%}

MCDISPLAY
%{
  magnify("zy");
  multiline(5, 0.0, (double)ymin, (double)zmin,
               0.0, (double)ymax, (double)zmin,
               0.0, (double)ymax, (double)zmax,
               0.0, (double)ymin, (double)zmax,
               0.0, (double)ymin, (double)zmin);
%}

END
