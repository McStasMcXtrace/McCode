/*******************************************************************************
*
* McStas, the neutron ray-tracing package: Virtual_input.comp
*         Copyright 1997-2001 Risoe National Laboratory, Roskilde, Denmark
*
* Component: Virtual_input
*
* %I
* Written by: <a href="mailto:farhi@ill.fr">E. Farhi</a>
* Date: Sep 28th, 2001
* Version:  $Revision: 1.2 $
* Origin: McStas release 1.5.1/<a href="http://www.ill.fr">ILL</a>
*
* Source that generates neutron events from an ascii/binary 'source' file.
*
* %D
*   This component reads neutron events stored in a file, and sends them into
* the instrument. It thus replaces a Source component, using a previously
* computed neutron set. The 'source' file type may be either of text or binary
* format. The component may recognize its format automatically, but you may 
* force the file type ('type' parameter). The number of neutron events for the
* simulation is set to the length of the 'source' file times the
* repetition parameter 'repeat_count' (1 by default).
*   It is particularly useful to generate a virtual source at a point that few
* neutron reach. A long simulation will then only be performed once, to create
* the 'source' file. Further simulations are much faster if they start from
* this low flux position with the 'source' file.
*
* Possible file formats are:
* 1-text column formatted with lines containing at least 11 values in the order:
*       x y z vx vy vz t sx sy sz p
*   Such files may be generated for instance by Monitor_nD with 
*       Monitor_nD(options="list all source", filename="MySource.list")
* 2-Vitess files (binary files of Neutron structure records of 'double')
*   Such files may be generated for instance by Vitess_output with 
*       Vitess_output(outname="MySource.vit", bufsize = 10000)
* 3-float binary files (with the 11 values 'x y z vx vy vz t sx sy sz p')
*   Such files may be generated for instance by Vitess_output with 
*       Monitor_nD(options="list all source binary", filename="MySource.bin")
*
* EXAMPLE:
* To create a 'source' file collecting all neutron states, use:
*   COMPONENT MySourceCreator = Monitor_nD(
*     filename = "MySource.list", options="list all source")
* at the position where will be the Virtual_input.
* The output file is text formatted with:[x y z vx vy vz t sx sy sz p p2] lines 
* and is about 83 bytes per neutron. A binary float format (44 byte/n) is 
* obtained with Monitor_nD(options="list all source binary").
* A Vitess file may be obtained from the 'Vitess_output' component or from a
* Vitess simulation (96 bytes per neutron).
* Then unactivate the component MySourceCreator (add 'unactivate' in options),
* as well as your real source, and put the new instrument source:
*   COMPONENT Source = Source_file(
*     input="MySource.list")
* at the same position as 'MySourceCreator'. 
*
* %P
* INPUT PARAMETERS
* input:        (str) name of the neutron input file, or stdin if left to 0. 
* 
* Optional input parameters:
* bufsize:      (records)   Size of neutron input buffer. 0 for 'use all'.
* repeat_count: (1)         Number of times the source must be generated.
*                           0 unactivates the component
* type:         (str) may be "text", "Vitess" or "float" to force file type.
*                     Vitess files are prioritary when input is sdtin, 
*                     else text files are prioritary.
*
* OUTPUT PARAMETERS
*
* finished:     Set to 1 when the last neutron has been read [int]  
*
* %E
*
*******************************************************************************/

DEFINE COMPONENT Virtual_input
DEFINITION PARAMETERS (input=0, type=0)
SETTING PARAMETERS (repeat_count = 1, bufsize=0)
OUTPUT PARAMETERS (file, source, rep, pos, FileType, read_s_file, finished)
STATE PARAMETERS (x,y,z,vx,vy,vz,t,s1,s2,p)
POLARISATION PARAMETERS (sx, sy, sz)

SHARE
%{
#ifndef VITESS_LIB_H
#define VITESS_LIB_H
/* The Neutron structure, taken from VITESS source code "general.h" */
typedef double VectorType[3];
typedef struct
  {
    double        Time;
    double        Wavelength;
    double        Probability;
    VectorType    Position;
    VectorType    Vector;
    VectorType    Spin;
  } Neutron;
  
  /* Convert McStas state parameters to VITESS Neutron structure. In
   VITESS, the neutron velocity is represented by a wavelength in
   AAngstroem and a unit direction vector, time is in msec and
   positions are in cm.*/
Neutron mcstas2vitess(double x, double y, double z,
		      double vx, double vy, double vz,
		      double t, 
          double sx, double sy, double sz,
          double p)
{
  double v,s;			/* Neutron speed */
  Neutron neu;			/* Vitess Neutron structure */

  neu.Position[0] = x*100;	/* Convert position from m to cm */
  neu.Position[1] = y*100;
  neu.Position[2] = z*100;
  v = sqrt(vx*vx + vy*vy + vz*vz);
  if(v == 0.0)
  {
    fprintf(stderr, "mcstas2vitess: Error: zero velocity!\n");
    exit(1);
  }
  neu.Wavelength = 3956.0346/v;	/* Convert speed to wavelength */
  neu.Vector[0] = vx/v;		/* Convert velocity to unit direction vector */
  neu.Vector[1] = vy/v;
  neu.Vector[2] = vz/v;
  s = sqrt(sx*sx+sy*sy+sz*sz);
  if(s != 0.0)
  {
    neu.Spin[0] = sx/s;
    neu.Spin[1] = sy/s;
    neu.Spin[2] = sz/s;
  }
  
  neu.Time = t*1000;		/* Convert time from sec to msec */
  neu.Probability = p;		/* Neutron weight */
  return neu;
}

/* Convert VITESS neutron structure to McStas state parameters. In
   VITESS, the neutron velocity is represented by a wavelength in
   AAngstroem and a unit direction vector, time is in msec and
   positions are in cm. */
void vitess2mcstas(Neutron neu,
		   double *x, double *y, double *z,
		   double *vx, double *vy, double *vz,
       double *t, 
       double *sx, double *sy, double *sz,
		   double *p)
{
  double v;			/* Neutron speed */

  *x = 0.01*neu.Position[0];	/* Convert position from cm to m */
  *y = 0.01*neu.Position[1];
  *z = 0.01*neu.Position[2];
  if(neu.Wavelength == 0.0)
  {
    fprintf(stderr, "mcstas2vitess: Error: zero wavelength!\n");
    exit(1);
  }
  v = 3956.0346/neu.Wavelength;	/* Convert wavelength to speed */
  *vx = v*neu.Vector[0];	/* Convert unit direction vector to velocity */
  *vy = v*neu.Vector[1];
  *vz = v*neu.Vector[2];
  *sx = neu.Spin[0];
  *sy = neu.Spin[1];
  *sz = neu.Spin[2];
  *t = 0.001*neu.Time;		/* Convert msec to sec */
  *p = neu.Probability;		/* Neutron weight */
}
#endif
%}

DECLARE
%{

  #include <sys/stat.h>
  
  double*
  read_s_file(char *file, double *size, double buffer_size)
  {
    FILE   *f;
    double  i=0;
    int     s_block=0;
    double *s;
    
    if (buffer_size == 0) buffer_size = 10000;    
    *size=0;

    if (file)
      f = fopen(file, "r");
    else
      f = stdin;
      
    if(!f)
    {
      fprintf(stderr, "Virtual_input: Error: file '%s' cannot be opened/found.\n", file);
      exit(1);
    }
    s = (double*)malloc((buffer_size)*11*sizeof(double));
    if(!s)
    {
      fprintf(stderr, "Virtual_input: Error: Cannot allocate neutron buffer\n");
      exit(1);
    }  
    while(!feof(f))
    {
      double fx, fy, fz, fvx, fvy, fvz, ft, fsx, fsy, fsz, fp;
      double dummy;
      int    ret;
      char   Buffer[1024];

      ret = fscanf(f, "%lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf\n",
        &fx, &fy, &fz, &fvx, &fvy, &fvz, &ft, &fsx, &fsy, &fsz, &fp);
      if(ret == EOF)
        break;
      if(ret < 11)
      {
        fgets(Buffer, 1024, f);
        continue;
      } 
      else
      {
        long j;
        
        j = (long)i;
        if (s_block>=buffer_size)
        {
           s_block = 0;
           s = (double*)realloc(s, (long)(i+buffer_size)*11*sizeof(double));
           if(!s)
            {
              fprintf(stderr, "Virtual_input: Error: Cannot re-allocate neutron buffer\n");
              exit(1);
            }  
        }
        s[11*j+0]  = fx;  s[11*j+1] = fy;  s[11*j+2] = fz; 
        s[11*j+3]  = fvx; s[11*j+4] = fvy; s[11*j+5] = fvz; 
        s[11*j+6]  = ft;
        s[11*j+7]  = fsx; s[11*j+8] = fsy; s[11*j+9] = fsz; 
        s[11*j+10] = fp;
        i++;  s_block++;
      }
    } /* end while */
    fclose(f);
    *size=i;
    if (i == 0) return(NULL);
    s = (double*)realloc(s, (long)(i+1)*11*sizeof(double) );
    if(!s)
    {
      fprintf(stderr, "Virtual_input: Error: Cannot re-allocate neutron buffer (final)\n");
      exit(1);
    }
    return (s);
  }
  
  double *source;   /* Neutron input buffer */
  double  length, pos;
  int     rep;      /* Neutron repeat count */
  char    FileType[32];
  int finished;			/* Set to 1 when last neutron read */
%}

INITIALIZE
%{
  struct stat stfile;
  long   filesize, i, nelements;
  FILE *f;
  char   FileName[256];
  
  length=0;
  rep   =0;
  source=NULL;
  strcpy(FileType,"");
  if (input)
    strcpy(FileName, input);
  else 
    strcpy(FileName, "[stdin]"); 
    
  if (repeat_count != 0)
  {
    /* Try to Open neutron input text file. */
    if((input && type == NULL) || (type && !strcmp(type,"text"))) 
      source = read_s_file(input, &length, bufsize);

    /* Try to Open neutron input binary file. */
    if(length == 0 || source == NULL || (type && !strcmp(type,"Vitess")) || (type && !strcmp(type,"float")) )
    {
      if (input)
      {
        stat(input,&stfile);
	      filesize = stfile.st_size;
        f = fopen(input, "r"); /* must exist else exit(-1) in read_s_file */
      }
      else
      {  f = stdin; 
         if (bufsize ==0) bufsize = 10000;
         filesize = bufsize*sizeof(Neutron);  }
      
      /* try to read Vitess files */
      if ((fmod(filesize, sizeof(Neutron)) == 0) && (type == NULL || !strcmp(type,"Vitess")))
      {
        strcpy(FileType, "Vitess");
        nelements = (long)(filesize/sizeof(Neutron));
        source = (double*)malloc(filesize);
        nelements = fread(source, sizeof(Neutron), nelements, f);
        if (source==NULL || !nelements)
        {
          fprintf(stderr,"Virtual_input: error reading %i elements in Vitess file '%s'\n", nelements, FileName);
          exit(-1);
        }
        length = (double)nelements;
        source = (double*)realloc(source, length*sizeof(Neutron));
      }
      else
      { /* try to read float bin files */
        if (fmod(filesize, sizeof(float)) ==0)
        {
          strcpy(FileType, "float");
          nelements = (long)(filesize/sizeof(float));
          source = (double*)malloc(filesize);
          nelements = fread(source, sizeof(float), nelements, f);
          if (source==NULL || !nelements)
          {
            fprintf(stderr,"Virtual_input: error reading %i elements in float file '%s'\n", nelements, FileName);
            exit(-1);
          }
          length = (double)floor(nelements/11);
          source = (double*)realloc(source, length*sizeof(float)*11);
        }
      }
      fclose(f);
    }
    else
      strcpy(FileType, "text");
    
    if (length == 0)
    {
      fprintf(stderr,"Virtual_input: Can not read neutron %i events from %s file '%s'\n", (long)length, FileType, FileName);
      exit(-1);
    }
    
      printf("Virtual_input: Read %i neutron events from %s file '%s'\n", (long)length, FileType, FileName);
      
    pos = 0;
    if (bufsize != 0 && bufsize <= length) length = bufsize;    
    mcset_ncount(length*repeat_count);
  }
%}

TRACE
%{
  
  if (repeat_count)
  {
    if (pos >= length)
      { rep++; pos = 0; } /* Reposition at start of buffer */

    if (rep > repeat_count)
      { finished = 1; ABSORB; }
    else
    {
      long i;
      i = (long)pos;
      
      if (!strcmp(FileType, "Vitess"))
      {
        Neutron neu;
        Neutron *s;
        double v;
        
        s=(Neutron*)source;
        
        vitess2mcstas(s[i], &x, &y, &z, &vx, &vy, &vz, &t, &sx, &sy, &sz, &p);
      } 
      else
      {
        if (!strcmp(FileType, "text")) 
        {  /* &x, &y, &z, &vx, &vy, &vz, &t, &sx, &sy, &sz, &p (&dummy was not stored) */
          double *s;
          s = (double*)source;
          x  = s[11*i+0]   ; y  = s[11*i+1] ; z  = s[11*i+2];
          vx = s[11*i+3]   ; vy = s[11*i+4] ; vz = s[11*i+5];
          t  = s[11*i+6]   ;
          sx = s[11*i+7]   ; sy = s[11*i+8] ; sz = s[11*i+9];
          p  = s[11*i+10]  ;
        }
        else 
        { /* &x, &y, &z, &vx, &vy, &vz, &t, &sx, &sy, &sz, &p, &p2 */
          float *s;
          s = (float*)source;
          x  = s[11*i+0]   ; y  = s[11*i+1] ; z  = s[11*i+2];
          vx = s[11*i+3]   ; vy = s[11*i+4] ; vz = s[11*i+5];
          t  = s[11*i+6]   ;
          sx = s[11*i+7]   ; sy = s[11*i+8] ; sz = s[11*i+9];
          p  = s[11*i+10]  ;
        }
      }
      pos++;
      p /= repeat_count;
    }
    SCATTER;
  }
%}

FINALLY
%{
  if(source)
    free(source);
%}

MCDISPLAY
%{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.1,0,0);
  line(0,0,0,0,0.1,0);
  line(0,0,0,0,0,0.1);
%}

END

