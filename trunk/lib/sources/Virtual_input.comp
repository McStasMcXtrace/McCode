/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright 1997-2002, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Component: Virtual_input
*
* %I
* Written by: <a href="mailto:farhi@ill.fr">E. Farhi</a>
* Date: Sep 28th, 2001
* Version:  $Revision: 1.8 $
* Origin: <a href="http://www.ill.fr">ILL</a>
* Release: McStas 1.6
* Modified by: EF, Oct 2002. make use of shared read-table library.
*
* Source that generates neutron events from an ascii/binary 'source' file.
*
* %D
*   This component reads neutron events stored in a file, and sends them into
* the instrument. It thus replaces a Source component, using a previously
* computed neutron set. The 'source' file type may be either of text or binary
* format. The component may recognize its format automatically, but you may 
* force the file type ('type' parameter). The number of neutron events for the
* simulation is set to the length of the 'source' file times the
* repetition parameter 'repeat_count' (1 by default).
*   It is particularly useful to generate a virtual source at a point that few
* neutron reach. A long simulation will then only be performed once, to create
* the 'source' file. Further simulations are much faster if they start from
* this low flux position with the 'source' file.
*
* Possible file formats are:
* 1-text column formatted with lines containing 11 values in the order:
*       p x y z vx vy vz t sx sy sz
*   Such files may be generated for instance by Monitor_nD with 
*       Monitor_nD(options="list all source", filename="MySource.list")
* 2-Vitess files (binary files of Neutron structure records of 'double')
*   Such files may be generated for instance by Vitess_output with 
*       Vitess_output(outname="MySource.vit", bufsize = 10000)
* 3-float binary files (with the 11 values 'p x y z vx vy vz t sx sy sz')
*   Such files may be generated for instance by Vitess_output with 
*       Monitor_nD(options="list all source binary", filename="MySource.bin")
*
* EXAMPLE:
* To create a 'source' file collecting all neutron states, use:
*   COMPONENT MySourceCreator = Monitor_nD(
*     filename = "MySource.list", options="list all source")
* at the position where will be the Virtual_input.
* The output file is text formatted with:[p x y z vx vy vz t sx sy sz] lines 
* and is about 83 bytes per neutron. A binary float format (44 byte/n) is 
* obtained with Monitor_nD(options="list all source binary").
* A Vitess file may be obtained from the 'Vitess_output' component or from a
* Vitess simulation (96 bytes per neutron).
* Then unactivate the component MySourceCreator (add 'unactivate' in options),
* as well as your real source, and put the new instrument source:
*   COMPONENT Source = Virtual_input(
*     input="MySource.list", type="text")
* at the same position as 'MySourceCreator'. 
*
* %P
* INPUT PARAMETERS
* input:        (str) name of the neutron input file, or stdin if left to 0. 
* 
* Optional input parameters:
* bufsize:      (records)   Size of neutron input buffer. 0 for 'use all'.
* repeat_count: (1)         Number of times the source must be generated.
*                           0 unactivates the component
* type:         (str) may be "text", "Vitess" or "float" to force file type.
*                     Vitess files are prioritary when input is sdtin, 
*                     else text files are prioritary.
*
* OUTPUT PARAMETERS
*
* finished:     Set to 1 when the last neutron has been read [int]  
*
* %E
*
*******************************************************************************/

DEFINE COMPONENT Virtual_input
DEFINITION PARAMETERS (input=0, type=0)
SETTING PARAMETERS (repeat_count = 1, bufsize=0)
OUTPUT PARAMETERS (source, rep, pos, FileType, finished, rTable, length)
STATE PARAMETERS (x,y,z,vx,vy,vz,t,s1,s2,p)
POLARISATION PARAMETERS (sx, sy, sz)

SHARE
%{
%include "vitess-lib" 
%include "read_table-lib"
%}

DECLARE
%{

#include <sys/stat.h>

  double *source;   /* Neutron input buffer */
  double  length, pos;
  int     rep;      /* Neutron repeat count */
  char    FileType[32];
  int     finished; /* Set to 1 when last neutron read */
  t_Table rTable;
%}

INITIALIZE
%{
  long   filesize;
  FILE *f;
  char   FileName[256];
  
  length=0;
  rep   =0;
  source=NULL;
  strcpy(FileType,"[stdin]");
  if (input)
    strcpy(FileName, input);
    
  if (repeat_count != 0)
  {
    /* Try to Open neutron input text file. */
    if((input && type == NULL) || (type && !strcmp(type,"text"))) 
    {
      Table_Read(&rTable, input, 0); /* read all data from file into rTable */
      if (rTable.rows < 11) Table_Free(&rTable);
      source = rTable.data;
      length = rTable.rows;
      strcpy(FileType, "text");
      if (length == 0)
      {
        fprintf(stderr,"Virtual_input: error reading %d elements from %s file '%s'. Wrong type ?\n", (long)length, FileType, FileName);
        exit(-1);
      }
    }
    
    /* Try to Open neutron input binary file (float/Vitess). */
    if(length == 0 || source == NULL || (type && !strcmp(type,"Vitess")) || (type && !strcmp(type,"float")) )
    {
      long nelements, sizeofelement;
      
      if (input)
      {
        struct stat stfile;
        
        stat(input,&stfile);
	      filesize = stfile.st_size;
        f = fopen(input, "r"); /* must exist else exit(-1) from text file */
      }
      else
      {  f = stdin; 
         if (bufsize ==0) bufsize = 10000;
         filesize = bufsize*sizeof(Neutron);  }
      
      /* try to read Vitess files */
      if ((fmod(filesize, sizeof(Neutron)) == 0) && (type == NULL || !strcmp(type,"Vitess")))
      {
        strcpy(FileType, "Vitess");
        sizeofelement = sizeof(Neutron);
      }
      else
      {
        strcpy(FileType, "float");
        sizeofelement = 11*sizeof(float);
      }
      nelements = (long)(filesize/sizeofelement);
      source    = (double*)malloc(filesize);
      nelements = fread(source, sizeofelement, nelements, f);
      
      if (source==NULL || !nelements)
      {
        fprintf(stderr,"Virtual_input: error reading %d elements from %s file '%s'. Wrong type ?\n", nelements, FileType, FileName);
        exit(-1);
      }
      else length = (double)nelements;
      
      source = (double*)realloc(source, length*sizeofelement);
      fclose(f);
    }
    
    if (length == 0)
    {
      fprintf(stderr,"Virtual_input: Can not read neutron %i events from %s file '%s'\n", (long)length, FileType, FileName);
      exit(-1);
    }
    else
      printf("Virtual_input: Read %i neutron events from %s file '%s'. Repeat %g time(s)\n", (long)length, FileType, FileName, repeat_count);
      
    pos = 0;
    if (bufsize != 0 && bufsize <= length) length = bufsize;    
    mcset_ncount(length*repeat_count);
  }
%}

TRACE
%{
  
  if (repeat_count)
  {
    if (pos >= length)
      { rep++; pos = 0; } /* Reposition at start of buffer */

    if (rep > repeat_count)
      { finished = 1; ABSORB; }
    else
    {
      long i;
      i = (long)pos;
      
      if (!strcmp(FileType, "Vitess"))
      {
        Neutron neu;
        Neutron *s;
        double v;
        
        s=(Neutron*)source;
        
        vitess2mcstas(s[i], &x, &y, &z, &vx, &vy, &vz, &t, &sx, &sy, &sz, &p);
      } 
      else
      {
        if (!strcmp(FileType, "text")) 
        {  /* &p, &x, &y, &z, &vx, &vy, &vz, &t, &sx, &sy, &sz */
          mcrestore_neutron(source,i, &x, &y, &z, &vx, &vy, &vz, &t, &sx, &sy,  &sz, &p); 
          
        }
        else 
        { /* &p, &x, &y, &z, &vx, &vy, &vz, &t, &sx, &sy, &sz, &p */
          float *s;
          s = (float*)source;
          p  = s[11*i+0]  ;
          x  = s[11*i+1]   ; y  = s[11*i+2] ; z  = s[11*i+3];
          vx = s[11*i+4]   ; vy = s[11*i+5] ; vz = s[11*i+6];
          t  = s[11*i+7]   ;
          sx = s[11*i+8]   ; sy = s[11*i+9] ; sz = s[11*i+10];
        }
      }
      pos++;
      p /= repeat_count;
    }
    SCATTER;
  }
%}

FINALLY
%{
  if(source)
    free(source);
%}

MCDISPLAY
%{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  line(0,0,0,0.1,0,0);
  line(0,0,0,0,0.1,0);
  line(0,0,0,0,0,0.1);
%}

END

