/*******************************************************************************
*
* McStas, the neutron ray-tracing package: ESS_moderator_long
*         Copyright 1997-2001 Risoe National Laboratory, Roskilde, Denmark
*
* Component: ESS_moderator_long
*
* %I
* Adapted from Moderator by: KN, M.Hagen, August 1998
* Written by: Kim Lefmann
* Date: 2001
* Version: $Revision: 1.4 $
* Origin: McStas 1.4.2
*
* A parametrised pulsed source for modelling ESS long pulses.
*
* %D
* Produces a time-of-flight spectrum, from the ESS parameters
* Chooses evenly in lambda, evenly/exponentially decaying in time 
*
* Units of flux: n/cm^2/s/AA/ster  
* (McStas units are in general neutrons/second)
*
* %P
* Input parameters:
*
* size:   (m)    Edge of cube shaped source
* l_low:  (AA)   Lower edge of lambda distribution
* l_high: (AA)   Upper edge of energy distribution
* dist:   (m)    Distance from source to focusing rectangle; at (0,0,dist)
* xw:     (m)    Width of focusing rectangle
* yh:     (m)    Height of focusing rectangle
* T:      (K)    Temperature of source
* tau:    (s)    long time decay constant for pulse tail 1a 
* tau1:   (s)    long time decay constant for pulse tail 1b
* tau2:   (s)
* d:      (s)    pulse length
* n:      (1)    pulse shape parameter, 1
* n2:     (1)    pulse shape parameter, 2
* chi2:   (1/AA) lambda-distribution parameter in pulse 2
* I0:     (flux) integrated flux, 1 (in flux units, see above)
* I2:     (flux) Flux, 2 (in flux units, see above)
* branch1: (1)   limit for switching between two time structures in
                 distribution 1 (only for coupled water, else = 1)
* branch2: (1)   limit for switching between distribution 1 and 2. 
*                (default value 0.5)
* branch_tail: (1)   limit for switching between pulse and tail
*                (suggested value: tau/d)
* %E
*******************************************************************************/

DEFINE COMPONENT ESS_moderator_long
DEFINITION PARAMETERS ()
SETTING PARAMETERS (size, l_low, l_high, dist, xw, yh, 
                    T, tau, tau1, tau2, d, n, n2, chi2, I0, I2, 
                    branch1, branch2, branch_tail)
OUTPUT PARAMETERS (l_range, w_mult)
STATE PARAMETERS (x,y,z,vx,vy,vz,t,s1,s2,p)

DECLARE
%{
  double l_range, w_mult;

  double M(double l, double temp)
    {
      double a=949.0/temp;
      return 2*a*a*exp(-a/(l*l))/(l*l*l*l*l);
    }
  
  double F(double t, double tau, int n)
    {
      return (exp(-t/tau)-exp(-n*t/tau))*n/(n-1)/tau;
    }
%}

INITIALIZE
%{
  l_range = l_high-l_low;
  w_mult = size*size*1.0e4;     /* source area correction */
  w_mult *= l_range;            /* wavelength range correction */
  w_mult *= 1/mcget_ncount();   /* Correct for number of rays */
%}
TRACE
%{
  double v,tau_l,E,lambda,k,r,xf,yf,dx,dy,w_focus,tail_flag;

  z=0;

  x = 0.5*size*randpm1();
  y = 0.5*size*randpm1();         /* Choose initial position */

  xf = 0.5*xw*randpm1();          /* Choose focusing position uniformly */
  yf = 0.5*yh*randpm1();
  dx = xf-x;
  dy = yf-y;
  r = sqrt(dx*dx+dy*dy+dist*dist);

  lambda = l_low+l_range*rand01();    /* Choose from uniform distribution */
  k = 2*PI/lambda;
  v = K2V*k;

  vz = v*dist/r;
  vy = v*dy/r;
  vx = v*dx/r;

  w_focus = xw*yh*dist/(r*r*r);         /* target area * cos(phi)/r^2 */

/*  printf("pos0 (%g %g %g), pos1 (%g %g %g), r: %g, v (%g %g %g), v %g\n",
  x,y,z,xf,yf,dist,r,vx,vy,vz, v);
  printf("l %g, w_focus %g \n", lambda, w_focus);  */

  tail_flag = (rand01()<branch_tail);   /* Choose tail/bulk */
  if (tail_flag)
  {
    if (rand01() < branch2)
    {
      if (rand01() < branch1)     /* Quick and dirty non-general solution */
      {  /* FIRST CASE a */
        tau_l = tau;
        p = 1/(branch1*branch2*branch_tail); /* Correct for switching prob. */
      }
      else
      {  /* FIRST CASE b */
        tau_l = tau1;
        p = 1/((1-branch1)*branch2*branch_tail); /* Correct for switching prob. */
      }
      t = -tau_l*log(1e-12+rand01());       /* Sample from long-time tail a */
   /* Correct for true pulse shape */
      p *= w_focus;                         /* Correct for target focusing */
      p *= tau_l/d;                         /* Correct for tail part */
      p *= I0*w_mult*M(lambda,T);           /* Calculate true intensity */
    }
    else
    {
      /* SECOND CASE */
      tau_l = tau2*lambda;  
      t = -tau_l*log(1e-12+rand01());       /* Sample from long-time tail */
      p = n2/(n2-1)*((1-exp(-d/tau_l))-(1-exp(-n2*d/tau_l))*exp(-(n2-1)*t/tau_l)/n);    
                                            /* Correct for true pulse shape */
      p /= (1-branch2)*branch_tail;          /* Correct for switching prob. */
      p *= tau_l/d;                         /* Correct for tail part */
      p *= w_focus;                         /* Correct for target focusing */
      p *= I2*w_mult/(1+exp(chi2*lambda-2.2))/lambda;           
                                            /* Calculate true intensity */
    }
    t += d;                                 /* Add pulse length */
  }
  else
  {
    t = d*rand01();                        /* Sample from bulk pulse */
    if (rand01() < branch2)
    {
      if (rand01() < branch1)     /* Quick and dirty non-general solution */
      {  /* FIRST CASE a */
        tau_l = tau;
        p = 1/(branch1*branch2*(1-branch_tail)); /* Correct for switching prob. */
      }
      else
      {  /* FIRST CASE b */
        tau_l = tau1;
        p = 1/((1-branch1)*branch2*(1-branch_tail)); /* Correct for switching prob. */
      }
      p *= 1-n/(n-1)*(exp(-t/tau_l)-exp(-n*t/tau_l)/n); /* Correct for true pulse shape */
      p *= w_focus;                         /* Correct for target focusing */
      p *= I0*w_mult*M(lambda,T);           /* Calculate true intensity */
    }
    else
    {
      /* SECOND CASE */
      tau_l = tau2*lambda;  
      p = 1-n2/(n2-1)*(exp(-t/tau_l)-exp(-n2*t/tau_l)/n2); /* Correct for true pulse shape */
      p /= (1-branch2)*(1-branch_tail);      /* Correct for switching prob. */
      p *= w_focus;                         /* Correct for target focusing */
      p *= I2*w_mult/(1+exp(chi2*lambda-2.2))/lambda;           
                                            /* Calculate true intensity */
    }
    SCATTER;
  }
%}

MCDISPLAY
%{
  magnify("xy");
  multiline(5, -(double)dist/2.0, -(double)dist/2.0, 0.0,
                (double)dist/2.0, -(double)dist/2.0, 0.0,
                (double)dist/2.0,  (double)dist/2.0, 0.0,
               -(double)dist/2.0,  (double)dist/2.0, 0.0,
               -(double)dist/2.0, -(double)dist/2.0, 0.0); 
%}

END
