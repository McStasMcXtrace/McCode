DEFINE COMPONENT Source_adapt
DEFINITION PARAMETERS (radius, dist, xw, yh, E0, dE, NUM, alpha, beta)
SETTING PARAMETERS ()
OUTPUT PARAMETERS (hdiv, vdiv, p_in, y_0, C, r_0)
STATE PARAMETERS (x,y,z,vx,vy,vz,t,s1,s2,p)
DECLARE
%{
#include "alg.h"
 double hdiv,vdiv;
 double p_in;
 struct adapt_tree *atree;
 int aindex;
 double *a_psi, *a_n;
 double a_total_psi;
 double a_pi, a_num;
 double count;
 double y_0, C, r_0;
 double a_factor;
%}
INITIALIZE
%{
  int i;

  hdiv = atan(xw/(2.0*dist));
  vdiv = atan(yh/(2.0*dist));
  p_in = (4*hdiv*vdiv)/(4*PI); /* Small angle approx. */
  atree = adapt_tree_init(NUM);
  a_psi = malloc(NUM*sizeof(*a_psi));
  a_n = malloc(NUM*sizeof(*a_n));
  if(!(a_psi && a_n))
  {
    fprintf(stderr, "Fatal error: out of memory.\n");
    exit(1);
  }
  for(i = 0; i < NUM; i++)
  {
    adapt_tree_add(atree, i, 1.0/(double)NUM);
    a_psi[i] = a_n[i] = 0;
  }
  a_total_psi = 0;
  a_num = NUM;
  count = 0;
  y_0 = NUM > 8 ? 2.0/(double)NUM : 0.25;
  r_0 = 1/(double)alpha*log((1 - y_0)/y_0)/(double)mcget_ncount();
  C = 1/(1 + log(y_0 + (1 - y_0)*exp(-r_0*mcget_ncount()))/(r_0*mcget_ncount()));
  printf("Source_adapt: y_0=%8.3g r_0=%8.3g C=%8.3g\n", y_0, r_0, C);
%}
TRACE
%{
 double theta0,phi0,chi,theta,phi,E,v,r;
 double new_v;

 p=p_in;
 z=0;

 chi=2*PI*rand01();                          /* Choose point on source */
 r=sqrt(rand01())*radius;                    /* with uniform distribution. */
 x=r*cos(chi);
 y=r*sin(chi);

 theta0= -atan(x/dist);              /* Angles to aim at target centre */
 phi0= -atan(y/dist);

 theta=theta0+hdiv*randpm1();        /* Small angle approx. */
 phi=phi0+vdiv*randpm1();

 r = rand01();
 aindex = adapt_tree_search(atree, atree->total*r);
 if(aindex >= NUM)
 {
   fprintf(stderr, "Hm, aindex is %d, NUM is %d, r is %g, atree->total is %g\n",
	   aindex, (int)NUM, r, atree->total);
   aindex = NUM - 1;
 }
 E = E0 - dE + (aindex + rand01())*(2.0*dE/(double)NUM);
 a_factor = y_0/(y_0 + (1 - y_0)*exp(-r_0*count));
 count++;
 p /= atree->v[aindex]/(atree->total/(double)NUM);
 p *= C*a_factor;

 if(a_n[aindex] > 0)
   a_total_psi -= a_psi[aindex]/(a_n[aindex]*(a_n[aindex] + 1));
 a_n[aindex]++;
 /* First adjust assuming absorbtion. */
 if(a_total_psi != 0)
 {
   new_v = (1-beta)*a_factor*a_psi[aindex]/(a_n[aindex]*a_total_psi) +
     beta/a_num;
   adapt_tree_add(atree, aindex, new_v - atree->v[aindex]);
 }

 v=sqrt(E)*SE2V;

 vz=v*cos(phi)*cos(theta);
 vy=v*sin(phi);
 vx=v*cos(phi)*sin(theta);
 a_pi = p;
%}

FINALLY
%{
  int *p0;
  double *p1,*p2;
  int i;
  p0 = malloc(NUM*sizeof(int));
  p1 = malloc(NUM*sizeof(double));
  p2 = malloc(NUM*sizeof(double));
  for(i = 0; i < NUM; i++)
  {
    p0[i] = 1;
    p1[i] = atree->v[i]/atree->total;
    p2[i] = p1[i]*p1[i];
  }
  printf("Source_adapt: Total=%g\n", atree->total);
  DETECTOR_OUT_1D(
	"Adaptive source energy distribution",
	"Energy [meV]",
	"Probability",
	"E", E0 - dE, E0 + dE, NUM,
	NULL, p1, NULL, "source_adapt.dist");
  adapt_tree_free(atree);
%}
MCDISPLAY
%{
  magnify("xy");
  circle("xy",0,0,0,radius);
%}

END
