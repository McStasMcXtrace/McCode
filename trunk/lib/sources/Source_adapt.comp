DEFINE COMPONENT Source_adapt
DEFINITION PARAMETERS (radius, dist, xw, yh, E0, dE, N_E, N_xpos, N_xdiv, alpha, beta)
SETTING PARAMETERS ()
OUTPUT PARAMETERS (hdiv, vdiv, p_in, y_0, C, r_0, NUM)
STATE PARAMETERS (x,y,z,vx,vy,vz,t,s1,s2,p)
DECLARE
%{
#include "alg.h"
#define NUM (N_E*N_xpos*N_xdiv)
 double hdiv,vdiv;
 double p_in;
 struct adapt_tree *atree;
 int aindex;
 double *a_psi, *a_n;
 double a_total_psi;
 double a_pi, a_num;
 double count;
 double y_0, C, r_0;
 double a_factor;
%}
INITIALIZE
%{
  int i;

  hdiv = atan(xw/(2.0*dist));
  vdiv = atan(yh/(2.0*dist));
  p_in = (4*hdiv*vdiv)/(4*PI); /* Small angle approx. */
  atree = adapt_tree_init(NUM);
  a_psi = malloc(NUM*sizeof(*a_psi));
  a_n = malloc(NUM*sizeof(*a_n));
  if(!(a_psi && a_n))
  {
    fprintf(stderr, "Fatal error: out of memory.\n");
    exit(1);
  }
  for(i = 0; i < NUM; i++)
  {
    adapt_tree_add(atree, i, 1.0/(double)NUM);
    a_psi[i] = a_n[i] = 0;
  }
  a_total_psi = 0;
  a_num = NUM;
  count = 0;
  y_0 = NUM > 8 ? 2.0/(double)NUM : 0.25;
  r_0 = 1/(double)alpha*log((1 - y_0)/y_0)/(double)mcget_ncount();
  C = 1/(1 + log(y_0 + (1 - y_0)*exp(-r_0*mcget_ncount()))/(r_0*mcget_ncount()));
  printf("Source_adapt: y_0=%8.3g r_0=%8.3g C=%8.3g\n", y_0, r_0, C);
%}
TRACE
%{
  double thmin,thmax,phmin,phmax,theta,phi,E,v,r;
  double new_v;
  int i_E, i_xpos, I_xdiv;

  /* Randomly select a bin in the current distribution */
  r = rand01();
  aindex = adapt_tree_search(atree, atree->total*r);
  if(aindex >= NUM)
  {
    fprintf(stderr,
	    "Hm, aindex is %d, NUM is %d, r is %g, atree->total is %g\n",
	    aindex, (int)NUM, r, atree->total);
    aindex = NUM - 1;
  }
  /* Now find the bin coordinates. */
  i_xdiv = aindex % N_xdiv;
  i_xpos = (aindex / N_xdiv) % N_xpos;
  i_E = (aindex / N_xdiv) / N_xpos;
  /* Compute the initial neutron parameters, selecting uniformly randomly
     within each bin dimension. */
  x = xmin + (i_xpos + rand01())*((xmax - xmin)/(double)N_xpos);
  y = ymin + rand01()*(xmax - xmin);
  z=0;
  thmin = atan2(-xw/2.0 - x, dist);
  thmax = atan2( xw/2.0 - x, dist);
  theta = thmin + (i_xdiv + rand01())*((thmax - thmin)/(double)N_xdiv);
  phmin = atan2(-yh/2.0 - y, dist);
  phmax = atan2( yh/2.0 - y, dist);
  phi = phmin + rand01()*(phmax - phmin);
  E = E0 - dE + (i_E + rand01())*(2.0*dE/(double)N_E);
  v = sqrt(E)*SE2V;
  vy = v*sin(phi);
  vx = v*cos(phi)*sin(theta);
  vz = v*cos(phi)*cos(theta);
  t = 0;
  /* Adjust neutron weight. */
  p = p_in;
  a_factor = y_0/(y_0 + (1 - y_0)*exp(-r_0*count));
  count++;
  p /= atree->v[aindex]/(atree->total/(double)NUM);
  p *= C*a_factor;
  /* Update distribution, assuming absorbtion. */
  if(a_n[aindex] > 0)
    a_total_psi -= a_psi[aindex]/(a_n[aindex]*(a_n[aindex] + 1));
  a_n[aindex]++;
  if(a_total_psi != 0)
  {
    new_v = (1-beta)*a_factor*a_psi[aindex]/(a_n[aindex]*a_total_psi) +
      beta/a_num;
    adapt_tree_add(atree, aindex, new_v - atree->v[aindex]);
  }
  /* Remember initial neutron weight. */
  a_pi = p;
%}

FINALLY
%{
  int *p0;
  double *p1,*p2;
  int i;
  p0 = malloc(NUM*sizeof(int));
  p1 = malloc(NUM*sizeof(double));
  p2 = malloc(NUM*sizeof(double));
  for(i = 0; i < NUM; i++)
  {
    p0[i] = 1;
    p1[i] = atree->v[i]/atree->total;
    p2[i] = p1[i]*p1[i];
  }
  printf("Source_adapt: Total=%g\n", atree->total);
  DETECTOR_OUT_1D(
	"Adaptive source energy distribution",
	"Energy [meV]",
	"Probability",
	"E", E0 - dE, E0 + dE, NUM,
	NULL, p1, NULL, "source_adapt.dist");
  adapt_tree_free(atree);
%}
MCDISPLAY
%{
  magnify("xy");
  circle("xy",0,0,0,radius);
%}

END
