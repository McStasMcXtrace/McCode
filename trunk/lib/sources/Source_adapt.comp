/*******************************************************************************
* Focusing is only approximate (for simplicity); neutrons are also emitted to
* pass slightly above and below the focusing rectangle, more so for wider
* focusing.
*******************************************************************************/

DEFINE COMPONENT Source_adapt
DEFINITION PARAMETERS (xmin,xmax,ymin,ymax, dist, xw, yh, E0, dE, flux, N_E, N_xpos, N_xdiv, alpha, beta)
SETTING PARAMETERS ()
OUTPUT PARAMETERS (p_in, y_0, C, r_0)
STATE PARAMETERS (x,y,z,vx,vy,vz,t,s1,s2,p)
DECLARE
%{
#include "alg.h"
 double p_in;
 struct adapt_tree *atree;
 int aindex;
 double *a_psi, *a_n;
 double a_total_psi;
 double a_pi, a_num;
 double count;
 double y_0, C, r_0;
 double a_factor;
%}
INITIALIZE
%{
  int i;
  double a, lambda_min, lambda_max, delta_lambda, source_area;

  a_num = N_E*N_xpos*N_xdiv;
  lambda_min = sqrt(81.81/(E0+dE)); /* AAngstroem */
  lambda_max = sqrt(81.81/(E0-dE));
  delta_lambda = lambda_max - lambda_min;
  source_area = (xmax - xmin)*(ymax - ymin)*1e4; /* cm^2 */
  p_in = flux/mcget_ncount()*delta_lambda*source_area;
  atree = adapt_tree_init(a_num);
  a_psi = malloc(a_num*sizeof(*a_psi));
  a_n = malloc(a_num*sizeof(*a_n));
  if(!(a_psi && a_n))
  {
    fprintf(stderr, "Fatal error: out of memory.\n");
    exit(1);
  }
  for(i = 0; i < a_num; i++)
  {
    adapt_tree_add(atree, i, 1.0/a_num);
    a_psi[i] = a_n[i] = 0;
  }
  a_total_psi = 0;
  count = 0;
  y_0 = a_num > 8 ? 2.0/a_num : 0.25;
  r_0 = 1/(double)alpha*log((1 - y_0)/y_0)/(double)mcget_ncount();
  C = 1/(1 + log(y_0 + (1 - y_0)*exp(-r_0*mcget_ncount()))/(r_0*mcget_ncount()));
  printf("Source_adapt: y_0=%8.3g r_0=%8.3g C=%8.3g\n", y_0, r_0, C);
%}
TRACE
%{
  double thmin,thmax,phmin,phmax,theta,phi,E,v,r;
  double new_v;
  int i_E, i_xpos, i_xdiv;

  /* Randomly select a bin in the current distribution */
  r = rand01();
  aindex = adapt_tree_search(atree, atree->total*r);
  if(aindex >= a_num)
  {
    fprintf(stderr,
	    "Hm, aindex is %d, a_num is %d, r is %g, atree->total is %g\n",
	    aindex, (int)a_num, r, atree->total);
    aindex = a_num - 1;
  }
  /* Now find the bin coordinates. */
  i_xdiv = aindex % (int)N_xdiv;
  i_xpos = (aindex / (int)N_xdiv) % (int)N_xpos;
  i_E = (aindex / (int)N_xdiv) / (int)N_xpos;
  /* Compute the initial neutron parameters, selecting uniformly randomly
     within each bin dimension. */
  x = xmin + (i_xpos + rand01())*((xmax - xmin)/(double)N_xpos);
  y = ymin + rand01()*(xmax - xmin);
  z=0;
  thmin = atan2(-xw/2.0 - x, dist);
  thmax = atan2( xw/2.0 - x, dist);
  theta = thmin + (i_xdiv + rand01())*((thmax - thmin)/(double)N_xdiv);
  phmin = atan2(-yh/2.0 - y, dist);
  phmax = atan2( yh/2.0 - y, dist);
  phi = phmin + rand01()*(phmax - phmin);
  E = E0 - dE + (i_E + rand01())*(2.0*dE/(double)N_E);
  v = sqrt(E)*SE2V;
  vy = v*sin(phi);
  vx = v*cos(phi)*sin(theta);
  vz = v*cos(phi)*cos(theta);
  t = 0;
  /* Adjust neutron weight. */
  p = p_in;
  a_factor = y_0/(y_0 + (1 - y_0)*exp(-r_0*count));
  count++;
  p /= atree->v[aindex]/(atree->total/a_num);
  p *= C*a_factor*(thmax - thmin)*(sin(phmax) - sin(phmin));
  /* Update distribution, assuming absorbtion. */
  if(a_n[aindex] > 0)
    a_total_psi -= a_psi[aindex]/(a_n[aindex]*(a_n[aindex] + 1));
  a_n[aindex]++;
  if(a_total_psi != 0)
  {
    new_v = (1-beta)*a_factor*a_psi[aindex]/(a_n[aindex]*a_total_psi) +
      beta/a_num;
    adapt_tree_add(atree, aindex, new_v - atree->v[aindex]);
  }
  /* Remember initial neutron weight. */
  a_pi = p;
%}

FINALLY
%{
  int *p0;
  double *p1,*p2;
  int i;
  p0 = malloc(a_num*sizeof(int));
  p1 = malloc(a_num*sizeof(double));
  p2 = malloc(a_num*sizeof(double));
  for(i = 0; i < a_num; i++)
  {
    p0[i] = 1;
    p1[i] = atree->v[i]/atree->total;
    p2[i] = p1[i]*p1[i];
  }
  printf("Source_adapt: Total=%g\n", atree->total);
  DETECTOR_OUT_1D(
	"Adaptive source energy distribution",
	"Energy [meV]",
	"Probability",
	"E", E0 - dE, E0 + dE, a_num,
	NULL, p1, NULL, "source_adapt.dist");
  adapt_tree_free(atree);
%}
MCDISPLAY
%{
  magnify("xy");
  multiline(5, (double)xmin, (double)ymin, 0.0,
               (double)xmax, (double)ymin, 0.0,
               (double)xmax, (double)ymax, 0.0,
               (double)xmin, (double)ymax, 0.0,
               (double)xmin, (double)ymin, 0.0);
%}

END
