/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright 1997-2002, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Component: Virtual_tripoli4_input.comp

* %I
* Written by: <a href="mailto:guillaume.campioni@cea.fr">Guillaume Campioni</a>
* Date: Sep 28th, 2001
* Version:  $Revision: 1.3 $
* Origin: <a href="http://www.serma.cea.fr/">SERMA</a>
* Release: McStas 1.8
*
* This component uses a file of recorded neutrons from the reactor monte carlo
* code TRIPOLI4.4 as a source of particles.
*
* %D
* TRIPOLI4 is a monte carlo code for reactors (as MCNP). It is used to
* calculate flux exiting from hot or cold neutron sources. Stock files from
* TRIPOLI4.4 contains several batches of particules. Using this McStas
* component with Virtual_tripoli4_output there is no need of conversion.  As
* McStas keeps the notion of batch with this component, it's possible to
* calculate  standard deviations for the flux in differents energy groups. The
* component Virtual_tripoli4_output.comp is used to record neutrons at the end
* of the neutron guide.
*
* Format of TRIPOLI4.4 stock files is :
*
*   NEUTRON energy position_X position_Y position_Z dir_X dir_Y dir_Z weight
*
* energy is in Mega eV
* positions are in cm and the direction vector is normalized to 1.
*
* Note that axes orientation may be different between TRIPOLI4.4 and McStas
*
*
* EXAMPLE:
* To create a 'source' file collecting all neutron states, use:
* COMPONENT source_file_tripoli = Virtual_tripoli4_input(
*    file = "/home/count_durant/Mcstas/tripoli_file.stock",
*    repeat_count  = 1, verbose = 0)
*  at the position where will be the Virtual_tripoli4_input.
*
*
* %P
* INPUT PARAMETERS
* file:         (str) name of the Tripoli4.4 neutron input file,
*                     or stdin if left to 0.
* repeat_count: (1)         Number of times the source must be generated.
*                           0 unactivates the component
* verbose:      (0|1)       displays additional informations
*
* OUTPUT PATAMETERS
* head: (char) header buffer
* nl:   (long) nb of lines in header

* %L
* <a href="http://www.nea.fr/html/dbprog/tripoli-abs.html">Tripoli</a>
* Virtual_tripoli4_output
*
* %E
*
*******************************************************************************/

DEFINE COMPONENT Virtual_tripoli4_input
DEFINITION PARAMETERS (file=0)
SETTING PARAMETERS (repeat_count=1, verbose=0)
OUTPUT PARAMETERS (hfile,head,nl,rep,begin_of_file,num_batch)
STATE PARAMETERS (x,y,z,vx,vy,vz,t,s1,s2,p)
POLARISATION PARAMETERS (sx, sy, sz)

SHARE
%{
#ifndef TRIPOLI4_INPUT_DEFS
#define TRIPOLI4_INPUT_DEFS
/* define Tripoli File parsing functions */
#define WORDSIZE 256
/* functions to identify Tripoli keywords */
int begin_of_batch(const char * word )
{
  return strcmp(word,"BEGIN_OF_BATCH")==0?1:0;
}
int end_of_batch(const char * word)
{
  return strcmp(word,"END_OF_BATCH")==0?1:0;
}
int is_neutron(const char * word)
{
  return strcmp(word,"NEUTRON")==0?1:0;
}

/* tripoli_read_word:
   function that reads iteratively words in the file
   returns  EOF or last character
   word[0..l-1]
 */
int tripoli_read_word(FILE *hfile,char *word){
  char c;
  int  i=0;

  while((c=fgetc(hfile))!=EOF && isspace(c)){}

  if(c!=EOF){
    word[i++]=c;
    while((c=fgetc(hfile))!=EOF && i < WORDSIZE){
    if(isspace(c))break;
      word[i++]=c;}
    }
    word[i]='\0';
  return c;
}

/* tripoli_create_neutron:
   function that reads values following the NEUTRON keyword
   and assigns neutron parameters
 */
int tripoli_create_neutron(FILE *hfile, double *x,double *y,double *z,
                                 double *vx, double *vy, double *vz,
                                 double *t,
                                 double *sx, double *sy, double *sz,
                                 double *p)
{
  double Mev2Joule=1.602e-13;
  double speed;
  int    exit_flag=0, ifield=0;
  char   word[WORDSIZE];
  double field[8];

  while(ifield<8){
    if(tripoli_read_word(hfile,word)==EOF) { exit_flag=1; goto abnormal; };
    field[ifield++]=strtod(word,NULL);
  }
  if(field[0]<0){ exit_flag=1; goto abnormal;}
  speed=sqrt(2.* field[0]*Mev2Joule/MNEUTRON);
  *x=field[1]/100.;
  *y=field[2]/100.;
  *z=field[3]/100.;
  *vx=field[4]*speed;
  *vy=field[5]*speed;
  *vz=field[6]*speed;
  *p=field[7];
  *sx=1.;*sy=*sz=0;
  *t=0;
 abnormal:
  return (exit_flag);
}
/* tripoli_get_header:
   function that gets header lines until the Tripoli start of a batch
 */
char **tripoli_get_header(FILE *hfile,long *nl){
  int i;
  char **head;
  char   word[WORDSIZE];

  *nl=0;
  fgets(word,WORDSIZE,hfile);
  while(strncmp(word,"BEGIN_OF_BATCH",14)!=0){
    fgets(word,WORDSIZE,hfile);
    (*nl)++;
  }
  rewind(hfile);
  head=(char **)calloc(*nl,sizeof(char *));
  for(i=0;i<*nl;++i){
    fgets(word,WORDSIZE,hfile);
    head[i]=(char *)malloc(WORDSIZE);
    strcpy(head[i],word);
  }
  rewind(hfile);
  return head;
}

//#undef WORDSIZE
#endif

%}

DECLARE
%{

  int   rep=1;                        /* Neutron repeat count */
  FILE *hfile;                    /* Neutron input file handle */
  char **head;                   /*Tripol4 header*/
  long  nl;                       /* Number of lines in header*/
  long  begin_file=0;
  long  num_batch =0, nbatch=0;
%}

INITIALIZE
%{
  char  word[WORDSIZE];
  char  exit_flag=0;  /* set to 1 if end of simulation */
  int   result_read;
  double mean_x =0, mean_y =0, mean_z =0;
  double mean_vx=0, mean_vy=0, mean_vz=0;
  double min_x = FLT_MAX, min_y = FLT_MAX, min_z = FLT_MAX;
  double max_x =-FLT_MAX, max_y =-FLT_MAX, max_z =-FLT_MAX;
  double min_vx= FLT_MAX, min_vy= FLT_MAX, min_vz= FLT_MAX;
  double max_vx=-FLT_MAX, max_vy=-FLT_MAX, max_vz=-FLT_MAX;
  double n_neutrons=0, n_batches=0;

 /* Open neutron input file. */
  if(file)
    hfile = fopen(file, "r");
  else {
    hfile = stdin;
    if (repeat_count > 1) {
      fprintf(stderr, "Virtual_tripoli4_input: %s: Warning: Cannot repeat 'stdin'. Setting single shot (repeat_count=1).\n", NAME_CURRENT_COMP);
      repeat_count = 1;
    }
  }
  if(!hfile)
  {
    fprintf(stderr, "Virtual_tripoli4_input: %s: Error: Cannot open input file.\n", NAME_CURRENT_COMP);
    exit(1);
  } else if (verbose)
    printf("Virtual_tripoli4_input: %s: opening Tripoli4 file '%s'.\n",NAME_CURRENT_COMP,(file ? file : "stdin"));

  head = tripoli_get_header(hfile, &nl);

  while (tripoli_read_word(hfile,word) != EOF) {
    /* store position of first batch in file for repeat */
    begin_file=ftell(hfile);
    if (begin_of_batch(word)) {
      if (tripoli_read_word(hfile,word)!=EOF) {
        num_batch=strtol(word,NULL,0);
        break;
      }
    }
  }

  if (hfile != stdin) {
    if (verbose) printf("Virtual_tripoli4_input: %s: Analysing Tripoli4 file %s.\n", NAME_CURRENT_COMP, file);
    /* analyse Tripoli file: count neutrons, get beam center and mean speed */
    while (!exit_flag) {
      result_read=tripoli_read_word(hfile,word);

      if (is_neutron(word)) {  /* if key word NEUTRON is found */
        double x,y,z,vx,vy,vz,t,p,sx,sy,sz;
        if (tripoli_create_neutron(hfile,&x,&y,&z,&vx,&vy,&vz,&t,&sx,&sy,&sz,&p)) {
          fprintf(stderr, "Virtual_tripoli4_input: %s: Error: Cannot get neutron in batch %d.\n",NAME_CURRENT_COMP,num_batch);
          exit_flag = 1;
        } else {
          n_neutrons++;
          mean_x  += x;  mean_y  += y;  mean_z  += z;
          mean_vx += vx; mean_vy += vy; mean_vz += vz;
          if (x  < min_x)  min_x  = x;
          if (y  < min_y)  min_y  = y;
          if (z  < min_z)  min_z  = z;
          if (vx < min_vx) min_vx = vx;
          if (vy < min_vy) min_vy = vy;
          if (vz < min_vz) min_vz = z;
          if (x  > max_x)  max_x  = x;
          if (y  > max_y)  max_y  = y;
          if (z  > max_z)  max_z  = z;
          if (vx > max_vx) max_vx = vx;
          if (vy > max_vy) max_vy = vy;
          if (vz > max_vz) max_vz = z;
        }
        break;
      }

      if (end_of_batch(word)) {  /* if key word END_OF_BATCH is found */
        if (tripoli_read_word(hfile,word) != EOF) {
        /* this is the number of finisshing batch */
          nbatch=strtol(word,NULL,0);
          if (nbatch!=num_batch) {
          /* finishing batch does not match the one we were reading ! */
             if (verbose) fprintf(stderr, "Virtual_tripoli4_input: %s: Warning: inconsistent batch numbers between END(%d) and BEGIN(%d).\n",NAME_CURRENT_COMP,nbatch,num_batch);
          }
        }
        else {
         fprintf(stderr, "Virtual_tripoli4_input: %s: Expect 'END_OF_BATCH', found '%s' (after batch %d).", word, num_batch);
          exit_flag = 1;
        }
      }

      if (begin_of_batch(word)){/* if key word BEGIN_OF_BATCH is found */
        if (tripoli_read_word(hfile,word) != EOF) {
          num_batch=strtol(word,NULL,0);
          n_batches++;
        }
        else {
          fprintf(stderr, "Virtual_tripoli4_input: %s: Expect 'BEGIN_OF_BATCH', found '%s' (after batch %d).", word, num_batch);
          exit_flag = 1;
        }
      }

      if (result_read==EOF) {  /* normal end of file */
        exit_flag=1;
      }
    } /* end while */
    if (n_neutrons) {
      mean_x  /= n_neutrons;
      mean_y  /= n_neutrons;
      mean_z  /= n_neutrons;
      mean_vx /= n_neutrons;
      mean_vy /= n_neutrons;
      mean_vz /= n_neutrons;
      if (verbose) {
        double mean_v, mean_k, mean_w=0, mean_L=0;
        mean_v = (mean_vx+mean_vy+mean_vz)/3;
        mean_k = V2K*mean_v;
        if (mean_k) mean_L = 2*PI/mean_k;
        mean_w = VS2E*mean_v*mean_v;
        printf("Tripoli4 file %s: %g neutrons in %d batches\n", file, n_neutrons, n_batches);
        printf("  Source size (full width in [cm]):");
        printf("    X:%g Y:%g Z:%g\n", max_x-min_x, max_y-min_y, max_z-min_z);
        printf("  Source center (in [cm]):");
        printf("    X:%g Y:%g Z:%g\n", mean_x, mean_y, mean_z);
        printf("  Beam divergence (full width in [deg]):\n");
        printf("    dX:%g dY:%g dZ:%g\n",
          atan2(max_vx-min_vx, mean_v)*RAD2DEG,
          atan2(max_vy-min_vy, mean_v)*RAD2DEG,
          atan2(max_vz-min_vz, mean_v)*RAD2DEG);
        printf("  Beam mean energy:\n");
        printf("    speed:%g [m/s] energy:%g [meV] wavelength:%g [Angs] wavevector:%g [Angs-1]\n", mean_v, mean_w, mean_L, mean_k);
      }
      mcset_ncount(n_neutrons*repeat_count);
    } else {
      fprintf(stderr, "Virtual_tripoli4_input: %s: Error: file %s neutrons does not contains any neutron. \n",NAME_CURRENT_COMP, file);
      exit(-1);
    }
    /* reposition for file reading */
    if (fseek(hfile, begin_file,SEEK_SET))
      fprintf(stderr, "Virtual_tripoli4_input: %s: Warning: Can not reset Tripoli4 file (fseek error at analyze). \n",NAME_CURRENT_COMP);

  } /* end if hfile: end analysis */

  num_batch = 0;

%}

TRACE
%{
  char exit_flag=0;  /* set to 1 if end of simulation */
  int result_read;
  char  word[WORDSIZE];

  while(1) {

  result_read=tripoli_read_word(hfile,word);

  if (is_neutron(word)) {  /* if key word NEUTRON is found */
    if (tripoli_create_neutron(hfile,&x,&y,&z,&vx,&vy,&vz,&t,&sx,&sy,&sz,&p)) {
      exit_flag = 1;
    }
    break;
  }

  if (end_of_batch(word)) {  /* if key word END_OF_BATCH is found */
    if (tripoli_read_word(hfile,word) != EOF) {
    /* this is the number of finisshing batch */
      nbatch=strtol(word,NULL,0);
      if (verbose) printf("Virtual_tripoli4_input: %s: End Batch Number %d \n",NAME_CURRENT_COMP,nbatch);
    }
    else exit_flag = 1;
  }

  if (begin_of_batch(word)){/* if key word BEGIN_OF_BATCH is found */
    if (tripoli_read_word(hfile,word) != EOF) {
      num_batch=strtol(word,NULL,0);
      if (verbose) printf("Virtual_tripoli4_input: %s: Start Batch Number %d\n",NAME_CURRENT_COMP,num_batch);
    }
    else exit_flag = 1;
  }

  if (result_read==EOF) {  /* normal end of file */
    rep++;
    if (rep < repeat_count) {
      /* reposition at start of file (batch start) */
     int ret = fseek(hfile, begin_file,SEEK_SET);
      if (ret) {
        fprintf(stderr, "Virtual_tripoli4_input: %s: Error: Can not repeat Tripoli4 file (fseek error at repeat %d). \n",NAME_CURRENT_COMP, rep);
        exit_flag = 1;
      }
      result_read = tripoli_read_word(hfile,word); /* should be batch start */
      num_batch=strtol(word,NULL,0);
      if (verbose) printf("Virtual_tripoli4_input: %s: Start Batch Number %d (iteration %d)\n",NAME_CURRENT_COMP,num_batch, rep);
    }
    else exit_flag=1;
  }

  if (exit_flag) { mcset_ncount(mcget_run_num()); ABSORB; }

} /* end while */


%}

FINALLY
%{
  if (head)  free(head);
  if (hfile) fclose(hfile);
%}

END

