/*******************************************************************************
 *
 * McStas, neutron ray-tracing package
 *         Copyright 1997-2003, All rights reserved
 *         Risoe National Laboratory, Roskilde, Denmark
 *         Institut Laue Langevin, Grenoble, France
 *
 * Component: ISIS_moderator
 *
 *
 * %I
 * Written by: S. Ansell and D. Champion
 * Date: August 2004
 * Version: $Revision: 1.2 $
 * Origin: ISIS
 * Release: McStas 1.8
 *
 * ISIS Moderators
 *
 * %D
 * Produces a TS1 or TS2 ISIS moderator distribution.  The Face argument determines which moderator
 * is to be sampled. Each face uses a different Etable file (the location of which is determined by
 * the MCTABLES environment variable).  Neutrons are created having a range of energies 
 * determined by the E0 and E1 arguments.  Trajectories are produced such that they pass
 * through the moderator face (defined by modXsixe and modYsize) and a focusing rectangle 
 * (defined by xh,yh and dist).  Please download the documentation for precise instructions for use.
 *
 * Example:   ISIS_moderator(Face ="water", E0 = 49.0,E1 = 51.0, dist = 1.0, xw = 0.01,
 *    yh = 0.01, modXsize = 0.074, modYsize = 0.074, CAngle = 0.0,SAC= 1)
 *
 * %P
 * INPUT PARAMETERS:
 *
 * Face:   (word) Name of the face - TS2:groove,hydrogen,narrow,broad -
 *                                 - TS1:Water,ch4,h2,merlin or instrument name eg maps, crisp etc. 
 *                                 - TS2: W1-9 E1-9
 * E0:     (meV) Lower edge of energy distribution
 * E1:     (meV) Upper edge of energy distribution
 * dist:   (m)   Distance from source to the focusing rectangle
 * xw:     (m)   Width of focusing rectangle
 * yh:     (m)   Height of focusing rectangle
 * modXsize: (m)  Moderator vertical size
 * modYsize: (m)  Moderator Horizontal size
 * CAngle: (radians)  Angle from the centre line
 * SAC:    (boolean)  Apply solid angle correction or not (1/0)
 *
 * %L
 * Further <A HREF="http://www.isis.rl.ac.uk/Computing/Software/MC/index.htm">information</A> should be
 * downloaded from the ISIS MC website.
 * %E
 *
 *
 *
 *
 *
 *******************************************************************************/

DEFINE COMPONENT ISIS_moderator
DEFINITION PARAMETERS (Face)
SETTING PARAMETERS (E0, E1,dist,xw,yh,modXsize,modYsize,CAngle,SAC)
STATE PARAMETERS (x,y,z,vx,vy,vz,t,s1,s2,p)
POLARISATION PARAMETERS (sx,sy,sz)
DECLARE
%{

#include <ctype.h>
  /* New functions */
  double Epass();
  double Ezone(double);
  int Tpass(double);
  int Ipass(double);
  void polcof(double*,double*,double*);
  double polValue(int,double);
  double polInterp(double);
  double findValue(double*,double,double);
  double findMax(double*);
  void writeMidQuad(int);
  void calcQcomp(int,double*,double*,double*);
  double findTime(double*);
  double Tprob(double*,double);
  int cmdnumberD(char *,double*,const int);
  int cmdnumberI(char *,int*,const int);
  FILE* openFile(char*);
  double strArea();


  double p_in;            /* Polorization term (from McSTAS) */ 
  int Tnpts;              /* Number of points in parameteriation */
  int Einc;               /* Number of points in energy seperated total (E0-E1) */
  double scaleSize;        /* correction for the actual area of the moderator viewed */
  double eCol[200],vCol[200],iCol[200];
  double eTotal;          /* the Intgrated intensity at the max Energy (E1) */
  double angleArea;       /* Area seen by the window  */

  double eRange[500];     /* list of the energies in the table */
  double Param[500][4];   /* Table param ,g1,g2,maxVal,Tcut */ 
  double iBase[500];      /* List is integrated intensity from energy =0.0 -> Etable max.  */  
  double reBase;          /* Value of the IBase at E0 */
  int Ncount;             /* Count of number of points run */

  /* runtime variables*/

  double rtE0,rtE1;       /* runtime Energy minima and maxima so we can use angstroms as negative input */
  double rtmodX,rtmodY;    /* runtime moderator sizes, so that a negative argument may give a default size */


  int
    cmdnumberD(char *mc,double* num,const int len)
    /* returns 1 on succe/Software/MC/index.htmss and 0 on failure */
    {
      int i,j;
      char* ss;
      char **endptr;
      double nmb;
    
      if (len<1) 
	return 0;
      j=0;
    
      for(i=0;i<len && mc[i] && 
	    (mc[i]=='\t' || mc[i]==' '  || mc[i]==',');i++);
      if(i==len || !mc[i]) return 0;
      ss=malloc(sizeof(char)*(len+1));
      /*  char *ss=new c/Software/MC/index.htmhar[len+1]; */
      for(;i<len && mc[i]!='\n' && mc[i] 
	    && mc[i]!='\t' && mc[i]!=' ' && mc[i]!=',';i++)
	{
	  ss[j]=mc[i];
	  j++;
	}
      if (!j)
	{ 
	  free(ss);
	  return 0;         //This should be impossible
	}
      ss[j]=0;
      endptr=malloc(sizeof(char*));
      nmb = strtod(ss,endptr); 
      if (*endptr != ss+j)
	{
	  free(endptr);
	  free(ss);
	  return 0;
	}
      *num = (double) nmb;
      for(j=0;j<i && mc[j];j++)
	mc[j]=' ';
      free(endptr);
      free(ss);
      return 1;
    }

  int
    cmdnumberI(char *mc,int* num,const int len)
    /* returns 1 on success and 0 on failure */
    {
      int i,j;
      char* ss;
      char **endptr;
      double nmb;
      
      if (len<1) 
	return 0;
      j=0;
      
      for(i=0;i<len && mc[i] && 
	    (mc[i]=='\t' || mc[i]==' '  || mc[i]==',');i++);
      if(i==len || !mc[i]) return 0;
      ss=malloc(sizeof(char)*(len+1));
      /*  char *ss=new char[len+1]; */
      for(;i<len && mc[i]!='\n' && mc[i] 
	    && mc[i]!='\t' && mc[i]!=' ' && mc[i]!=',';i++)
	{
	  ss[j]=mc[i];
	  j++;
	}
      if (!j)
	{ 
	  free(ss);
	  return 0;         //This should be impossible
	}
      ss[j]=0;
      endptr=malloc(sizeof(char*));
      nmb = strtod(ss,endptr); 
      if (*endptr != ss+j)
	{
	  free(endptr);
	  free(ss);
	  return 0;
	}
      *num = (double) nmb;
      for(j=0;j<i && mc[j];j++)
	mc[j]=' ';
      free(endptr);
      free(ss);
      return 1;
    }

  double Epass()
    /*
      This uses a binary search to find the energy point within the system of the 
      system (searches in the selected range rtE0->rtE1) 
    
    */
    {
      double x;
      x=-1.0;
      while (x<rtE0 || x>rtE1)
	{
	  x=rand01()*eTotal;            /* Select a value between 0->maxIntensity */
	  x=polInterp(x);                     /* calc the Energy corresponding to that i */
	} 
      return x;
    }

  double Ezone(double x)
    /*
      This uses a binary search to find the energy point within the system of the 
      system 
    */
    {
      double oE;
      oE=polInterp(x);
      return oE;
    }

  double polInterp(double intensity) 
    /* returns the interpolated polynominal between iBase */
    {
      int idx;
      double* X;                /* coordinate of iBase and eRange */
      double* Y;
      double aim;

      double out,errOut;         /* out put variables */
      double C[4],D[4];
      double testDiff,diff;

      double w,den,ho,hp;           /* intermediate variables */
      int i,m,ns;

      aim=intensity+reBase;         /* renormalise */
      idx=Ipass(aim);
      if (idx<2)
	idx=2;

      Y=eRange+idx-2;      /* note the swap */
      X=iBase+idx-2;
  
      ns=0;
      diff=fabs(aim-X[0]);
      C[0]=Y[0];
      D[0]=Y[0];
      for(i=1;i<4;i++)
	{
	  testDiff=fabs(aim-X[i]);
	  if (diff>testDiff)
	    {
	      ns=i;
	      diff=testDiff;
	    }
	  C[i]=Y[i];
	  D[i]=Y[i];
	}
  
      out=Y[ns];
      ns--;              /* Now can be -1 !!!! */ 

      for(m=1;m<4;m++)
	{
	  for(i=0;i<4-m;i++)
	    {
	      ho=X[i]-aim;
	      hp=X[i+m]-aim;
	      w=C[i+1]-D[i];
	      /*	  den=ho-hp;  -- test !=0.0 */
	      den=w/(ho-hp);
	      D[i]=hp*den;
	      C[i]=ho*den;
	    }

	  errOut= (2*(ns+1)<(4-m)) ? C[ns+1] : D[ns--];
	  out+=errOut;
	}
      return out;
    }

 
  void writeMidQuad(int N)
    {
      int i;
      double yv,xv,step;
      FILE* ofile;


      step=eTotal/N;
      xv=0.0;
      ofile=fopen("MidValue.dat","w");
      fprintf(stderr,"Opened MidValue\n");
      for(i=0;i<N;i++)
	{
	  yv=Ezone(xv);
	  fprintf(ofile,"%12.6g %12.6g\n",yv,xv);
	  xv+=step;
	}   
      fclose(ofile);
      return;
    }

 
  int 
    Tpass(double Eval)
    /* Given an energy Eval it determine the Erange
       bin between which Eval fits. Erange[out-1]<Eval<Erange[out]
    */
    {
      int i,low,high;
      i=Tnpts/2;
      low=0;
      high=Tnpts;
      while(eRange[i-1]>Eval || Eval>eRange[i])
	{
	  if (Eval<eRange[i-1])
	    {
	      high=i;
	      i=(low+i)/2;
	    }
	  else
	    {
	      low=i;
	      i=(high+i)/2;
	    }
	}
      if (i<1)
	{
	  fprintf(stderr, "return LOW BOUNDARY TPass %g %g\n",Eval,eRange[i]);
	  i=1;
	}
      return i;
    }

  int 
    Ipass(double NValue)
    /* Given an intensity NValue it determine the Erange / Ibase
       bin between which Nvalue fits. iBase[out-1]<NValue<iBase[out]
    */
    {
      int i,low,high;
      i=Tnpts/2;
      low=0;
      high=Tnpts;
      while(iBase[i-1]>NValue || NValue>iBase[i])
	{
	  if (NValue<iBase[i-1])
	    {
	      high=i;
	      i=(low+i)/2;
	    }
	  else
	    {
	      low=i;
	      i=(high+i)/2;
	    }
	}
      if (i<1)
	{
	  fprintf(stderr, "return LOW BOUNDARY IPass %g %g\n",NValue,iBase[i]);
	  i=1;
	}
      return i;
    }

  FILE* openFile(char* FileName)
    {

  
      FILE* efile=0;
      char ss[256];
      char mct[256];
      char mcdir[256];
  
      /* Is the file located in working dir? */
      efile=fopen(FileName,"r");
      if (!efile) {
	/* Is the file in a local 'tablefiles' folder? */
	sprintf(ss,"%s%c%s%c%s", ".", MC_PATHSEP_C, "ISIS_tables", MC_PATHSEP_C, FileName);
	efile=fopen(ss,"r"); 
	fprintf(stderr,"Searching -- %s\n",ss);
      }
      if (!efile) {
	/* Is MCTABLES set, files located there? */
	if (getenv("MCTABLES")) {
	  strcpy(mct, getenv("MCTABLES"));
	  sprintf(ss, "%s%c%s", mct, MC_PATHSEP_C, FileName);
	  efile=fopen(ss,"r");  
	  fprintf(stderr,"Searching -- %s, MCTABLES directory\n",ss);         
	}
      }
      if (!efile) {
	/* Try locating the file in the MCSTAS contrib library */
	if (getenv("MCSTAS")) strcpy(mcdir, getenv("MCSTAS"));
	else strcpy(mcdir, MCSTAS); /* Get from the define symbol */
	sprintf(ss, "%s%c%s%c%s%c%s", mcdir, MC_PATHSEP_C,"contrib", MC_PATHSEP_C, "ISIS_tables", MC_PATHSEP_C, FileName);
	efile=fopen(ss,"r");
	fprintf(stderr,"Searching -- %s, MCSTAS contrib library\n",ss);
      }
      if (!efile) { /* Still no file - die! */
	fprintf(stderr,"Fatal: Could not read Etable file %s from:\n.\n.%ctablefiles\n%s%ccontrib%cISIS_tables\nor using MCTABLES...\n", FileName, MC_PATHSEP_C, mcdir, MC_PATHSEP_C, MC_PATHSEP_C);
	fprintf(stderr,"\nPlease check your McStas installation and/or MCTABLES environment variable!\n");
	exit(1);
      }
      return efile;
    }


  int processLine(char* sLine,double* Eread,double* Iread)
    /* reads a line from the Etable file 
       returns 1 if the line is good 
       Updates: (counter) Tnpts 
       iBase,Param,eRange
         
    */
    {
      double evalue,P1,P2,mvalue,tcut,la;      
      int ix;
      if (sLine[0]=='#')                                        /* # is a comment in the file */
	return 0;
  
      ix=cmdnumberD(sLine,&evalue,254);                     /* Read Energy  */ 
      ix+=cmdnumberD(sLine,&la,254);                        /* Read wavelength (discard) */ 
      ix+=cmdnumberD(sLine,&P1,254);                        /* Read gm[1] */ 
      ix+=cmdnumberD(sLine,&P2,254);                        /* Read gm[2] */ 
      ix+=cmdnumberD(sLine,&mvalue,254);                    /* Read maxVal */ 
      ix+=cmdnumberD(sLine,&tcut,254);                      /* Read TimeCut */ 
      ix+=cmdnumberD(sLine,Iread,254);                      /* Intensity */ 
      if (ix!=7)                                            /* Failed to read line */
	return 0; 
      eRange[Tnpts]=evalue*1000.0;                          /* Scale energy into meV */ 
      *Eread=1000.0*evalue;
      Param[Tnpts][0]=P1;
      Param[Tnpts][1]=P2;
      Param[Tnpts][2]=mvalue;                               /* THIS SHOULD BE RECALC HERE !!!! */
      Param[Tnpts][3]=tcut;
      iBase[Tnpts]=(Tnpts>0) ? *Iread+iBase[Tnpts-1] : *Iread; 
      Tnpts++;
      return 1;
    }

  int readEtable(FILE* eFile)
    /* Reads the table give into the main global arrays */ 
    {
      double *eC,*iC;         /* pointers to save some typing */
      double lastE,tmp;
      Einc=1;                 /* Entry in the array table        */
      vCol[0]=0.0;            /* neutrons in energy bin          */ 
      eCol[0]=rtE0;             /* end Energy of bin               */ 
      iCol[0]=0.0;            /* integrated neutron is bins to this point */
      lastE=0.0;              /* previous energy used */
      char ss[256];           /* Dump space for line */
      double eV,vT;           /* Variables for process line to return energy and intensity */
      double scale;           /* Temp holding variable for position betwene energies */ 
      int j;                  /* loop counter */




      while(lastE<rtE1)                            // File test here ....
	{
	  if (!fgets(ss,255,eFile))                                   /* read line from file */
	    {
	      fprintf(stderr,"Error with file beyond %f",rtE1);
	      exit(1);
	    }
	  if (processLine(ss,&eV,&vT))                             /* Can we process the line properly */
	    {
	      if (eV>rtE0)
		{
		  if (eV>rtE1)
		    {
		      scale=(rtE1-eCol[Einc-1])/(eV-lastE);
		      eCol[Einc]=rtE1;
		      vCol[Einc]=scale*vT;
		      iCol[Einc]=scale*vT+iCol[Einc-1];
		      fprintf(stderr,"iCol(last) == %g:%g\n",eCol[Einc],iCol[Einc]);
		    }
		  else 
		    {
		      scale=(eV-eCol[Einc-1])/(eV-lastE);
		      eCol[Einc]=eV;
		      vCol[Einc]=scale*vT;
		      iCol[Einc]=scale*vT+iCol[Einc-1];
		      fprintf(stderr,"iCol(mid) == %g:%g\n",eCol[Einc],iCol[Einc]);
		    }		  
		  Einc++;
		} 
	      lastE=eV;
	    }
	}
      eTotal=iCol[Einc-1];

      if(Einc > 2)
	{
	  reBase=iBase[1+Tnpts-Einc]-iCol[1];      /* Value up to rtE0 (Einc starts from 1) */ 
	}
      else
	{
	  eC=eRange+Tnpts-Einc;        //pointer arithmetic to a place in eRange array
	  scale=(rtE0-*eC)/(*(eC+1)-*eC); //need to calculate new scale
	  fprintf(stderr,"scale=%g ",scale);
	  iC=iBase+Tnpts-Einc;        //pointer arithmetic to a place in iBase array
	  reBase= *iC*(1-scale)+*(iC+1)*scale; 
	  fprintf(stderr,"eC=%g iC==%g ",*eC,*iC);
	}
      fprintf(stderr,"rebase= %g \n",reBase);
      //  exit(1);


      if (Tnpts<2 || Einc<2)
	{
	  fprintf(stderr, "Cannot read the sufficient Param file %d :: %d \n",Tnpts,Einc);
	  exit(1);
	}
      /* Get 3 extra points for the iBase and eRange table (used in Quad fit) */
      fgets(ss,255,eFile);                    /* read extra line from file */
      for(j=0;j<3 && processLine(ss,&eV,&vT);j++)
	fgets(ss,255,eFile);                  /* read line from file */

      return Tnpts;
    }

  double findMax(double* gm)
    {
      /* Gets max from modfunction */
      double tlow,tmid,thigh,vlow,vmid,vhigh;
      double ttest,vtest;
      int cnt;

      tlow=0.0;
      thigh=1e-3;
      vlow=0.0;
      vhigh=Tprob(gm,thigh);
      cnt=0;
      while(vhigh==0.0 && cnt<50)
	{  /*  switch (toupper(Face[0]))*/
	  thigh/=2.0;
	  vhigh=Tprob(gm,thigh);
	  cnt++;
	}
      if (cnt==50)
	return 0.0;

      tmid=(tlow+thigh)/2.0;
      vmid=Tprob(gm,tmid);
      cnt=0;
  
      while((thigh-tlow)>1e-12 && cnt<100)
	{
	  cnt++;
	  if (vhigh>vlow)
	    {
	      ttest=(tlow+tmid)/2.0;
	      vtest=Tprob(gm,ttest);
	      if (vtest<vmid)
		{
		  vlow=vtest;
		  tlow=ttest;
		}
	      else
		{
		  vhigh=vmid;
		  thigh=tmid;
		  vmid=vtest;
		  tmid=ttest;
		}
	    }
	  else
	    {
	      ttest=(thigh+tmid)/2.0; 

	      vtest=Tprob(gm,ttest);
	      if (vtest<vmid)
		{
		  vhigh=vtest;
		  thigh=ttest;
		}
	      else
		{
		  vlow=vmid;
		  tlow=tmid;
		  vmid=vtest;
		  tmid=ttest;
		}
	    }
	}
      return tmid;
    }
 
  double 
    findTime(double* P)
    /* 
       Calculates the time, use param [3] == max time 
       param[2] == max values (used in Tprob)) 
    */
    {
      double ttest,res,tp,maxT;
      double scale;

      //  *TW= 1.0;

      maxT=P[3];
      ttest=rand01();
      if (ttest>0.99 && maxT<1e-3)
	{
	  ttest=rand01()*(1e-3-maxT);
	  ttest+=maxT;
	  tp=Tprob(P,ttest);
	  tp*=100.0;
	}
      else
	{
	  ttest*=maxT/0.99;
	  tp=Tprob(P,ttest);
	}


      //  for(i=0;i<4;i++)
      //    fprintf(stderr,"%12.6g ");
      //  fprintf(stderr,"\n");


      res=rand01();

      while(tp<res)
	{
	  ttest=rand01();
	  if (ttest>0.99 && maxT<1e-3)
	    {
	      ttest=rand01()*(1e-3 -maxT);
	      ttest+=maxT;
	      tp=Tprob(P,ttest);
	      tp*=100.0;
	    }
	  else
	    {
	      ttest*=maxT/0.99;
	      tp=Tprob(P,ttest);
	    }
	  res=rand01();
	}

      //*TW=1.0;
    
      if (tp>1)
	{
	  fprintf(stderr,"Boundary condition >1 == %g %g from %g \n",maxT,ttest,tp);
	  return -ttest;
	}
      return ttest;
    }



  double findValue(double* gm,double vmax,double tstart)
    /*  Gets a value from modfunction
	Between tstart and the end */
    {
      double tlow,thigh,vlow,vhigh;
      double tmid,vmid,vtest,ttest;
      int cnt;

      if (tstart<0.0)
	tstart=0.0;
      if (vmax==0.0)
	return 0.0;  
      tlow=tstart;     //OUTPUT PARAMETERS (modXsize)

      thigh=1e-3;     // start pnt at 1e-3 sec.
      vlow=Tprob(gm,tlow);        
      vhigh=Tprob(gm,thigh);        
      if (vlow>vhigh)
	{
	  vtest=vhigh;
	  vhigh=vlow;
	  vlow=vtest;
	  ttest=thigh;
	  thigh=tlow;
	  tlow=ttest;
	}
      if (vhigh<vmax || vlow>vmax)
	{
	  return tlow;
	}
    
    
      cnt=0;
      while((vhigh-vlow)/(vhigh+vlow)>1e-3 && cnt<100)
	{
	  ttest=(tlow+thigh)/2.0;
	  vtest=Tprob(gm,ttest);
	  if (vtest>vmax)
	    {
	      vhigh=vtest;
	      thigh=ttest;
	    }
	  else
	    {
	      vlow=vtest;
	      tlow=ttest;
	    }
	}
      return (thigh+tlow)/2.0;
    }


  double strArea()
    {
      /* 
	 Returns the mean Str view of the viewport 
	 This integrates over each point on the window xw to yh 
	 View port is symmetric so use only 1/4 of the view 
	 Control Values rtmodY rtmodX xw yh
                    
      */
  
      double A;
      double Vx,Vy;        // view temp points
      double Mx,My;        // moderator x,y
      double D2;           // Distance ^2 
      int i,j,aa,bb;       // loop variables 

      D2=dist*dist;
      A=0.0;  

      for(i=0;i<50;i++)              // Mod X
	{
	  Mx=i*rtmodX/100.0;
	  for(j=0;j<50;j++)         // Mod Y
	    {
	      My=j*rtmodY/100.0;
	      for(aa=-50;aa<51;aa++)
		for(bb=-50;bb<51;bb++)
		  {
		    Vx=aa*xw/101.0;
		    Vy=bb*yh/101.0;
		    A+=1.0/((Mx-Vx)*(Mx-Vx)+(My-Vy)*(My-Vy)+D2);
		  }
	    }
	}

      A*=(xw*yh)/(10101.0*2500.0);
      fprintf(stderr,"Viewport == %g %g Moderator size == (%g * %g) m^2 \n",xw,yh,rtmodX,rtmodY);
      fprintf(stderr,"Dist == %g (metres) \n",dist);
      fprintf(stderr,"Viewport Solid angle == %g str\n",A);
      return A;
    }



  double Tprob(double* P,double x)
    {
      /*  Parameters are ::
	  P[3]=max time
	  P[2]= Integration factor (normalisation to 1)
	  P[0]=t2
	  P[1]=tln
	  EQN val(t)=(1-exp(-t^2/t2^2))*exp(-t/t_ln)
      */
  
      double l1,l2;
  
      l1= -(x*x)/(P[0]*P[0]);
      if (l1>-50)
	l1=1.0-exp(l1);
      else
	l1=1.0;
      l2= -x/fabs(P[1]);
      if (l2>-50)
	l2=exp(l2);
      else
	return 0.0;
#ifdef StuDEBUG
      if (l1*l2/P[2]>1.0)
	fprintf(stderr,"Fraction == %f %f %f %f %f %f\n",x,l1*l2/P[2],P[0],P[1],P[2],P[3]);
#endif
      return l1*l2/P[2];
    }

  %}

INITIALIZE
%{
  /* READ IN THE ENERGY FILE */

  int table;         /* Variables */
  char fname[256];
  FILE* Tfile;
  double tmp;
  char lowerFace[255];
  int Bcnt;
  int i;
  struct BeamLine
    {
      char Name[50];
      double Xsize;
      double Ysize;
    } Olist[50];

  Bcnt=0;
  // CH4 face 1 (north)
  strcpy(Olist[Bcnt].Name,"mari"); Olist[Bcnt].Xsize=0.12; Olist[Bcnt].Ysize=0.115; Bcnt++;
  strcpy(Olist[Bcnt].Name,"gem"); Olist[Bcnt].Xsize=0.12; Olist[Bcnt].Ysize=0.115; Bcnt++;
  strcpy(Olist[Bcnt].Name,"hrpd"); Olist[Bcnt].Xsize=0.12; Olist[Bcnt].Ysize=0.115; Bcnt++;
  strcpy(Olist[Bcnt].Name,"pearl"); Olist[Bcnt].Xsize=0.12; Olist[Bcnt].Ysize=0.115; Bcnt++;
  // CH4 face 2 (south)
  strcpy(Olist[Bcnt].Name,"sandals"); Olist[Bcnt].Xsize=0.12; Olist[Bcnt].Ysize=0.115; Bcnt++;
  strcpy(Olist[Bcnt].Name,"prisma"); Olist[Bcnt].Xsize=0.12; Olist[Bcnt].Ysize=0.115; Bcnt++;

  // H2 face
  strcpy(Olist[Bcnt].Name,"surf"); Olist[Bcnt].Xsize=0.12; Olist[Bcnt].Ysize=0.11; Bcnt++;
  strcpy(Olist[Bcnt].Name,"crisp"); Olist[Bcnt].Xsize=0.12; Olist[Bcnt].Ysize=0.11; Bcnt++;
  strcpy(Olist[Bcnt].Name,"iris"); Olist[Bcnt].Xsize=0.12; Olist[Bcnt].Ysize=0.11; Bcnt++;

  // Water face 1 
  strcpy(Olist[Bcnt].Name,"polaris"); Olist[Bcnt].Xsize=0.12; Olist[Bcnt].Ysize=0.115; Bcnt++;
  strcpy(Olist[Bcnt].Name,"het"); Olist[Bcnt].Xsize=0.12; Olist[Bcnt].Ysize=0.115; Bcnt++;
  strcpy(Olist[Bcnt].Name,"tosca"); Olist[Bcnt].Xsize=0.12; Olist[Bcnt].Ysize=0.115; Bcnt++;

  // Water face 2
  strcpy(Olist[Bcnt].Name,"maps"); Olist[Bcnt].Xsize=0.12; Olist[Bcnt].Ysize=0.115; Bcnt++;
  strcpy(Olist[Bcnt].Name,"evs"); Olist[Bcnt].Xsize=0.12; Olist[Bcnt].Ysize=0.115; Bcnt++;
  strcpy(Olist[Bcnt].Name,"sxd"); Olist[Bcnt].Xsize=0.12; Olist[Bcnt].Ysize=0.115; Bcnt++;

  // TS1 Generics
  strcpy(Olist[Bcnt].Name,"ch4"); Olist[Bcnt].Xsize=0.12; Olist[Bcnt].Ysize=0.115; Bcnt++;
  strcpy(Olist[Bcnt].Name,"h2"); Olist[Bcnt].Xsize=0.12; Olist[Bcnt].Ysize=0.11; Bcnt++;
  strcpy(Olist[Bcnt].Name,"water"); Olist[Bcnt].Xsize=0.12; Olist[Bcnt].Ysize=0.115; Bcnt++;

  // TS2 Generics
  strcpy(Olist[Bcnt].Name,"groove"); Olist[Bcnt].Xsize=0.08333; Olist[Bcnt].Ysize=0.03; Bcnt++;
  strcpy(Olist[Bcnt].Name,"hydrogen"); Olist[Bcnt].Xsize=0.12; Olist[Bcnt].Ysize=0.11; Bcnt++;
  strcpy(Olist[Bcnt].Name,"narrow"); Olist[Bcnt].Xsize=0.12; Olist[Bcnt].Ysize=0.12; Bcnt++;
  strcpy(Olist[Bcnt].Name,"broad"); Olist[Bcnt].Xsize=0.12; Olist[Bcnt].Ysize=0.12; Bcnt++;

  // TS2 groove
  strcpy(Olist[Bcnt].Name,"e1"); Olist[Bcnt].Xsize=0.08333; Olist[Bcnt].Ysize=0.03; Bcnt++;
  strcpy(Olist[Bcnt].Name,"e2"); Olist[Bcnt].Xsize=0.08333; Olist[Bcnt].Ysize=0.03; Bcnt++;
  strcpy(Olist[Bcnt].Name,"e3"); Olist[Bcnt].Xsize=0.08333; Olist[Bcnt].Ysize=0.03; Bcnt++;
  strcpy(Olist[Bcnt].Name,"e4"); Olist[Bcnt].Xsize=0.08333; Olist[Bcnt].Ysize=0.03; Bcnt++;
  strcpy(Olist[Bcnt].Name,"e5"); Olist[Bcnt].Xsize=0.08333; Olist[Bcnt].Ysize=0.03; Bcnt++;

  //Broad face
  strcpy(Olist[Bcnt].Name,"e6"); Olist[Bcnt].Xsize=0.12; Olist[Bcnt].Ysize=0.12; Bcnt++;
  strcpy(Olist[Bcnt].Name,"e7"); Olist[Bcnt].Xsize=0.12; Olist[Bcnt].Ysize=0.12; Bcnt++;
  strcpy(Olist[Bcnt].Name,"e8"); Olist[Bcnt].Xsize=0.12; Olist[Bcnt].Ysize=0.12; Bcnt++;
  strcpy(Olist[Bcnt].Name,"e9"); Olist[Bcnt].Xsize=0.12; Olist[Bcnt].Ysize=0.12; Bcnt++;
  // Narrow face

  strcpy(Olist[Bcnt].Name,"w1"); Olist[Bcnt].Xsize=0.12; Olist[Bcnt].Ysize=0.12; Bcnt++;
  strcpy(Olist[Bcnt].Name,"w2"); Olist[Bcnt].Xsize=0.12; Olist[Bcnt].Ysize=0.12; Bcnt++;
  strcpy(Olist[Bcnt].Name,"w3"); Olist[Bcnt].Xsize=0.12; Olist[Bcnt].Ysize=0.12; Bcnt++;
  strcpy(Olist[Bcnt].Name,"w4"); Olist[Bcnt].Xsize=0.12; Olist[Bcnt].Ysize=0.12; Bcnt++;

  //Hydrogen face
  strcpy(Olist[Bcnt].Name,"w5"); Olist[Bcnt].Xsize=0.12; Olist[Bcnt].Ysize=0.11; Bcnt++;
  strcpy(Olist[Bcnt].Name,"w6"); Olist[Bcnt].Xsize=0.12; Olist[Bcnt].Ysize=0.11; Bcnt++;
  strcpy(Olist[Bcnt].Name,"w7"); Olist[Bcnt].Xsize=0.12; Olist[Bcnt].Ysize=0.11; Bcnt++;
  strcpy(Olist[Bcnt].Name,"w8"); Olist[Bcnt].Xsize=0.12; Olist[Bcnt].Ysize=0.11; Bcnt++;
  strcpy(Olist[Bcnt].Name,"w9"); Olist[Bcnt].Xsize=0.12; Olist[Bcnt].Ysize=0.11; Bcnt++;


  /* write out version number */
  fprintf(stderr,"**********************************************************************\n");
  fprintf(stderr,"****   This is ISIS_moderator.comp version 0.9 (22/5/04)          ****\n");
  fprintf(stderr,"****   Please check to see if your files are up-to-date           ****\n");
  fprintf(stderr,"****   http://www.isis.rl.ac.uk/Computing/Software/MC/index.htm   ****\n");
  fprintf(stderr,"**********************************************************************\n\n");


  /* convert arguments to runtime variables so that they may be altered */
  rtE0=E0;
  rtE1=E1;
  rtmodX=modXsize;
  rtmodY=modYsize;
  

  /* Convert NEGATIVE energy (denoting angstroms) into meV */
  if ( (rtE0<0 && E1>0) | (rtE0>0 && E1<0))
    {
      fprintf(stderr,"Cannot have differing signs for E0 and E1, choose Angstroms or meV!\n");
      exit(1);
    }

 
  if (rtE0<0 && E1<0)
    {
      fprintf (stderr,"converting Angstroms to meV\n");
      rtE0=81.793936/(rtE0*rtE0);
      rtE1=81.793936/(rtE1*rtE1);
    }
  if (rtE0>rtE1)
    {
      tmp=rtE1;
      rtE1=rtE0;
      rtE0=tmp;
      fprintf (stderr,"%g A -> %g A =>  %g meV -> %g meV\n",-E0,-E1,rtE0,rtE1);
    }

  Tnpts=0;
  Ncount=0;
  fprintf(stderr,"Face == %s \n",Face);
  
  for(i=0;Face[i] && Face[i]!=' ';i++)
    lowerFace[i]=tolower(Face[i]);
  lowerFace[i]=0;

  for(i=0;i<Bcnt;i++)
    if (strcmp(lowerFace,Olist[i].Name)==0)
      {
	if (rtmodX<=0.0)
	  {
	    rtmodX=Olist[i].Xsize;
	    fprintf(stderr,"default modXsize used %g m\n",rtmodX);
	  }
	if (rtmodY<=0.0)
	  {
	    rtmodY=Olist[i].Ysize;
	    fprintf(stderr,"default modYsize used %g m\n",rtmodY);
	  }
	sprintf(fname,"Etable.%s",Olist[i].Name);
	scaleSize=(SAC) ? 1.0 : rtmodY*rtmodX*10000.0;
	break;
      }

  if(i==Bcnt)
    {
      fprintf(stderr,"Unknown moderator type ::%s::\n",lowerFace);
      fprintf(stderr,"Valid options == > \n");
      for(i=0;i<Bcnt;i++)
	{
	  fprintf(stderr," %s ",Olist[i].Name);
	  if (!((i+1) % 4))
	    fprintf(stderr,"\n");
	}
      scaleSize=modXsize*modYsize/0.0025;
      exit(1);
    }

  rtmodY*=cos(CAngle);
  fprintf(stderr,"Table == %d\n",table);

  /* READ PARAMETER FILE */
    
  Tfile=openFile(fname);

  if (!readEtable(Tfile))
    {
      fprintf(stderr,"Failed to read the Etable file \n");
      exit(1);
    }
  fclose(Tfile);
  //  writeMidQuad(500);
  //  exit(1);


  /* Do solid angle correction if required */
  // if SAC=0/1 solid angle is determined
  if(dist)
    angleArea=(SAC) ? strArea() : 1.0;
  else
    angleArea=1.0;

#ifdef StuDEBUG
  for(j=0;j<Einc;j++)
    fprintf(stderr,"%g %g %g\n",eCol[j],vCol[j],iCol[j]);
#endif
%}

TRACE
%{
  double v,r,E;
  double xf,yf,dx,dy,w_focus,Efrac,mxp,txp;    /* mxp ->max var in param space */
  double rParam[4];
  double Ddist;   /* Temp versions of dist */
  double timeWeight;     /* Weight of the time window */
  int Ti,i;
  Ncount++;

  p=p_in;
  z=0;
  x = 0.5*rtmodX*randpm1();
  y = 0.5*rtmodY*randpm1();
  xf = 0.5*xw*randpm1();          /* Choose focusing position uniformly */
  yf = 0.5*yh*randpm1();
  dx = xf-x;
  dy = yf-y;
  if (dist>0.0)                   /* check input variable */
    {
      r = sqrt(dx*dx+dy*dy+dist*dist);                 /* Actual distance to point */
      w_focus = scaleSize*(dist*dist)/(r*r)*eTotal;
      Ddist=dist;
    }
  else
    {
      r=1.0;
      w_focus=eTotal*scaleSize;
      Ddist=1.0;
    }

  E = Epass();
  v = SE2V*sqrt(E);
  vz = v*Ddist/r;
  vy = v*dy/r;
  vx = v*dx/r;


  Ti = Tpass(E);  /* get an integer relating to the Erange for your selected energy */
#ifdef StuDEBUG
  fprintf(stderr,"E range == %f %f\n",eRange[Ti-1],eRange[Ti]);
#endif

  /* --------------------------------- 
     Scale by fraction between groups 
     --------------------------------- 
  */

  Efrac = (E-eRange[Ti-1])/(eRange[Ti]-eRange[Ti-1]); 
  if (!(Ncount % 10000))
    fprintf(stderr,"FF[%d]=> %d %g %g  \n",Ncount,Ti,Efrac,E);
  for(i=0;i<2;i++)
    rParam[i]=(1.0-Efrac)*Param[Ti-1][i]+Efrac*Param[Ti][i];
  for(i=2;i<4;i++)
    rParam[i]=(Param[Ti][i]>Param[Ti-1][i]) ?  Param[Ti][i] : Param[Ti-1][i] ;

  /* fprintf(stderr,"FF=> %g %d %g %g %g %g %g %g  \n",
     E,Ti,eRange[Ti-1],eRange[Ti],rParam[0],rParam[1],rParam[2],rParam[3]); */

  txp=findMax(rParam);      // Find the time at the function max.
  mxp=Tprob(rParam,txp);            
  rParam[3]=findValue(rParam,mxp/1000.0,txp);  
  rParam[2]*=mxp;
  t = findTime(rParam);
  

#ifdef StuDEBUG
  if (t<0)
    {
      t*=-1;
      fprintf(stderr,"FF=> %g %d %g %g %g %g  \n",E,Ti,eRange[Ti-1],eRange[Ti],rParam[2],rParam[3]); 
    }
  fprintf(stderr,"%g %g %g : E %g %g %g %g\n",vx,vy,vz,E,t,p_in,p);
#endif
  p=w_focus*angleArea;
  

%}


MCDISPLAY
%{
  double cirp=0.0,cirq=0.3,pi=3.141592654;
  int pp=0; /* circle drawing parameter*/



  magnify("xy");
  multiline(5,-0.5*rtmodX,-0.5*rtmodY,0.0,
	    0.5*rtmodX,-0.5*rtmodY,0.0,
	    0.5*rtmodX,0.5*rtmodY,0.0,
	    -0.5*rtmodX,0.5*rtmodY,0.0,
	    -0.5*rtmodX,-0.5*rtmodY,0.0);
  /* circle("xy",0.0,0.0,0.0,cos(cirp)); */

  /*line(0.5*sin(cirp),0.0,0.5*cos(cirp),0.5*sin(cirq),0.0,0.5*cos(cirq));*/

  /*line(-0.5,0.0,0.0,0.0,0.0,0.5);*/

  for (pp=0;pp<=20;pp=pp+2)
    {
      cirp= (pp*(pi/21.0))-(0.5*pi);
      cirq= ((pp+1)*(pi/21.0))-(0.5*pi);
      line(0.5*sin(cirp),0.0,0.5*cos(cirp),0.5*sin(cirq),0.0,0.5*cos(cirq));
    }

  %}

END
