/*******************************************************************************
*
* McXtrace, X-ray tracing package
*         Copyright, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*         University of Copenhagen, Copenhagen, Denmark
*
* Component: Lens_parab
*
* %
*
* Written by: Jana Baltser and Erik Knudsen
* 
* Date: August 2010
* Version: 1.0
* Release: McXtrace 0.1
* Origin: NBI
*
* %D
* A simple X-ray compound refractive lens (CRL) with a parabolic profile simulates the photons' movement on passing through it.
*
* %P
* Input parameters:
* r - radius of the profile;
* w - parabola parameter, constraining it along the propagation axis;
* d - distance between two surfaces of the lens along the propagation axis;
* N - amount of single lenses in a stack.
* T - transmission of the lens
* 
* attenuation coefficient mu is taken from the NIST database and 
* Be_data.txt
*
*
*******************************************************************************/


DEFINE COMPONENT Lens_parab
DEFINITION PARAMETERS (string material_datafile="Be_data.txt")
SETTING PARAMETERS (r=0.42e-3,w=0.46e-3,d=0.2e-4,T=1,N=1)
OUTPUT PARAMETERS (prms,parab)
STATE PARAMETERS (x,y,z,kx,ky,kz,phi,Ex,Ey,Ez,p)

SHARE
%{
  %include "read_table-lib"
  struct datastruct{
    int Z;
    double Ar, rho;
    double *E, *mu, *f;
  }; 
  typedef struct {
  double coord[3];
  double k[3];
  } incom;
typedef struct {
  double constants[5];
} lens;
  
  incom intersection(incom a,lens b){
    incom result={a.coord[0],a.coord[1],a.coord[2],a.k[0],a.k[1],a.k[2]};  
    int i;
    double A,B,C,D,r,w;
    double t[2],p[3],knorm[3],k[3],pos1_tmp[3],pos_tmp[3];
  
    double N[3],Nx,Ny,Nz,Nnorm,Knorm;
    double cos_theta,cos_theta1,Arg,Arg1,s,q,s1,q1,alpha,beta;
    double k_new[3],k_new1[3],M,Sign,d;
  
    for(i=0;i<=2;i++){
      k[i]=a.k[i];
      p[i]=a.coord[i];
    }
    
    Knorm=sqrt(k[0]*k[0]+k[1]*k[1]+k[2]*k[2]);
    knorm[0]=k[0]/Knorm; knorm[1]=k[1]/Knorm; knorm[2]=k[2]/Knorm;
    
    r=b.constants[0]; w=b.constants[1]; d=b.constants[2]; 
    M=b.constants[3]; Sign=b.constants[4];
  
    if (knorm[0]*knorm[0]*w+knorm[1]*knorm[1]*w == 0){
      /*incident k-vector is parallel (exactly) to the z-axis. Thus, the eq. becomes linear*/
      t[0]=(-p[0]*p[0]*w-p[1]*p[1]*w+Sign*p[2]*r*r-Sign*d*r*r)/(2.0*p[0]*knorm[0]*w+2*p[1]*knorm[1]*w-Sign*knorm[2]*r*r);
      for(i=0; i<=2; i++){
        result.coord[i]=p[i]+t[0]*knorm[i];
      }
    } else {
      A=knorm[0]*knorm[0]*w + knorm[1]*knorm[1]*w; 
      B=2.0*p[0]*knorm[0]*w + 2.0*p[1]*knorm[1]*w - Sign*r*r*knorm[2]; 
      C=p[0]*p[0]*w + p[1]*p[1]*w - Sign*r*r*p[2] + Sign*r*r*d; 
      D=B*B-4.0*A*C;      
      if (D<0) {
        /*ray does not intersect the parabola*/
        return result;
      }
      else {
        if(A==0){ fprintf(stderr, "Division by zero in %s\n",NAME_CURRENT_COMP); return; }	  
        double qq;
        if (B<0){
          qq=-0.5*(B-sqrt(D));
        }else{
          qq=-0.5*(B+sqrt(D)); 
       }
        t[0]=qq/A; 
        t[1]=C/qq;
        
        for(i=0;i<=2;i++){
	  pos_tmp[i]=p[i]+t[0]*knorm[i]; 
	  pos1_tmp[i]=p[i]+t[1]*knorm[i];
	}
	if ((pos_tmp[0]*pos_tmp[0]+pos_tmp[1]*pos_tmp[1])<(r*r)){
	  for(i=0;i<=2;i++){
	  result.coord[i]=pos_tmp[i];
	  }
	}
	else if ((pos1_tmp[0]*pos1_tmp[0]+pos1_tmp[1]*pos1_tmp[1])<(r*r)){
	  for(i=0;i<=2;i++){
	    result.coord[i]=pos1_tmp[i];
	  }
	}
	else return result;
      }     
    }
    
      /* Calculating normal */
    Nx=(2.0*result.coord[0])/(r*r); Ny=(2.0*result.coord[1])/(r*r); Nz=-Sign/w;
    Nnorm=sqrt(Nx*Nx+Ny*Ny+Nz*Nz);
    N[0]=Nx/Nnorm; N[1]=Ny/Nnorm; N[2]=Nz/Nnorm; 
        
    /* Calculating the angle between two vectors, applying Snell's law & getting the new k vector */
    cos_theta=N[0]*knorm[0]+N[1]*knorm[1]+N[2]*knorm[2]; 
    
    Arg=1.0-M*M*(1.0-cos_theta*cos_theta);
    cos_theta1=sqrt(Arg); // cos-sin transitions
        
    if (cos_theta<0) {
      cos_theta1=-sqrt(Arg);
    }
    /* new k vector */
    if ((1.0-cos_theta*cos_theta)==0) {
       fprintf(stderr,"line 134: Division by zero\n"); return; }
    Arg1=(1.0-cos_theta1*cos_theta1)/(1.0-cos_theta*cos_theta);
    s=(1/M)*sqrt(Arg1);
    q=(Knorm/Nnorm)*((1/M)*cos_theta1-s*cos_theta);
    
    k_new[0]=q*Nx+s*k[0];k_new[1]=q*Ny+s*k[1];k_new[2]=q*Nz+s*k[2];
  
    return result; 
  }

  const double Re=2.8179402894e-5;     /* Thomson Scattering length [Angstrom] */
  const double Na=6.02214179e23;       /* Avogadro's number [atoms per gram-mole]*/
%}

DECLARE
%{
  struct datastruct *prms;
%} 


INITIALIZE 
%{
  t_Table t;
  Table_Read(&t, material_datafile,0);
  char **header_parsed;
  header_parsed=Table_ParseHeader(t.header,"Z=","Ar=","rho=");
  prms=calloc(1,sizeof(struct datastruct));
  if (!prms->Z) prms->Z=strtol(header_parsed[0],NULL,10)
  if (!prms->Ar) prms->Ar=strtod(header_parsed[1],NULL);
  if (!prms->rho) prms->rho=strtod(header_parsed[2],NULL);
  prms->E=malloc(sizeof(double)*(t.rows+1));
  prms->mu=malloc(sizeof(double)*(t.rows+1));
  prms->f=malloc(sizeof(double)*(t.rows+1));
  int i;
  for(i=0;i<t.rows;i++){
      prms->E[i]=t.data[i*t.columns]; 
      prms->mu[i]=t.data[1+i*t.columns]*1e2;     /*mu is now in SI, [m^-1]*/          
      prms->f[i]=t.data[2+i*t.columns];
  }
  Table_Free(&t);
%}




TRACE 
%{
  incom incid,refr,outg;
  lens parab;

  double E,mu,f,rhoel,dl,e,k,delta,beta,Refractive_Index_Re,Refractive_Index_Im; 

  int i=0,nr;
  
  parab.constants[0]=r;
  parab.constants[1]=w;
  
  k=sqrt(kx*kx+ky*ky+kz*kz); 
 
  e=K2E/k;  /*Energy in KeV, same unit as datafile */

/*Interpolation of Table Values*/

  while (e>prms->E[i]){
    i++;
    if (prms->E[i]==-1){
      fprintf(stderr,"Photon energy (%g keV) is outside of the lens' material data\n",k); ABSORB;
    }
  }
  E=(e-prms->E[i-1])/(prms->E[i]-prms->E[i-1]);
  mu=(1-E)*prms->mu[i-1]+E*prms->mu[i];
  mu= 1e-10*mu;  /*factor conversion from m^-1 to A^-1*/
  f=(1-E)*prms->f[i-1]+E*prms->f[i]; //printf("221: f=%g\n", f);


/*Calculation of Refractive Index */

  rhoel= f*Na*(prms->rho*1e-24)/prms->Ar;    /*Material's Number Density of Electrons [e/A^3] incl f' scattering length correction*/

  delta= 2.0*M_PI*Re*rhoel/(k*k);
  //delta=((2.0*M_PI*Re)/pow(k,2))*((Na/prms->Ar)*prms->rho*(prms->Z+f)*1e-24); 
 
  //printf("223: Ar=%g, rho=%g, Z=%d, k=%g\n", prms->Ar, prms->rho, prms->Z,k);
  
  beta=mu/(2.0*k);          /*mu and k in  A^-1*/
  
  /*n=1.0-delta; printf("225: delta=%g, beta=%g, n=%e\n", delta, beta, n);  /* before it was n=1.0-delta-beta; -> Wrong !!! */

  Refractive_Index_Re = 1.0-delta; //printf("225: delta=%g, beta=%g, Re(n)=%e\n", delta, beta, Refractive_Index_Re);  /* before it was n=1.0-delta-beta; -> Wrong !!! */

  Refractive_Index_Im = beta; 

/*Ray Tracing*/

  incid.k[0]=kx; incid.k[1]=ky; incid.k[2]=kz; 
  incid.coord[0]=x; incid.coord[1]=y; incid.coord[2]=z;
  for (nr=0;nr<=(N-1);nr++){
    parab.constants[2]=nr*d+nr*2*w;
    parab.constants[3]=1.0/Refractive_Index_Re;
    parab.constants[4]=-1.0;
    
    refr=intersection(incid,parab);
    if(refr.k[0]==0 && refr.k[1]==0 && refr.k[2]==0) continue;   
    dl=sqrt( (refr.coord[0]-x)*(refr.coord[0]-x) + (refr.coord[1]-y)*(refr.coord[1]-y) + (refr.coord[2]-z)*(refr.coord[2]-z) );
    PROP_DL(dl);
    SCATTER;	
    //alter parabolic input to match second parabola
    kx=refr.k[0]; ky=refr.k[1]; kz=refr.k[2];
    //printf("266: kx=%g, ky=%g, kz=%g\n", kx,ky,kz);
    parab.constants[2]=(nr+1)*d+nr*2*w;
    parab.constants[3]=Refractive_Index_Re;
    parab.constants[4]=1.0; 
    outg=intersection(refr,parab);
    dl=sqrt( (outg.coord[0]-x)*(outg.coord[0]-x) + (outg.coord[1]-y)*(outg.coord[1]-y) + (outg.coord[2]-z)*(outg.coord[2]-z) );
    PROP_DL(dl);
    SCATTER;

    kx=outg.k[0]; ky=outg.k[1]; kz=outg.k[2];
    incid=outg;
  }
   // transmission calculation
   if (T==0)
      ABSORB;
   else 
     T=exp(-mu*d*N);
   p*=T;

%}

MCDISPLAY
%{
  magnify("xy");
  double z_c,zdepth;
  zdepth=N*(2*w+d);
  z_c=zdepth/2.0-w;
  box(0,0,z_c,r,r,zdepth);
%}

END
