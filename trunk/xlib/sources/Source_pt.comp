/************************************************************************'
 * 
 * McXtrace X-ray tracing software
 * Copyright, All Rights Reserved
 * Risoe-DTU, Roskilde, Denmark
 *
 *
 * Component: Source_pt
 *
 * Written by: Erik Knudsen
 * Date: June 29th, 2009
 * Version: $Revision: $
 * Origin: Risoe
 * Release: McXtrace 0.1
 * 
 * %D
 * A simple source model emitting photons from a point source uniformly into 4pi. A square target centered
 * on the Z-axis restricts the beam to that aperture.
 * Further, the beam is restricted to emit photons between E0+-dE keV, or lambda0+-dlambda Ã…, whichever is given.
 * Flux is given in the unit photons/s
 * 
 * Example: Source_pt(distance=1,focus_xw=0.1,focus_yh=0.1, lamda=0.231, dlambda=0.002)
 *
 *
 * %P
 * 
 * 
 */

DEFINE COMPONENT Source_pt
DEFINITION PARAMETERS ()
SETTING PARAMETERS (focus_xw=0,focus_yh=0,flux=1,distance=1,gamma=0,E0=0, dE=0, lambda=-1,dlambda=-1,phase=-1,randomphase=0)
OUTPUT PARAMETERS ()
STATE PARAMETERS (x,y,z,kx,ky,kz,phi,Ex,Ey,Ez,p)

DECLARE
%{
  double e,l;
  double pmul;
%}

INITIALIZE
%{
  double fi_x,fi_y,t_ome;
  /*input logic*/
  if (focus_xw)
    fi_x=atan(focus_xw/2.0/distance);
  else {
    printf("Source_pt (%s): Target area unmeaningful! (negative distance / focus_xw / focus_yh)\n ERROR - Exiting\n",
           NAME_CURRENT_COMP);
    exit(0);
  }
  if (focus_yh)
    fi_y=atan(focus_yh/2.0/distance);
  else {
    printf("Source_pt (%s): Target area unmeaningful! (negative distance / focus_xw / focus_yh)\n ERROR - Exiting\n",
           NAME_CURRENT_COMP);
    exit(0);
  }
  /*fractional solid angle subtended by the target*/
  t_ome=(sin(fi_y))*fi_x/M_PI;

  if (E0 && dE){
    lambda=E0;
    dlambda=dE;
  }else if (!lambda){
    fprintf(stderr,"Source_pt (%s): Must specify either wavelength or energy distribution\n",NAME_CURRENT_COMP); 
    exit(0);  
  }

  printf("got phase %g from outsde\n",phase);
  /*calculate the X-ray weight from the flux*/
  if (flux){
    pmul=flux;
  }else{
    pmul=1;
  }
  pmul*=t_ome/mcget_ncount();
%}

TRACE
%{
  double k,l;
  /*point source*
  p=pmul;
%}/
  x=0;y=0;z=0;
  
  /*draw random coordinates in the acceptance window*/
  kx= (focus_xw/2.0 * randpm1());
  ky= (focus_yh/2.0 * randpm1());
  kz= distance;
  NORM(kx,ky,kz);  
  //printf("%g %g %g\n",kx,ky,kz);
  /*sample wavelength - for now - do it uniformly in the window*/
  if (dlambda){
    l=randpm1()*dlambda*0.5 + lambda;
  }else{
    l=lambda;
  }
  k=2*M_PI/l;
  kx*=k;
  ky*=k;
  kz*=k;
  
  /*randomly pick phase or set to something rea*/
  if (randomphase){
    phi=rand01()*2*M_PI;
  }else{
    phi=phase;
  }

  /*set polarrization vector*/
  Ex=0;Ey=0;Ez=0;

  p=pmul;
%}

MCDISPLAY
%{
  double radius=0.05;
  magnify("xy");
  circle("xy",0,0,0,radius);
%}

END
