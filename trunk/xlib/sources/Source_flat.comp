/*******************************************************************************
*
* McXtrace, X-ray tracing package
*         Copyright, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Component: Source_simple
*
* %I
* Written by:Erik Knudsen
* Date: September 25, 2009
* Version: $Revision$
* Origin: Risoe
* Release: McXtrcae 0.1_alpha
*
* A circular xray source with flat energy spectrum and arbitrary flux
*
* %D
*
* %P
* radius: [m]   Radius of circle in (x,y,0) plane where neutrons
*               are generated.
* yheight [m]   Height of rectangle in (x,y,0) plane where neutrons
*               are generated.
* xwidth  [m]   Width of rectangle in (x,y,0) plane where neutrons
*               are generated.
* dist:   [m]   Distance to target along z axis.
* focus_xw:[m]  Width of target
* focus_yh:[m]  Height of target
* E0:     [keV] Mean energy of neutrons.
* dE:     [keV] Energy half spread of neutrons (flat or gaussian sigma).
* lambda0:[AA]  Mean wavelength of neutrons.
* dlambda:[AA]  Wavelength half spread of neutrons.
* gauss:  [1]   Gaussian (1) or Flat (0) energy/wavelength distribution
*
* %E
*******************************************************************************/

DEFINE COMPONENT Source_flat
DEFINITION PARAMETERS ()
SETTING PARAMETERS (radius=0, yheight=0, xwidth=0, 
  dist=0, focus_xw=.045, focus_yh=.12, 
  E0=0, dE=0, lambda0=0, dlambda=0, gauss=0)
OUTPUT PARAMETERS ()
STATE PARAMETERS (x,y,z,kx,ky,kz,phi, Ex,Ey,Ez,p)
DECLARE
%{
  double pmul, srcArea;
  int square;
%}
INITIALIZE
%{
  square = 0;
  /* Determine source area */
  if (radius && !yheight && !xwidth ) {
    square = 0;
    srcArea = PI*radius*radius;
  } else if(yheight && xwidth) {
    square = 1;
    srcArea = xwidth * yheight;
  }

  
  if (srcArea <= 0) {
    printf("Source_flat: %s: Source area is <= 0 !\n ERROR - Exiting\n",
           NAME_CURRENT_COMP);
    exit(0);
  }
  if (dist <= 0 || focus_xw <= 0 || focus_yh <= 0) {
    printf("Source_flat: %s: Target area unmeaningful! (negative dist / focus_xw / focus_yh)\n ERROR - Exiting\n",
           NAME_CURRENT_COMP);
    exit(0);
  }
  
  if ((!lambda0 && !E0 && !dE && !dlambda)) {
    printf("Source_flat: %s: You must specify either a wavelength or energy range!\n ERROR - Exiting\n",
           NAME_CURRENT_COMP);
    exit(0);
  }
  if ((!lambda0 && !dlambda && (E0 <= 0 || dE < 0 || E0-dE <= 0))
    || (!E0 && !dE && (lambda0 <= 0 || dlambda < 0 || lambda0-dlambda <= 0))) {
    printf("Source_flat: %s: Unmeaningful definition of wavelength or energy range!\n ERROR - Exiting\n",
           NAME_CURRENT_COMP);
      exit(0);
  }
%}
TRACE
%{
 double chi,E,lambda,k,r, xf, yf, rf, dx, dy, pdir;

 phi=0;
 z=0;
 
 if (square == 1) {
   x = xwidth * (rand01() - 0.5);
   y = yheight * (rand01() - 0.5);
 } else {
   chi=2*PI*rand01();                          /* Choose point on source */
   r=sqrt(rand01())*radius;                    /* with uniform distribution. */
   x=r*cos(chi);
   y=r*sin(chi);
 }
 randvec_target_rect_real(&xf, &yf, &rf, &pdir,
			  0, 0, dist, focus_xw, focus_yh, ROT_A_CURRENT_COMP, x, y, z, 2);

 dx = xf-x;
 dy = yf-y;
 rf = sqrt(dx*dx+dy*dy+dist*dist);

 p = pdir*pmul;

 if(lambda0==0) {
   if (!gauss) {
     E=E0+dE*randpm1();              /*  Choose from uniform distribution */
   } else {
     E=E0+randnorm()*dE;
   }
   k=E*E2K;
 } else {
   if (!gauss) {
     lambda=lambda0+dlambda*randpm1();
   } else {
     lambda=lambda0+randnorm()*dlambda;
   }
   k = (2*PI/lambda);
 }
 ky=k*dy/rf;
 kx=k*dx/rf;
 kz=k*dist/rf;
  
 /*for now only do flat weighting*/ 
 p=1;
%}

MCDISPLAY
%{
  if (square == 1) {
    magnify("xy");
    rectangle("xy",0,0,0,xwidth,yheight);
  } else {
    magnify("xy");
    circle("xy",0,0,0,radius);
  }
  if (dist) {
    dashed_line(0,0,0, -focus_xw/2,-focus_yh/2,dist, 4);
    dashed_line(0,0,0,  focus_xw/2,-focus_yh/2,dist, 4);
    dashed_line(0,0,0,  focus_xw/2, focus_yh/2,dist, 4);
    dashed_line(0,0,0, -focus_xw/2, focus_yh/2,dist, 4);
  }
%}

END
