.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "CodeText 3pm"
.TH CodeText 3pm "2004-03-17" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Tk::CodeText \- a TextUndo widget with syntax highlighting capabilities
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& use Tk;
\& require Tk::CodeText;
\&
\& my $m = new MainWindow;
\&
\& my $e = $m\->Scrolled(\*(AqCodeText\*(Aq,
\&    \-disablemenu => 1,
\&    \-syntax => \*(AqPerl\*(Aq,
\&    \-scrollbars => \*(Aqse\*(Aq,
\& )\->pack(\-expand => 1, \-fill => \*(Aqboth\*(Aq);
\&
\& $m\->configure(\-menu => $e\->menu);
\& $m\->MainLoop;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Tk::CodeText inherits Tk::TextUndo and all its options and methods. Besides
syntax highlighting, methods are provided for commenting and uncommenting
as well as indenting and unindenting a selected area, matching pairs of braces, brackets and
brackets and curlies and automatic indenting of new lines.
.PP
Syntax highlighting is done through a plugin approach. Adding languages 
is a matter of writing plugin modules. Theoretically this is not limited to programming languages. 
The plugin approach could also provide the possibility for grammar or spell checking in spoken 
languages.
.PP
Currently there is support for \fBBash\fR, \fB\s-1HTML\s0\fR, \fBPerl\fR, \fBPod\fR, and \fBXresources\fR.
.SH "OPTIONS"
.IX Header "OPTIONS"
.IP "Name: \fBautoindent\fR" 4
.IX Item "Name: autoindent"
.PD 0
.IP "Class: \fBAutoindent\fR" 4
.IX Item "Class: Autoindent"
.IP "Switch: \fB\-autoindent\fR" 4
.IX Item "Switch: -autoindent"
.PD
Boolean, when you press the enter button, should the next line begin at the
same position as the current line or not. By default \fBfalse\fR.
.IP "Name: \fBcommentchar\fR" 4
.IX Item "Name: commentchar"
.PD 0
.IP "Class: \fBCommentchar\fR" 4
.IX Item "Class: Commentchar"
.IP "Switch: \fB\-commentchar\fR" 4
.IX Item "Switch: -commentchar"
.PD
By default \*(L"#\*(R".
.IP "Name: \fBdisablemenu\fR" 4
.IX Item "Name: disablemenu"
.PD 0
.IP "Class: \fBDisablemenu\fR" 4
.IX Item "Class: Disablemenu"
.IP "Switch: \fB\-disablemenu\fR" 4
.IX Item "Switch: -disablemenu"
.PD
Boolean, by default 0. In case you don't want the menu under the
right mouse button to pop up.
.IP "Name: \fBindentchar\fR" 4
.IX Item "Name: indentchar"
.PD 0
.IP "Class: \fBIndentchar\fR" 4
.IX Item "Class: Indentchar"
.IP "Switch: \fB\-indentchar\fR" 4
.IX Item "Switch: -indentchar"
.PD
By default \*(L"\et\*(R".
.IP "Name: \fBmatch\fR" 4
.IX Item "Name: match"
.PD 0
.IP "Class: \fBMatch\fR" 4
.IX Item "Class: Match"
.IP "Switch: \fB\-match\fR" 4
.IX Item "Switch: -match"
.PD
string of pairs for brace/bracket/curlie etc matching. If this description
doesn't make anything clear, don't worry, the default setting will:
.Sp
.Vb 1
\& \*(Aq[]{}()\*(Aq
.Ve
.Sp
if you don't want matching to be available, simply set it to ''.
.IP "Name: \fBmatchoptions\fR" 4
.IX Item "Name: matchoptions"
.PD 0
.IP "Class: \fBMatchoptions\fR" 4
.IX Item "Class: Matchoptions"
.IP "Switch: \fB\-matchoptions\fR" 4
.IX Item "Switch: -matchoptions"
.PD
Options list for the tag 'Match'. By default:
.Sp
.Vb 1
\& [\-background => \*(Aqred\*(Aq, \-foreground => \*(Aqyellow\*(Aq]
.Ve
.Sp
You can also specify this option as a space separated string. Might come in
handy for your Xresource files.
.Sp
.Vb 1
\& "\-background red \-foreground yellow"
.Ve
.IP "Name: not available" 4
.IX Item "Name: not available"
.PD 0
.IP "Class: not available" 4
.IX Item "Class: not available"
.IP "Switch \fB\-rules\fR" 4
.IX Item "Switch -rules"
.PD
Specify the color and font options for highlighting. You specify a list
looking a bit like this.
.Sp
.Vb 4
\& [
\&     [\*(AqTagname1\*(Aq, @options1],
\&     [\*(AqTagname2\*(Aq, @options2],
\& ]
.Ve
.Sp
The names of the tags are depending on the syntax that is highlighted. 
See the language modules for more information about this data structure.
.IP "Name: rulesdir" 4
.IX Item "Name: rulesdir"
.PD 0
.IP "Class: Rulesdir" 4
.IX Item "Class: Rulesdir"
.IP "Switch \fB\-rulesdir\fR" 4
.IX Item "Switch -rulesdir"
.PD
Specify the directory where this widget stores its coloring defenitions.
Files in this directory are stored as \*(L"\s-1HTML\s0.rules\*(R", \*(L"Perl.rules\*(R" etc.
By default it is set to '', which means that when you switch syntax
the highlighting rules are not loaded or stored. The hard coded defaults
in the language modules will be used.
.IP "Name: \fBsyntax\fR" 4
.IX Item "Name: syntax"
.PD 0
.IP "Class: \fBSyntax\fR" 4
.IX Item "Class: Syntax"
.IP "Switch: \fB\-syntax\fR" 4
.IX Item "Switch: -syntax"
.PD
Specifies the language for highlighting. At this moment the possible
values are \fBNone\fR, \fB\s-1HTML\s0\fR, \fBPerl\fR, \fBPod\fR and \fBXresources\fR. 
By default \fBNone\fR
.Sp
Alternatively it is possible to specify a reference to your independent plugin.
.IP "Name: Not available" 4
.IX Item "Name: Not available"
.PD 0
.IP "Class: Not available" 4
.IX Item "Class: Not available"
.IP "Switch: \fB\-updatecall\fR" 4
.IX Item "Switch: -updatecall"
.PD
Here you can specify a callback that will be executed whenever the insert
cursor has moved or text has been modified, so your application can keep
track of position etc. Don't make this callback to heavy, the widget will
get sluggish quickly.
.PP
There are some undocumented options. They are used internally. 
It is propably best to leave them alone.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBdoAutoIndent\fR" 4
.IX Item "doAutoIndent"
Checks the indention of the previous line and indents
the line where the cursor is equally deep.
.ie n .IP "\fBhighlight\fR(\fI\fI$begin\fI\fR, \fI\fI$end\fI\fR);" 4
.el .IP "\fBhighlight\fR(\fI\f(CI$begin\fI\fR, \fI\f(CI$end\fI\fR);" 4
.IX Item "highlight($begin, $end);"
Does syntax highlighting on the section of text indicated by \f(CW$begin\fR and \f(CW$end\fR. 
\&\f(CW$begin\fR and \f(CW$end\fR are linenumbers not indexes!
.ie n .IP "\fBhighlightCheck\fR>(\fI\fI$begin\fI\fR, \fI\fI$end\fI\fR);" 4
.el .IP "\fBhighlightCheck\fR>(\fI\f(CI$begin\fI\fR, \fI\f(CI$end\fI\fR);" 4
.IX Item "highlightCheck>($begin, $end);"
An insert or delete has taken place affecting the section of text between \f(CW$begin\fR and \f(CW$end\fR.
\&\fBhighlightCheck\fR is being called after and insert or delete operation. \f(CW$begin\fR and \f(CW$end\fR (again
linenumbers, not indexes) indicate the section of text affected. \fBhighlightCheck\fR checks what 
needs to be highlighted again and does the highlighting.
.ie n .IP "\fBhighlightLine\fR(\fI\fI$line\fI\fR);" 4
.el .IP "\fBhighlightLine\fR(\fI\f(CI$line\fI\fR);" 4
.IX Item "highlightLine($line);"
Does syntax highlighting on linenumber \f(CW$line\fR.
.IP "\fBhighlightPlug\fR" 4
.IX Item "highlightPlug"
Checks wether the appropriate highlight plugin has been loaded. If none or the wrong 
one is loaded, it loads the correct plugin. It returns a reference to the plugin loaded.
It also checks wether the rules have changed. If so, it restarts highlighting 
from the beginning of the text.
.IP "\fBhighlightPlugInit\fR" 4
.IX Item "highlightPlugInit"
Loads and initalizes a highlighting plugin. First it checks the value of the \fB\-syntax\fR option
to see which plugin should be loaded. Then it checks wether a set of rules is defined to this plugin
in the \fB\-rules\fR option. If not, it tries to obtain a set of rules from disk using \fBrulesFetch\fR. 
If this fails as well it will use the hardcoded rules from the syntax plugin.
.ie n .IP "\fBhighlightPurge\fR(\fI\fI$line\fI\fR);" 4
.el .IP "\fBhighlightPurge\fR(\fI\f(CI$line\fI\fR);" 4
.IX Item "highlightPurge($line);"
Tells the widget that the text from linenumber \f(CW$line\fR to the end of the text is not to be considered 
highlighted any more.
.IP "\fBhighlightVisual\fR" 4
.IX Item "highlightVisual"
Calls \fBvisualEnd\fR to see what part of the text is visible on the display, and adjusts highlighting
accordingly.
.ie n .IP "\fBlinenumber\fR(\fI\fI$index\fI\fR);" 4
.el .IP "\fBlinenumber\fR(\fI\f(CI$index\fI\fR);" 4
.IX Item "linenumber($index);"
Returns the linenumber part of an index. You may also specify indexes like 'end' or 'insert' etc.
.IP "\fBmatchCheck\fR" 4
.IX Item "matchCheck"
Checks wether the character that is just before the 'insert'\-mark should be matched, and if so
should it match forwards or backwards. It then calls \fBmatchFind\fR.
.ie n .IP "\fBmatchFind\fR(\fI\fI$direction\fI\fR, \fI\fI$char\fI\fR, \fI\fI$match\fI\fR, \fI\fI$start\fI\fR, \fI\fI$stop\fI\fR);" 4
.el .IP "\fBmatchFind\fR(\fI\f(CI$direction\fI\fR, \fI\f(CI$char\fI\fR, \fI\f(CI$match\fI\fR, \fI\f(CI$start\fI\fR, \fI\f(CI$stop\fI\fR);" 4
.IX Item "matchFind($direction, $char, $match, $start, $stop);"
Matches \f(CW$char\fR to \f(CW$match\fR, skipping nested \f(CW$char\fR/$match pairs, and displays the match found (if any).
.IP "\fBrulesEdit\fR" 4
.IX Item "rulesEdit"
Pops up a window that enables the user to set the color and font options
for the current syntax.
.IP "\fBrulesFetch\fR" 4
.IX Item "rulesFetch"
Checks wether the file
.Sp
.Vb 1
\& $text\->cget(\*(Aq\-rulesdir\*(Aq) . \*(Aq/\*(Aq . $text\->cget(\*(Aq\-syntax\*(Aq) . \*(Aq.rules\*(Aq
.Ve
.Sp
exists, and if so attempts to load this as a set of rules.
.IP "\fBrulesSave\fR" 4
.IX Item "rulesSave"
Saves the currently loaded rules as
.Sp
.Vb 1
\& $text\->cget(\*(Aq\-rulesdir\*(Aq) . \*(Aq/\*(Aq . $text\->cget(\*(Aq\-syntax\*(Aq) . \*(Aq.rules\*(Aq
.Ve
.IP "\fBselectionComment\fR" 4
.IX Item "selectionComment"
Comment currently selected text.
.IP "\fBselectionIndent\fR" 4
.IX Item "selectionIndent"
Indent currently selected text.
.IP "\fBselectionModify\fR" 4
.IX Item "selectionModify"
Used by the other \fBselection...\fR methods to do the actual work.
.IP "\fBselectionUnComment\fR" 4
.IX Item "selectionUnComment"
Uncomment currently selected text.
.IP "\fBselectionUnIndent\fR" 4
.IX Item "selectionUnIndent"
Unindent currently selected text.
.SH "SYNTAX HIGHLIGHTING"
.IX Header "SYNTAX HIGHLIGHTING"
This section is a brief description of how the syntax highlighting process
works.
.PP
\&\fBInitiating plugin\fR
.PP
The highlighting plugin is only then initiated when it is needed. When some
highlighting needs to be done, the widget calls \fBhighlightPlug\fR to retrieve
a reference to the plugin.
.PP
\&\fBhighlightPlug\fR checks wether a plugin is present. Next it will check whether
the \fB\-rules\fR option has been specified or wether the \fB\-rules\fR option has changed.
If no rules are specified in \fB\-rules\fR, it will look for a pathname
in the \fB\-rulesdir\fR option. If that is found it will try to load a file
called '*.rules', where * is the value of \fB\-syntax\fR.
.PP
If no plugin is present, or the \fB\-syntax\fR option has changed value,
\&\fBhighlightPlug\fR loads the plugin. and constructs optionally giving it 
a reference to the found rules as parameter. if no rules
are specified, the plugin will use its internal hardcoded defaults.
.PP
\&\fBChanging the rules\fR
.PP
A set of rules is a list, containing lists of tagnames, followed by options. 
If you want to see what they look like, you can have a look at the constructors
of each plugin module. Every plugin has a fixed set of tagnames it can handle.
.PP
There are two ways to change the rules.
.PP
You can invoke the \fBrulesEdit\fR method, which is also available through the 
\&\fBView\fR menu. The result is a popup in which you can specify color and font
options for each tagname. After pressing 'Ok', the edited rules will be applied.
If \fB\-rulesdir\fR is specified, the rules will be saved on disk as
\&\fIrulesdir/syntax.rules\fR.
.PP
You can also use \fBconfigure\fR to specify a new set of rules. In this you have
ofcause more freedom to use all available tag options. For more details about
those there is a nice section about tag options in the Tk::Text documentation.
After the call to \fBconfigure\fR it is wise to call \fBhighlightPlug\fR.
.PP
\&\fBHighlighting text\fR
.PP
Syntax highlighting is done in a lazy manor. Only that piece of text is
highlighted that is needed to present the user a pretty picture. This is
done to minimize use of system resources. Highlighting is running on the
foreground. Jumping directly to the end of a long fresh loaded textfile may
very well take a couple of seconds.
.PP
Highlighting is done on a line to line basis. At the end of each line the
highlighting status is saved in the list in \fB\-colorinf\fR, so when highlighting
the next line, the \fBhighlight\fR method of \fBCodeText\fR will know how to begin.
.PP
The line that needs highlighting is offered to the \fBhighlight\fR method of
the plugin. This method returns a list of offset and tagname pairs.
Take for example the following line of perl code.
.PP
.Vb 1
\& my $mother = \*(Aqolder than i am\*(Aq;
.Ve
.PP
The \fBhighlight\fR method of the Perl plugin will return the following list;
.PP
.Vb 8
\& (2 => \*(AqReserved\*(Aq,    #\*(Aqmy\*(Aq is a reserved word
\&  1 => \*(AqDEFAULT\*(Aq,     #Space
\&  7 => \*(AqVariable\*(Aq,    #$mother
\&  1 => \*(AqDEFAULT\*(Aq,     #Space
\&  1 => \*(AqOperator\*(Aq,    #\*(Aq=\*(Aq
\&  1 => \*(AqDEFAULT\*(Aq,     #Space
\&  17 => \*(AqString\*(Aq,     #\*(Aqolder than i am\*(Aq
\&  1 => \*(AqDEFAULT\*(Aq,)    #;
.Ve
.PP
The \fBhighlight\fR method of CodeText will then mark positions 0 to 2 as 
\&'Reserved', positions 2 to 3 as '\s-1DEFAULT\s0', positions 3 to 10 as 'Variable',
etcetera.
.SH "WRITING PLUGINS"
.IX Header "WRITING PLUGINS"
After writing a couple of plugins myself i have come to a couple of guidelines
about how to set them up. If you are interested in adding support for your
own syntax highlighting problem or language this section is of interest to you.
.PP
\&\fBFrom scratch\fR
.PP
If you choose to build a plugin completely from scratch, your module needs
to meet the following requirements.
.PP
.Vb 8
\& \- If you want to write a formal addition to Tk::CodeText, 
\&   your plugin must be in the namespace 
\&   Tk::CodeText::YourSyntax.
\& \- The constructor is called \*(Aqnew\*(Aq, and it should accept 
\&   a reference a reference to a list of rules as parameters.
\& \- The following methods will be called upon by Tk::CodeText: 
\&     highlight, stateCompare, rules, setSate, 
\&     getState, syntax.
.Ve
.PP
More information about those methods is available in the documentation of
Tk::CodeText::None and Tk::CodeText::Template. Good luck, you're on your own now.
.PP
\&\fBInheriting Tk::CodeText::Template\fR
.PP
For many highlighting problems Tk::CodeText::Template
provides a nice basis to start from. Your code
could look like this:
.PP
.Vb 1
\& package Tk::CodeText::MySyntax;
\& 
\& use strict;
\& use base(\*(AqTk::CodeText::Template\*(Aq);
\& 
\& sub new {
\&    my ($proto, $wdg, $rules) = @_;
\&    my $class = ref($proto) || $proto;
.Ve
.PP
Next, specify the set of hardcoded rules.
.PP
.Vb 6
\&    if (not defined($rules)) {
\&       $rules =  [
\&          [\*(AqTagname1\*(Aq, \-foreground => \*(Aqred\*(Aq],
\&          [\*(AqTagname1\*(Aq, \-foreground => \*(Aqred\*(Aq],
\&       ];
\&    };
.Ve
.PP
Call the constructor of Tk::CodeText::Template and bless your
object.
.PP
.Vb 1
\&    my $self = $class\->SUPER::new($rules);
.Ve
.PP
So now we have the \s-1SUPER\s0 class avalable and we can start defining
a couple of things.
.PP
You could add a couple of lists, usefull for keywords etc.
.PP
.Vb 4
\&    $self\->lists({
\&        \*(AqKeywords\*(Aq => [\*(Aqfoo\*(Aq, \*(Aqbar\*(Aq],
\&        \*(AqOperators\*(Aq => [\*(Aqand\*(Aq, \*(Aqor\*(Aq],
\&    });
.Ve
.PP
For every tag you have to define a corresponding callback like this.
.PP
.Vb 4
\&    $self\->callbacks({
\&        \*(AqTagname1\*(Aq => \e&Callback1,
\&        \*(AqTagname2\*(Aq => \e&Callback2,
\&    });
.Ve
.PP
You have to define a default tagname like this:
.PP
.Vb 1
\&    $self\->stackPush(\*(AqTagname1\*(Aq);
.Ve
.PP
Perhaps do a couple of other things but in the end, wrap up the new method.
.PP
.Vb 3
\&    bless ($self, $class);
\&    return $self;
\& }
.Ve
.PP
Then you need define the callbacks that are mentioned in the \fBcallbacks\fR
hash. When you just start writing your plugin i suggest you make them look
like this:
.PP
.Vb 4
\& sub callback1 {
\&    my ($self $txt) = @_;
\&    return $self\->parserError($txt); #for debugging your later additions
\& }
.Ve
.PP
Later you add matching statements inside these callback methods. For instance,
if you want \fIcallback1\fR to parse spaces it is going to look like this:
.PP
.Vb 8
\& sub callback1 {
\&    my ($self $txt) = @_;
\&    if ($text =~ s/^(\es+)//) { #spaces
\&        $self\->snippetParse($1, \*(AqTagname1\*(Aq); #the tagname here is optional
\&        return $text;
\&    }
\&    return $self\->parserError($txt); #for debugging your later additions
\& }
.Ve
.PP
If \fIcallback1\fR is the callback that is called by default, you have to add
the mechanism for checking lists to it. Hnce, the code will look like this:
.PP
.Vb 10
\& sub callback1 {
\&    my ($self $txt) = @_;
\&    if ($text =~ s/^(\es+)//) { #spaces
\&        $self\->snippetParse($1, \*(AqTagname1\*(Aq); #the tagname here is optional
\&        return $text;
\&    }
\&    if ($text =~ s/^([^$separators]+)//) {      #fetching a bare part
\&        if ($self\->tokenTest($1, \*(AqReserved\*(Aq)) {
\&            $self\->snippetParse($1, \*(AqReserved\*(Aq);
\&        } elsif ($self\->tokenTest($1, \*(AqKeyword\*(Aq)) {
\&            $self\->snippetParse($1, \*(AqKeyword\*(Aq);
\&        } else { #unrecognized text
\&            $self\->snippetParse($1);
\&        }
\&        return $text
\&    }
\&    return $self\->parserError($txt); #for debugging your later additions
\& }
.Ve
.PP
Have a look at the code of Tk::CodeText::Bash. Things should clear up.
And then, last but not least, you need a \fBsyntax\fR method.
.PP
\&\fBUsing another module as basis\fR
.PP
An example of this approach is the Perl syntax module.
.PP
Also with this approach you will have to meet the minimum criteria
as set out in the \fBFrom scratch\fR section.
.SH "CONTRIBUTIONS"
.IX Header "CONTRIBUTIONS"
If you have written a plugin, i will be happy to include it in the next release
of Tk::CodeText. If you send it to me, please have it accompanied with the 
sample of code that you used for testing.
.SH "AUTHOR"
.IX Header "AUTHOR"
.IP "Hans Jeuken (haje@toneel.demon.nl)" 4
.IX Item "Hans Jeuken (haje@toneel.demon.nl)"
.SH "BUGS"
.IX Header "BUGS"
Unknown. If you find any, please contact the author.
.SH "TODO"
.IX Header "TODO"
.IP "Add additional language modules. I am going to need help on this one." 4
.IX Item "Add additional language modules. I am going to need help on this one."
.PD 0
.IP "\s-1HTML\s0 and Xresources plugins need rewriting." 4
.IX Item "HTML and Xresources plugins need rewriting."
.IP "The sample files in the test suite should be set up so that conformity with the language specification can actually be verified." 4
.IX Item "The sample files in the test suite should be set up so that conformity with the language specification can actually be verified."
.PD
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\fBTk::Text\fR, \fBTk::TextUndo\fR, \fBTk::CodeText::None\fR, \fBTk::CodeText::Perl\fR \fBTk::CodeText::HTML\fR, \fBTk::CodeText::Template\fR, \fBTk::CodeText::Bash\fR" 4
.IX Item "Tk::Text, Tk::TextUndo, Tk::CodeText::None, Tk::CodeText::Perl Tk::CodeText::HTML, Tk::CodeText::Template, Tk::CodeText::Bash"
