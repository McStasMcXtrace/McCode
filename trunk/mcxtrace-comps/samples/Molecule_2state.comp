/*******************************************************************************
*
* McXtrace, X-ray tracing package
*         Copyright, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*         University of Copenhagen, Copenhagen, Denmark
*
* Component: Molecule_2state
*
* %I
*
* Written by: Erik B Knudsen 
* Date: October 2012
* Version: 1.0
* Release: McXtrace 1.1
* Origin: DTU Physics
*
* Disordered optical-excitable molecule sample.
*
* %D
* A sample model for pump probe experiments
*
* %P
* Input parameters:
*
* (none)
*
* %E
*******************************************************************************/

DEFINE COMPONENT Molecule_2state2
DEFINITION PARAMETERS (string form_factors="FormFactors.txt",string state_0_file=NULL,string state_1_file=NULL, nq=201, string material_datafile="Be.txt")
SETTING PARAMETERS (delta_t=100e-9,excitation_yield=0.2,t_relax=100e-9,psimin=0,psimax=M_PI_2, etamin=0, etamax=2*M_PI, radius=0, yheight=0, xwidth=0, zdepth=0, concentration=1,p_transmit=0.1)
OUTPUT PARAMETERS (delta_q,prms,shape)
/* X-ray parameters: (x,y,z,kx,ky,kz,phi,t,Ex,Ey,Ez,p) */ 

SHARE
%{
  %include "read_table-lib"
  %include "form_factor-lib"
  enum SHAPES {NONE,CYLINDER,SPHERE,BOX};
  struct mat_prms {
    int Z;
    double At, rho;
    double *E,*mu;
  };
%}


DECLARE
%{
  double delta_q=0.01;
  struct{
    double *q,*f2;
    int rows;
    double f2sum,f2mcsum,qnmin,qnmax;
  } prms[2];
  struct mat_prms *Prms;
  enum SHAPES shape;
%}


INITIALIZE
%{
  t_Table T[2],f0;
  int status;

  if ( state_0_file && (status=Table_Read(&(T[0]),state_0_file,0))==-1){
    fprintf(stderr,"Error: Could not parse file \"%s\" in COMP %s\n",state_0_file,NAME_CURRENT_COMP);
      exit(-1);
  }
  if ( state_1_file && (status=Table_Read(&(T[1]),state_1_file,0))==-1){
    fprintf(stderr,"Error: Could not parse file \"%s\" in COMP %s\n",state_1_file,NAME_CURRENT_COMP);
    fprintf(stderr,"Proceeding as a single state sample\n");
    T[1]=T[0];
  }

  if(form_factors){
    if (status=Table_Read(&(f0),form_factors,0)==-1){
      fprintf(stderr,"Error(%s): Could not parse file \"%s\"\n",NAME_CURRENT_COMP,form_factors);
      exit(-1);
    }
  }
  prms[0].f2=malloc(sizeof(double)*nq);/*could be done by read_table-lib*/
  prms[0].q=malloc(sizeof(double)*nq);
  prms[1].f2=malloc(sizeof(double)*nq);
  prms[1].q=malloc(sizeof(double)*nq);
  
  if (!psimax) psimax=M_PI;
  /*compute q-limits*/;
  prms[0].qnmin=prms[1].qnmin=M_SQRT2*sqrt(1-cos(psimin));
  prms[0].qnmax=prms[1].qnmax=M_SQRT2*sqrt(1-cos(psimax));

  printf("%s: Computing F2(q) for two states:\n", NAME_CURRENT_COMP);
  int r,n,m,states;/*do this for two states*/
  double dq= 6.0/(nq-1);
  for (states=0;states<2;states++){
    for (r=0;r<nq;r++){
      double f2=0;
      double q=prms[states].qnmin + r*dq;//Table_Index(f0,r,0);
      for (n=0;n<T[states].rows;n++){
        int Zn=(int) Table_Index(T[states],n,0);
        /*figure out Z_n*/
        double f0n=atomic_form_factor(Zn,0,q);//Table_Index(f0,r,Zn);
        double nx,ny,nz;
        nx=Table_Index(T[states],n,1);
        ny=Table_Index(T[states],n,2);
        nz=Table_Index(T[states],n,3);
        f2+=fabs(f0n*f0n);
        //printf("debug %d %g\n",Zn,f2);
        for (m=n+1;m<T[states].rows;m++){
          int Zm=(int) Table_Index(T[states],m,0);
          double f0m=atomic_form_factor(Zm,0,q);//Table_Index(f0,r,Zm);
          double mx,my,mz,dr;
          mx=Table_Index(T[states],m,1);
          my=Table_Index(T[states],m,2);
          mz=Table_Index(T[states],m,3);
          dr=sqrt((nx-mx)*(nx-mx)+(ny-my)*(ny-my)+(nz-mz)*(nz-mz));
          if (q){
            f2+=2 * f0m*f0n*sin(q*dr)/(q*dr);
          }else{
            f2+=2* f0m*f0n;
          }
        }
      }
      prms[states].f2[r]=f2;
      prms[states].q[r]=q;
      if (r>0){
        //double dq=q-Table_Index(f0,r-1,0);
        /*integrate using linear interpolation*/ 
        prms[states].f2sum+=0.5*(prms[states].f2[r-1]+f2)*dq;
        if (q>prms[states].qnmin && q<prms[states].qnmax){
          double q1,q2,alpha;
          q1=(prms[states].qnmin>q-dq?prms[states].qnmin:q-dq);
          q2=(prms[states].qnmax<q?prms[states].qnmax:q);
          alpha=((q1+q2)*0.5-(q-dq))/q;
          prms[states].f2mcsum+=(q2-q1)*(alpha*prms[states].f2[r-1]+ (1-alpha)*f2);
        }
      }
    }
    prms[states].rows=T[states].rows;
    printf("Integrated f2 for state %d= %g, Mu_s=%g\n",states,prms[states].f2sum,RE*RE*prms[states].f2sum); 
  }
  
  if (radius){
    if (yheight) shape=CYLINDER;
    else shape=SPHERE;
  }else if (xwidth && yheight && zdepth){
    shape=BOX;
  }
  if (shape==NONE){
    fprintf(stderr,"Error (%s): could not understand which shape the thing is\n",NAME_CURRENT_COMP);exit(1);
  }

/*Read absorption table*/
  t_Table A;
  if ( (status=Table_Read(&A,material_datafile,0))==-1){
    fprintf(stderr,"Error: Could not parse file \"%s\" in COMP %s\n",material_datafile,NAME_CURRENT_COMP);
    exit(-1);
  }
  char **header_parsed;
  header_parsed=Table_ParseHeader(A.header,"Z","A[r]","rho","Z/A","sigma[a]",NULL);
  Prms=calloc(1,sizeof(struct mat_prms));
  Prms->E=malloc(sizeof(double)*(A.rows+1));
  Prms->mu=malloc(sizeof(double)*(A.rows+1));
  if(header_parsed[2]){Prms->rho=strtod(header_parsed[2],NULL);}
  else{fprintf(stderr,"Warning(%s): %s found in header of %s, set to 1\n",NAME_CURRENT_COMP,"rho",material_datafile);Prms->rho=1;}
  /*which columns holds the mus*/
  int mu_c=5;
  if (A.columns==3) mu_c=1;

  int i;
  for (i=0;i<A.rows;i++){
    Prms->E[i]=A.data[i*A.columns];
    Prms->mu[i]=A.data[mu_c+i*A.columns]*Prms->rho*1e2;     /*mu is now in SI, [m^-1]*/ 
  }

  Prms->E[A.rows]=-1.0;
  Prms->mu[A.rows]=-FLT_MAX;
  
  Table_Free(&A);


%}

TRACE
%{
  int hit,state;
  double alpha,e,k,mu;
  double l0,l1;
  int i;
  if (shape==CYLINDER){
    hit=cylinder_intersect(&l0,&l1,x,y,z,kx,ky,kz,radius,yheight);
    /*sample is a cylinder*/
  }else if (shape==SPHERE){
    /*sample is a sphere - unlikely*/
    hit=sphere_intersect(&l0,&l1,x,y,z,kx,ky,kz,radius);
  }else if (shape==BOX){
    /*sample is a box*/
    hit=box_intersect(&l0,&l1,x,y,z,kx,ky,kz,xwidth,yheight,zdepth);
  }
  if (hit){
    /*if we've intersected with the sample, propagate to intersection*/ 
    PROP_DL(l0);

    /*Absorption table interpolation*/
    k=sqrt(kx*kx+ky*ky+kz*kz);
    e=k*K2E;
    i=0;
    while (e>Prms->E[i]){
      i++;
      if (Prms->E[i]==-1){
        fprintf(stderr,"Photon energy (%g keV) is outside the filter's material data\n",e); ABSORB;
      }
    }
    alpha=(e-Prms->E[i-1])/(Prms->E[i]-Prms->E[i-1]);
    mu=(1-alpha)*Prms->mu[i-1]+alpha*Prms->mu[i];
    /*which state is the molecule in?*/
    /*delta_T is positive for optical pulse coming before x-ray pulse (t). Assuming the optical pulse to be  
     *short, relaxation has progressed since t+delta_t. Then the probability
     *the molecule is in an excited state is: excitation_yield* t_relax * exp(-t_relax *(t+delta_t)*/
    if(delta_t<t){
      /*photon arrives before pump pulse - molecule cannot be excited*/
      state=0;
    }else {
      double r=rand01();
      if( r< excitation_yield * exp(-(t+delta_t)/t_relax) ){
        /*excited state*/
        //printf("I'm excited %g %g %e\n",r, excitation_yield * exp(-(t+delta_t)/t_relax),t);
        state=1;
      }else{
        //printf("I'm bored %g %g %e\n",r, excitation_yield * exp(-(t+delta_t)/t_relax),t);
        state=0;
      }
    }
    /*now figure out if we scatter at all*/
    double dl=l1-l0;
    double mu_s=RE*RE*prms[state].f2sum;
    double l_conc=pow(concentration,0.3333333333333333333333333333333333333);
    double pmul=1,p_s;
    double pr;
    p_s=1-exp(-mu_s*dl);

    pr=rand01();
    if (p_transmit<pr){
      /*scattering branch*/
      /*find scattering pt*/
      dl=rand01()*dl;

      PROP_DL(dl);
      SCATTER;

	/*Absorption before scattering*/
      p*=exp(-mu*dl);


      /*figure out accessible q for the incident wavelength*/
      double psi,eta,q,alpha,f2,rr;
      eta=rand01()*(etamax-etamin)+ etamin;
      psi=rand01()*(psimax-psimin)+ psimin;
      q=k*M_SQRT2*sqrt(1-cos(psi));
      
      /*find f2 for this q by interpolation*/
      int r;
      for(r=1;r<nq;r++){
        if (prms[state].q[r]>q) break;
      }
      alpha=(q-prms[state].q[r-1])/(prms[state].q[r]-prms[state].q[r-1]);
      f2=(1-alpha)*prms[state].f2[r-1] + alpha*prms[state].f2[r];

      /*apply psi and eta rotations to k to get the new vector*/
      /*first find a vector to rotate psi around - this is the
projection of y
       * onto the plane normal to k*/
      double ktx,kty,ktz;
      double ax,ay,az;
      ax= 0 - ky/k * kx/k;
      ay= 1 - ky/k * ky/k;
      az= 0 - ky/k * kz*k;
      rotate(ktx,kty,ktz,kx,ky,kz,psi,ax,ay,az);
      /*now rotate eta around the initial k-vector*/
      rotate(kx,ky,kz, ktx,kty,ktz, eta, kx,ky,kz);
      
      /*using this new vector, recompute the intersections to find length to go to correct for multiple scattering and absorption*/ 
      if (shape==CYLINDER){
        hit=cylinder_intersect(&l0,&l1,x,y,z,kx,ky,kz,radius,yheight);
        /*sample is a cylinder*/
      }else if (shape==SPHERE){
        /*sample is a sphere - unlikely*/
        hit=sphere_intersect(&l0,&l1,x,y,z,kx,ky,kz,radius);
      }else if (shape==BOX){
        /*sample is a box*/
        hit=box_intersect(&l0,&l1,x,y,z,kx,ky,kz,xwidth,yheight,zdepth);
      }

      /*scale p according to F2 and \int_0_inf F2*/ 
      p*=(f2/prms[state].f2sum) * (psimax-psimin)/M_PI * (etamax-etamin)/(2*M_PI) *  p_s/(1-p_transmit);
      //p*=prms[state].f2mcsum/prms[state].f2sum * (etamax-etamin)/(2*M_PI) *  p_s/(1-p_transmit);

	/*Absorption after scattering*/
      p*=exp(-mu*l1);
      //printf("ATT: %g %g %g\n",l1,mu,exp(-mu*l1));

    }else{
      /*tunneling branch*/
      /*downscale p by the total amount of scattering while going straight through ,weighted */
      p*=(1-p_s)/(p_transmit);
      /*also downscale for absorption effects*/
      l1-=l0;
      p*=exp(-mu*l1);
      /*here we should also take into account flourescence*/
    }
  }
%}

MCDISPLAY
%{
  magnify("");
  if (shape==CYLINDER){
    /*sample is a cylinder*/
    circle("xz", 0,  yheight/2.0, 0, radius);
    circle("xz", 0, -yheight/2.0, 0, radius);
    line(-radius, -yheight/2.0, 0, -radius, +yheight/2.0, 0);
    line(+radius, -yheight/2.0, 0, +radius, +yheight/2.0, 0);
    line(0, -yheight/2.0, -radius, 0, +yheight/2.0, -radius);
    line(0, -yheight/2.0, +radius, 0, +yheight/2.0, +radius);
  }else if (shape==SPHERE){
    /*sample is a sphere*/
    circle("xy",0,0,0,radius);
    circle("xz",0,0,0,radius);
    circle("yz",0,0,0,radius);
  }else if (shape==BOX){
   /*sample is a box*/
    box(0,0,0,xwidth,yheight,zdepth); 
  }


  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
%}

END
