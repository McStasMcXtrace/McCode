/*******************************************************************************
*
* McXtrace, X-ray tracing package
*         Copyright 1997-2002, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Component: Filter
*
* %I
* Written by: Erik Knudsen
* Date: Jan 24, 2011
* Version: $Revision$
* Origin: DTU Physics
* Release: McXtrace 1.1
*
* Block of an attenuating material
* 
* %D
* A rectangular block of attenuating material. Attenuation is computed through
* the effective length travelled within the material. No scattering is modelled at present.
*
* %P
* INPUT PARAMETERS
*
* xwidth: Width of block. (m) 
* yheight: Height of block. (m)
* zdepth:  Thickness of block. (m)
* material_datafile: Dile where the material parameters for the filter may be found. Format is similar to what may be found off the NISP website. [Be.txt]
* geometry: File (oof/ply) containing the polygon definition of a general shape object. ( )
* %E
*******************************************************************************/
DEFINE COMPONENT Filter
DEFINITION PARAMETERS (refraction=1,fixed_delta=0,string material_datafile="Be.txt")
SETTING PARAMETERS (string geometry=0,xwidth,yheight,zdepth) 
OUTPUT PARAMETERS (prms,filter_row)
/* X-ray parameters: (x,y,z,kx,ky,kz,phi,t,Ex,Ey,Ez,p) */ 

SHARE
%{
  %include "read_table-lib"
  %include "interoff-lib"

  enum shapes_t {NONE=-1,SPHERE, CUBE, ELLIPSOID, ANY};

  int filter_refract(double *kx, double *ky, double *kz, double nx, double ny, double nz, double delta0, double delta1){
    const double n2=scalar_prod(nx,ny,nz, nx,ny,nz);
    const double k=sqrt(scalar_prod(*kx,*ky,*kz, *kx,*ky,*kz));
    const double nr=(1.0-delta0)/(1.0-delta1);
    double kxi=*kx;
    double kyi=*ky;
    double kzi=*kz;
    double s;

    NORM(kxi,kyi,kzi);
    if(n2!=1){
      NORM(nx,ny,nz);
    }
    //kinv=1.0/sqrt(k2);
    s=scalar_prod(nx,ny,nz,kxi,kyi,kzi);
    if(s>0){
      /*n points in the direction of k - i.e. into material 1, so use -n instead*/
      double sinth2=nr*nr*(1.0-(s)*(s));
      *kx=nr* (kxi) - (nr*(-s)+sqrt(1.0-sinth2))*(-nx);
      *ky=nr* (kyi) - (nr*(-s)+sqrt(1.0-sinth2))*(-ny);
      *kz=nr* (kzi) - (nr*(-s)+sqrt(1.0-sinth2))*(-nz);
    } else {
      /*n points oppsite to k - i.e. out of material 1, into mat. 0*/ 
      double sinth2=nr*nr*(1.0-s*s);
      *kx=nr* (kxi) - (nr*s+sqrt(1.0-sinth2))*nx;
      *ky=nr* (kyi) - (nr*s+sqrt(1.0-sinth2))*ny;
      *kz=nr* (kzi) - (nr*s+sqrt(1.0-sinth2))*nz;
    }
    *kx *=k;
    *ky *=k;
    *kz *=k;
    return 1;
  }

%}

DECLARE
%{
  struct {
    int Z,mu_c;
    double Ar, rho;
    double delta_prefactor,betafact;
    t_Table table;
    enum shapes_t shape;
    off_struct offdata;
  } *prms;
  int filter_row;

%}

INITIALIZE
%{
  int status=0;
 
  if(!xwidth || !yheight || !zdepth){
    fprintf(stderr,"%s: Filter has zero effective volume\n",NAME_CURRENT_COMP);
    exit(0);
  }
  
  prms=calloc(1,sizeof(* prms));
  
  //t_Table T;
  if ( (status=Table_Read(&(prms->table),material_datafile,0))==-1){
    fprintf(stderr,"Error: Could not parse file \"%s\" in COMP %s\n",material_datafile,NAME_CURRENT_COMP);
    exit(-1);
  }
  char **header_parsed;
  header_parsed=Table_ParseHeader(prms->table.header,"Z","A[r]","rho","Z/A","sigma[a]",NULL);
  if (header_parsed[0]){prms->Z=strtol(header_parsed[0],NULL,10);}
  if (header_parsed[1]){prms->Ar=strtod(header_parsed[1],NULL);}
  if (header_parsed[2]){prms->rho=strtod(header_parsed[2],NULL);}
  else{fprintf(stderr,"Warning(%s): %s not found in header of %s, set to 1\n",NAME_CURRENT_COMP,"rho",material_datafile);prms->rho=1;}
  /*which columns holds the mus*/
  prms->mu_c=5;
  if (prms->table.columns==3) prms->mu_c=1;

  prms->delta_prefactor= NA*(prms->rho*1e-24)/prms->Ar * 2.0*M_PI*RE;
  int j;
  for (j=0;j<prms->table.rows;j++){
    prms->table.data[j*prms->table.columns]=log(prms->table.data[j*prms->table.columns]);
  }/*now in terms of log e instead of just e - makes for better rebinning*/
  if(10*(double)mcget_ncount()>(prms->table.max_x-prms->table.min_x)/(prms->table.step_x)){
    /*it is probably worth Rebinning*/
    printf("%s: Rebinning material data (%s) for faster tracing...",NAME_CURRENT_COMP,material_datafile); 
    Table_Rebin(&(prms->table));
    printf("done\n");
  }
  
  /*if wanted, do the thing with off - file*/
  prms->shape=CUBE; 
  if (geometry && strlen(geometry) && strcmp(geometry, "NULL") && strcmp(geometry, "0")) {
    if (off_init(geometry, xwidth, yheight, zdepth, 0, &(prms->offdata))) {
      prms->shape=ANY; 
    }
  }
%}

TRACE
%{
  double alpha,e,k,mu,mu0,delta,beta,f;
  double l0,l1,nx,ny,nz;
  int i,status=0;
  if (prms->shape==CUBE) {
    status=box_intersect(&l0,&l1,x,y,z,kx,ky,kz,xwidth,yheight,zdepth);
  }else if (prms->shape==ANY){
    status = off_x_intersect(&l0, &l1, NULL, NULL, x, y, z, kx, ky, kz, prms->offdata );
    //if(status) printf("intersected off - object %d %g %g\n",status,l0,l1);
  } 

  if(status){
    PROP_DL(l0);
    k=sqrt(kx*kx+ky*ky+kz*kz);
    e=k*K2E;
    /*Material's Number Density of Electrons [e/A^3] incl f' scattering length correction*/
    /*We have reparametrized e as log(e) for a more practical constant step table.*/
    f=Table_Value(prms->table,log(e),1);
    delta = (fixed_delta ? fixed_delta : f/(k*k) * prms->delta_prefactor);
    mu0=Table_Value(prms->table,log(e),prms->mu_c)*prms->rho*1e2;
    beta = mu0/(2*k);

    /*change direction of ray due to refraction*/
    if(refraction){
      switch (prms->shape){
        case CUBE:
          if( fabs(x-xwidth*0.5)<FLT_EPSILON || fabs(x+xwidth*0.5)<FLT_EPSILON ){
            nx=1.0;ny=0.0;nz=0.0;
          }else if( fabs(y-yheight*0.5)<FLT_EPSILON || fabs(y+yheight*0.5)<FLT_EPSILON ){ 
            nx=0.0;ny=1.0;nz=0.0;
          }else if( fabs(z-zdepth*0.5)<FLT_EPSILON || fabs(z+zdepth*0.5)<FLT_EPSILON ){ 
            nx=0.0;ny=0.0;nz=1.0;
          };
          break;
        default:
          1;
      }
      status=filter_refract(&kx,&ky,&kz,nx,ny,nz,0.0,delta);
      SCATTER;
    }

    /*change k ' we're now inside some material*/
    kx*=1-delta;
    ky*=1-delta;
    kz*=1-delta;

    /*propagate to next intersection with filter (assumed to be exit)*/
    l1-=l0; 
    p*=exp(-mu0*l1);
    SCATTER;
    PROP_DL(l1);
    
    /*change direction of ray due to refraction*/
    if(refraction){
      switch (prms->shape){
        case CUBE:
          if( fabs(x-xwidth*0.5)<FLT_EPSILON || fabs(x+xwidth*0.5)<FLT_EPSILON ){
            nx=1.0;ny=0.0;nz=0.0;
          }else if( fabs(y-yheight*0.5)<FLT_EPSILON || fabs(y+yheight*0.5)<FLT_EPSILON ){ 
            nx=0.0;ny=1.0;nz=0.0;
          }else if( fabs(z-zdepth*0.5)<FLT_EPSILON || fabs(z+zdepth*0.5)<FLT_EPSILON ){ 
            nx=0.0;ny=0.0;nz=1.0;
          };
          break;
        default:
          1;
      }
      SCATTER;
      status=filter_refract(&kx,&ky,&kz,nx,ny,nz,delta,0.0);
    }

    /*correct for optical path length through the material*/
    /*change k back*/
    kx/=1-delta;
    ky/=1-delta;
    kz/=1-delta;
  }
%}

FINALLY
%{
  Table_Free(&(prms->table));
  free(prms);
%}

MCDISPLAY
%{
  magnify("xy");
  if (prms->shape==CUBE){
    box(0,0,0,xwidth,yheight,zdepth);
  }else if (prms->shape == ANY) {	/* OFF file */
    off_display(prms->offdata);
  }
%}

END
