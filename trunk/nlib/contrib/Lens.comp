/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright (C) 1997-2009, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Component: Lens
*
* %Identification
*
* Written by: C. Monzat/E. Farhi/S. Desert
* Date: 2009
* Version: $Revision 1.0$
* Origin: ILL
* Release: McStas 2.0
*
* Refractive Lens with absorption, incoherent scattering and surface imperfection. May be spherical or parabolic
*
* %Description
*
*
* %Parameters
* INPUT PARAMETERS:
* r1 (m)  : radius of the first circle describing the lens
* r2 (m)  : radius of the second circle describing the lens
* focus1 (m) : focal of the first parabola describing the lens
* focus2 (m) : focal of the second parabola describing the lens
* phiy1 (degrees) : angle of plane1 (r1=0) around y axis
* phiy2 (degrees) : angle of plane2 (r2=0) around y axis
* r>0 means concave face, r<0 means convex, r=0 means plane
* H  (m) : thickness of the lens
* bc (fm)  : bound coherent scattering length
* d   : density of the considered element for the lens
* M (g/mol)  : molar mass of the element
* R (m)  : height of the lens
* focus_aw (degrees) : vertical zone to focus after diffusion
* focus_ah (degrees) : horizontal zone to focus after diffusion
* sigma_coh (barn) : coherent cross section
* sigma_inc (barn) : incoherent cross section
* sigma_abs (barn) : thermal absorption cross section
* RMS (m) : root mean square of the surface
* %E
*******************************************************************************/

DEFINE COMPONENT Lens
DEFINITION PARAMETERS ()
SETTING PARAMETERS (r1=0.025,r2=0.025,focus1=0,focus2=0,phiy1=0,phiy2=0,H=0.001,bc=9.6656,sigma_coh=11.74,sigma_inc=0.0816,sigma_abs=0.0822,d=3.148,M=62.3018,R=0.015,p_interact=0.1,focus_aw=10,focus_ah=10,RMS=0)
OUTPUT PARAMETERS (n,average_n,nb_neutron)
STATE PARAMETERS (x,y,z,vx,vy,vz,t,s1,s2,p)


SHARE
%{
%}

DECLARE
%{
double n,average_n,nb_neutron;

%}

INITIALIZE
%{
average_n=0;
nb_neutron=0;

%}

TRACE
%{
double t0,t1,t2,t_out,temp,x_temp,y_temp,z_temp,z0,z1,z2,x0,cx,cy,cz,nx,ny,nz,theta,cos_theta,theta1,theta2,ax,ay,az,v1x,v1y,v1z,nv,delta1,alpha1,beta1,gamma1,phi_rad,phi_rad2,phi,rho,b,cste,lambda,n2,sign,sigma_tot,precision,oui,theta_RMS;

nv=sqrt(vx*vx+vy*vy+vz*vz);
precision=10e-6;

rho= d*6.02214179*pow(10,23)*pow(10,-24)/M; /*Number of atoms by AA^3, pow(10,-24) stands for conversion from cm^3 to AA^3*/
//rho=3.042882e-2;
//printf("rho %e\n",rho);

if (sigma_coh!=0){
	b=sqrt(sigma_coh*100/4/PI)*pow(10,-5);
}
else
{
	b=bc*pow(10,-5);/*b is in fm, converted to AA*/
}

cste= rho*b/PI;
// printf("\n Valeurs\n");
// printf("v : %f\n",nv);
lambda=3.9560032*pow(10,-7)*pow(10,10)/nv;
//printf("lambda : %f\n",lambda);
n= sqrt(1-(lambda*lambda*cste));
//printf("n : %f\n",n);

n2 = sqrt(1 - 4*PI*rho*b/(V2K*V2K*(vx*vx + vy*vy + vz*vz)));
//printf("n2 : %f\n\n",n2);
//printf("nÂ² : %f",1 - 4*PI*rho*b*poz(10,-5)/(V2K*(vx*vx + vy*vy + vz*vz)));

// printf("Lens\n");
// printf("vx1:%f ,vy1:%f ,vz1:%f \n\n",vx,vy,vz);
phi_rad=phiy1*2*PI/360;
phi_rad2=phiy2*2*PI/360;
theta_RMS=atan(2*RMS/lambda);
// 	printf("%f\n",x);
// 	printf("%f\n",y);
// 	printf("%f\n\n",z);
/*First face of the lens*/
if (r1!=0){
	if (sphere_intersect(&t0,&t1,x,y,z+H/2+r1,vx,vy,vz,fabs(r1))){
		if (r1>0)
			{PROP_DT(t1);
			if ((x*x+y*y<=R*R/4)&&(z>=-H/2-r1*(1-sqrt(1-R*R/(4*r1*r1)))))
				SCATTER;
			else ABSORB;}
		else
			{PROP_DT(t0);
			if ((x*x+y*y<=R*R/4)&&(z<=0))
				SCATTER;
			else ABSORB;}
	}
	else ABSORB;
}
else
{
	if (focus1!=0){
		temp = (-R*R/16/focus1-H/2-z)/vz;
		x_temp = vx*temp+x;
		y_temp = vy*temp+y;
		if (x_temp*x_temp+y_temp*y_temp > R*R/4) {
			ABSORB;}
// 		if ((x*x+y*y< (R*R/4)*0.01)&&(vx*vx+vy*vy<0.000001)){
// 		/*
// 		Spheric approximation of the parabol for rays close to z axis
// 		*/
// 			if (sphere_intersect(&t0,&t1,x,y,z+H/2+2*focus1,vx,vy,vz,2*focus1)){
// 				PROP_DT(t1);
// 				SCATTER;
// 			}
// 			else
// 			{ABSORB;}
// 		}
		if ((vx*vx+vy*vy<precision)){
		/*Approximation : trajectory of the neutron follows z axis
		*/
			t1=(-z-H/2-(x*x+y*y)/(4*focus1))/vz;
			PROP_DT(t1);
			SCATTER;
		}
		else
		{
			double zplus1=0.0;
			if (focus1<0) zplus1=R*R/16/focus1;
			alpha1 = (vx*vx+vy*vy);
			beta1  = 2*(vx*x+vy*y)+4*focus1*vz;
			gamma1 = x*x+y*y+4*focus1*((H/2)+z-zplus1);
			delta1 = beta1*beta1 - 4*alpha1*gamma1;
			
			if (delta1 < 0) ABSORB;
	
			t1= (-beta1 - sqrt(delta1))/(2*alpha1);
			t2= (-beta1 + sqrt(delta1))/(2*alpha1);
			//printf("z : %f\n",z);
			z1 = vz*t1+z;
			z2 = vz*t2+z;
			z0 = -R*R/(16*fabs(focus1))-H/2;
// 			printf("focus1\n");
// 			printf("alpha1 : %e\n",alpha1);
// 			printf("beta1: %e\n",beta1);
// 			printf("gamma1 : %e\n",gamma1);
// 			printf("delta1 : %e\n",delta1);
// 			printf("z : %f\n",z);
// 			printf("t1 : %f\n",t1);
// 			printf("t2 : %f\n",t2);
// 			printf("z0 : %f\n",z0);
// 			printf("z1 : %f\n",z1);
// 			printf("z2 : %f\n",z2);
			if ((focus1*z1>focus1*z2)&&(z1>z0)){
				PROP_DT(t1);
// 	 			printf("z1 : %g\n",z1);
				SCATTER;
			}
			else if ((focus1*z2>focus1*z1)&&(z2>z0)){
				PROP_DT(t2);
// 	 			printf("z2 : %g\n",z2);
				SCATTER;
			}
			else  {
	// 		printf("absorbed\n");
			ABSORB;}
		}
	}
	else
		if (plane_intersect(&t0,x,y,z,vx,vy,vz,-sin(phi_rad),0,-cos(phi_rad),0,0,-H/2)>0){
			{PROP_DT(t0);
			if (x*x+y*y<=R*R/4*cos(phi_rad)){
				//SCATTER;
				oui=0;
// 			printf("x : %e\n",x);
// 			printf("y : %e\n",y);
// 			printf("z : %e\n",z);
// 			printf("vx : %e\n",vx);
// 			printf("vy : %e\n",vy);
// 			printf("vz : %e\n",vz);
// 			printf("t : %e\n",t0);
			}
			else
				ABSORB;}
		}
		else ABSORB;
}
// double test=z+(x*x+y*y)/(4*focus1)+H/2;
// printf("diff : %e\n",test);
// printf("%f\n",x);
// printf("%f\n",y);
// printf("%f\n",z);

/*Refraction first face*/
if (r1!=0){
	sign=r1/fabs(r1);
	nx=-sign*x;
	ny=-sign*y;
	nz=sign*(-z-H/2-r1);
// 	printf("%f\n",nx);
// 	printf("%f\n",ny);
// 	printf("%f\n",nz);
}
else{
	if (focus1!=0){
		nx=-x/2/focus1;
		ny=-y/2/focus1;
		nz=-1;
// 		 	printf("%f\n",nx);
// 		 	printf("%f\n",ny);
// 		 	printf("%f\n",nz);
	}
	else
	{
		nx=-sin(phi_rad);
		ny=0;
		nz=-cos(phi_rad);
	}
}
//printf("avant :: nx : %f, ny : %f, nz : %f\n\n",nx,ny,nz);
if (RMS>0){
	double nt_x, nt_y, nt_z;  /* transverse vector */
	double n1_x, n1_y, n1_z;  /* normal vector (tmp) */
	double wav_z = theta_RMS;
	double phi=180/PI;

	wav_z  *= DEG2RAD/(sqrt(8*log(2)));
	/* normal vector n_z = [ 0,0,1], n_t = n x n_z; */
	vec_prod(nt_x,nt_y,nt_z, nx,ny,nz, 0,1,0);
	//printf("vecprod :: nt_x : %f, nt_y : %f, nt_z : %f\n\n",nt_x,nt_y,nt_z);
	/* rotate n with angle wav_z around n_t -> n1 */
	wav_z=wav_z*randnorm();
	//printf("wav_z : %f\n",wav_z);
	rotate(n1_x,n1_y,n1_z, nx,ny,nz,wav_z,nt_x,nt_y,nt_z);
	//printf("vecrot :: n1_x : %f, n1_y : %f, n1_z : %f\n\n",n1_x,n1_y,n1_z);

	/* rotate n1 with angle phi around n -> nt */
	rotate(nt_x,nt_y,nt_z, n1_x,n1_y,n1_z, phi*randnorm(), nx,ny,nz);
	//printf("vecrot2 :: nt_x : %f, nt_y : %f, nt_z : %f\n\n",nt_x,nt_y,nt_z);
	nx=nt_x;
	ny=nt_y;
	nz=nt_z;
}



// printf("test1\n");
NORM(nx,ny,nz);
//printf("apres :: nx : %f, ny : %f, nz : %f\n\n",nx,ny,nz);


vec_prod(ax,ay,az,nx,ny,nz,-vx,-vy,-vz);
// printf("ax1:%f ,ay1:%f ,az1:%f \n\n",ax,ay,az);
theta1 = atan2(sqrt(ax*ax+ay*ay+az*az),scalar_prod(nx,ny,nz,-vx,-vy,-vz));

//double theta_1 = acos((nx)*(-vx/nv)+(ny)*(-vy/nv)+(nz)*(-vz/nv));
//printf("in0 : %f\n",theta_incident*RAD2DEG);	
theta2=asin(sin(theta1)/n);
// printf("in1 : %f\n",theta1*RAD2DEG);
// printf("out1 : %f\n",theta2*RAD2DEG);
// printf("n : %f\n",n);
// printf("Diff1 : %f\n",(theta1-theta2)*RAD2DEG);
// printf("x : %f\n",x);
// printf("y : %f\n",y);
// printf("z : %f\n",z);

alpha1 = (sin(theta2))/(sin(theta1));
beta1 = (alpha1*nv*cos(theta1))-(nv*cos(theta2));
vx = beta1*nx + alpha1*vx;
vy = beta1*ny + alpha1*vy;
vz = beta1*nz + alpha1*vz;

// printf("vx1:%f ,vy1:%f ,vz1:%f \n\n",vx,vy,vz);

/*Second face of the lens*/
if (r2!=0){
	if (sphere_intersect(&t0,&t1,x,y,z-H/2-r2,vx,vy,vz,fabs(r2))){
		if (r2>0)
			{//PROP_DT(t0);
			t_out=t0;
// 			if ((x*x+y*y<=R*R/4)&&(z<=H/2+r2*(1-sqrt(1-R*R/(4*r2*r2)))))
// 				SCATTER;
// 			else ABSORB;
			}
		else
			{//PROP_DT(t1);
			t_out=t1;
// 			if ((x*x+y*y<=R*R/4)&&(z>=0))
// 				SCATTER;
// 			else ABSORB;
			}
	}
	else ABSORB;
}
else
{
	if (focus2!=0){
		temp = (R*R/16/focus2+H/2-z)/vz;
		x_temp = vx*temp+x;
		y_temp = vy*temp+y;
		if (x_temp*x_temp+y_temp*y_temp > R*R/4) {
			t_out=-1;}
		else
		{
	// 		if ((x*x+y*y< (R*R/4)*0.01)&&(vx*vx+vy*vy<0.000001)){
	// 		/*
	// 		Spheric approximation of the parabol for rays close to z axis
	// 		*/
	// 			if (sphere_intersect(&t0,&t1,x,y,z-H/2-2*focus1,vx,vy,vz,2*focus1)){
	// 				//PROP_DT(t0);
	// 				t_out=t0;
	// // 				SCATTER;
	// 			}
	// 			else
	// 			{ABSORB;}
	// 		}
			if ((vx*vx+vy*vy<precision)){
			/*Approximation : trajectory of the neutron follows z axis
			*/
				t1=(-z+H/2+(x*x+y*y)/(4*focus2))/vz;
				t_out=t1;
			}
			else
			{
				double zplus2=0.0;
				if (focus2<0) zplus2=R*R/16/focus2;
				alpha1 = vx*vx+vy*vy;
				beta1  = 2*(vx*x+vy*y)-vz*4*focus2;
				gamma1 = x*x+y*y+4*focus2*(H/2-z-zplus2);
				delta1 = beta1*beta1 - 4*alpha1*gamma1;
				
				if (delta1 < 0) t_out=-1;
				else 
				{
					t1= (-beta1 - sqrt(delta1))/(2*alpha1);
					t2= (-beta1 + sqrt(delta1))/(2*alpha1);
					z1 = vz*t1+z;
					z2 = vz*t2+z;
			
					z0=R*R/(16*fabs(focus2))+H/2;
		// 			printf("focus2\n");
		// 			printf("z : %f\n",z);
		// 			printf("t1 : %f\n",t1);
		// 			printf("t2 : %f\n",t2);
		// 			printf("z0 : %f\n",z0);
		// 			printf("z1 : %f\n",z1);
		// 			printf("z2 : %f\n",z2);
					if ((focus2*z1<focus2*z2)&&(z1<=z0)){
						//PROP_DT(t1);
						t_out=t1;
			 			//printf("z1\n");
						}
					else if ((focus2*z2<focus2*z1)&&(z2<=z0)){
						//PROP_DT(t2);
						t_out=t2;
			 			//printf("z2\n");
						}
					else {
					//printf("absorbed\n");
					t_out=-1;}
				}
			}
		}
	}
	else
		if (plane_intersect(&t0,x,y,z,vx,vy,vz,-sin(phi_rad2),0,-cos(phi_rad2),0,0,H/2)>0){
			{//PROP_DT(t0);
			t_out=t0;
			x_temp = vx*t_out+x;
			y_temp = vy*t_out+y;
			if (x_temp*x_temp+y_temp*y_temp>R*R/4*cos(phi_rad2))
				t_out=-1;
			}
		}
		else ABSORB;
}

/*Absorption and diffusion between the two faces*/
double my_s,my_a_v,my_a,my_t,p_trans,p_scatt,mc_trans,mc_scatt,dt,aw,ah,ws,d_path;
double p_mult=1;
int flag=0;
double l_i=0;
double solid_angle=0;
double x_in,y_in,z_in;
double vx_in,vy_in,vz_in;

nv=sqrt(vx*vx+vy*vy+vz*vz);
x_in=x;
y_in=y;
z_in=z;
vx_in=vx;
vy_in=vy;
vz_in=vz;
// printf("debut\n");
//printf("x : %f,y : %f,z : %f\n\n",x_in,y_in,z_in);
// printf("vx1:%f ,vy1:%f ,vz1:%f \n\n",vx,vy,vz);
// printf("p : %f\n",p);
aw=DEG2RAD*focus_aw;
ah=DEG2RAD*focus_ah;
my_s=rho * 100 *(sigma_inc+sigma_coh);
my_a_v=rho * 100 * sigma_abs;
// printf("my_s : %e\n",my_s);
// printf("my_a_v : %e\n",my_a_v);
// printf("v : %f\n",nv);
if (nv) my_a = my_a_v*(2200/nv);
else
{
	printf("Incoherent: %s: ERROR: Null velocity\n",NAME_CURRENT_COMP);
	ABSORB; /* should never occur */
}

my_t = my_a + my_s;
ws = my_s/my_t;  /* (inc+coh)/(inc+coh+abs) */

d_path = nv * t_out;
// printf("dpath : %e\n",d_path);
// printf("t : %e\n",t_out);
/* Proba of transmission along length d_path */
p_trans = exp(-my_t*d_path);
p_scatt = 1 - p_trans;

flag = 0; /* flag used for propagation to exit point before ending */
/* are we next to the exit ? probably no scattering (avoid rounding errors) */
if (my_s*d_path <= 4e-7) {
	flag = 1;           /* No interaction before the exit */
}

/* force a given fraction of the beam to scatter */
if (p_interact>0 && p_interact<=1) {
	/* we force a portion of the beam to interact */
	/* This is used to improve statistics on single scattering (and multiple) */
	mc_trans = 1-p_interact;
} else {
	mc_trans = p_trans; /* 1 - p_scatt */
}

mc_scatt = 1 - mc_trans; /* portion of beam to scatter (or force to) */
if (mc_scatt <= 0 || mc_scatt>1) flag=1;

/* MC choice: Interaction or transmission ? */
if (!flag && mc_scatt > 0 && (mc_scatt >= 1 || (rand01()) < mc_scatt)) { /* Interaction neutron/sample */
	p_mult *= ws; /* Update weight ; account for absorption and retain scattered fraction */
	/* we have chosen portion mc_scatt of beam instead of p_scatt, so we compensate */
	p_mult *= fabs(p_scatt/mc_scatt); /* lower than 1 */
} else {
	flag = 1; /* Transmission : no interaction neutron/sample */
	p_mult *= fabs(p_trans/mc_trans);  /* attenuate beam by portion which is scattered (and left along) */
}

if (flag) { /* propagate to exit of sample and finish */
	p *= p_mult; /* apply absorption correction */
// 	printf("No scattering\n");
// 	printf("p_trans  : %e\n",p);
	//printf("t_out : %g\n",t_out);
	if (t_out<0) ABSORB;
	else
	{
	PROP_DT(t_out);
	}
}
else
{
	double a;
	if (my_t*d_path < 1e-6){
		/* For very weak scattering, use simple uniform sampling of scattering
		point to avoid rounding errors. */
		dt = rand0max(d_path); /* length */
		//printf("test\n");
	} else {
		a = rand0max((1 - exp(-my_t*d_path)));
		dt = -log(1 - a) / my_t; /* length */
	}
// 	printf("my_t %e\n",my_t);
// 	printf("d_path %e\n",d_path);
// 	printf("my_t*d_path %e\n",my_t*d_path);
// 	printf("1-exp %e\n",(1 - exp(-my_t*d_path)));
// 	printf("rand : %e\n",a);
// 	printf("1/my_t : %e\n",1/my_t);
// 	printf("dpath : %f\n",d_path);
//  	printf("dt : %e\n",dt);
	l_i = dt;/* Penetration in sample: scattering+abs */
	dt /= nv; /* Time from present position to scattering point */
// 	printf("scattering\n");
	PROP_DT(dt); /* Point of scattering */
// 	printf("vx1:%f ,vy1:%f ,vz1:%f \n\n",vx,vy,vz);
// 	printf("t : %f\n",t_out);
	randvec_target_rect_angular(&vx, &vy, &vz, &solid_angle,0,0,1 /*x_in+vx_in*t_out,y_in+vy_in*t_out,z_in+vz_in*t_out*/, aw, ah, ROT_A_CURRENT_COMP);
	NORM(vx, vy, vz);
// 	printf("solid angle %f \n",solid_angle);
// 	printf("aw:%f ,ah:%f\n",aw,ah);
	vx*=nv;
	vy*=nv;
	vz*=nv;
// 	printf("vx1:%f ,vy1:%f ,vz1:%f \n\n",vx,vy,vz);
// 	printf("x : %f,y : %f,z : %f\n\n",x_in+vx_in*t_out,y_in+vy_in*t_out,z_in+vz_in*t_out);
	p_mult *= solid_angle/4/PI;
	p *= p_mult;
	SCATTER;
// 	printf("p_scatt : %e\n",p);
	/*refraction second face*/
	if (r2!=0){
		if (sphere_intersect(&t0,&t1,x,y,z-H/2-r2,vx,vy,vz,fabs(r2))){
			if (r2>0)
				{PROP_DT(t0);
				if ((x*x+y*y<=R*R/4)&&(z<=H/2+r2*(1-sqrt(1-R*R/(4*r2*r2)))))
					SCATTER;
				else ABSORB;
				}
			else
				{PROP_DT(t1);
				if ((x*x+y*y<=R*R/4)&&(z>=0))
					SCATTER;
				else ABSORB;}
		}
		else ABSORB;
	}
	else
	{
		if (focus2!=0){
			temp = (R*R/16/focus1+H/2-z)/vz;
			x_temp = vx*temp+x;
			y_temp = vy*temp+y;
			if (x_temp*x_temp+y_temp*y_temp > R*R/4) {
				ABSORB;}
// 			if ((x*x+y*y< (R*R/4)*0.01)&&(vx*vx+vy*vy<0.000001)){
// 			/*
// 			Spheric approximation of the parabol for rays close to z axis
// 			*/
// 				if (sphere_intersect(&t0,&t1,x,y,z-H/2-2*focus1,vx,vy,vz,2*focus1)){
// 					PROP_DT(t0);
// 					SCATTER;
// 				}
// 				else
// 				{ABSORB;}
// 			}
			if ((vx*vx+vy*vy<precision)){
			/*Approximation : trajectory of the neutron follows z axis
			*/
				t1=(-z+H/2+(x*x+y*y)/(4*focus1))/vz;
				PROP_DT(t1);
				SCATTER;
			}
			else
			{
				double zplus2=0.0;
				if (focus2<0) zplus2=R*R/16/focus2;
				alpha1 = vx*vx+vy*vy;
				beta1  = 2*(vx*x+vy*y)-vz*4*focus2;
				gamma1 = x*x+y*y+4*focus2*(H/2-z-zplus2);
				delta1 = beta1*beta1 - 4*alpha1*gamma1;
				if (delta1 < 0) ABSORB;
		
				t1= (-beta1 - sqrt(delta1))/(2*alpha1);
				t2= (-beta1 + sqrt(delta1))/(2*alpha1);
				z1 = vz*t1+z;
				z2 = vz*t2+z;
		
				z0=R*R/(16*fabs(focus2))+H/2;
		// 		printf("focus2\n");
		// 		printf("z : %f\n",z);
		// 		printf("t1 : %f\n",t1);
		// 		printf("t2 : %f\n",t2);
		// 		printf("z0 : %f\n",z0);
		// 		printf("z1 : %f\n",z1);
		// 		printf("z2 : %f\n",z2);
				if ((focus2*z1<focus2*z2)&&(z1<=z0)){
					PROP_DT(t1);
					SCATTER;
		  			//printf("z1\n");
					}
				else if ((focus2*z2<focus2*z1)&&(z2<=z0)){
					PROP_DT(t2);
					SCATTER;
					//printf("z2\n");
					}
				else {
		 		printf("absorbed\n");
				ABSORB;}
			}
		}
		else
		{
			if (plane_intersect(&t0,x,y,z,vx,vy,vz,-sin(phi_rad2),0,-cos(phi_rad2),0,0,H/2)>0){
				{PROP_DT(t0);
				if (x*x+y*y<=R*R/4*cos(phi_rad2)){
					//SCATTER;
					oui=0;
				}
				else
					ABSORB;}
			}
			else ABSORB;
		}
	}
}

//printf("test0\n");
/*Refraction secund face*/
if (r2!=0){
	sign=r2/fabs(r2);
	nx=sign*x;
	ny=sign*y;
	nz=sign*(z-H/2-r2);
}
else
{
	if (focus2!=0){
		nx=x/2/focus2;
		ny=y/2/focus2;
		nz=-1;
	}
	else
	{
		nx=-sin(phi_rad2);
		ny=0;
		nz=-cos(phi_rad2);
	}
}

// printf("avant :: nx : %f, ny : %f, nz : %f\n\n",nx,ny,nz);
if (RMS>0){
	double nt_x, nt_y, nt_z;  /* transverse vector */
	double n1_x, n1_y, n1_z;  /* normal vector (tmp) */
	double wav_z = theta_RMS;
	double phi=rand01()*180/PI;

	wav_z  *= DEG2RAD/(sqrt(8*log(2)));
	/* normal vector n_z = [ 0,0,1], n_t = n x n_z; */
	vec_prod(nt_x,nt_y,nt_z, nx,ny,nz, 0,1,0);
	//printf("vecprod :: nt_x : %f, nt_y : %f, nt_z : %f\n\n",nt_x,nt_y,nt_z);
	/* rotate n with angle wav_z around n_t -> n1 */
	wav_z=wav_z*randnorm();
// 	printf("wav_z : %f\n",wav_z);
	rotate(n1_x,n1_y,n1_z, nx,ny,nz,wav_z,nt_x,nt_y,nt_z);
// 	printf("vecrot :: n1_x : %f, n1_y : %f, n1_z : %f\n\n",n1_x,n1_y,n1_z);

	/* rotate n1 with angle phi around n -> nt */
	rotate(nt_x,nt_y,nt_z, n1_x,n1_y,n1_z, phi*randnorm(), nx,ny,nz);
// 	printf("vecrot2 :: nt_x : %f, nt_y : %f, nt_z : %f\n\n",nt_x,nt_y,nt_z);
	nx=nt_x;
	ny=nt_y;
	nz=nt_z;
}

NORM(nx,ny,nz);
// printf("apres :: nx : %f, ny : %f, nz : %f\n\n",nx,ny,nz);
vec_prod(ax,ay,az,nx,ny,nz,-vx,-vy,-vz);
// printf("ax2:%f ,ay2:%f ,az2:%f \n\n",ax,ay,az);
theta1 = atan2(sqrt(ax*ax+ay*ay+az*az),scalar_prod(nx,ny,nz,-vx,-vy,-vz));

theta2=asin(sin(theta1)*n);
// printf("in2 : %f\n",theta1*RAD2DEG);
// printf("out2 : %f\n",theta2*RAD2DEG);
// printf("Diff2 : %f\n",(theta2-theta1)*RAD2DEG);
// printf("x : %f\n",x);
// printf("y : %f\n",y);
// printf("z : %f\n",z);

nv=sqrt(vx*vx+vy*vy+vz*vz);
alpha1 = (sin(theta2))/(sin(theta1));
beta1 = (alpha1*nv*cos(theta1))-(nv*cos(theta2));
vx = beta1*nx + alpha1*vx;
vy = beta1*ny + alpha1*vy;
vz = beta1*nz + alpha1*vz;

// printf("vx2:%f ,vy2:%f ,vz2:%f \n\n",vx,vy,vz);

average_n+=n;
nb_neutron++;
%}

FINALLY
%{
if (nb_neutron!=0)
	average_n=average_n/nb_neutron;
else
	average_n=0;
printf("Numbers of neutrons : %f\n",nb_neutron);
printf("Average n : %f\n",average_n);
%}

MCDISPLAY
%{
magnify("xy");
double x0,x1,y1,z1,theta1,theta2,theta00,theta01,eps,phi_rad,phi_rad2,gamma1,gamma2,eps2,theta_line,distance,height,height2,dist_parab1,dist_parab2;
int test=0;
phi_rad=phiy1*2*PI/360;
phi_rad2=phiy2*2*PI/360;
height=R/2;
height2=R/2;
dist_parab1=0.0;
dist_parab2=0.0;

if (r1!=0){
	theta00=asin(fabs((R/2)/r1));
	if (r1<0&&r2<=0&&(-r1+r1*cos(theta00)>H/2)){
		theta00=acos((fabs(r1)-H/2)/fabs(r1));
		height=fabs(r1)*sin(theta00);
	}
	
// 	eps=2*theta00/100.0;
// 	theta1=-theta00;
// 	theta2= theta1+eps;
// 	eps2=2*theta00/10.0;
// 	gamma1=-theta00;
// 	gamma2= gamma1;
// 	while (gamma2<=theta00){
// 		while (theta2<=theta00){
// 			line(r1*sin(theta1)*cos(gamma2),r1*sin(gamma2),-H/2-r1+r1*cos(theta1)*cos(gamma2),r1*sin(theta2)*cos(gamma2),r1*sin(gamma2),-H/2-r1+r1*cos(theta2)*cos(gamma2));
// 			line(r1*sin(gamma2),r1*sin(theta1)*cos(gamma2),-H/2-r1+r1*cos(theta1)*cos(gamma2),r1*sin(gamma2),r1*sin(theta1)*cos(gamma2),-H/2-r1+r1*cos(theta2)*cos(gamma2));
// 			theta1=theta2;
// 			theta2+=eps;
// 		}
// 	theta1=-theta00;
// 	theta2= theta1+eps;
// 	gamma2+=eps2;
// 	}
	theta1=-theta00;
	eps=theta00/10.0;
	eps2=2*PI/10.0; 
	while (theta1<0){
		circle("xy",0,0,-H/2-r1+r1*cos(theta1),fabs(r1)*sin(theta1));
		theta1+=eps;
		theta_line=0;
		while (theta_line<2*PI){
			line(fabs(r1)*sin(theta1-eps)*cos(theta_line),fabs(r1)*sin(theta1-eps)*sin(theta_line),-H/2-r1+r1*cos(theta1-eps),fabs(r1)*sin(theta1)*cos(theta_line),fabs(r1)*sin(theta1)*sin(theta_line),-H/2-r1+r1*cos(theta1));
			theta_line+=eps2;
		}
	}
	//circle("xz",0,0,-H/2-r1,fabs(r1));
}
else
{
	if (focus1!=0){
// 		eps=R/100;
// 		x0=-R/2;
// 		x1=x0+eps;
// 		while (x1<=R/2+eps){
// 			line(x0,0,-H/2-x0*x0/(4*focus1),x1,0,-H/2-x1*x1/(4*focus1));
// 			x0=x1;
// 			x1+=eps;
// 		}
		if (focus1>0){
			dist_parab1=-R*R/(16*focus1);
		}else{
			dist_parab1=0.0;
		}
		
		distance=-(R*R/4)/(4*focus1);
		eps=-distance/10.0;
		eps2=2*PI/10.0;
		while (focus1*distance<0){
			if (focus1>0){
				circle("xy",0,0,distance-H/2,sqrt((4*focus1*fabs(distance))));
				distance+=eps;
				theta_line=0;
				while (theta_line<2*PI){
				line(sqrt(4*fabs(focus1)*(fabs(distance-eps)))*cos(theta_line),sqrt(4*fabs(focus1)*(fabs(distance-eps)))*sin(theta_line),distance-eps-H/2,sqrt(4*fabs(focus1)*fabs(distance))*cos(theta_line),sqrt(4*fabs(focus1)*fabs(distance))*sin(theta_line),distance-H/2);
				theta_line+=eps2;
				}
			}else{
				circle("xy",0,0,(R*R/4)/(4*focus1)+distance-H/2,sqrt((4*fabs(focus1)*fabs(distance))));
				distance+=eps;
				theta_line=0;
				while (theta_line<2*PI){
				line(sqrt(4*fabs(focus1)*(fabs(distance-eps)))*cos(theta_line),sqrt(4*fabs(focus1)*(fabs(distance-eps)))*sin(theta_line),distance+(R*R/4)/(4*focus1)-eps-H/2,sqrt(4*fabs(focus1)*fabs(distance))*cos(theta_line),sqrt(4*fabs(focus1)*fabs(distance))*sin(theta_line),distance+(R*R/4)/(4*focus1)-H/2);
				theta_line+=eps2;
			}

			}
		}
	}
	else
	{
		test=1;
	}
}

if (r2!=0){
	theta01=asin(fabs((R/2)/r2));
	if (r1<=0&&r2<0&&(r2-r2*cos(theta01)<-H/2)){
		theta01=acos((fabs(r2)-H/2)/fabs(r2));
		height2=fabs(r2)*sin(theta01);
	}
	theta1=PI-theta01;
// 	eps=2*theta01/100.0;
// 	theta2= theta1+eps;
// 	while (theta2<=PI+theta01){
// 		line(r2*sin(theta1),0,H/2+r2+r2*cos(theta1),r2*sin(theta2),0,H/2+r2+r2*cos(theta2));
// 		theta1=theta2;
// 		theta2+=eps;
// 	}
	eps=(PI-theta1)/10.0;
	eps2=2*PI/10.0; 
	while (theta1<PI){
		circle("xy",0,0,H/2+r2+r2*cos(theta1),fabs(r2)*sin(theta1));
		theta1+=eps;
		theta_line=0;
		while (theta_line<2*PI){
			line(fabs(r2)*sin(theta1-eps)*cos(theta_line),fabs(r2)*sin(theta1-eps)*sin(theta_line),H/2+r2+r2*cos(theta1-eps),fabs(r2)*sin(theta1)*cos(theta_line),fabs(r2)*sin(theta1)*sin(theta_line),H/2+r2+r2*cos(theta1));
			theta_line+=eps2;
		}
	}
	//circle("xz",0,0,H/2+r2,fabs(r2));
}
else
{
	if (focus2!=0){
// 			eps=R/100;
// 			x0=-R/2;
// 			x1=x0+eps;
// 			while (x1<=R/2+eps){
// 				line(x0,0,H/2+x0*x0/(4*focus2),x1,0,H/2+x1*x1/(4*focus2));
// 				x0=x1;
// 				x1+=eps;
// 			}
			if (focus2>0){
				dist_parab2=R*R/(16*focus2);
			}else{
				dist_parab2=0.0;
			}

			distance=(R*R/4)/(4*focus2);
			height2=sqrt((4*focus2*fabs(distance)));
			eps=-distance/10.0;
			eps2=2*PI/10.0;
			while (focus2*distance>0){
				if (focus2>0){
				circle("xy",0,0,distance+H/2,sqrt((4*focus2*fabs(distance))));
				distance+=eps;
				theta_line=0;
				while (theta_line<2*PI){
					line(sqrt(4*focus2*(fabs(distance-eps)))*cos(theta_line),sqrt(4*focus2*(fabs(distance-eps)))*sin(theta_line),distance-eps+H/2,sqrt(4*focus2*fabs(distance))*cos(theta_line),sqrt(4*focus2*fabs(distance))*sin(theta_line),distance+H/2);
					theta_line+=eps2;
				}
				}else{
				circle("xy",0,0,-(R*R/4)/(4*focus2)+distance+H/2,sqrt((4*fabs(focus2)*fabs(distance))));
				distance+=eps;
				theta_line=0;
				while (theta_line<2*PI){
					line(sqrt(4*fabs(focus2)*(fabs(distance-eps)))*cos(theta_line),sqrt(4*fabs(focus2)*(fabs(distance-eps)))*sin(theta_line),distance-eps+H/2-(R*R/4)/(4*focus2),sqrt(4*fabs(focus2)*fabs(distance))*cos(theta_line),sqrt(4*fabs(focus2)*fabs(distance))*sin(theta_line),distance+H/2-(R*R/4)/(4*focus2));
					theta_line+=eps2;
				}
				}
			}
			
		}
		else
		{
			line(height,-height,(H/2-R/2*sin(phi_rad2))/cos(phi_rad2),-height,-height,(H/2+R/2*sin(phi_rad2))/cos(phi_rad2));
			line(height,height,(H/2-R/2*sin(phi_rad2))/cos(phi_rad2),-height,height,(H/2+R/2*sin(phi_rad2))/cos(phi_rad2));
			line(-height,-height,(H/2-R/2*sin(phi_rad2))/cos(phi_rad2),-height,height,(H/2+R/2*sin(phi_rad2))/cos(phi_rad2));
			line(height,-height,(H/2-R/2*sin(phi_rad2))/cos(phi_rad2),height,height,(H/2+R/2*sin(phi_rad2))/cos(phi_rad2));
		}
}
if (test==1){
				line(height2,-height2,(-H/2-R/2*sin(phi_rad))/cos(phi_rad),-height2,-height2,(-H/2+R/2*sin(phi_rad))/cos(phi_rad));
				line(height2,height2,(-H/2-R/2*sin(phi_rad))/cos(phi_rad),-height2,height2,(-H/2+R/2*sin(phi_rad))/cos(phi_rad));
				line(-height2,-height2,(-H/2-R/2*sin(phi_rad))/cos(phi_rad),-height2,height2,(-H/2+R/2*sin(phi_rad))/cos(phi_rad));
				line(height2,-height2,(-H/2-R/2*sin(phi_rad))/cos(phi_rad),height2,height2,(-H/2+R/2*sin(phi_rad))/cos(phi_rad));
}	

//if (((-r1+r1*cos(theta00)<H/2)||(r2-r2*cos(theta01)>H/2)))
	if (r1!=0&&r2!=0){
			line(-fabs(r1)*sin(theta00),-fabs(r1)*sin(theta00),-H/2-r1+r1*cos(theta00),-fabs(r2)*sin(theta01),fabs(r2)*sin(theta01),H/2+r2-r2*cos(theta01));
			line(fabs(r1)*sin(theta00),-fabs(r1)*sin(theta00),-H/2-r1+r1*cos(theta00),fabs(r2)*sin(theta01),fabs(r1)*sin(theta00),H/2+r2-r2*cos(theta01));
			line(-fabs(r1)*sin(theta00),-fabs(r1)*sin(theta00),-H/2-r1+r1*cos(theta00),fabs(r2)*sin(theta01),-fabs(r1)*sin(theta00),H/2+r2-r2*cos(theta01));
			line(-fabs(r1)*sin(theta00),fabs(r1)*sin(theta00),-H/2-r1+r1*cos(theta00),fabs(r2)*sin(theta01),fabs(r1)*sin(theta00),H/2+r2-r2*cos(theta01));
		}
		else if (r1!=0) {
			if (focus2==0){
				line(-height,0,-H/2-r1+r1*cos(theta00),-height,0,(H/2+R/2*sin(phi_rad2))/cos(phi_rad2));
				line(height,0,-H/2-r1+r1*cos(theta00),height,0,(H/2-R/2*sin(phi_rad2))/cos(phi_rad2));
				line(0,-height,-H/2-r1+r1*cos(theta00),0,-height,(H/2+R/2*sin(phi_rad2))/cos(phi_rad2));
				line(0,height,-H/2-r1+r1*cos(theta00),0,height,(H/2-R/2*sin(phi_rad2))/cos(phi_rad2));
			}
			else
			{
				line(-fabs(r1)*sin(theta00),0,-H/2-r1+r1*cos(theta00),-R/2,0,H/2+R*R/(16*focus2));
				line(fabs(r1)*sin(theta00),0,-H/2-r1+r1*cos(theta00),R/2,0,H/2+R*R/(16*focus2));
			}	
		}
		else if (r2!=0) {
			if (focus1==0){
				line(-height2,0,(-H/2+R/2*sin(phi_rad))/cos(phi_rad),-height2,0,H/2+r2-r2*cos(theta01));
				line(height2,0,(-H/2-R/2*sin(phi_rad))/cos(phi_rad),height2,0,H/2+r2-r2*cos(theta01));
				line(0,height2,(-H/2+R/2*sin(phi_rad))/cos(phi_rad),0,height2,H/2+r2-r2*cos(theta01));
				line(0,height2,(-H/2-R/2*sin(phi_rad))/cos(phi_rad),0,height2,H/2+r2-r2*cos(theta01));
			}
			else
			{
				line(-height2,0,-H/2-R*R/(16*focus1),-height2,0,(H/2+R/2*sin(phi_rad2))/cos(phi_rad2));
				line(height2,0,-H/2-R*R/(16*focus1),height2,0,(H/2-R/2*sin(phi_rad2))/cos(phi_rad2));
				line(0,height2,-H/2-R*R/(16*focus1),0,height2,(H/2+R/2*sin(phi_rad2))/cos(phi_rad2));
				line(0,height2,-H/2-R*R/(16*focus1),0,height2,(H/2-R/2*sin(phi_rad2))/cos(phi_rad2));
			}
		}
		else {
			if (focus1==0&&focus2==0){
				line(-R/2,0,(-H/2+R/2*sin(phi_rad))/cos(phi_rad),-R/2,0,(H/2+R/2*sin(phi_rad2))/cos(phi_rad2));
				line(R/2,0,(-H/2-R/2*sin(phi_rad))/cos(phi_rad),R/2,0,(H/2-R/2*sin(phi_rad2))/cos(phi_rad2));
				line(0,-R/2,(-H/2+R/2*sin(phi_rad))/cos(phi_rad),0,-R/2,(H/2+R/2*sin(phi_rad2))/cos(phi_rad2));
				line(0,R/2,(-H/2-R/2*sin(phi_rad))/cos(phi_rad),0,R/2,(H/2-R/2*sin(phi_rad2))/cos(phi_rad2));
			}
			else if (focus1==0){
				line(-R/2,0,(-H/2+R/2*sin(phi_rad))/cos(phi_rad),-R/2,0,H/2+dist_parab2);
				line(R/2,0,(-H/2-R/2*sin(phi_rad))/cos(phi_rad),R/2,0,H/2+dist_parab2);
				line(0,-R/2,(-H/2+R/2*sin(phi_rad))/cos(phi_rad),0,-R/2,H/2+dist_parab2);
				line(0,R/2,(-H/2-R/2*sin(phi_rad))/cos(phi_rad),0,R/2,H/2+dist_parab2);
			}
			else if (focus2==0){
				line(-height,0,-H/2+dist_parab1,-height,0,(H/2+R/2*sin(phi_rad2))/cos(phi_rad2));
				line(height,0,-H/2+dist_parab1,height,0,(H/2-R/2*sin(phi_rad2))/cos(phi_rad2));
				line(0,-height,-H/2+dist_parab1,0,-height,(H/2+R/2*sin(phi_rad2))/cos(phi_rad2));
				line(0,height,-H/2+dist_parab1,0,height,(H/2-R/2*sin(phi_rad2))/cos(phi_rad2));
			}
			else {
				line(-R/2,0,-H/2+dist_parab1,-R/2,0,H/2+dist_parab2);
				line(R/2,0,-H/2+dist_parab1,R/2,0,H/2+dist_parab2);
				line(0,-R/2,-H/2+dist_parab1,0,-R/2,H/2+dist_parab2);
				line(0,R/2,-H/2+dist_parab1,0,R/2,H/2+dist_parab2);
			}
		}

%}

END
