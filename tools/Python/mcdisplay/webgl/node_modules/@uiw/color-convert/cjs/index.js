"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault")["default"];
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validHex = exports.rgbaToRgb = exports.rgbaToHsva = exports.rgbaToHexa = exports.rgbaToHex = exports.rgbaStringToHsva = exports.rgbStringToHsva = exports.parseHue = exports.hsvaToRgbaString = exports.hsvaToRgba = exports.hsvaToRgbString = exports.hsvaToHsvaString = exports.hsvaToHsvString = exports.hsvaToHsv = exports.hsvaToHslaString = exports.hsvaToHsla = exports.hsvaToHslString = exports.hsvaToHexa = exports.hsvaToHex = exports.hsvaStringToHsva = exports.hsvStringToHsva = exports.hslaToHsva = exports.hslaToHsl = exports.hslaStringToHsva = exports.hslStringToHsva = exports.hslStringToHsla = exports.hexToRgba = exports.hexToHsva = exports.getContrastingColor = exports.equalHex = exports.equalColorString = exports.equalColorObjects = exports.color = void 0;
var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread2"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var RGB_MAX = 255;
var HUE_MAX = 360;
var SV_MAX = 100;
/**
 * ```js
 * rgbaToHsva({ r: 255, g: 255, b: 255, a: 1 }) //=> { h: 0, s: 0, v: 100, a: 1 }
 * ```
 */
var rgbaToHsva = exports.rgbaToHsva = function rgbaToHsva(_ref) {
  var r = _ref.r,
    g = _ref.g,
    b = _ref.b,
    a = _ref.a;
  var max = Math.max(r, g, b);
  var delta = max - Math.min(r, g, b);

  // prettier-ignore
  var hh = delta ? max === r ? (g - b) / delta : max === g ? 2 + (b - r) / delta : 4 + (r - g) / delta : 0;
  return {
    h: 60 * (hh < 0 ? hh + 6 : hh),
    s: max ? delta / max * SV_MAX : 0,
    v: max / RGB_MAX * SV_MAX,
    a: a
  };
};
var hsvaToHslString = exports.hsvaToHslString = function hsvaToHslString(hsva) {
  var _hsvaToHsla = hsvaToHsla(hsva),
    h = _hsvaToHsla.h,
    s = _hsvaToHsla.s,
    l = _hsvaToHsla.l;
  // return `hsl(${h}, ${s}%, ${l}%)`;
  return "hsl(".concat(h, ", ").concat(Math.round(s), "%, ").concat(Math.round(l), "%)");
};
var hsvaToHsvString = exports.hsvaToHsvString = function hsvaToHsvString(_ref2) {
  var h = _ref2.h,
    s = _ref2.s,
    v = _ref2.v;
  return "hsv(".concat(h, ", ").concat(s, "%, ").concat(v, "%)");
};
var hsvaToHsvaString = exports.hsvaToHsvaString = function hsvaToHsvaString(_ref3) {
  var h = _ref3.h,
    s = _ref3.s,
    v = _ref3.v,
    a = _ref3.a;
  return "hsva(".concat(h, ", ").concat(s, "%, ").concat(v, "%, ").concat(a, ")");
};
var hsvaToHslaString = exports.hsvaToHslaString = function hsvaToHslaString(hsva) {
  var _hsvaToHsla2 = hsvaToHsla(hsva),
    h = _hsvaToHsla2.h,
    s = _hsvaToHsla2.s,
    l = _hsvaToHsla2.l,
    a = _hsvaToHsla2.a;
  return "hsla(".concat(h, ", ").concat(s, "%, ").concat(l, "%, ").concat(a, ")");
};
var hslStringToHsla = exports.hslStringToHsla = function hslStringToHsla(str) {
  var _map = (str.match(/\d+/g) || []).map(Number),
    _map2 = (0, _slicedToArray2["default"])(_map, 4),
    h = _map2[0],
    s = _map2[1],
    l = _map2[2],
    a = _map2[3];
  return {
    h: h,
    s: s,
    l: l,
    a: a
  };
};
var hslaStringToHsva = exports.hslaStringToHsva = function hslaStringToHsva(hslString) {
  var matcher = /hsla?\(?\s*(-?\d*\.?\d+)(deg|rad|grad|turn)?[,\s]+(-?\d*\.?\d+)%?[,\s]+(-?\d*\.?\d+)%?,?\s*[/\s]*(-?\d*\.?\d+)?(%)?\s*\)?/i;
  var match = matcher.exec(hslString);
  if (!match) return {
    h: 0,
    s: 0,
    v: 0,
    a: 1
  };
  return hslaToHsva({
    h: parseHue(match[1], match[2]),
    s: Number(match[3]),
    l: Number(match[4]),
    a: match[5] === undefined ? 1 : Number(match[5]) / (match[6] ? 100 : 1)
  });
};
var hslStringToHsva = exports.hslStringToHsva = hslaStringToHsva;
var hslaToHsva = exports.hslaToHsva = function hslaToHsva(_ref4) {
  var h = _ref4.h,
    s = _ref4.s,
    l = _ref4.l,
    a = _ref4.a;
  s *= (l < 50 ? l : SV_MAX - l) / SV_MAX;
  return {
    h: h,
    s: s > 0 ? 2 * s / (l + s) * SV_MAX : 0,
    v: l + s,
    a: a
  };
};
var hsvaToHsla = exports.hsvaToHsla = function hsvaToHsla(_ref5) {
  var h = _ref5.h,
    s = _ref5.s,
    v = _ref5.v,
    a = _ref5.a;
  var hh = (200 - s) * v / SV_MAX;
  return {
    h: h,
    s: hh > 0 && hh < 200 ? s * v / SV_MAX / (hh <= SV_MAX ? hh : 200 - hh) * SV_MAX : 0,
    l: hh / 2,
    a: a
  };
};
var hsvaStringToHsva = exports.hsvaStringToHsva = function hsvaStringToHsva(hsvString) {
  var matcher = /hsva?\(?\s*(-?\d*\.?\d+)(deg|rad|grad|turn)?[,\s]+(-?\d*\.?\d+)%?[,\s]+(-?\d*\.?\d+)%?,?\s*[/\s]*(-?\d*\.?\d+)?(%)?\s*\)?/i;
  var match = matcher.exec(hsvString);
  if (!match) return {
    h: 0,
    s: 0,
    v: 0,
    a: 1
  };
  return {
    h: parseHue(match[1], match[2]),
    s: Number(match[3]),
    v: Number(match[4]),
    a: match[5] === undefined ? 1 : Number(match[5]) / (match[6] ? SV_MAX : 1)
  };
};

/**
 * Valid CSS <angle> units.
 * https://developer.mozilla.org/en-US/docs/Web/CSS/angle
 */
var angleUnits = {
  grad: HUE_MAX / 400,
  turn: HUE_MAX,
  rad: HUE_MAX / (Math.PI * 2)
};
var parseHue = exports.parseHue = function parseHue(value) {
  var unit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'deg';
  return Number(value) * (angleUnits[unit] || 1);
};
var hsvStringToHsva = exports.hsvStringToHsva = hsvaStringToHsva;
var rgbaStringToHsva = exports.rgbaStringToHsva = function rgbaStringToHsva(rgbaString) {
  var matcher = /rgba?\(?\s*(-?\d*\.?\d+)(%)?[,\s]+(-?\d*\.?\d+)(%)?[,\s]+(-?\d*\.?\d+)(%)?,?\s*[/\s]*(-?\d*\.?\d+)?(%)?\s*\)?/i;
  var match = matcher.exec(rgbaString);
  if (!match) return {
    h: 0,
    s: 0,
    v: 0,
    a: 1
  };
  return rgbaToHsva({
    r: Number(match[1]) / (match[2] ? SV_MAX / RGB_MAX : 1),
    g: Number(match[3]) / (match[4] ? SV_MAX / RGB_MAX : 1),
    b: Number(match[5]) / (match[6] ? SV_MAX / RGB_MAX : 1),
    a: match[7] === undefined ? 1 : Number(match[7]) / (match[8] ? SV_MAX : 1)
  });
};
var rgbStringToHsva = exports.rgbStringToHsva = rgbaStringToHsva;

/** Converts an RGBA color plus alpha transparency to hex */
var rgbaToHex = exports.rgbaToHex = function rgbaToHex(_ref6) {
  var r = _ref6.r,
    g = _ref6.g,
    b = _ref6.b;
  var bin = r << 16 | g << 8 | b;
  return "#".concat(function (h) {
    return new Array(7 - h.length).join('0') + h;
  }(bin.toString(16)));
};
var rgbaToHexa = exports.rgbaToHexa = function rgbaToHexa(_ref7) {
  var r = _ref7.r,
    g = _ref7.g,
    b = _ref7.b,
    a = _ref7.a;
  var alpha = typeof a === 'number' && (a * 255 | 1 << 8).toString(16).slice(1);
  return "".concat(rgbaToHex({
    r: r,
    g: g,
    b: b,
    a: a
  })).concat(alpha ? alpha : '');
};
var hexToHsva = exports.hexToHsva = function hexToHsva(hex) {
  return rgbaToHsva(hexToRgba(hex));
};
var hexToRgba = exports.hexToRgba = function hexToRgba(hex) {
  var htemp = hex.replace('#', '');
  if (/^#?/.test(hex) && htemp.length === 3) {
    hex = "#".concat(htemp.charAt(0)).concat(htemp.charAt(0)).concat(htemp.charAt(1)).concat(htemp.charAt(1)).concat(htemp.charAt(2)).concat(htemp.charAt(2));
  }
  var reg = new RegExp("[A-Za-z0-9]{2}", 'g');
  var _map3 = hex.match(reg).map(function (v) {
      return parseInt(v, 16);
    }),
    _map4 = (0, _slicedToArray2["default"])(_map3, 4),
    r = _map4[0],
    g = _map4[1],
    _map4$ = _map4[2],
    b = _map4$ === void 0 ? 0 : _map4$,
    a = _map4[3];
  return {
    r: r,
    g: g,
    b: b,
    a: (a !== null && a !== void 0 ? a : 255) / RGB_MAX
  };
};

/**
 * Converts HSVA to RGBA. Based on formula from https://en.wikipedia.org/wiki/HSL_and_HSV
 * @param color HSVA color as an array [0-360, 0-1, 0-1, 0-1]
 */
var hsvaToRgba = exports.hsvaToRgba = function hsvaToRgba(_ref8) {
  var h = _ref8.h,
    s = _ref8.s,
    v = _ref8.v,
    a = _ref8.a;
  var _h = h / 60,
    _s = s / SV_MAX,
    _v = v / SV_MAX,
    hi = Math.floor(_h) % 6;
  var f = _h - Math.floor(_h),
    _p = RGB_MAX * _v * (1 - _s),
    _q = RGB_MAX * _v * (1 - _s * f),
    _t = RGB_MAX * _v * (1 - _s * (1 - f));
  _v *= RGB_MAX;
  var rgba = {};
  switch (hi) {
    case 0:
      rgba.r = _v;
      rgba.g = _t;
      rgba.b = _p;
      break;
    case 1:
      rgba.r = _q;
      rgba.g = _v;
      rgba.b = _p;
      break;
    case 2:
      rgba.r = _p;
      rgba.g = _v;
      rgba.b = _t;
      break;
    case 3:
      rgba.r = _p;
      rgba.g = _q;
      rgba.b = _v;
      break;
    case 4:
      rgba.r = _t;
      rgba.g = _p;
      rgba.b = _v;
      break;
    case 5:
      rgba.r = _v;
      rgba.g = _p;
      rgba.b = _q;
      break;
  }
  rgba.r = Math.round(rgba.r);
  rgba.g = Math.round(rgba.g);
  rgba.b = Math.round(rgba.b);
  return (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, rgba), {}, {
    a: a
  });
};
var hsvaToRgbString = exports.hsvaToRgbString = function hsvaToRgbString(hsva) {
  var _hsvaToRgba = hsvaToRgba(hsva),
    r = _hsvaToRgba.r,
    g = _hsvaToRgba.g,
    b = _hsvaToRgba.b;
  return "rgb(".concat(r, ", ").concat(g, ", ").concat(b, ")");
};
var hsvaToRgbaString = exports.hsvaToRgbaString = function hsvaToRgbaString(hsva) {
  var _hsvaToRgba2 = hsvaToRgba(hsva),
    r = _hsvaToRgba2.r,
    g = _hsvaToRgba2.g,
    b = _hsvaToRgba2.b,
    a = _hsvaToRgba2.a;
  return "rgba(".concat(r, ", ").concat(g, ", ").concat(b, ", ").concat(a, ")");
};
var rgbaToRgb = exports.rgbaToRgb = function rgbaToRgb(_ref9) {
  var r = _ref9.r,
    g = _ref9.g,
    b = _ref9.b;
  return {
    r: r,
    g: g,
    b: b
  };
};
var hslaToHsl = exports.hslaToHsl = function hslaToHsl(_ref10) {
  var h = _ref10.h,
    s = _ref10.s,
    l = _ref10.l;
  return {
    h: h,
    s: s,
    l: l
  };
};
var hsvaToHex = exports.hsvaToHex = function hsvaToHex(hsva) {
  return rgbaToHex(hsvaToRgba(hsva));
};
var hsvaToHexa = exports.hsvaToHexa = function hsvaToHexa(hsva) {
  return rgbaToHexa(hsvaToRgba(hsva));
};
var hsvaToHsv = exports.hsvaToHsv = function hsvaToHsv(_ref11) {
  var h = _ref11.h,
    s = _ref11.s,
    v = _ref11.v;
  return {
    h: h,
    s: s,
    v: v
  };
};
var color = exports.color = function color(str) {
  var rgb;
  var hsl;
  var hsv;
  var rgba;
  var hsla;
  var hsva;
  var hex;
  var hexa;
  if (typeof str === 'string' && validHex(str)) {
    hsva = hexToHsva(str);
    hex = str;
  } else if (typeof str !== 'string') {
    hsva = str;
  }
  if (hsva) {
    hsv = hsvaToHsv(hsva);
    hsla = hsvaToHsla(hsva);
    rgba = hsvaToRgba(hsva);
    hexa = rgbaToHexa(rgba);
    hex = hsvaToHex(hsva);
    hsl = hslaToHsl(hsla);
    rgb = rgbaToRgb(rgba);
  }
  return {
    rgb: rgb,
    hsl: hsl,
    hsv: hsv,
    rgba: rgba,
    hsla: hsla,
    hsva: hsva,
    hex: hex,
    hexa: hexa
  };
};
var getContrastingColor = exports.getContrastingColor = function getContrastingColor(str) {
  if (!str) {
    return '#ffffff';
  }
  var col = color(str);
  var yiq = (col.rgb.r * 299 + col.rgb.g * 587 + col.rgb.b * 114) / 1000;
  return yiq >= 128 ? '#000000' : '#ffffff';
};
var equalColorObjects = exports.equalColorObjects = function equalColorObjects(first, second) {
  if (first === second) return true;
  for (var prop in first) {
    // The following allows for a type-safe calling of this function (first & second have to be HSL, HSV, or RGB)
    // with type-unsafe iterating over object keys. TS does not allow this without an index (`[key: string]: number`)
    // on an object to define how iteration is normally done. To ensure extra keys are not allowed on our types,
    // we must cast our object to unknown (as RGB demands `r` be a key, while `Record<string, x>` does not care if
    // there is or not), and then as a type TS can iterate over.
    if (first[prop] !== second[prop]) return false;
  }
  return true;
};
var equalColorString = exports.equalColorString = function equalColorString(first, second) {
  return first.replace(/\s/g, '') === second.replace(/\s/g, '');
};
var equalHex = exports.equalHex = function equalHex(first, second) {
  if (first.toLowerCase() === second.toLowerCase()) return true;

  // To compare colors like `#FFF` and `ffffff` we convert them into RGB objects
  return equalColorObjects(hexToRgba(first), hexToRgba(second));
};
var validHex = exports.validHex = function validHex(hex) {
  return /^#?([A-Fa-f0-9]{3,4}){1,2}$/.test(hex);
};