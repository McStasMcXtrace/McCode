import {
  IESSpotLight_default
} from "./chunk-SITAOY33.js";
import {
  ACESFilmicToneMapping,
  AgXToneMapping,
  AmbientLight,
  BackSide,
  BoxGeometry,
  BufferAttribute,
  BufferGeometry,
  CineonToneMapping,
  Color,
  CubeCamera,
  CubeReflectionMapping,
  CubeRefractionMapping,
  CubeUVReflectionMapping,
  DataArrayTexture,
  DepthTexture,
  DirectionalLight,
  DynamicDrawUsage,
  EventDispatcher,
  FileLoader,
  Float16BufferAttribute,
  Float32BufferAttribute,
  FloatType,
  FramebufferTexture,
  HalfFloatType,
  HemisphereLight,
  InstancedBufferAttribute,
  InstancedInterleavedBuffer,
  IntType,
  InterleavedBuffer,
  InterleavedBufferAttribute,
  LessCompare,
  LineBasicMaterial,
  LineDashedMaterial,
  LinearFilter,
  LinearMipMapLinearFilter,
  LinearMipmapLinearFilter,
  LinearSRGBColorSpace,
  LinearToneMapping,
  Loader,
  Material,
  MaterialLoader,
  MathUtils,
  Matrix3,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  MeshLambertMaterial,
  MeshMatcapMaterial,
  MeshNormalMaterial,
  MeshPhongMaterial,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  MeshToonMaterial,
  NearestFilter,
  NoBlending,
  NoToneMapping,
  Object3D,
  ObjectLoader,
  ObjectSpaceNormalMap,
  OrthographicCamera,
  PerspectiveCamera,
  Plane,
  PointLight,
  PointsMaterial,
  REVISION,
  RGBAFormat,
  ReinhardToneMapping,
  RenderTarget,
  SRGBColorSpace,
  Scene,
  ShadowMaterial,
  SpotLight,
  SpriteMaterial,
  StaticDrawUsage,
  TangentSpaceNormalMap,
  UnsignedIntType,
  Vector2,
  Vector3,
  Vector4,
  WebGLCoordinateSystem,
  WebGLCubeRenderTarget,
  WebGPUCoordinateSystem
} from "./chunk-AB3AYXXB.js";
import {
  __export
} from "./chunk-ZS7NZCD4.js";

// node_modules/three/examples/jsm/nodes/core/constants.js
var NodeShaderStage = {
  VERTEX: "vertex",
  FRAGMENT: "fragment"
};
var NodeUpdateType = {
  NONE: "none",
  FRAME: "frame",
  RENDER: "render",
  OBJECT: "object"
};
var NodeType = {
  BOOLEAN: "bool",
  INTEGER: "int",
  FLOAT: "float",
  VECTOR2: "vec2",
  VECTOR3: "vec3",
  VECTOR4: "vec4",
  MATRIX2: "mat2",
  MATRIX3: "mat3",
  MATRIX4: "mat4"
};
var defaultShaderStages = ["fragment", "vertex"];
var defaultBuildStages = ["setup", "analyze", "generate"];
var shaderStages = [...defaultShaderStages, "compute"];
var vectorComponents = ["x", "y", "z", "w"];

// node_modules/three/examples/jsm/nodes/core/NodeUtils.js
var NodeUtils_exports = {};
__export(NodeUtils_exports, {
  arrayBufferToBase64: () => arrayBufferToBase64,
  base64ToArrayBuffer: () => base64ToArrayBuffer,
  getCacheKey: () => getCacheKey,
  getNodeChildren: () => getNodeChildren,
  getValueFromType: () => getValueFromType,
  getValueType: () => getValueType
});
function getCacheKey(object, force = false) {
  let cacheKey = "{";
  if (object.isNode === true) {
    cacheKey += object.id;
  }
  for (const { property: property2, childNode } of getNodeChildren(object)) {
    cacheKey += "," + property2.slice(0, -4) + ":" + childNode.getCacheKey(force);
  }
  cacheKey += "}";
  return cacheKey;
}
function* getNodeChildren(node, toJSON = false) {
  for (const property2 in node) {
    if (property2.startsWith("_") === true)
      continue;
    const object = node[property2];
    if (Array.isArray(object) === true) {
      for (let i = 0; i < object.length; i++) {
        const child = object[i];
        if (child && (child.isNode === true || toJSON && typeof child.toJSON === "function")) {
          yield { property: property2, index: i, childNode: child };
        }
      }
    } else if (object && object.isNode === true) {
      yield { property: property2, childNode: object };
    } else if (typeof object === "object") {
      for (const subProperty in object) {
        const child = object[subProperty];
        if (child && (child.isNode === true || toJSON && typeof child.toJSON === "function")) {
          yield { property: property2, index: subProperty, childNode: child };
        }
      }
    }
  }
}
function getValueType(value) {
  if (value === void 0 || value === null)
    return null;
  const typeOf = typeof value;
  if (value.isNode === true) {
    return "node";
  } else if (typeOf === "number") {
    return "float";
  } else if (typeOf === "boolean") {
    return "bool";
  } else if (typeOf === "string") {
    return "string";
  } else if (typeOf === "function") {
    return "shader";
  } else if (value.isVector2 === true) {
    return "vec2";
  } else if (value.isVector3 === true) {
    return "vec3";
  } else if (value.isVector4 === true) {
    return "vec4";
  } else if (value.isMatrix3 === true) {
    return "mat3";
  } else if (value.isMatrix4 === true) {
    return "mat4";
  } else if (value.isColor === true) {
    return "color";
  } else if (value instanceof ArrayBuffer) {
    return "ArrayBuffer";
  }
  return null;
}
function getValueFromType(type, ...params) {
  const last4 = type ? type.slice(-4) : void 0;
  if (params.length === 1) {
    if (last4 === "vec2")
      params = [params[0], params[0]];
    else if (last4 === "vec3")
      params = [params[0], params[0], params[0]];
    else if (last4 === "vec4")
      params = [params[0], params[0], params[0], params[0]];
  }
  if (type === "color") {
    return new Color(...params);
  } else if (last4 === "vec2") {
    return new Vector2(...params);
  } else if (last4 === "vec3") {
    return new Vector3(...params);
  } else if (last4 === "vec4") {
    return new Vector4(...params);
  } else if (last4 === "mat3") {
    return new Matrix3(...params);
  } else if (last4 === "mat4") {
    return new Matrix4(...params);
  } else if (type === "bool") {
    return params[0] || false;
  } else if (type === "float" || type === "int" || type === "uint") {
    return params[0] || 0;
  } else if (type === "string") {
    return params[0] || "";
  } else if (type === "ArrayBuffer") {
    return base64ToArrayBuffer(params[0]);
  }
  return null;
}
function arrayBufferToBase64(arrayBuffer2) {
  let chars = "";
  const array = new Uint8Array(arrayBuffer2);
  for (let i = 0; i < array.length; i++) {
    chars += String.fromCharCode(array[i]);
  }
  return btoa(chars);
}
function base64ToArrayBuffer(base64) {
  return Uint8Array.from(atob(base64), (c) => c.charCodeAt(0)).buffer;
}

// node_modules/three/examples/jsm/nodes/core/Node.js
var NodeClasses = /* @__PURE__ */ new Map();
var _nodeId = 0;
var Node = class extends EventDispatcher {
  constructor(nodeType = null) {
    super();
    this.nodeType = nodeType;
    this.updateType = NodeUpdateType.NONE;
    this.updateBeforeType = NodeUpdateType.NONE;
    this.uuid = MathUtils.generateUUID();
    this.version = 0;
    this._cacheKey = null;
    this._cacheKeyVersion = 0;
    this.global = false;
    this.isNode = true;
    Object.defineProperty(this, "id", { value: _nodeId++ });
  }
  set needsUpdate(value) {
    if (value === true) {
      this.version++;
    }
  }
  get type() {
    return this.constructor.type;
  }
  onUpdate(callback, updateType) {
    this.updateType = updateType;
    this.update = callback.bind(this.getSelf());
    return this;
  }
  onFrameUpdate(callback) {
    return this.onUpdate(callback, NodeUpdateType.FRAME);
  }
  onRenderUpdate(callback) {
    return this.onUpdate(callback, NodeUpdateType.RENDER);
  }
  onObjectUpdate(callback) {
    return this.onUpdate(callback, NodeUpdateType.OBJECT);
  }
  onReference(callback) {
    this.updateReference = callback.bind(this.getSelf());
    return this;
  }
  getSelf() {
    return this.self || this;
  }
  updateReference() {
    return this;
  }
  isGlobal() {
    return this.global;
  }
  *getChildren() {
    for (const { childNode } of getNodeChildren(this)) {
      yield childNode;
    }
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  traverse(callback) {
    callback(this);
    for (const childNode of this.getChildren()) {
      childNode.traverse(callback);
    }
  }
  getCacheKey(force = false) {
    force = force || this.version !== this._cacheKeyVersion;
    if (force === true || this._cacheKey === null) {
      this._cacheKey = getCacheKey(this, force);
      this._cacheKeyVersion = this.version;
    }
    return this._cacheKey;
  }
  getHash() {
    return this.uuid;
  }
  getUpdateType() {
    return this.updateType;
  }
  getUpdateBeforeType() {
    return this.updateBeforeType;
  }
  getElementType(builder) {
    const type = this.getNodeType(builder);
    const elementType = builder.getElementType(type);
    return elementType;
  }
  getNodeType(builder) {
    const nodeProperties = builder.getNodeProperties(this);
    if (nodeProperties.outputNode) {
      return nodeProperties.outputNode.getNodeType(builder);
    }
    return this.nodeType;
  }
  getShared(builder) {
    const hash2 = this.getHash(builder);
    const nodeFromHash = builder.getNodeFromHash(hash2);
    return nodeFromHash || this;
  }
  setup(builder) {
    const nodeProperties = builder.getNodeProperties(this);
    let index = 0;
    for (const childNode of this.getChildren()) {
      nodeProperties["node" + index++] = childNode;
    }
    return null;
  }
  construct(builder) {
    console.warn("THREE.Node: construct() is deprecated. Use setup() instead.");
    return this.setup(builder);
  }
  increaseUsage(builder) {
    const nodeData = builder.getDataFromNode(this);
    nodeData.usageCount = nodeData.usageCount === void 0 ? 1 : nodeData.usageCount + 1;
    return nodeData.usageCount;
  }
  analyze(builder) {
    const usageCount = this.increaseUsage(builder);
    if (usageCount === 1) {
      const nodeProperties = builder.getNodeProperties(this);
      for (const childNode of Object.values(nodeProperties)) {
        if (childNode && childNode.isNode === true) {
          childNode.build(builder);
        }
      }
    }
  }
  generate(builder, output2) {
    const { outputNode } = builder.getNodeProperties(this);
    if (outputNode && outputNode.isNode === true) {
      return outputNode.build(builder, output2);
    }
  }
  updateBefore() {
    console.warn("Abstract function.");
  }
  update() {
    console.warn("Abstract function.");
  }
  build(builder, output2 = null) {
    const refNode = this.getShared(builder);
    if (this !== refNode) {
      return refNode.build(builder, output2);
    }
    builder.addNode(this);
    builder.addChain(this);
    let result = null;
    const buildStage = builder.getBuildStage();
    if (buildStage === "setup") {
      this.updateReference(builder);
      const properties = builder.getNodeProperties(this);
      if (properties.initialized !== true || builder.context.tempRead === false) {
        const stackNodesBeforeSetup = builder.stack.nodes.length;
        properties.initialized = true;
        properties.outputNode = this.setup(builder);
        if (properties.outputNode !== null && builder.stack.nodes.length !== stackNodesBeforeSetup) {
          properties.outputNode = builder.stack;
        }
        for (const childNode of Object.values(properties)) {
          if (childNode && childNode.isNode === true) {
            childNode.build(builder);
          }
        }
      }
    } else if (buildStage === "analyze") {
      this.analyze(builder);
    } else if (buildStage === "generate") {
      const isGenerateOnce = this.generate.length === 1;
      if (isGenerateOnce) {
        const type = this.getNodeType(builder);
        const nodeData = builder.getDataFromNode(this);
        result = nodeData.snippet;
        if (result === void 0) {
          result = this.generate(builder) || "";
          nodeData.snippet = result;
        }
        result = builder.format(result, type, output2);
      } else {
        result = this.generate(builder, output2) || "";
      }
    }
    builder.removeChain(this);
    return result;
  }
  getSerializeChildren() {
    return getNodeChildren(this);
  }
  serialize(json) {
    const nodeChildren = this.getSerializeChildren();
    const inputNodes = {};
    for (const { property: property2, index, childNode } of nodeChildren) {
      if (index !== void 0) {
        if (inputNodes[property2] === void 0) {
          inputNodes[property2] = Number.isInteger(index) ? [] : {};
        }
        inputNodes[property2][index] = childNode.toJSON(json.meta).uuid;
      } else {
        inputNodes[property2] = childNode.toJSON(json.meta).uuid;
      }
    }
    if (Object.keys(inputNodes).length > 0) {
      json.inputNodes = inputNodes;
    }
  }
  deserialize(json) {
    if (json.inputNodes !== void 0) {
      const nodes = json.meta.nodes;
      for (const property2 in json.inputNodes) {
        if (Array.isArray(json.inputNodes[property2])) {
          const inputArray = [];
          for (const uuid of json.inputNodes[property2]) {
            inputArray.push(nodes[uuid]);
          }
          this[property2] = inputArray;
        } else if (typeof json.inputNodes[property2] === "object") {
          const inputObject = {};
          for (const subProperty in json.inputNodes[property2]) {
            const uuid = json.inputNodes[property2][subProperty];
            inputObject[subProperty] = nodes[uuid];
          }
          this[property2] = inputObject;
        } else {
          const uuid = json.inputNodes[property2];
          this[property2] = nodes[uuid];
        }
      }
    }
  }
  toJSON(meta) {
    const { uuid, type } = this;
    const isRoot = meta === void 0 || typeof meta === "string";
    if (isRoot) {
      meta = {
        textures: {},
        images: {},
        nodes: {}
      };
    }
    let data = meta.nodes[uuid];
    if (data === void 0) {
      data = {
        uuid,
        type,
        meta,
        metadata: {
          version: 4.6,
          type: "Node",
          generator: "Node.toJSON"
        }
      };
      if (isRoot !== true)
        meta.nodes[data.uuid] = data;
      this.serialize(data);
      delete data.meta;
    }
    function extractFromCache(cache2) {
      const values = [];
      for (const key in cache2) {
        const data2 = cache2[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const nodes = extractFromCache(meta.nodes);
      if (textures.length > 0)
        data.textures = textures;
      if (images.length > 0)
        data.images = images;
      if (nodes.length > 0)
        data.nodes = nodes;
    }
    return data;
  }
};
var Node_default = Node;
function addNodeClass(type, nodeClass) {
  if (typeof nodeClass !== "function" || !type)
    throw new Error(`Node class ${type} is not a class`);
  if (NodeClasses.has(type)) {
    console.warn(`Redefinition of node class ${type}`);
    return;
  }
  NodeClasses.set(type, nodeClass);
  nodeClass.type = type;
}
function createNodeFromType(type) {
  const Class = NodeClasses.get(type);
  if (Class !== void 0) {
    return new Class();
  }
}

// node_modules/three/examples/jsm/nodes/core/TempNode.js
var TempNode = class extends Node_default {
  constructor(type) {
    super(type);
    this.isTempNode = true;
  }
  hasDependencies(builder) {
    return builder.getDataFromNode(this).usageCount > 1;
  }
  build(builder, output2) {
    const buildStage = builder.getBuildStage();
    if (buildStage === "generate") {
      const type = builder.getVectorType(this.getNodeType(builder, output2));
      const nodeData = builder.getDataFromNode(this);
      if (builder.context.tempRead !== false && nodeData.propertyName !== void 0) {
        return builder.format(nodeData.propertyName, type, output2);
      } else if (builder.context.tempWrite !== false && type !== "void" && output2 !== "void" && this.hasDependencies(builder)) {
        const snippet = super.build(builder, type);
        const nodeVar = builder.getVarFromNode(this, null, type);
        const propertyName = builder.getPropertyName(nodeVar);
        builder.addLineFlowCode(`${propertyName} = ${snippet}`);
        nodeData.snippet = snippet;
        nodeData.propertyName = propertyName;
        return builder.format(nodeData.propertyName, type, output2);
      }
    }
    return super.build(builder, output2);
  }
};
var TempNode_default = TempNode;
addNodeClass("TempNode", TempNode);

// node_modules/three/examples/jsm/nodes/utils/ArrayElementNode.js
var ArrayElementNode = class extends Node_default {
  // @TODO: If extending from TempNode it breaks webgpu_compute
  constructor(node, indexNode) {
    super();
    this.node = node;
    this.indexNode = indexNode;
    this.isArrayElementNode = true;
  }
  getNodeType(builder) {
    return this.node.getElementType(builder);
  }
  generate(builder) {
    const nodeSnippet = this.node.build(builder);
    const indexSnippet = this.indexNode.build(builder, "uint");
    return `${nodeSnippet}[ ${indexSnippet} ]`;
  }
};
var ArrayElementNode_default = ArrayElementNode;
addNodeClass("ArrayElementNode", ArrayElementNode);

// node_modules/three/examples/jsm/nodes/utils/ConvertNode.js
var ConvertNode = class extends Node_default {
  constructor(node, convertTo) {
    super();
    this.node = node;
    this.convertTo = convertTo;
  }
  getNodeType(builder) {
    const requestType = this.node.getNodeType(builder);
    let convertTo = null;
    for (const overloadingType of this.convertTo.split("|")) {
      if (convertTo === null || builder.getTypeLength(requestType) === builder.getTypeLength(overloadingType)) {
        convertTo = overloadingType;
      }
    }
    return convertTo;
  }
  serialize(data) {
    super.serialize(data);
    data.convertTo = this.convertTo;
  }
  deserialize(data) {
    super.deserialize(data);
    this.convertTo = data.convertTo;
  }
  generate(builder, output2) {
    const node = this.node;
    const type = this.getNodeType(builder);
    const snippet = node.build(builder, type);
    return builder.format(snippet, type, output2);
  }
};
var ConvertNode_default = ConvertNode;
addNodeClass("ConvertNode", ConvertNode);

// node_modules/three/examples/jsm/nodes/utils/JoinNode.js
var JoinNode = class extends TempNode_default {
  constructor(nodes = [], nodeType = null) {
    super(nodeType);
    this.nodes = nodes;
  }
  getNodeType(builder) {
    if (this.nodeType !== null) {
      return builder.getVectorType(this.nodeType);
    }
    return builder.getTypeFromLength(this.nodes.reduce((count, cur) => count + builder.getTypeLength(cur.getNodeType(builder)), 0));
  }
  generate(builder, output2) {
    const type = this.getNodeType(builder);
    const nodes = this.nodes;
    const primitiveType = builder.getComponentType(type);
    const snippetValues = [];
    for (const input of nodes) {
      let inputSnippet = input.build(builder);
      const inputPrimitiveType = builder.getComponentType(input.getNodeType(builder));
      if (inputPrimitiveType !== primitiveType) {
        inputSnippet = builder.format(inputSnippet, inputPrimitiveType, primitiveType);
      }
      snippetValues.push(inputSnippet);
    }
    const snippet = `${builder.getType(type)}( ${snippetValues.join(", ")} )`;
    return builder.format(snippet, type, output2);
  }
};
var JoinNode_default = JoinNode;
addNodeClass("JoinNode", JoinNode);

// node_modules/three/examples/jsm/nodes/utils/SplitNode.js
var stringVectorComponents = vectorComponents.join("");
var SplitNode = class extends Node_default {
  constructor(node, components = "x") {
    super();
    this.node = node;
    this.components = components;
    this.isSplitNode = true;
  }
  getVectorLength() {
    let vectorLength = this.components.length;
    for (const c of this.components) {
      vectorLength = Math.max(vectorComponents.indexOf(c) + 1, vectorLength);
    }
    return vectorLength;
  }
  getComponentType(builder) {
    return builder.getComponentType(this.node.getNodeType(builder));
  }
  getNodeType(builder) {
    return builder.getTypeFromLength(this.components.length, this.getComponentType(builder));
  }
  generate(builder, output2) {
    const node = this.node;
    const nodeTypeLength = builder.getTypeLength(node.getNodeType(builder));
    let snippet = null;
    if (nodeTypeLength > 1) {
      let type = null;
      const componentsLength = this.getVectorLength();
      if (componentsLength >= nodeTypeLength) {
        type = builder.getTypeFromLength(this.getVectorLength(), this.getComponentType(builder));
      }
      const nodeSnippet = node.build(builder, type);
      if (this.components.length === nodeTypeLength && this.components === stringVectorComponents.slice(0, this.components.length)) {
        snippet = builder.format(nodeSnippet, type, output2);
      } else {
        snippet = builder.format(`${nodeSnippet}.${this.components}`, this.getNodeType(builder), output2);
      }
    } else {
      snippet = node.build(builder, output2);
    }
    return snippet;
  }
  serialize(data) {
    super.serialize(data);
    data.components = this.components;
  }
  deserialize(data) {
    super.deserialize(data);
    this.components = data.components;
  }
};
var SplitNode_default = SplitNode;
addNodeClass("SplitNode", SplitNode);

// node_modules/three/examples/jsm/nodes/utils/SetNode.js
var SetNode = class extends TempNode_default {
  constructor(sourceNode, components, targetNode) {
    super();
    this.sourceNode = sourceNode;
    this.components = components;
    this.targetNode = targetNode;
  }
  getNodeType(builder) {
    return this.sourceNode.getNodeType(builder);
  }
  generate(builder) {
    const { sourceNode, components, targetNode } = this;
    const sourceType = this.getNodeType(builder);
    const targetType = builder.getTypeFromLength(components.length);
    const targetSnippet = targetNode.build(builder, targetType);
    const sourceSnippet = sourceNode.build(builder, sourceType);
    const length2 = builder.getTypeLength(sourceType);
    const snippetValues = [];
    for (let i = 0; i < length2; i++) {
      const component = vectorComponents[i];
      if (component === components[0]) {
        snippetValues.push(targetSnippet);
        i += components.length - 1;
      } else {
        snippetValues.push(sourceSnippet + "." + component);
      }
    }
    return `${builder.getType(sourceType)}( ${snippetValues.join(", ")} )`;
  }
};
var SetNode_default = SetNode;
addNodeClass("SetNode", SetNode);

// node_modules/three/examples/jsm/nodes/core/InputNode.js
var InputNode = class extends Node_default {
  constructor(value, nodeType = null) {
    super(nodeType);
    this.isInputNode = true;
    this.value = value;
    this.precision = null;
  }
  getNodeType() {
    if (this.nodeType === null) {
      return getValueType(this.value);
    }
    return this.nodeType;
  }
  getInputType(builder) {
    return this.getNodeType(builder);
  }
  setPrecision(precision) {
    this.precision = precision;
    return this;
  }
  serialize(data) {
    super.serialize(data);
    data.value = this.value;
    if (this.value && this.value.toArray)
      data.value = this.value.toArray();
    data.valueType = getValueType(this.value);
    data.nodeType = this.nodeType;
    if (data.valueType === "ArrayBuffer")
      data.value = arrayBufferToBase64(data.value);
    data.precision = this.precision;
  }
  deserialize(data) {
    super.deserialize(data);
    this.nodeType = data.nodeType;
    this.value = Array.isArray(data.value) ? getValueFromType(data.valueType, ...data.value) : data.value;
    this.precision = data.precision || null;
    if (this.value && this.value.fromArray)
      this.value = this.value.fromArray(data.value);
  }
  generate() {
    console.warn("Abstract function.");
  }
};
var InputNode_default = InputNode;
addNodeClass("InputNode", InputNode);

// node_modules/three/examples/jsm/nodes/core/ConstNode.js
var ConstNode = class extends InputNode_default {
  constructor(value, nodeType = null) {
    super(value, nodeType);
    this.isConstNode = true;
  }
  generateConst(builder) {
    return builder.generateConst(this.getNodeType(builder), this.value);
  }
  generate(builder, output2) {
    const type = this.getNodeType(builder);
    return builder.format(this.generateConst(builder), type, output2);
  }
};
var ConstNode_default = ConstNode;
addNodeClass("ConstNode", ConstNode);

// node_modules/three/examples/jsm/nodes/shadernode/ShaderNode.js
var currentStack = null;
var NodeElements = /* @__PURE__ */ new Map();
function addNodeElement(name, nodeElement) {
  if (NodeElements.has(name)) {
    console.warn(`Redefinition of node element ${name}`);
    return;
  }
  if (typeof nodeElement !== "function")
    throw new Error(`Node element ${name} is not a function`);
  NodeElements.set(name, nodeElement);
}
var parseSwizzle = (props) => props.replace(/r|s/g, "x").replace(/g|t/g, "y").replace(/b|p/g, "z").replace(/a|q/g, "w");
var shaderNodeHandler = {
  setup(NodeClosure, params) {
    const inputs = params.shift();
    return NodeClosure(nodeObjects(inputs), ...params);
  },
  get(node, prop, nodeObj) {
    if (typeof prop === "string" && node[prop] === void 0) {
      if (node.isStackNode !== true && prop === "assign") {
        return (...params) => {
          currentStack.assign(nodeObj, ...params);
          return nodeObj;
        };
      } else if (NodeElements.has(prop)) {
        const nodeElement = NodeElements.get(prop);
        return node.isStackNode ? (...params) => nodeObj.add(nodeElement(...params)) : (...params) => nodeElement(nodeObj, ...params);
      } else if (prop === "self") {
        return node;
      } else if (prop.endsWith("Assign") && NodeElements.has(prop.slice(0, prop.length - "Assign".length))) {
        const nodeElement = NodeElements.get(prop.slice(0, prop.length - "Assign".length));
        return node.isStackNode ? (...params) => nodeObj.assign(params[0], nodeElement(...params)) : (...params) => nodeObj.assign(nodeElement(nodeObj, ...params));
      } else if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true) {
        prop = parseSwizzle(prop);
        return nodeObject(new SplitNode_default(nodeObj, prop));
      } else if (/^set[XYZWRGBASTPQ]{1,4}$/.test(prop) === true) {
        prop = parseSwizzle(prop.slice(3).toLowerCase());
        prop = prop.split("").sort().join("");
        return (value) => nodeObject(new SetNode_default(node, prop, value));
      } else if (prop === "width" || prop === "height" || prop === "depth") {
        if (prop === "width")
          prop = "x";
        else if (prop === "height")
          prop = "y";
        else if (prop === "depth")
          prop = "z";
        return nodeObject(new SplitNode_default(node, prop));
      } else if (/^\d+$/.test(prop) === true) {
        return nodeObject(new ArrayElementNode_default(nodeObj, new ConstNode_default(Number(prop), "uint")));
      }
    }
    return Reflect.get(node, prop, nodeObj);
  },
  set(node, prop, value, nodeObj) {
    if (typeof prop === "string" && node[prop] === void 0) {
      if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true || prop === "width" || prop === "height" || prop === "depth" || /^\d+$/.test(prop) === true) {
        nodeObj[prop].assign(value);
        return true;
      }
    }
    return Reflect.set(node, prop, value, nodeObj);
  }
};
var nodeObjectsCacheMap = /* @__PURE__ */ new WeakMap();
var nodeBuilderFunctionsCacheMap = /* @__PURE__ */ new WeakMap();
var ShaderNodeObject = function(obj, altType = null) {
  const type = getValueType(obj);
  if (type === "node") {
    let nodeObject2 = nodeObjectsCacheMap.get(obj);
    if (nodeObject2 === void 0) {
      nodeObject2 = new Proxy(obj, shaderNodeHandler);
      nodeObjectsCacheMap.set(obj, nodeObject2);
      nodeObjectsCacheMap.set(nodeObject2, nodeObject2);
    }
    return nodeObject2;
  } else if (altType === null && (type === "float" || type === "boolean") || type && type !== "shader" && type !== "string") {
    return nodeObject(getConstNode(obj, altType));
  } else if (type === "shader") {
    return tslFn(obj);
  }
  return obj;
};
var ShaderNodeObjects = function(objects, altType = null) {
  for (const name in objects) {
    objects[name] = nodeObject(objects[name], altType);
  }
  return objects;
};
var ShaderNodeArray = function(array, altType = null) {
  const len = array.length;
  for (let i = 0; i < len; i++) {
    array[i] = nodeObject(array[i], altType);
  }
  return array;
};
var ShaderNodeProxy = function(NodeClass, scope = null, factor = null, settings = null) {
  const assignNode = (node) => nodeObject(settings !== null ? Object.assign(node, settings) : node);
  if (scope === null) {
    return (...params) => {
      return assignNode(new NodeClass(...nodeArray(params)));
    };
  } else if (factor !== null) {
    factor = nodeObject(factor);
    return (...params) => {
      return assignNode(new NodeClass(scope, ...nodeArray(params), factor));
    };
  } else {
    return (...params) => {
      return assignNode(new NodeClass(scope, ...nodeArray(params)));
    };
  }
};
var ShaderNodeImmutable = function(NodeClass, ...params) {
  return nodeObject(new NodeClass(...nodeArray(params)));
};
var ShaderCallNodeInternal = class extends Node_default {
  constructor(shaderNode, inputNodes) {
    super();
    this.shaderNode = shaderNode;
    this.inputNodes = inputNodes;
  }
  getNodeType(builder) {
    const properties = builder.getNodeProperties(this);
    if (properties.outputNode === null) {
      properties.outputNode = this.setupOutput(builder);
    }
    return properties.outputNode.getNodeType(builder);
  }
  call(builder) {
    const { shaderNode, inputNodes } = this;
    if (shaderNode.layout) {
      let functionNodesCacheMap = nodeBuilderFunctionsCacheMap.get(builder.constructor);
      if (functionNodesCacheMap === void 0) {
        functionNodesCacheMap = /* @__PURE__ */ new WeakMap();
        nodeBuilderFunctionsCacheMap.set(builder.constructor, functionNodesCacheMap);
      }
      let functionNode = functionNodesCacheMap.get(shaderNode);
      if (functionNode === void 0) {
        functionNode = nodeObject(builder.buildFunctionNode(shaderNode));
        functionNodesCacheMap.set(shaderNode, functionNode);
      }
      if (builder.currentFunctionNode !== null) {
        builder.currentFunctionNode.includes.push(functionNode);
      }
      return nodeObject(functionNode.call(inputNodes));
    }
    const jsFunc = shaderNode.jsFunc;
    const outputNode = inputNodes !== null ? jsFunc(inputNodes, builder.stack, builder) : jsFunc(builder.stack, builder);
    return nodeObject(outputNode);
  }
  setup(builder) {
    const { outputNode } = builder.getNodeProperties(this);
    return outputNode || this.setupOutput(builder);
  }
  setupOutput(builder) {
    builder.addStack();
    builder.stack.outputNode = this.call(builder);
    return builder.removeStack();
  }
  generate(builder, output2) {
    const { outputNode } = builder.getNodeProperties(this);
    if (outputNode === null) {
      return this.call(builder).build(builder, output2);
    }
    return super.generate(builder, output2);
  }
};
var ShaderNodeInternal = class extends Node_default {
  constructor(jsFunc) {
    super();
    this.jsFunc = jsFunc;
    this.layout = null;
  }
  get isArrayInput() {
    return /^\((\s+)?\[/.test(this.jsFunc.toString());
  }
  setLayout(layout) {
    this.layout = layout;
    return this;
  }
  call(inputs = null) {
    nodeObjects(inputs);
    return nodeObject(new ShaderCallNodeInternal(this, inputs));
  }
  setup() {
    return this.call();
  }
};
var bools = [false, true];
var uints = [0, 1, 2, 3];
var ints = [-1, -2];
var floats = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2];
var boolsCacheMap = /* @__PURE__ */ new Map();
for (const bool2 of bools)
  boolsCacheMap.set(bool2, new ConstNode_default(bool2));
var uintsCacheMap = /* @__PURE__ */ new Map();
for (const uint2 of uints)
  uintsCacheMap.set(uint2, new ConstNode_default(uint2, "uint"));
var intsCacheMap = new Map([...uintsCacheMap].map((el) => new ConstNode_default(el.value, "int")));
for (const int2 of ints)
  intsCacheMap.set(int2, new ConstNode_default(int2, "int"));
var floatsCacheMap = new Map([...intsCacheMap].map((el) => new ConstNode_default(el.value)));
for (const float2 of floats)
  floatsCacheMap.set(float2, new ConstNode_default(float2));
for (const float2 of floats)
  floatsCacheMap.set(-float2, new ConstNode_default(-float2));
var cacheMaps = { bool: boolsCacheMap, uint: uintsCacheMap, ints: intsCacheMap, float: floatsCacheMap };
var constNodesCacheMap = new Map([...boolsCacheMap, ...floatsCacheMap]);
var getConstNode = (value, type) => {
  if (constNodesCacheMap.has(value)) {
    return constNodesCacheMap.get(value);
  } else if (value.isNode === true) {
    return value;
  } else {
    return new ConstNode_default(value, type);
  }
};
var safeGetNodeType = (node) => {
  try {
    return node.getNodeType();
  } catch (_) {
    return void 0;
  }
};
var ConvertType = function(type, cacheMap = null) {
  return (...params) => {
    if (params.length === 0 || !["bool", "float", "int", "uint"].includes(type) && params.every((param) => typeof param !== "object")) {
      params = [getValueFromType(type, ...params)];
    }
    if (params.length === 1 && cacheMap !== null && cacheMap.has(params[0])) {
      return nodeObject(cacheMap.get(params[0]));
    }
    if (params.length === 1) {
      const node = getConstNode(params[0], type);
      if (safeGetNodeType(node) === type)
        return nodeObject(node);
      return nodeObject(new ConvertNode_default(node, type));
    }
    const nodes = params.map((param) => getConstNode(param));
    return nodeObject(new JoinNode_default(nodes, type));
  };
};
var defined = (value) => value && value.value;
var getConstNodeType = (value) => value !== void 0 && value !== null ? value.nodeType || value.convertTo || (typeof value === "string" ? value : null) : null;
function ShaderNode(jsFunc) {
  return new Proxy(new ShaderNodeInternal(jsFunc), shaderNodeHandler);
}
var nodeObject = (val, altType = null) => (
  /* new */
  ShaderNodeObject(val, altType)
);
var nodeObjects = (val, altType = null) => new ShaderNodeObjects(val, altType);
var nodeArray = (val, altType = null) => new ShaderNodeArray(val, altType);
var nodeProxy = (...params) => new ShaderNodeProxy(...params);
var nodeImmutable = (...params) => new ShaderNodeImmutable(...params);
var tslFn = (jsFunc) => {
  const shaderNode = new ShaderNode(jsFunc);
  const fn = (...params) => {
    let inputs;
    nodeObjects(params);
    if (params[0] && params[0].isNode) {
      inputs = [...params];
    } else {
      inputs = params[0];
    }
    return shaderNode.call(inputs);
  };
  fn.shaderNode = shaderNode;
  fn.setLayout = (layout) => {
    shaderNode.setLayout(layout);
    return fn;
  };
  return fn;
};
addNodeClass("ShaderNode", ShaderNode);
addNodeElement("toGlobal", (node) => {
  node.global = true;
  return node;
});
var setCurrentStack = (stack2) => {
  if (currentStack === stack2) {
  }
  currentStack = stack2;
};
var getCurrentStack = () => currentStack;
var If = (...params) => currentStack.if(...params);
function append(node) {
  if (currentStack)
    currentStack.add(node);
  return node;
}
addNodeElement("append", append);
var color = new ConvertType("color");
var float = new ConvertType("float", cacheMaps.float);
var int = new ConvertType("int", cacheMaps.ints);
var uint = new ConvertType("uint", cacheMaps.uint);
var bool = new ConvertType("bool", cacheMaps.bool);
var vec2 = new ConvertType("vec2");
var ivec2 = new ConvertType("ivec2");
var uvec2 = new ConvertType("uvec2");
var bvec2 = new ConvertType("bvec2");
var vec3 = new ConvertType("vec3");
var ivec3 = new ConvertType("ivec3");
var uvec3 = new ConvertType("uvec3");
var bvec3 = new ConvertType("bvec3");
var vec4 = new ConvertType("vec4");
var ivec4 = new ConvertType("ivec4");
var uvec4 = new ConvertType("uvec4");
var bvec4 = new ConvertType("bvec4");
var mat2 = new ConvertType("mat2");
var imat2 = new ConvertType("imat2");
var umat2 = new ConvertType("umat2");
var bmat2 = new ConvertType("bmat2");
var mat3 = new ConvertType("mat3");
var imat3 = new ConvertType("imat3");
var umat3 = new ConvertType("umat3");
var bmat3 = new ConvertType("bmat3");
var mat4 = new ConvertType("mat4");
var imat4 = new ConvertType("imat4");
var umat4 = new ConvertType("umat4");
var bmat4 = new ConvertType("bmat4");
var string = (value = "") => nodeObject(new ConstNode_default(value, "string"));
var arrayBuffer = (value) => nodeObject(new ConstNode_default(value, "ArrayBuffer"));
addNodeElement("toColor", color);
addNodeElement("toFloat", float);
addNodeElement("toInt", int);
addNodeElement("toUint", uint);
addNodeElement("toBool", bool);
addNodeElement("toVec2", vec2);
addNodeElement("toIvec2", ivec2);
addNodeElement("toUvec2", uvec2);
addNodeElement("toBvec2", bvec2);
addNodeElement("toVec3", vec3);
addNodeElement("toIvec3", ivec3);
addNodeElement("toUvec3", uvec3);
addNodeElement("toBvec3", bvec3);
addNodeElement("toVec4", vec4);
addNodeElement("toIvec4", ivec4);
addNodeElement("toUvec4", uvec4);
addNodeElement("toBvec4", bvec4);
addNodeElement("toMat2", mat2);
addNodeElement("toImat2", imat2);
addNodeElement("toUmat2", umat2);
addNodeElement("toBmat2", bmat2);
addNodeElement("toMat3", mat3);
addNodeElement("toImat3", imat3);
addNodeElement("toUmat3", umat3);
addNodeElement("toBmat3", bmat3);
addNodeElement("toMat4", mat4);
addNodeElement("toImat4", imat4);
addNodeElement("toUmat4", umat4);
addNodeElement("toBmat4", bmat4);
var element = nodeProxy(ArrayElementNode_default);
var convert = (node, types) => nodeObject(new ConvertNode_default(nodeObject(node), types));
var split = (node, channels) => nodeObject(new SplitNode_default(nodeObject(node), channels));
addNodeElement("element", element);
addNodeElement("convert", convert);

// node_modules/three/examples/jsm/nodes/core/AssignNode.js
var AssignNode = class extends TempNode_default {
  constructor(targetNode, sourceNode) {
    super();
    this.targetNode = targetNode;
    this.sourceNode = sourceNode;
  }
  hasDependencies() {
    return false;
  }
  getNodeType(builder, output2) {
    return output2 !== "void" ? this.targetNode.getNodeType(builder) : "void";
  }
  needsSplitAssign(builder) {
    const { targetNode } = this;
    if (builder.isAvailable("swizzleAssign") === false && targetNode.isSplitNode && targetNode.components.length > 1) {
      const targetLength = builder.getTypeLength(targetNode.node.getNodeType(builder));
      const assignDiferentVector = vectorComponents.join("").slice(0, targetLength) !== targetNode.components;
      return assignDiferentVector;
    }
    return false;
  }
  generate(builder, output2) {
    const { targetNode, sourceNode } = this;
    const needsSplitAssign = this.needsSplitAssign(builder);
    const targetType = targetNode.getNodeType(builder);
    const target = targetNode.context({ assign: true }).build(builder);
    const source = sourceNode.build(builder, targetType);
    const sourceType = sourceNode.getNodeType(builder);
    const nodeData = builder.getDataFromNode(this);
    let snippet;
    if (nodeData.initialized === true) {
      if (output2 !== "void") {
        snippet = target;
      }
    } else if (needsSplitAssign) {
      const sourceVar = builder.getVarFromNode(this, null, targetType);
      const sourceProperty = builder.getPropertyName(sourceVar);
      builder.addLineFlowCode(`${sourceProperty} = ${source}`);
      const targetRoot = targetNode.node.context({ assign: true }).build(builder);
      for (let i = 0; i < targetNode.components.length; i++) {
        const component = targetNode.components[i];
        builder.addLineFlowCode(`${targetRoot}.${component} = ${sourceProperty}[ ${i} ]`);
      }
      if (output2 !== "void") {
        snippet = target;
      }
    } else {
      snippet = `${target} = ${source}`;
      if (output2 === "void" || sourceType === "void") {
        builder.addLineFlowCode(snippet);
        if (output2 !== "void") {
          snippet = target;
        }
      }
    }
    nodeData.initialized = true;
    return builder.format(snippet, targetType, output2);
  }
};
var AssignNode_default = AssignNode;
var assign = nodeProxy(AssignNode);
addNodeClass("AssignNode", AssignNode);
addNodeElement("assign", assign);

// node_modules/three/examples/jsm/nodes/core/VaryingNode.js
var VaryingNode = class extends Node_default {
  constructor(node, name = null) {
    super();
    this.node = node;
    this.name = name;
    this.isVaryingNode = true;
  }
  isGlobal() {
    return true;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  setupVarying(builder) {
    const properties = builder.getNodeProperties(this);
    let varying2 = properties.varying;
    if (varying2 === void 0) {
      const name = this.name;
      const type = this.getNodeType(builder);
      properties.varying = varying2 = builder.getVaryingFromNode(this, name, type);
      properties.node = this.node;
    }
    varying2.needsInterpolation || (varying2.needsInterpolation = builder.shaderStage === "fragment");
    return varying2;
  }
  setup(builder) {
    this.setupVarying(builder);
  }
  generate(builder) {
    const properties = builder.getNodeProperties(this);
    const varying2 = this.setupVarying(builder);
    if (properties.propertyName === void 0) {
      const type = this.getNodeType(builder);
      const propertyName = builder.getPropertyName(varying2, NodeShaderStage.VERTEX);
      builder.flowNodeFromShaderStage(NodeShaderStage.VERTEX, this.node, type, propertyName);
      properties.propertyName = propertyName;
    }
    return builder.getPropertyName(varying2);
  }
};
var VaryingNode_default = VaryingNode;
var varying = nodeProxy(VaryingNode);
addNodeElement("varying", varying);
addNodeClass("VaryingNode", VaryingNode);

// node_modules/three/examples/jsm/nodes/core/AttributeNode.js
var AttributeNode = class extends Node_default {
  constructor(attributeName, nodeType = null, defaultNode = null) {
    super(nodeType);
    this.defaultNode = defaultNode;
    this._attributeName = attributeName;
  }
  isGlobal() {
    return true;
  }
  getHash(builder) {
    return this.getAttributeName(builder);
  }
  getNodeType(builder) {
    let nodeType = super.getNodeType(builder);
    if (nodeType === null) {
      const attributeName = this.getAttributeName(builder);
      if (builder.hasGeometryAttribute(attributeName)) {
        const attribute2 = builder.geometry.getAttribute(attributeName);
        nodeType = builder.getTypeFromAttribute(attribute2);
      } else {
        nodeType = "float";
      }
    }
    return nodeType;
  }
  setAttributeName(attributeName) {
    this._attributeName = attributeName;
    return this;
  }
  getAttributeName() {
    return this._attributeName;
  }
  generate(builder) {
    const attributeName = this.getAttributeName(builder);
    const nodeType = this.getNodeType(builder);
    const geometryAttribute = builder.hasGeometryAttribute(attributeName);
    if (geometryAttribute === true) {
      const attribute2 = builder.geometry.getAttribute(attributeName);
      const attributeType = builder.getTypeFromAttribute(attribute2);
      const nodeAttribute = builder.getAttribute(attributeName, attributeType);
      if (builder.shaderStage === "vertex") {
        return builder.format(nodeAttribute.name, attributeType, nodeType);
      } else {
        const nodeVarying = varying(this);
        return nodeVarying.build(builder, nodeType);
      }
    } else {
      console.warn(`AttributeNode: Vertex attribute "${attributeName}" not found on geometry.`);
      const { defaultNode } = this;
      if (defaultNode !== null) {
        return defaultNode.build(builder, nodeType);
      } else {
        return builder.generateConst(nodeType);
      }
    }
  }
};
var AttributeNode_default = AttributeNode;
var attribute = (name, nodeType, defaultNode) => nodeObject(new AttributeNode(name, nodeType, nodeObject(defaultNode)));
addNodeClass("AttributeNode", AttributeNode);

// node_modules/three/examples/jsm/nodes/core/BypassNode.js
var BypassNode = class extends Node_default {
  constructor(returnNode, callNode) {
    super();
    this.isBypassNode = true;
    this.outputNode = returnNode;
    this.callNode = callNode;
  }
  getNodeType(builder) {
    return this.outputNode.getNodeType(builder);
  }
  generate(builder) {
    const snippet = this.callNode.build(builder, "void");
    if (snippet !== "") {
      builder.addLineFlowCode(snippet);
    }
    return this.outputNode.build(builder);
  }
};
var BypassNode_default = BypassNode;
var bypass = nodeProxy(BypassNode);
addNodeElement("bypass", bypass);
addNodeClass("BypassNode", BypassNode);

// node_modules/three/examples/jsm/nodes/core/NodeCache.js
var id = 0;
var NodeCache = class {
  constructor() {
    this.id = id++;
    this.nodesData = /* @__PURE__ */ new WeakMap();
  }
  getNodeData(node) {
    return this.nodesData.get(node);
  }
  setNodeData(node, data) {
    this.nodesData.set(node, data);
  }
};
var NodeCache_default = NodeCache;

// node_modules/three/examples/jsm/nodes/core/CacheNode.js
var CacheNode = class extends Node_default {
  constructor(node, cache2 = new NodeCache_default()) {
    super();
    this.isCacheNode = true;
    this.node = node;
    this.cache = cache2;
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  build(builder, ...params) {
    const previousCache = builder.getCache();
    const cache2 = this.cache || builder.globalCache;
    builder.setCache(cache2);
    const data = this.node.build(builder, ...params);
    builder.setCache(previousCache);
    return data;
  }
};
var CacheNode_default = CacheNode;
var cache = nodeProxy(CacheNode);
var globalCache = (node) => cache(node, null);
addNodeElement("cache", cache);
addNodeElement("globalCache", globalCache);
addNodeClass("CacheNode", CacheNode);

// node_modules/three/examples/jsm/nodes/core/ContextNode.js
var ContextNode = class extends Node_default {
  constructor(node, context2 = {}) {
    super();
    this.isContextNode = true;
    this.node = node;
    this.context = context2;
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  analyze(builder) {
    this.node.build(builder);
  }
  setup(builder) {
    const previousContext = builder.getContext();
    builder.setContext({ ...builder.context, ...this.context });
    const node = this.node.build(builder);
    builder.setContext(previousContext);
    return node;
  }
  generate(builder, output2) {
    const previousContext = builder.getContext();
    builder.setContext({ ...builder.context, ...this.context });
    const snippet = this.node.build(builder, output2);
    builder.setContext(previousContext);
    return snippet;
  }
};
var ContextNode_default = ContextNode;
var context = nodeProxy(ContextNode);
var label = (node, name) => context(node, { label: name });
addNodeElement("context", context);
addNodeElement("label", label);
addNodeClass("ContextNode", ContextNode);

// node_modules/three/examples/jsm/nodes/core/IndexNode.js
var IndexNode = class _IndexNode extends Node_default {
  constructor(scope) {
    super("uint");
    this.scope = scope;
    this.isInstanceIndexNode = true;
  }
  generate(builder) {
    const nodeType = this.getNodeType(builder);
    const scope = this.scope;
    let propertyName;
    if (scope === _IndexNode.VERTEX) {
      propertyName = builder.getVertexIndex();
    } else if (scope === _IndexNode.INSTANCE) {
      propertyName = builder.getInstanceIndex();
    } else {
      throw new Error("THREE.IndexNode: Unknown scope: " + scope);
    }
    let output2;
    if (builder.shaderStage === "vertex" || builder.shaderStage === "compute") {
      output2 = propertyName;
    } else {
      const nodeVarying = varying(this);
      output2 = nodeVarying.build(builder, nodeType);
    }
    return output2;
  }
};
IndexNode.VERTEX = "vertex";
IndexNode.INSTANCE = "instance";
var IndexNode_default = IndexNode;
var vertexIndex = nodeImmutable(IndexNode, IndexNode.VERTEX);
var instanceIndex = nodeImmutable(IndexNode, IndexNode.INSTANCE);
addNodeClass("IndexNode", IndexNode);

// node_modules/three/examples/jsm/nodes/core/LightingModel.js
var LightingModel = class {
  start() {
  }
  finish() {
  }
  direct() {
  }
  indirectDiffuse() {
  }
  indirectSpecular() {
  }
  ambientOcclusion() {
  }
};
var LightingModel_default = LightingModel;

// node_modules/three/examples/jsm/nodes/core/VarNode.js
var VarNode = class extends Node_default {
  constructor(node, name = null) {
    super();
    this.node = node;
    this.name = name;
    this.isVarNode = true;
  }
  isGlobal() {
    return true;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  generate(builder) {
    const { node, name } = this;
    const nodeVar = builder.getVarFromNode(this, name, builder.getVectorType(this.getNodeType(builder)));
    const propertyName = builder.getPropertyName(nodeVar);
    const snippet = node.build(builder, nodeVar.type);
    builder.addLineFlowCode(`${propertyName} = ${snippet}`);
    return propertyName;
  }
};
var VarNode_default = VarNode;
var temp = nodeProxy(VarNode);
addNodeElement("temp", temp);
addNodeElement("toVar", (...params) => temp(...params).append());
addNodeClass("VarNode", VarNode);

// node_modules/three/examples/jsm/nodes/core/NodeAttribute.js
var NodeAttribute = class {
  constructor(name, type, node = null) {
    this.isNodeAttribute = true;
    this.name = name;
    this.type = type;
    this.node = node;
  }
};
var NodeAttribute_default = NodeAttribute;

// node_modules/three/examples/jsm/nodes/core/NodeUniform.js
var NodeUniform = class {
  constructor(name, type, node, needsUpdate = void 0) {
    this.isNodeUniform = true;
    this.name = name;
    this.type = type;
    this.node = node.getSelf();
    this.needsUpdate = needsUpdate;
  }
  get value() {
    return this.node.value;
  }
  set value(val) {
    this.node.value = val;
  }
  get id() {
    return this.node.id;
  }
  get groupNode() {
    return this.node.groupNode;
  }
};
var NodeUniform_default = NodeUniform;

// node_modules/three/examples/jsm/nodes/core/NodeVar.js
var NodeVar = class {
  constructor(name, type) {
    this.isNodeVar = true;
    this.name = name;
    this.type = type;
  }
};
var NodeVar_default = NodeVar;

// node_modules/three/examples/jsm/nodes/core/NodeVarying.js
var NodeVarying = class extends NodeVar_default {
  constructor(name, type) {
    super(name, type);
    this.needsInterpolation = false;
    this.isNodeVarying = true;
  }
};
var NodeVarying_default = NodeVarying;

// node_modules/three/examples/jsm/nodes/core/NodeCode.js
var NodeCode = class {
  constructor(name, type, code2 = "") {
    this.name = name;
    this.type = type;
    this.code = code2;
    Object.defineProperty(this, "isNodeCode", { value: true });
  }
};
var NodeCode_default = NodeCode;

// node_modules/three/examples/jsm/nodes/core/NodeKeywords.js
var NodeKeywords = class {
  constructor() {
    this.keywords = [];
    this.nodes = {};
    this.keywordsCallback = {};
  }
  getNode(name) {
    let node = this.nodes[name];
    if (node === void 0 && this.keywordsCallback[name] !== void 0) {
      node = this.keywordsCallback[name](name);
      this.nodes[name] = node;
    }
    return node;
  }
  addKeyword(name, callback) {
    this.keywords.push(name);
    this.keywordsCallback[name] = callback;
    return this;
  }
  parse(code2) {
    const keywordNames = this.keywords;
    const regExp = new RegExp(`\\b${keywordNames.join("\\b|\\b")}\\b`, "g");
    const codeKeywords = code2.match(regExp);
    const keywordNodes = [];
    if (codeKeywords !== null) {
      for (const keyword of codeKeywords) {
        const node = this.getNode(keyword);
        if (node !== void 0 && keywordNodes.indexOf(node) === -1) {
          keywordNodes.push(node);
        }
      }
    }
    return keywordNodes;
  }
  include(builder, code2) {
    const keywordNodes = this.parse(code2);
    for (const keywordNode of keywordNodes) {
      keywordNode.build(builder);
    }
  }
};
var NodeKeywords_default = NodeKeywords;

// node_modules/three/examples/jsm/nodes/core/PropertyNode.js
var PropertyNode = class extends Node_default {
  constructor(nodeType, name = null, varying2 = false) {
    super(nodeType);
    this.name = name;
    this.varying = varying2;
    this.isPropertyNode = true;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  isGlobal() {
    return true;
  }
  generate(builder) {
    let nodeVar;
    if (this.varying === true) {
      nodeVar = builder.getVaryingFromNode(this, this.name);
      nodeVar.needsInterpolation = true;
    } else {
      nodeVar = builder.getVarFromNode(this, this.name);
    }
    return builder.getPropertyName(nodeVar);
  }
};
var PropertyNode_default = PropertyNode;
var property = (type, name) => nodeObject(new PropertyNode(type, name));
var varyingProperty = (type, name) => nodeObject(new PropertyNode(type, name, true));
var diffuseColor = nodeImmutable(PropertyNode, "vec4", "DiffuseColor");
var roughness = nodeImmutable(PropertyNode, "float", "Roughness");
var metalness = nodeImmutable(PropertyNode, "float", "Metalness");
var clearcoat = nodeImmutable(PropertyNode, "float", "Clearcoat");
var clearcoatRoughness = nodeImmutable(PropertyNode, "float", "ClearcoatRoughness");
var sheen = nodeImmutable(PropertyNode, "vec3", "Sheen");
var sheenRoughness = nodeImmutable(PropertyNode, "float", "SheenRoughness");
var iridescence = nodeImmutable(PropertyNode, "float", "Iridescence");
var iridescenceIOR = nodeImmutable(PropertyNode, "float", "IridescenceIOR");
var iridescenceThickness = nodeImmutable(PropertyNode, "float", "IridescenceThickness");
var alphaT = nodeImmutable(PropertyNode, "float", "AlphaT");
var anisotropy = nodeImmutable(PropertyNode, "float", "Anisotropy");
var anisotropyT = nodeImmutable(PropertyNode, "vec3", "AnisotropyT");
var anisotropyB = nodeImmutable(PropertyNode, "vec3", "AnisotropyB");
var specularColor = nodeImmutable(PropertyNode, "color", "SpecularColor");
var specularF90 = nodeImmutable(PropertyNode, "float", "SpecularF90");
var shininess = nodeImmutable(PropertyNode, "float", "Shininess");
var output = nodeImmutable(PropertyNode, "vec4", "Output");
var dashSize = nodeImmutable(PropertyNode, "float", "dashSize");
var gapSize = nodeImmutable(PropertyNode, "float", "gapSize");
var pointWidth = nodeImmutable(PropertyNode, "float", "pointWidth");
var ior = nodeImmutable(PropertyNode, "float", "IOR");
var transmission = nodeImmutable(PropertyNode, "float", "Transmission");
var thickness = nodeImmutable(PropertyNode, "float", "Thickness");
var attenuationDistance = nodeImmutable(PropertyNode, "float", "AttenuationDistance");
var attenuationColor = nodeImmutable(PropertyNode, "color", "AttenuationColor");
var dispersion = nodeImmutable(PropertyNode, "float", "Dispersion");
addNodeClass("PropertyNode", PropertyNode);

// node_modules/three/examples/jsm/nodes/core/ParameterNode.js
var ParameterNode = class extends PropertyNode_default {
  constructor(nodeType, name = null) {
    super(nodeType, name);
    this.isParameterNode = true;
  }
  getHash() {
    return this.uuid;
  }
  generate() {
    return this.name;
  }
};
var ParameterNode_default = ParameterNode;
var parameter = (type, name) => nodeObject(new ParameterNode(type, name));
addNodeClass("ParameterNode", ParameterNode);

// node_modules/three/examples/jsm/nodes/code/CodeNode.js
var CodeNode = class extends Node_default {
  constructor(code2 = "", includes = [], language = "") {
    super("code");
    this.isCodeNode = true;
    this.code = code2;
    this.language = language;
    this.includes = includes;
  }
  isGlobal() {
    return true;
  }
  setIncludes(includes) {
    this.includes = includes;
    return this;
  }
  getIncludes() {
    return this.includes;
  }
  generate(builder) {
    const includes = this.getIncludes(builder);
    for (const include of includes) {
      include.build(builder);
    }
    const nodeCode = builder.getCodeFromNode(this, this.getNodeType(builder));
    nodeCode.code = this.code;
    return nodeCode.code;
  }
  serialize(data) {
    super.serialize(data);
    data.code = this.code;
    data.language = this.language;
  }
  deserialize(data) {
    super.deserialize(data);
    this.code = data.code;
    this.language = data.language;
  }
};
var CodeNode_default = CodeNode;
var code = nodeProxy(CodeNode);
var js = (src, includes) => code(src, includes, "js");
var wgsl = (src, includes) => code(src, includes, "wgsl");
var glsl = (src, includes) => code(src, includes, "glsl");
addNodeClass("CodeNode", CodeNode);

// node_modules/three/examples/jsm/nodes/code/FunctionNode.js
var FunctionNode = class extends CodeNode_default {
  constructor(code2 = "", includes = [], language = "") {
    super(code2, includes, language);
    this.keywords = {};
  }
  getNodeType(builder) {
    return this.getNodeFunction(builder).type;
  }
  getInputs(builder) {
    return this.getNodeFunction(builder).inputs;
  }
  getNodeFunction(builder) {
    const nodeData = builder.getDataFromNode(this);
    let nodeFunction = nodeData.nodeFunction;
    if (nodeFunction === void 0) {
      nodeFunction = builder.parser.parseFunction(this.code);
      nodeData.nodeFunction = nodeFunction;
    }
    return nodeFunction;
  }
  generate(builder, output2) {
    super.generate(builder);
    const nodeFunction = this.getNodeFunction(builder);
    const name = nodeFunction.name;
    const type = nodeFunction.type;
    const nodeCode = builder.getCodeFromNode(this, type);
    if (name !== "") {
      nodeCode.name = name;
    }
    const propertyName = builder.getPropertyName(nodeCode);
    let code2 = this.getNodeFunction(builder).getCode(propertyName);
    const keywords = this.keywords;
    const keywordsProperties = Object.keys(keywords);
    if (keywordsProperties.length > 0) {
      for (const property2 of keywordsProperties) {
        const propertyRegExp = new RegExp(`\\b${property2}\\b`, "g");
        const nodeProperty = keywords[property2].build(builder, "property");
        code2 = code2.replace(propertyRegExp, nodeProperty);
      }
    }
    nodeCode.code = code2 + "\n";
    if (output2 === "property") {
      return propertyName;
    } else {
      return builder.format(`${propertyName}()`, type, output2);
    }
  }
};
var FunctionNode_default = FunctionNode;
var nativeFn = (code2, includes = [], language = "") => {
  for (let i = 0; i < includes.length; i++) {
    const include = includes[i];
    if (typeof include === "function") {
      includes[i] = include.functionNode;
    }
  }
  const functionNode = nodeObject(new FunctionNode(code2, includes, language));
  const fn = (...params) => functionNode.call(...params);
  fn.functionNode = functionNode;
  return fn;
};
var glslFn = (code2, includes) => nativeFn(code2, includes, "glsl");
var wgslFn = (code2, includes) => nativeFn(code2, includes, "wgsl");
addNodeClass("FunctionNode", FunctionNode);

// node_modules/three/examples/jsm/nodes/core/UniformGroupNode.js
var UniformGroupNode = class extends Node_default {
  constructor(name, shared = false) {
    super("string");
    this.name = name;
    this.version = 0;
    this.shared = shared;
    this.isUniformGroup = true;
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
};
var uniformGroup = (name) => new UniformGroupNode(name);
var sharedUniformGroup = (name) => new UniformGroupNode(name, true);
var frameGroup = sharedUniformGroup("frame");
var renderGroup = sharedUniformGroup("render");
var objectGroup = uniformGroup("object");
var UniformGroupNode_default = UniformGroupNode;
addNodeClass("UniformGroupNode", UniformGroupNode);

// node_modules/three/examples/jsm/nodes/core/UniformNode.js
var UniformNode = class extends InputNode_default {
  constructor(value, nodeType = null) {
    super(value, nodeType);
    this.isUniformNode = true;
    this.groupNode = objectGroup;
  }
  setGroup(group) {
    this.groupNode = group;
    return this;
  }
  getGroup() {
    return this.groupNode;
  }
  getUniformHash(builder) {
    return this.getHash(builder);
  }
  onUpdate(callback, updateType) {
    const self = this.getSelf();
    callback = callback.bind(self);
    return super.onUpdate((frame) => {
      const value = callback(frame, self);
      if (value !== void 0) {
        this.value = value;
      }
    }, updateType);
  }
  generate(builder, output2) {
    const type = this.getNodeType(builder);
    const hash2 = this.getUniformHash(builder);
    let sharedNode = builder.getNodeFromHash(hash2);
    if (sharedNode === void 0) {
      builder.setHashNode(this, hash2);
      sharedNode = this;
    }
    const sharedNodeType = sharedNode.getInputType(builder);
    const nodeUniform = builder.getUniformFromNode(sharedNode, sharedNodeType, builder.shaderStage, builder.context.label);
    const propertyName = builder.getPropertyName(nodeUniform);
    if (builder.context.label !== void 0)
      delete builder.context.label;
    return builder.format(propertyName, type, output2);
  }
};
var UniformNode_default = UniformNode;
var uniform = (arg1, arg2) => {
  const nodeType = getConstNodeType(arg2 || arg1);
  const value = arg1 && arg1.isNode === true ? arg1.node && arg1.node.value || arg1.value : arg1;
  return nodeObject(new UniformNode(value, nodeType));
};
addNodeClass("UniformNode", UniformNode);

// node_modules/three/examples/jsm/nodes/accessors/UVNode.js
var uv = (index) => attribute("uv" + (index > 0 ? index : ""), "vec2");

// node_modules/three/examples/jsm/nodes/accessors/TextureSizeNode.js
var TextureSizeNode = class extends Node_default {
  constructor(textureNode, levelNode = null) {
    super("uvec2");
    this.isTextureSizeNode = true;
    this.textureNode = textureNode;
    this.levelNode = levelNode;
  }
  generate(builder, output2) {
    const textureProperty = this.textureNode.build(builder, "property");
    const levelNode = this.levelNode.build(builder, "int");
    return builder.format(`${builder.getMethod("textureDimensions")}( ${textureProperty}, ${levelNode} )`, this.getNodeType(builder), output2);
  }
};
var textureSize = nodeProxy(TextureSizeNode);
addNodeElement("textureSize", textureSize);
addNodeClass("TextureSizeNode", TextureSizeNode);

// node_modules/three/examples/jsm/nodes/math/OperatorNode.js
var OperatorNode = class _OperatorNode extends TempNode_default {
  constructor(op, aNode, bNode, ...params) {
    super();
    this.op = op;
    if (params.length > 0) {
      let finalBNode = bNode;
      for (let i = 0; i < params.length; i++) {
        finalBNode = new _OperatorNode(op, finalBNode, params[i]);
      }
      bNode = finalBNode;
    }
    this.aNode = aNode;
    this.bNode = bNode;
  }
  getNodeType(builder, output2) {
    const op = this.op;
    const aNode = this.aNode;
    const bNode = this.bNode;
    const typeA = aNode.getNodeType(builder);
    const typeB = typeof bNode !== "undefined" ? bNode.getNodeType(builder) : null;
    if (typeA === "void" || typeB === "void") {
      return "void";
    } else if (op === "%") {
      return typeA;
    } else if (op === "~" || op === "&" || op === "|" || op === "^" || op === ">>" || op === "<<") {
      return builder.getIntegerType(typeA);
    } else if (op === "!" || op === "==" || op === "&&" || op === "||" || op === "^^") {
      return "bool";
    } else if (op === "<" || op === ">" || op === "<=" || op === ">=") {
      const typeLength = output2 ? builder.getTypeLength(output2) : Math.max(builder.getTypeLength(typeA), builder.getTypeLength(typeB));
      return typeLength > 1 ? `bvec${typeLength}` : "bool";
    } else {
      if (typeA === "float" && builder.isMatrix(typeB)) {
        return typeB;
      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {
        return builder.getVectorFromMatrix(typeA);
      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {
        return builder.getVectorFromMatrix(typeB);
      } else if (builder.getTypeLength(typeB) > builder.getTypeLength(typeA)) {
        return typeB;
      }
      return typeA;
    }
  }
  generate(builder, output2) {
    const op = this.op;
    const aNode = this.aNode;
    const bNode = this.bNode;
    const type = this.getNodeType(builder, output2);
    let typeA = null;
    let typeB = null;
    if (type !== "void") {
      typeA = aNode.getNodeType(builder);
      typeB = typeof bNode !== "undefined" ? bNode.getNodeType(builder) : null;
      if (op === "<" || op === ">" || op === "<=" || op === ">=" || op === "==") {
        if (builder.isVector(typeA)) {
          typeB = typeA;
        } else {
          typeA = typeB = "float";
        }
      } else if (op === ">>" || op === "<<") {
        typeA = type;
        typeB = builder.changeComponentType(typeB, "uint");
      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {
        typeB = builder.getVectorFromMatrix(typeA);
      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {
        typeA = builder.getVectorFromMatrix(typeB);
      } else {
        typeA = typeB = type;
      }
    } else {
      typeA = typeB = type;
    }
    const a = aNode.build(builder, typeA);
    const b = typeof bNode !== "undefined" ? bNode.build(builder, typeB) : null;
    const outputLength = builder.getTypeLength(output2);
    const fnOpSnippet = builder.getFunctionOperator(op);
    if (output2 !== "void") {
      if (op === "<" && outputLength > 1) {
        return builder.format(`${builder.getMethod("lessThan")}( ${a}, ${b} )`, type, output2);
      } else if (op === "<=" && outputLength > 1) {
        return builder.format(`${builder.getMethod("lessThanEqual")}( ${a}, ${b} )`, type, output2);
      } else if (op === ">" && outputLength > 1) {
        return builder.format(`${builder.getMethod("greaterThan")}( ${a}, ${b} )`, type, output2);
      } else if (op === ">=" && outputLength > 1) {
        return builder.format(`${builder.getMethod("greaterThanEqual")}( ${a}, ${b} )`, type, output2);
      } else if (op === "!" || op === "~") {
        return builder.format(`(${op}${a})`, typeA, output2);
      } else if (fnOpSnippet) {
        return builder.format(`${fnOpSnippet}( ${a}, ${b} )`, type, output2);
      } else {
        return builder.format(`( ${a} ${op} ${b} )`, type, output2);
      }
    } else if (typeA !== "void") {
      if (fnOpSnippet) {
        return builder.format(`${fnOpSnippet}( ${a}, ${b} )`, type, output2);
      } else {
        return builder.format(`${a} ${op} ${b}`, type, output2);
      }
    }
  }
  serialize(data) {
    super.serialize(data);
    data.op = this.op;
  }
  deserialize(data) {
    super.deserialize(data);
    this.op = data.op;
  }
};
var OperatorNode_default = OperatorNode;
var add = nodeProxy(OperatorNode, "+");
var sub = nodeProxy(OperatorNode, "-");
var mul = nodeProxy(OperatorNode, "*");
var div = nodeProxy(OperatorNode, "/");
var remainder = nodeProxy(OperatorNode, "%");
var equal = nodeProxy(OperatorNode, "==");
var notEqual = nodeProxy(OperatorNode, "!=");
var lessThan = nodeProxy(OperatorNode, "<");
var greaterThan = nodeProxy(OperatorNode, ">");
var lessThanEqual = nodeProxy(OperatorNode, "<=");
var greaterThanEqual = nodeProxy(OperatorNode, ">=");
var and = nodeProxy(OperatorNode, "&&");
var or = nodeProxy(OperatorNode, "||");
var not = nodeProxy(OperatorNode, "!");
var xor = nodeProxy(OperatorNode, "^^");
var bitAnd = nodeProxy(OperatorNode, "&");
var bitNot = nodeProxy(OperatorNode, "~");
var bitOr = nodeProxy(OperatorNode, "|");
var bitXor = nodeProxy(OperatorNode, "^");
var shiftLeft = nodeProxy(OperatorNode, "<<");
var shiftRight = nodeProxy(OperatorNode, ">>");
addNodeElement("add", add);
addNodeElement("sub", sub);
addNodeElement("mul", mul);
addNodeElement("div", div);
addNodeElement("remainder", remainder);
addNodeElement("equal", equal);
addNodeElement("notEqual", notEqual);
addNodeElement("lessThan", lessThan);
addNodeElement("greaterThan", greaterThan);
addNodeElement("lessThanEqual", lessThanEqual);
addNodeElement("greaterThanEqual", greaterThanEqual);
addNodeElement("and", and);
addNodeElement("or", or);
addNodeElement("not", not);
addNodeElement("xor", xor);
addNodeElement("bitAnd", bitAnd);
addNodeElement("bitNot", bitNot);
addNodeElement("bitOr", bitOr);
addNodeElement("bitXor", bitXor);
addNodeElement("shiftLeft", shiftLeft);
addNodeElement("shiftRight", shiftRight);
addNodeClass("OperatorNode", OperatorNode);

// node_modules/three/examples/jsm/nodes/math/MathNode.js
var MathNode = class _MathNode extends TempNode_default {
  constructor(method, aNode, bNode = null, cNode = null) {
    super();
    this.method = method;
    this.aNode = aNode;
    this.bNode = bNode;
    this.cNode = cNode;
  }
  getInputType(builder) {
    const aType = this.aNode.getNodeType(builder);
    const bType = this.bNode ? this.bNode.getNodeType(builder) : null;
    const cType = this.cNode ? this.cNode.getNodeType(builder) : null;
    const aLen = builder.isMatrix(aType) ? 0 : builder.getTypeLength(aType);
    const bLen = builder.isMatrix(bType) ? 0 : builder.getTypeLength(bType);
    const cLen = builder.isMatrix(cType) ? 0 : builder.getTypeLength(cType);
    if (aLen > bLen && aLen > cLen) {
      return aType;
    } else if (bLen > cLen) {
      return bType;
    } else if (cLen > aLen) {
      return cType;
    }
    return aType;
  }
  getNodeType(builder) {
    const method = this.method;
    if (method === _MathNode.LENGTH || method === _MathNode.DISTANCE || method === _MathNode.DOT) {
      return "float";
    } else if (method === _MathNode.CROSS) {
      return "vec3";
    } else if (method === _MathNode.ALL) {
      return "bool";
    } else if (method === _MathNode.EQUALS) {
      return builder.changeComponentType(this.aNode.getNodeType(builder), "bool");
    } else if (method === _MathNode.MOD) {
      return this.aNode.getNodeType(builder);
    } else {
      return this.getInputType(builder);
    }
  }
  generate(builder, output2) {
    const method = this.method;
    const type = this.getNodeType(builder);
    const inputType = this.getInputType(builder);
    const a = this.aNode;
    const b = this.bNode;
    const c = this.cNode;
    const isWebGL = builder.renderer.isWebGLRenderer === true;
    if (method === _MathNode.TRANSFORM_DIRECTION) {
      let tA = a;
      let tB = b;
      if (builder.isMatrix(tA.getNodeType(builder))) {
        tB = vec4(vec3(tB), 0);
      } else {
        tA = vec4(vec3(tA), 0);
      }
      const mulNode = mul(tA, tB).xyz;
      return normalize(mulNode).build(builder, output2);
    } else if (method === _MathNode.NEGATE) {
      return builder.format("( - " + a.build(builder, inputType) + " )", type, output2);
    } else if (method === _MathNode.ONE_MINUS) {
      return sub(1, a).build(builder, output2);
    } else if (method === _MathNode.RECIPROCAL) {
      return div(1, a).build(builder, output2);
    } else if (method === _MathNode.DIFFERENCE) {
      return abs(sub(a, b)).build(builder, output2);
    } else {
      const params = [];
      if (method === _MathNode.CROSS || method === _MathNode.MOD) {
        params.push(
          a.build(builder, type),
          b.build(builder, type)
        );
      } else if (method === _MathNode.STEP) {
        params.push(
          a.build(builder, builder.getTypeLength(a.getNodeType(builder)) === 1 ? "float" : inputType),
          b.build(builder, inputType)
        );
      } else if (isWebGL && (method === _MathNode.MIN || method === _MathNode.MAX) || method === _MathNode.MOD) {
        params.push(
          a.build(builder, inputType),
          b.build(builder, builder.getTypeLength(b.getNodeType(builder)) === 1 ? "float" : inputType)
        );
      } else if (method === _MathNode.REFRACT) {
        params.push(
          a.build(builder, inputType),
          b.build(builder, inputType),
          c.build(builder, "float")
        );
      } else if (method === _MathNode.MIX) {
        params.push(
          a.build(builder, inputType),
          b.build(builder, inputType),
          c.build(builder, builder.getTypeLength(c.getNodeType(builder)) === 1 ? "float" : inputType)
        );
      } else {
        params.push(a.build(builder, inputType));
        if (b !== null)
          params.push(b.build(builder, inputType));
        if (c !== null)
          params.push(c.build(builder, inputType));
      }
      return builder.format(`${builder.getMethod(method, type)}( ${params.join(", ")} )`, type, output2);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.method = this.method;
  }
  deserialize(data) {
    super.deserialize(data);
    this.method = data.method;
  }
};
MathNode.ALL = "all";
MathNode.ANY = "any";
MathNode.EQUALS = "equals";
MathNode.RADIANS = "radians";
MathNode.DEGREES = "degrees";
MathNode.EXP = "exp";
MathNode.EXP2 = "exp2";
MathNode.LOG = "log";
MathNode.LOG2 = "log2";
MathNode.SQRT = "sqrt";
MathNode.INVERSE_SQRT = "inversesqrt";
MathNode.FLOOR = "floor";
MathNode.CEIL = "ceil";
MathNode.NORMALIZE = "normalize";
MathNode.FRACT = "fract";
MathNode.SIN = "sin";
MathNode.COS = "cos";
MathNode.TAN = "tan";
MathNode.ASIN = "asin";
MathNode.ACOS = "acos";
MathNode.ATAN = "atan";
MathNode.ABS = "abs";
MathNode.SIGN = "sign";
MathNode.LENGTH = "length";
MathNode.NEGATE = "negate";
MathNode.ONE_MINUS = "oneMinus";
MathNode.DFDX = "dFdx";
MathNode.DFDY = "dFdy";
MathNode.ROUND = "round";
MathNode.RECIPROCAL = "reciprocal";
MathNode.TRUNC = "trunc";
MathNode.FWIDTH = "fwidth";
MathNode.BITCAST = "bitcast";
MathNode.ATAN2 = "atan2";
MathNode.MIN = "min";
MathNode.MAX = "max";
MathNode.MOD = "mod";
MathNode.STEP = "step";
MathNode.REFLECT = "reflect";
MathNode.DISTANCE = "distance";
MathNode.DIFFERENCE = "difference";
MathNode.DOT = "dot";
MathNode.CROSS = "cross";
MathNode.POW = "pow";
MathNode.TRANSFORM_DIRECTION = "transformDirection";
MathNode.MIX = "mix";
MathNode.CLAMP = "clamp";
MathNode.REFRACT = "refract";
MathNode.SMOOTHSTEP = "smoothstep";
MathNode.FACEFORWARD = "faceforward";
var MathNode_default = MathNode;
var EPSILON = float(1e-6);
var INFINITY = float(1e6);
var PI = float(Math.PI);
var PI2 = float(Math.PI * 2);
var all = nodeProxy(MathNode, MathNode.ALL);
var any = nodeProxy(MathNode, MathNode.ANY);
var equals = nodeProxy(MathNode, MathNode.EQUALS);
var radians = nodeProxy(MathNode, MathNode.RADIANS);
var degrees = nodeProxy(MathNode, MathNode.DEGREES);
var exp = nodeProxy(MathNode, MathNode.EXP);
var exp2 = nodeProxy(MathNode, MathNode.EXP2);
var log = nodeProxy(MathNode, MathNode.LOG);
var log2 = nodeProxy(MathNode, MathNode.LOG2);
var sqrt = nodeProxy(MathNode, MathNode.SQRT);
var inverseSqrt = nodeProxy(MathNode, MathNode.INVERSE_SQRT);
var floor = nodeProxy(MathNode, MathNode.FLOOR);
var ceil = nodeProxy(MathNode, MathNode.CEIL);
var normalize = nodeProxy(MathNode, MathNode.NORMALIZE);
var fract = nodeProxy(MathNode, MathNode.FRACT);
var sin = nodeProxy(MathNode, MathNode.SIN);
var cos = nodeProxy(MathNode, MathNode.COS);
var tan = nodeProxy(MathNode, MathNode.TAN);
var asin = nodeProxy(MathNode, MathNode.ASIN);
var acos = nodeProxy(MathNode, MathNode.ACOS);
var atan = nodeProxy(MathNode, MathNode.ATAN);
var abs = nodeProxy(MathNode, MathNode.ABS);
var sign = nodeProxy(MathNode, MathNode.SIGN);
var length = nodeProxy(MathNode, MathNode.LENGTH);
var negate = nodeProxy(MathNode, MathNode.NEGATE);
var oneMinus = nodeProxy(MathNode, MathNode.ONE_MINUS);
var dFdx = nodeProxy(MathNode, MathNode.DFDX);
var dFdy = nodeProxy(MathNode, MathNode.DFDY);
var round = nodeProxy(MathNode, MathNode.ROUND);
var reciprocal = nodeProxy(MathNode, MathNode.RECIPROCAL);
var trunc = nodeProxy(MathNode, MathNode.TRUNC);
var fwidth = nodeProxy(MathNode, MathNode.FWIDTH);
var bitcast = nodeProxy(MathNode, MathNode.BITCAST);
var atan2 = nodeProxy(MathNode, MathNode.ATAN2);
var min = nodeProxy(MathNode, MathNode.MIN);
var max = nodeProxy(MathNode, MathNode.MAX);
var mod = nodeProxy(MathNode, MathNode.MOD);
var step = nodeProxy(MathNode, MathNode.STEP);
var reflect = nodeProxy(MathNode, MathNode.REFLECT);
var distance = nodeProxy(MathNode, MathNode.DISTANCE);
var difference = nodeProxy(MathNode, MathNode.DIFFERENCE);
var dot = nodeProxy(MathNode, MathNode.DOT);
var cross = nodeProxy(MathNode, MathNode.CROSS);
var pow = nodeProxy(MathNode, MathNode.POW);
var pow2 = nodeProxy(MathNode, MathNode.POW, 2);
var pow3 = nodeProxy(MathNode, MathNode.POW, 3);
var pow4 = nodeProxy(MathNode, MathNode.POW, 4);
var transformDirection = nodeProxy(MathNode, MathNode.TRANSFORM_DIRECTION);
var cbrt = (a) => mul(sign(a), pow(abs(a), 1 / 3));
var lengthSq = (a) => dot(a, a);
var mix = nodeProxy(MathNode, MathNode.MIX);
var clamp = (value, low = 0, high = 1) => nodeObject(new MathNode(MathNode.CLAMP, nodeObject(value), nodeObject(low), nodeObject(high)));
var saturate = (value) => clamp(value);
var refract = nodeProxy(MathNode, MathNode.REFRACT);
var smoothstep = nodeProxy(MathNode, MathNode.SMOOTHSTEP);
var faceForward = nodeProxy(MathNode, MathNode.FACEFORWARD);
var mixElement = (t, e1, e2) => mix(e1, e2, t);
var smoothstepElement = (x, low, high) => smoothstep(low, high, x);
addNodeElement("all", all);
addNodeElement("any", any);
addNodeElement("equals", equals);
addNodeElement("radians", radians);
addNodeElement("degrees", degrees);
addNodeElement("exp", exp);
addNodeElement("exp2", exp2);
addNodeElement("log", log);
addNodeElement("log2", log2);
addNodeElement("sqrt", sqrt);
addNodeElement("inverseSqrt", inverseSqrt);
addNodeElement("floor", floor);
addNodeElement("ceil", ceil);
addNodeElement("normalize", normalize);
addNodeElement("fract", fract);
addNodeElement("sin", sin);
addNodeElement("cos", cos);
addNodeElement("tan", tan);
addNodeElement("asin", asin);
addNodeElement("acos", acos);
addNodeElement("atan", atan);
addNodeElement("abs", abs);
addNodeElement("sign", sign);
addNodeElement("length", length);
addNodeElement("lengthSq", lengthSq);
addNodeElement("negate", negate);
addNodeElement("oneMinus", oneMinus);
addNodeElement("dFdx", dFdx);
addNodeElement("dFdy", dFdy);
addNodeElement("round", round);
addNodeElement("reciprocal", reciprocal);
addNodeElement("trunc", trunc);
addNodeElement("fwidth", fwidth);
addNodeElement("atan2", atan2);
addNodeElement("min", min);
addNodeElement("max", max);
addNodeElement("mod", mod);
addNodeElement("step", step);
addNodeElement("reflect", reflect);
addNodeElement("distance", distance);
addNodeElement("dot", dot);
addNodeElement("cross", cross);
addNodeElement("pow", pow);
addNodeElement("pow2", pow2);
addNodeElement("pow3", pow3);
addNodeElement("pow4", pow4);
addNodeElement("transformDirection", transformDirection);
addNodeElement("mix", mixElement);
addNodeElement("clamp", clamp);
addNodeElement("refract", refract);
addNodeElement("smoothstep", smoothstepElement);
addNodeElement("faceForward", faceForward);
addNodeElement("difference", difference);
addNodeElement("saturate", saturate);
addNodeElement("cbrt", cbrt);
addNodeClass("MathNode", MathNode);

// node_modules/three/examples/jsm/nodes/display/ColorSpaceNode.js
var sRGBToLinearShader = tslFn((inputs) => {
  const { value } = inputs;
  const { rgb } = value;
  const a = rgb.mul(0.9478672986).add(0.0521327014).pow(2.4);
  const b = rgb.mul(0.0773993808);
  const factor = rgb.lessThanEqual(0.04045);
  const rgbResult = mix(a, b, factor);
  return vec4(rgbResult, value.a);
});
var LinearTosRGBShader = tslFn((inputs) => {
  const { value } = inputs;
  const { rgb } = value;
  const a = rgb.pow(0.41666).mul(1.055).sub(0.055);
  const b = rgb.mul(12.92);
  const factor = rgb.lessThanEqual(31308e-7);
  const rgbResult = mix(a, b, factor);
  return vec4(rgbResult, value.a);
});
var getColorSpaceMethod = (colorSpace) => {
  let method = null;
  if (colorSpace === LinearSRGBColorSpace) {
    method = "Linear";
  } else if (colorSpace === SRGBColorSpace) {
    method = "sRGB";
  }
  return method;
};
var getMethod = (source, target) => {
  return getColorSpaceMethod(source) + "To" + getColorSpaceMethod(target);
};
var ColorSpaceNode = class _ColorSpaceNode extends TempNode_default {
  constructor(method, node) {
    super("vec4");
    this.method = method;
    this.node = node;
  }
  setup() {
    const { method, node } = this;
    if (method === _ColorSpaceNode.LINEAR_TO_LINEAR)
      return node;
    return Methods[method]({ value: node });
  }
};
ColorSpaceNode.LINEAR_TO_LINEAR = "LinearToLinear";
ColorSpaceNode.LINEAR_TO_sRGB = "LinearTosRGB";
ColorSpaceNode.sRGB_TO_LINEAR = "sRGBToLinear";
var Methods = {
  [ColorSpaceNode.LINEAR_TO_sRGB]: LinearTosRGBShader,
  [ColorSpaceNode.sRGB_TO_LINEAR]: sRGBToLinearShader
};
var ColorSpaceNode_default = ColorSpaceNode;
var linearToColorSpace = (node, colorSpace) => nodeObject(new ColorSpaceNode(getMethod(LinearSRGBColorSpace, colorSpace), nodeObject(node)));
var colorSpaceToLinear = (node, colorSpace) => nodeObject(new ColorSpaceNode(getMethod(colorSpace, LinearSRGBColorSpace), nodeObject(node)));
var linearTosRGB = nodeProxy(ColorSpaceNode, ColorSpaceNode.LINEAR_TO_sRGB);
var sRGBToLinear = nodeProxy(ColorSpaceNode, ColorSpaceNode.sRGB_TO_LINEAR);
addNodeElement("linearTosRGB", linearTosRGB);
addNodeElement("sRGBToLinear", sRGBToLinear);
addNodeElement("linearToColorSpace", linearToColorSpace);
addNodeElement("colorSpaceToLinear", colorSpaceToLinear);
addNodeClass("ColorSpaceNode", ColorSpaceNode);

// node_modules/three/examples/jsm/nodes/code/ExpressionNode.js
var ExpressionNode = class extends Node_default {
  constructor(snippet = "", nodeType = "void") {
    super(nodeType);
    this.snippet = snippet;
  }
  generate(builder, output2) {
    const type = this.getNodeType(builder);
    const snippet = this.snippet;
    if (type === "void") {
      builder.addLineFlowCode(snippet);
    } else {
      return builder.format(`( ${snippet} )`, type, output2);
    }
  }
};
var ExpressionNode_default = ExpressionNode;
var expression = nodeProxy(ExpressionNode);
addNodeClass("ExpressionNode", ExpressionNode);

// node_modules/three/examples/jsm/nodes/utils/MaxMipLevelNode.js
var MaxMipLevelNode = class extends UniformNode_default {
  constructor(textureNode) {
    super(0);
    this.textureNode = textureNode;
    this.updateType = NodeUpdateType.FRAME;
  }
  get texture() {
    return this.textureNode.value;
  }
  update() {
    const texture2 = this.texture;
    const images = texture2.images;
    const image = images && images.length > 0 ? images[0] && images[0].image || images[0] : texture2.image;
    if (image && image.width !== void 0) {
      const { width, height } = image;
      this.value = Math.log2(Math.max(width, height));
    }
  }
};
var MaxMipLevelNode_default = MaxMipLevelNode;
var maxMipLevel = nodeProxy(MaxMipLevelNode);
addNodeClass("MaxMipLevelNode", MaxMipLevelNode);

// node_modules/three/examples/jsm/nodes/accessors/TextureNode.js
var TextureNode = class extends UniformNode_default {
  constructor(value, uvNode = null, levelNode = null) {
    super(value);
    this.isTextureNode = true;
    this.uvNode = uvNode;
    this.levelNode = levelNode;
    this.compareNode = null;
    this.depthNode = null;
    this.gradNode = null;
    this.sampler = true;
    this.updateMatrix = false;
    this.updateType = NodeUpdateType.NONE;
    this.referenceNode = null;
    this._value = value;
    this.setUpdateMatrix(uvNode === null);
  }
  set value(value) {
    if (this.referenceNode) {
      this.referenceNode.value = value;
    } else {
      this._value = value;
    }
  }
  get value() {
    return this.referenceNode ? this.referenceNode.value : this._value;
  }
  getUniformHash() {
    return this.value.uuid;
  }
  getNodeType() {
    if (this.value.isDepthTexture === true)
      return "float";
    return "vec4";
  }
  getInputType() {
    return "texture";
  }
  getDefaultUV() {
    return uv(this.value.channel);
  }
  updateReference() {
    return this.value;
  }
  getTransformedUV(uvNode) {
    const texture2 = this.value;
    return uniform(texture2.matrix).mul(vec3(uvNode, 1)).xy;
  }
  setUpdateMatrix(value) {
    this.updateMatrix = value;
    this.updateType = value ? NodeUpdateType.FRAME : NodeUpdateType.NONE;
    return this;
  }
  setupUV(builder, uvNode) {
    const texture2 = this.value;
    if (builder.isFlipY() && (texture2.isRenderTargetTexture === true || texture2.isFramebufferTexture === true || texture2.isDepthTexture === true)) {
      uvNode = uvNode.setY(uvNode.y.oneMinus());
    }
    return uvNode;
  }
  setup(builder) {
    const properties = builder.getNodeProperties(this);
    let uvNode = this.uvNode;
    if ((uvNode === null || builder.context.forceUVContext === true) && builder.context.getUV) {
      uvNode = builder.context.getUV(this);
    }
    if (!uvNode)
      uvNode = this.getDefaultUV();
    if (this.updateMatrix === true) {
      uvNode = this.getTransformedUV(uvNode);
    }
    uvNode = this.setupUV(builder, uvNode);
    let levelNode = this.levelNode;
    if (levelNode === null && builder.context.getTextureLevel) {
      levelNode = builder.context.getTextureLevel(this);
    }
    properties.uvNode = uvNode;
    properties.levelNode = levelNode;
    properties.compareNode = this.compareNode;
    properties.gradNode = this.gradNode;
    properties.depthNode = this.depthNode;
  }
  generateUV(builder, uvNode) {
    return uvNode.build(builder, this.sampler === true ? "vec2" : "ivec2");
  }
  generateSnippet(builder, textureProperty, uvSnippet, levelSnippet, depthSnippet, compareSnippet, gradSnippet) {
    const texture2 = this.value;
    let snippet;
    if (levelSnippet) {
      snippet = builder.generateTextureLevel(texture2, textureProperty, uvSnippet, levelSnippet, depthSnippet);
    } else if (gradSnippet) {
      snippet = builder.generateTextureGrad(texture2, textureProperty, uvSnippet, gradSnippet, depthSnippet);
    } else if (compareSnippet) {
      snippet = builder.generateTextureCompare(texture2, textureProperty, uvSnippet, compareSnippet, depthSnippet);
    } else if (this.sampler === false) {
      snippet = builder.generateTextureLoad(texture2, textureProperty, uvSnippet, depthSnippet);
    } else {
      snippet = builder.generateTexture(texture2, textureProperty, uvSnippet, depthSnippet);
    }
    return snippet;
  }
  generate(builder, output2) {
    const properties = builder.getNodeProperties(this);
    const texture2 = this.value;
    if (!texture2 || texture2.isTexture !== true) {
      throw new Error("TextureNode: Need a three.js texture.");
    }
    const textureProperty = super.generate(builder, "property");
    if (output2 === "sampler") {
      return textureProperty + "_sampler";
    } else if (builder.isReference(output2)) {
      return textureProperty;
    } else {
      const nodeData = builder.getDataFromNode(this);
      let propertyName = nodeData.propertyName;
      if (propertyName === void 0) {
        const { uvNode, levelNode, compareNode, depthNode, gradNode } = properties;
        const uvSnippet = this.generateUV(builder, uvNode);
        const levelSnippet = levelNode ? levelNode.build(builder, "float") : null;
        const depthSnippet = depthNode ? depthNode.build(builder, "int") : null;
        const compareSnippet = compareNode ? compareNode.build(builder, "float") : null;
        const gradSnippet = gradNode ? [gradNode[0].build(builder, "vec2"), gradNode[1].build(builder, "vec2")] : null;
        const nodeVar = builder.getVarFromNode(this);
        propertyName = builder.getPropertyName(nodeVar);
        const snippet2 = this.generateSnippet(builder, textureProperty, uvSnippet, levelSnippet, depthSnippet, compareSnippet, gradSnippet);
        builder.addLineFlowCode(`${propertyName} = ${snippet2}`);
        if (builder.context.tempWrite !== false) {
          nodeData.snippet = snippet2;
          nodeData.propertyName = propertyName;
        }
      }
      let snippet = propertyName;
      const nodeType = this.getNodeType(builder);
      if (builder.needsColorSpaceToLinear(texture2)) {
        snippet = colorSpaceToLinear(expression(snippet, nodeType), texture2.colorSpace).setup(builder).build(builder, nodeType);
      }
      return builder.format(snippet, nodeType, output2);
    }
  }
  setSampler(value) {
    this.sampler = value;
    return this;
  }
  getSampler() {
    return this.sampler;
  }
  // @TODO: Move to TSL
  uv(uvNode) {
    const textureNode = this.clone();
    textureNode.uvNode = uvNode;
    textureNode.referenceNode = this;
    return nodeObject(textureNode);
  }
  blur(levelNode) {
    const textureNode = this.clone();
    textureNode.levelNode = levelNode.mul(maxMipLevel(textureNode));
    textureNode.referenceNode = this;
    return nodeObject(textureNode);
  }
  level(levelNode) {
    const textureNode = this.clone();
    textureNode.levelNode = levelNode;
    textureNode.referenceNode = this;
    return textureNode;
  }
  size(levelNode) {
    return textureSize(this, levelNode);
  }
  compare(compareNode) {
    const textureNode = this.clone();
    textureNode.compareNode = nodeObject(compareNode);
    textureNode.referenceNode = this;
    return nodeObject(textureNode);
  }
  grad(gradNodeX, gradNodeY) {
    const textureNode = this.clone();
    textureNode.gradNode = [nodeObject(gradNodeX), nodeObject(gradNodeY)];
    textureNode.referenceNode = this;
    return nodeObject(textureNode);
  }
  depth(depthNode) {
    const textureNode = this.clone();
    textureNode.depthNode = nodeObject(depthNode);
    textureNode.referenceNode = this;
    return nodeObject(textureNode);
  }
  // --
  serialize(data) {
    super.serialize(data);
    data.value = this.value.toJSON(data.meta).uuid;
  }
  deserialize(data) {
    super.deserialize(data);
    this.value = data.meta.textures[data.value];
  }
  update() {
    const texture2 = this.value;
    if (texture2.matrixAutoUpdate === true) {
      texture2.updateMatrix();
    }
  }
  clone() {
    const newNode = new this.constructor(this.value, this.uvNode, this.levelNode);
    newNode.sampler = this.sampler;
    return newNode;
  }
};
var TextureNode_default = TextureNode;
var texture = nodeProxy(TextureNode);
var textureLoad = (...params) => texture(...params).setSampler(false);
var sampler = (aTexture) => (aTexture.isNode === true ? aTexture : texture(aTexture)).convert("sampler");
addNodeElement("texture", texture);
addNodeClass("TextureNode", TextureNode);

// node_modules/three/examples/jsm/nodes/accessors/BufferNode.js
var BufferNode = class extends UniformNode_default {
  constructor(value, bufferType, bufferCount = 0) {
    super(value, bufferType);
    this.isBufferNode = true;
    this.bufferType = bufferType;
    this.bufferCount = bufferCount;
  }
  getElementType(builder) {
    return this.getNodeType(builder);
  }
  getInputType() {
    return "buffer";
  }
};
var BufferNode_default = BufferNode;
var buffer = (value, type, count) => nodeObject(new BufferNode(value, type, count));
addNodeClass("BufferNode", BufferNode);

// node_modules/three/examples/jsm/nodes/accessors/UniformsNode.js
var UniformsElementNode = class extends ArrayElementNode_default {
  constructor(arrayBuffer2, indexNode) {
    super(arrayBuffer2, indexNode);
    this.isArrayBufferElementNode = true;
  }
  getNodeType(builder) {
    return this.node.getElementType(builder);
  }
  generate(builder) {
    const snippet = super.generate(builder);
    const type = this.getNodeType();
    return builder.format(snippet, "vec4", type);
  }
};
var UniformsNode = class extends BufferNode_default {
  constructor(value, elementType = null) {
    super(null, "vec4");
    this.array = value;
    this.elementType = elementType;
    this._elementType = null;
    this._elementLength = 0;
    this.updateType = NodeUpdateType.RENDER;
    this.isArrayBufferNode = true;
  }
  getElementType() {
    return this.elementType || this._elementType;
  }
  getElementLength() {
    return this._elementLength;
  }
  update() {
    const { array, value } = this;
    const elementLength = this.getElementLength();
    const elementType = this.getElementType();
    if (elementLength === 1) {
      for (let i = 0; i < array.length; i++) {
        const index = i * 4;
        value[index] = array[i];
      }
    } else if (elementType === "color") {
      for (let i = 0; i < array.length; i++) {
        const index = i * 4;
        const vector = array[i];
        value[index] = vector.r;
        value[index + 1] = vector.g;
        value[index + 2] = vector.b || 0;
      }
    } else {
      for (let i = 0; i < array.length; i++) {
        const index = i * 4;
        const vector = array[i];
        value[index] = vector.x;
        value[index + 1] = vector.y;
        value[index + 2] = vector.z || 0;
        value[index + 3] = vector.w || 0;
      }
    }
  }
  setup(builder) {
    const length2 = this.array.length;
    this._elementType = this.elementType === null ? getValueType(this.array[0]) : this.elementType;
    this._elementLength = builder.getTypeLength(this._elementType);
    this.value = new Float32Array(length2 * 4);
    this.bufferCount = length2;
    return super.setup(builder);
  }
  element(indexNode) {
    return nodeObject(new UniformsElementNode(this, nodeObject(indexNode)));
  }
};
var UniformsNode_default = UniformsNode;
var uniforms = (values, nodeType) => nodeObject(new UniformsNode(values, nodeType));
addNodeClass("UniformsNode", UniformsNode);

// node_modules/three/examples/jsm/nodes/accessors/ReferenceNode.js
var ReferenceElementNode = class extends ArrayElementNode_default {
  constructor(referenceNode, indexNode) {
    super(referenceNode, indexNode);
    this.referenceNode = referenceNode;
    this.isReferenceElementNode = true;
  }
  getNodeType() {
    return this.referenceNode.uniformType;
  }
  generate(builder) {
    const snippet = super.generate(builder);
    const arrayType = this.referenceNode.getNodeType();
    const elementType = this.getNodeType();
    return builder.format(snippet, arrayType, elementType);
  }
};
var ReferenceNode = class extends Node_default {
  constructor(property2, uniformType, object = null, count = null) {
    super();
    this.property = property2;
    this.uniformType = uniformType;
    this.object = object;
    this.count = count;
    this.properties = property2.split(".");
    this.reference = null;
    this.node = null;
    this.updateType = NodeUpdateType.OBJECT;
  }
  element(indexNode) {
    return nodeObject(new ReferenceElementNode(this, nodeObject(indexNode)));
  }
  setNodeType(uniformType) {
    let node = null;
    if (this.count !== null) {
      node = buffer(null, uniformType, this.count);
    } else if (Array.isArray(this.getValueFromReference())) {
      node = uniforms(null, uniformType);
    } else if (uniformType === "texture") {
      node = texture(null);
    } else {
      node = uniform(null, uniformType);
    }
    this.node = node;
  }
  getNodeType(builder) {
    if (this.node === null) {
      this.updateValue();
    }
    return this.node.getNodeType(builder);
  }
  getValueFromReference(object = this.reference) {
    const { properties } = this;
    let value = object[properties[0]];
    for (let i = 1; i < properties.length; i++) {
      value = value[properties[i]];
    }
    return value;
  }
  updateReference(state) {
    this.reference = this.object !== null ? this.object : state.object;
    return this.reference;
  }
  setup() {
    this.updateValue();
    return this.node;
  }
  update() {
    this.updateValue();
  }
  updateValue() {
    if (this.node === null)
      this.setNodeType(this.uniformType);
    const value = this.getValueFromReference();
    if (Array.isArray(value)) {
      this.node.array = value;
    } else {
      this.node.value = value;
    }
  }
};
var ReferenceNode_default = ReferenceNode;
var reference = (name, type, object) => nodeObject(new ReferenceNode(name, type, object));
var referenceBuffer = (name, type, count, object) => nodeObject(new ReferenceNode(name, type, object, count));
addNodeClass("ReferenceNode", ReferenceNode);

// node_modules/three/examples/jsm/nodes/accessors/MaterialReferenceNode.js
var MaterialReferenceNode = class extends ReferenceNode_default {
  constructor(property2, inputType, material = null) {
    super(property2, inputType, material);
    this.material = material;
  }
  /*setNodeType( node ) {
  
  		super.setNodeType( node );
  
  		this.node.groupNode = renderGroup;
  
  	}*/
  updateReference(state) {
    this.reference = this.material !== null ? this.material : state.material;
    return this.reference;
  }
};
var MaterialReferenceNode_default = MaterialReferenceNode;
var materialReference = (name, type, material) => nodeObject(new MaterialReferenceNode(name, type, material));
addNodeClass("MaterialReferenceNode", MaterialReferenceNode);

// node_modules/three/examples/jsm/nodes/accessors/CameraNode.js
var cameraNear = uniform("float").onRenderUpdate(({ camera }) => camera.near);
var cameraFar = uniform("float").onRenderUpdate(({ camera }) => camera.far);
var cameraLogDepth = uniform("float").onRenderUpdate(({ camera }) => 2 / (Math.log(camera.far + 1) / Math.LN2));
var cameraProjectionMatrix = uniform("mat4").onRenderUpdate(({ camera }) => camera.projectionMatrix);
var cameraProjectionMatrixInverse = uniform("mat4").onRenderUpdate(({ camera }) => camera.projectionMatrixInverse);
var cameraViewMatrix = uniform("mat4").onRenderUpdate(({ camera }) => camera.matrixWorldInverse);
var cameraWorldMatrix = uniform("mat4").onRenderUpdate(({ camera }) => camera.matrixWorld);
var cameraNormalMatrix = uniform("mat3").onRenderUpdate(({ camera }) => camera.normalMatrix);
var cameraPosition = uniform(new Vector3()).onRenderUpdate(({ camera }, self) => self.value.setFromMatrixPosition(camera.matrixWorld));

// node_modules/three/examples/jsm/nodes/accessors/Object3DNode.js
var Object3DNode = class _Object3DNode extends Node_default {
  constructor(scope = _Object3DNode.VIEW_MATRIX, object3d = null) {
    super();
    this.scope = scope;
    this.object3d = object3d;
    this.updateType = NodeUpdateType.OBJECT;
    this._uniformNode = new UniformNode_default(null);
  }
  getNodeType() {
    const scope = this.scope;
    if (scope === _Object3DNode.WORLD_MATRIX || scope === _Object3DNode.VIEW_MATRIX) {
      return "mat4";
    } else if (scope === _Object3DNode.NORMAL_MATRIX) {
      return "mat3";
    } else if (scope === _Object3DNode.POSITION || scope === _Object3DNode.VIEW_POSITION || scope === _Object3DNode.DIRECTION || scope === _Object3DNode.SCALE) {
      return "vec3";
    }
  }
  update(frame) {
    const object = this.object3d;
    const uniformNode = this._uniformNode;
    const scope = this.scope;
    if (scope === _Object3DNode.VIEW_MATRIX) {
      uniformNode.value = object.modelViewMatrix;
    } else if (scope === _Object3DNode.NORMAL_MATRIX) {
      uniformNode.value = object.normalMatrix;
    } else if (scope === _Object3DNode.WORLD_MATRIX) {
      uniformNode.value = object.matrixWorld;
    } else if (scope === _Object3DNode.POSITION) {
      uniformNode.value = uniformNode.value || new Vector3();
      uniformNode.value.setFromMatrixPosition(object.matrixWorld);
    } else if (scope === _Object3DNode.SCALE) {
      uniformNode.value = uniformNode.value || new Vector3();
      uniformNode.value.setFromMatrixScale(object.matrixWorld);
    } else if (scope === _Object3DNode.DIRECTION) {
      uniformNode.value = uniformNode.value || new Vector3();
      object.getWorldDirection(uniformNode.value);
    } else if (scope === _Object3DNode.VIEW_POSITION) {
      const camera = frame.camera;
      uniformNode.value = uniformNode.value || new Vector3();
      uniformNode.value.setFromMatrixPosition(object.matrixWorld);
      uniformNode.value.applyMatrix4(camera.matrixWorldInverse);
    }
  }
  generate(builder) {
    const scope = this.scope;
    if (scope === _Object3DNode.WORLD_MATRIX || scope === _Object3DNode.VIEW_MATRIX) {
      this._uniformNode.nodeType = "mat4";
    } else if (scope === _Object3DNode.NORMAL_MATRIX) {
      this._uniformNode.nodeType = "mat3";
    } else if (scope === _Object3DNode.POSITION || scope === _Object3DNode.VIEW_POSITION || scope === _Object3DNode.DIRECTION || scope === _Object3DNode.SCALE) {
      this._uniformNode.nodeType = "vec3";
    }
    return this._uniformNode.build(builder);
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
Object3DNode.VIEW_MATRIX = "viewMatrix";
Object3DNode.NORMAL_MATRIX = "normalMatrix";
Object3DNode.WORLD_MATRIX = "worldMatrix";
Object3DNode.POSITION = "position";
Object3DNode.SCALE = "scale";
Object3DNode.VIEW_POSITION = "viewPosition";
Object3DNode.DIRECTION = "direction";
var Object3DNode_default = Object3DNode;
var objectDirection = nodeProxy(Object3DNode, Object3DNode.DIRECTION);
var objectViewMatrix = nodeProxy(Object3DNode, Object3DNode.VIEW_MATRIX);
var objectNormalMatrix = nodeProxy(Object3DNode, Object3DNode.NORMAL_MATRIX);
var objectWorldMatrix = nodeProxy(Object3DNode, Object3DNode.WORLD_MATRIX);
var objectPosition = nodeProxy(Object3DNode, Object3DNode.POSITION);
var objectScale = nodeProxy(Object3DNode, Object3DNode.SCALE);
var objectViewPosition = nodeProxy(Object3DNode, Object3DNode.VIEW_POSITION);
addNodeClass("Object3DNode", Object3DNode);

// node_modules/three/examples/jsm/nodes/accessors/ModelNode.js
var ModelNode = class _ModelNode extends Object3DNode_default {
  constructor(scope = _ModelNode.VIEW_MATRIX) {
    super(scope);
  }
  update(frame) {
    this.object3d = frame.object;
    super.update(frame);
  }
};
var ModelNode_default = ModelNode;
var modelDirection = nodeImmutable(ModelNode, ModelNode.DIRECTION);
var modelViewMatrix = nodeImmutable(ModelNode, ModelNode.VIEW_MATRIX).label("modelViewMatrix").temp("ModelViewMatrix");
var modelNormalMatrix = nodeImmutable(ModelNode, ModelNode.NORMAL_MATRIX);
var modelWorldMatrix = nodeImmutable(ModelNode, ModelNode.WORLD_MATRIX);
var modelPosition = nodeImmutable(ModelNode, ModelNode.POSITION);
var modelScale = nodeImmutable(ModelNode, ModelNode.SCALE);
var modelViewPosition = nodeImmutable(ModelNode, ModelNode.VIEW_POSITION);
var modelWorldMatrixInverse = uniform(new Matrix4()).onObjectUpdate(({ object }, self) => self.value.copy(object.matrixWorld).invert());
addNodeClass("ModelNode", ModelNode);

// node_modules/three/examples/jsm/nodes/accessors/NormalNode.js
var normalGeometry = attribute("normal", "vec3", vec3(0, 1, 0));
var normalLocal = normalGeometry.toVar("normalLocal");
var normalView = varying(modelNormalMatrix.mul(normalLocal), "v_normalView").normalize().toVar("normalView");
var normalWorld = varying(normalView.transformDirection(cameraViewMatrix), "v_normalWorld").normalize().toVar("transformedNormalWorld");
var transformedNormalView = property("vec3", "transformedNormalView");
var transformedNormalWorld = transformedNormalView.transformDirection(cameraViewMatrix).normalize().toVar("transformedNormalWorld");
var transformedClearcoatNormalView = property("vec3", "transformedClearcoatNormalView");

// node_modules/three/examples/jsm/nodes/accessors/MaterialNode.js
var _propertyCache = /* @__PURE__ */ new Map();
var MaterialNode = class _MaterialNode extends Node_default {
  constructor(scope) {
    super();
    this.scope = scope;
  }
  getCache(property2, type) {
    let node = _propertyCache.get(property2);
    if (node === void 0) {
      node = materialReference(property2, type);
      _propertyCache.set(property2, node);
    }
    return node;
  }
  getFloat(property2) {
    return this.getCache(property2, "float");
  }
  getColor(property2) {
    return this.getCache(property2, "color");
  }
  getTexture(property2) {
    return this.getCache(property2 === "map" ? "map" : property2 + "Map", "texture");
  }
  setup(builder) {
    const material = builder.context.material;
    const scope = this.scope;
    let node = null;
    if (scope === _MaterialNode.COLOR) {
      const colorNode = this.getColor(scope);
      if (material.map && material.map.isTexture === true) {
        node = colorNode.mul(this.getTexture("map"));
      } else {
        node = colorNode;
      }
    } else if (scope === _MaterialNode.OPACITY) {
      const opacityNode = this.getFloat(scope);
      if (material.alphaMap && material.alphaMap.isTexture === true) {
        node = opacityNode.mul(this.getTexture("alpha"));
      } else {
        node = opacityNode;
      }
    } else if (scope === _MaterialNode.SPECULAR_STRENGTH) {
      if (material.specularMap && material.specularMap.isTexture === true) {
        node = this.getTexture("specular").r;
      } else {
        node = float(1);
      }
    } else if (scope === _MaterialNode.SPECULAR_INTENSITY) {
      const specularIntensity = this.getFloat(scope);
      if (material.specularMap) {
        node = specularIntensity.mul(this.getTexture(scope).a);
      } else {
        node = specularIntensity;
      }
    } else if (scope === _MaterialNode.SPECULAR_COLOR) {
      const specularColorNode = this.getColor(scope);
      if (material.specularColorMap && material.specularColorMap.isTexture === true) {
        node = specularColorNode.mul(this.getTexture(scope).rgb);
      } else {
        node = specularColorNode;
      }
    } else if (scope === _MaterialNode.ROUGHNESS) {
      const roughnessNode = this.getFloat(scope);
      if (material.roughnessMap && material.roughnessMap.isTexture === true) {
        node = roughnessNode.mul(this.getTexture(scope).g);
      } else {
        node = roughnessNode;
      }
    } else if (scope === _MaterialNode.METALNESS) {
      const metalnessNode = this.getFloat(scope);
      if (material.metalnessMap && material.metalnessMap.isTexture === true) {
        node = metalnessNode.mul(this.getTexture(scope).b);
      } else {
        node = metalnessNode;
      }
    } else if (scope === _MaterialNode.EMISSIVE) {
      const emissiveNode = this.getColor(scope);
      if (material.emissiveMap && material.emissiveMap.isTexture === true) {
        node = emissiveNode.mul(this.getTexture(scope));
      } else {
        node = emissiveNode;
      }
    } else if (scope === _MaterialNode.NORMAL) {
      if (material.normalMap) {
        node = this.getTexture("normal").normalMap(this.getCache("normalScale", "vec2"));
      } else if (material.bumpMap) {
        node = this.getTexture("bump").r.bumpMap(this.getFloat("bumpScale"));
      } else {
        node = normalView;
      }
    } else if (scope === _MaterialNode.CLEARCOAT) {
      const clearcoatNode = this.getFloat(scope);
      if (material.clearcoatMap && material.clearcoatMap.isTexture === true) {
        node = clearcoatNode.mul(this.getTexture(scope).r);
      } else {
        node = clearcoatNode;
      }
    } else if (scope === _MaterialNode.CLEARCOAT_ROUGHNESS) {
      const clearcoatRoughnessNode = this.getFloat(scope);
      if (material.clearcoatRoughnessMap && material.clearcoatRoughnessMap.isTexture === true) {
        node = clearcoatRoughnessNode.mul(this.getTexture(scope).r);
      } else {
        node = clearcoatRoughnessNode;
      }
    } else if (scope === _MaterialNode.CLEARCOAT_NORMAL) {
      if (material.clearcoatNormalMap) {
        node = this.getTexture(scope).normalMap(this.getCache(scope + "Scale", "vec2"));
      } else {
        node = normalView;
      }
    } else if (scope === _MaterialNode.SHEEN) {
      const sheenNode = this.getColor("sheenColor").mul(this.getFloat("sheen"));
      if (material.sheenColorMap && material.sheenColorMap.isTexture === true) {
        node = sheenNode.mul(this.getTexture("sheenColor").rgb);
      } else {
        node = sheenNode;
      }
    } else if (scope === _MaterialNode.SHEEN_ROUGHNESS) {
      const sheenRoughnessNode = this.getFloat(scope);
      if (material.sheenRoughnessMap && material.sheenRoughnessMap.isTexture === true) {
        node = sheenRoughnessNode.mul(this.getTexture(scope).a);
      } else {
        node = sheenRoughnessNode;
      }
      node = node.clamp(0.07, 1);
    } else if (scope === _MaterialNode.ANISOTROPY) {
      if (material.anisotropyMap && material.anisotropyMap.isTexture === true) {
        const anisotropyPolar = this.getTexture(scope);
        const anisotropyMat = mat2(materialAnisotropyVector.x, materialAnisotropyVector.y, materialAnisotropyVector.y.negate(), materialAnisotropyVector.x);
        node = anisotropyMat.mul(anisotropyPolar.rg.mul(2).sub(vec2(1)).normalize().mul(anisotropyPolar.b));
      } else {
        node = materialAnisotropyVector;
      }
    } else if (scope === _MaterialNode.IRIDESCENCE_THICKNESS) {
      const iridescenceThicknessMaximum = reference("1", "float", material.iridescenceThicknessRange);
      if (material.iridescenceThicknessMap) {
        const iridescenceThicknessMinimum = reference("0", "float", material.iridescenceThicknessRange);
        node = iridescenceThicknessMaximum.sub(iridescenceThicknessMinimum).mul(this.getTexture(scope).g).add(iridescenceThicknessMinimum);
      } else {
        node = iridescenceThicknessMaximum;
      }
    } else if (scope === _MaterialNode.TRANSMISSION) {
      const transmissionNode = this.getFloat(scope);
      if (material.transmissionMap) {
        node = transmissionNode.mul(this.getTexture(scope).r);
      } else {
        node = transmissionNode;
      }
    } else if (scope === _MaterialNode.THICKNESS) {
      const thicknessNode = this.getFloat(scope);
      if (material.thicknessMap) {
        node = thicknessNode.mul(this.getTexture(scope).g);
      } else {
        node = thicknessNode;
      }
    } else if (scope === _MaterialNode.IOR) {
      node = this.getFloat(scope);
    } else {
      const outputType = this.getNodeType(builder);
      node = this.getCache(scope, outputType);
    }
    return node;
  }
};
MaterialNode.ALPHA_TEST = "alphaTest";
MaterialNode.COLOR = "color";
MaterialNode.OPACITY = "opacity";
MaterialNode.SHININESS = "shininess";
MaterialNode.SPECULAR = "specular";
MaterialNode.SPECULAR_STRENGTH = "specularStrength";
MaterialNode.SPECULAR_INTENSITY = "specularIntensity";
MaterialNode.SPECULAR_COLOR = "specularColor";
MaterialNode.REFLECTIVITY = "reflectivity";
MaterialNode.ROUGHNESS = "roughness";
MaterialNode.METALNESS = "metalness";
MaterialNode.NORMAL = "normal";
MaterialNode.CLEARCOAT = "clearcoat";
MaterialNode.CLEARCOAT_ROUGHNESS = "clearcoatRoughness";
MaterialNode.CLEARCOAT_NORMAL = "clearcoatNormal";
MaterialNode.EMISSIVE = "emissive";
MaterialNode.ROTATION = "rotation";
MaterialNode.SHEEN = "sheen";
MaterialNode.SHEEN_ROUGHNESS = "sheenRoughness";
MaterialNode.ANISOTROPY = "anisotropy";
MaterialNode.IRIDESCENCE = "iridescence";
MaterialNode.IRIDESCENCE_IOR = "iridescenceIOR";
MaterialNode.IRIDESCENCE_THICKNESS = "iridescenceThickness";
MaterialNode.IOR = "ior";
MaterialNode.TRANSMISSION = "transmission";
MaterialNode.THICKNESS = "thickness";
MaterialNode.ATTENUATION_DISTANCE = "attenuationDistance";
MaterialNode.ATTENUATION_COLOR = "attenuationColor";
MaterialNode.LINE_SCALE = "scale";
MaterialNode.LINE_DASH_SIZE = "dashSize";
MaterialNode.LINE_GAP_SIZE = "gapSize";
MaterialNode.LINE_WIDTH = "linewidth";
MaterialNode.LINE_DASH_OFFSET = "dashOffset";
MaterialNode.POINT_WIDTH = "pointWidth";
MaterialNode.DISPERSION = "dispersion";
var MaterialNode_default = MaterialNode;
var materialAlphaTest = nodeImmutable(MaterialNode, MaterialNode.ALPHA_TEST);
var materialColor = nodeImmutable(MaterialNode, MaterialNode.COLOR);
var materialShininess = nodeImmutable(MaterialNode, MaterialNode.SHININESS);
var materialEmissive = nodeImmutable(MaterialNode, MaterialNode.EMISSIVE);
var materialOpacity = nodeImmutable(MaterialNode, MaterialNode.OPACITY);
var materialSpecular = nodeImmutable(MaterialNode, MaterialNode.SPECULAR);
var materialSpecularIntensity = nodeImmutable(MaterialNode, MaterialNode.SPECULAR_INTENSITY);
var materialSpecularColor = nodeImmutable(MaterialNode, MaterialNode.SPECULAR_COLOR);
var materialSpecularStrength = nodeImmutable(MaterialNode, MaterialNode.SPECULAR_STRENGTH);
var materialReflectivity = nodeImmutable(MaterialNode, MaterialNode.REFLECTIVITY);
var materialRoughness = nodeImmutable(MaterialNode, MaterialNode.ROUGHNESS);
var materialMetalness = nodeImmutable(MaterialNode, MaterialNode.METALNESS);
var materialNormal = nodeImmutable(MaterialNode, MaterialNode.NORMAL);
var materialClearcoat = nodeImmutable(MaterialNode, MaterialNode.CLEARCOAT);
var materialClearcoatRoughness = nodeImmutable(MaterialNode, MaterialNode.CLEARCOAT_ROUGHNESS);
var materialClearcoatNormal = nodeImmutable(MaterialNode, MaterialNode.CLEARCOAT_NORMAL);
var materialRotation = nodeImmutable(MaterialNode, MaterialNode.ROTATION);
var materialSheen = nodeImmutable(MaterialNode, MaterialNode.SHEEN);
var materialSheenRoughness = nodeImmutable(MaterialNode, MaterialNode.SHEEN_ROUGHNESS);
var materialAnisotropy = nodeImmutable(MaterialNode, MaterialNode.ANISOTROPY);
var materialIridescence = nodeImmutable(MaterialNode, MaterialNode.IRIDESCENCE);
var materialIridescenceIOR = nodeImmutable(MaterialNode, MaterialNode.IRIDESCENCE_IOR);
var materialIridescenceThickness = nodeImmutable(MaterialNode, MaterialNode.IRIDESCENCE_THICKNESS);
var materialTransmission = nodeImmutable(MaterialNode, MaterialNode.TRANSMISSION);
var materialThickness = nodeImmutable(MaterialNode, MaterialNode.THICKNESS);
var materialIOR = nodeImmutable(MaterialNode, MaterialNode.IOR);
var materialAttenuationDistance = nodeImmutable(MaterialNode, MaterialNode.ATTENUATION_DISTANCE);
var materialAttenuationColor = nodeImmutable(MaterialNode, MaterialNode.ATTENUATION_COLOR);
var materialLineScale = nodeImmutable(MaterialNode, MaterialNode.LINE_SCALE);
var materialLineDashSize = nodeImmutable(MaterialNode, MaterialNode.LINE_DASH_SIZE);
var materialLineGapSize = nodeImmutable(MaterialNode, MaterialNode.LINE_GAP_SIZE);
var materialLineWidth = nodeImmutable(MaterialNode, MaterialNode.LINE_WIDTH);
var materialLineDashOffset = nodeImmutable(MaterialNode, MaterialNode.LINE_DASH_OFFSET);
var materialPointWidth = nodeImmutable(MaterialNode, MaterialNode.POINT_WIDTH);
var materialDispersion = nodeImmutable(MaterialNode, MaterialNode.DISPERSION);
var materialAnisotropyVector = uniform(new Vector2()).onReference(function(frame) {
  return frame.material;
}).onRenderUpdate(function({ material }) {
  this.value.set(material.anisotropy * Math.cos(material.anisotropyRotation), material.anisotropy * Math.sin(material.anisotropyRotation));
});
addNodeClass("MaterialNode", MaterialNode);

// node_modules/three/examples/jsm/nodes/accessors/PositionNode.js
var positionGeometry = attribute("position", "vec3");
var positionLocal = positionGeometry.toVar("positionLocal");
var positionWorld = varying(modelWorldMatrix.mul(positionLocal).xyz, "v_positionWorld");
var positionWorldDirection = varying(positionLocal.transformDirection(modelWorldMatrix), "v_positionWorldDirection").normalize().toVar("positionWorldDirection");
var positionView = varying(modelViewMatrix.mul(positionLocal).xyz, "v_positionView");
var positionViewDirection = varying(positionView.negate(), "v_positionViewDirection").normalize().toVar("positionViewDirection");

// node_modules/three/examples/jsm/nodes/accessors/ModelViewProjectionNode.js
var ModelViewProjectionNode = class extends TempNode_default {
  constructor(positionNode = null) {
    super("vec4");
    this.positionNode = positionNode;
  }
  setup(builder) {
    if (builder.shaderStage === "fragment") {
      return varying(builder.context.mvp);
    }
    const position = this.positionNode || positionLocal;
    return cameraProjectionMatrix.mul(modelViewMatrix).mul(position);
  }
};
var ModelViewProjectionNode_default = ModelViewProjectionNode;
var modelViewProjection = nodeProxy(ModelViewProjectionNode);
addNodeClass("ModelViewProjectionNode", ModelViewProjectionNode);

// node_modules/three/examples/jsm/nodes/accessors/BufferAttributeNode.js
var BufferAttributeNode = class extends InputNode_default {
  constructor(value, bufferType = null, bufferStride = 0, bufferOffset = 0) {
    super(value, bufferType);
    this.isBufferNode = true;
    this.bufferType = bufferType;
    this.bufferStride = bufferStride;
    this.bufferOffset = bufferOffset;
    this.usage = StaticDrawUsage;
    this.instanced = false;
    this.attribute = null;
    if (value && value.isBufferAttribute === true) {
      this.attribute = value;
      this.usage = value.usage;
      this.instanced = value.isInstancedBufferAttribute;
    }
  }
  getNodeType(builder) {
    if (this.bufferType === null) {
      this.bufferType = builder.getTypeFromAttribute(this.attribute);
    }
    return this.bufferType;
  }
  setup(builder) {
    if (this.attribute !== null)
      return;
    const type = this.getNodeType(builder);
    const array = this.value;
    const itemSize = builder.getTypeLength(type);
    const stride = this.bufferStride || itemSize;
    const offset = this.bufferOffset;
    const buffer2 = array.isInterleavedBuffer === true ? array : new InterleavedBuffer(array, stride);
    const bufferAttribute2 = new InterleavedBufferAttribute(buffer2, itemSize, offset);
    buffer2.setUsage(this.usage);
    this.attribute = bufferAttribute2;
    this.attribute.isInstancedBufferAttribute = this.instanced;
  }
  generate(builder) {
    const nodeType = this.getNodeType(builder);
    const nodeAttribute = builder.getBufferAttributeFromNode(this, nodeType);
    const propertyName = builder.getPropertyName(nodeAttribute);
    let output2 = null;
    if (builder.shaderStage === "vertex" || builder.shaderStage === "compute") {
      this.name = propertyName;
      output2 = propertyName;
    } else {
      const nodeVarying = varying(this);
      output2 = nodeVarying.build(builder, nodeType);
    }
    return output2;
  }
  getInputType() {
    return "bufferAttribute";
  }
  setUsage(value) {
    this.usage = value;
    return this;
  }
  setInstanced(value) {
    this.instanced = value;
    return this;
  }
};
var BufferAttributeNode_default = BufferAttributeNode;
var bufferAttribute = (array, type, stride, offset) => nodeObject(new BufferAttributeNode(array, type, stride, offset));
var dynamicBufferAttribute = (array, type, stride, offset) => bufferAttribute(array, type, stride, offset).setUsage(DynamicDrawUsage);
var instancedBufferAttribute = (array, type, stride, offset) => bufferAttribute(array, type, stride, offset).setInstanced(true);
var instancedDynamicBufferAttribute = (array, type, stride, offset) => dynamicBufferAttribute(array, type, stride, offset).setInstanced(true);
addNodeElement("toAttribute", (bufferNode) => bufferAttribute(bufferNode.value));
addNodeClass("BufferAttributeNode", BufferAttributeNode);

// node_modules/three/examples/jsm/nodes/accessors/InstanceNode.js
var InstanceNode = class extends Node_default {
  constructor(instanceMesh) {
    super("void");
    this.instanceMesh = instanceMesh;
    this.instanceMatrixNode = null;
    this.instanceColorNode = null;
  }
  setup() {
    let instanceMatrixNode = this.instanceMatrixNode;
    const instanceMesh = this.instanceMesh;
    if (instanceMatrixNode === null) {
      const instanceAttribute = instanceMesh.instanceMatrix;
      const buffer2 = new InstancedInterleavedBuffer(instanceAttribute.array, 16, 1);
      const bufferFn = instanceAttribute.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;
      const instanceBuffers = [
        // F.Signature -> bufferAttribute( array, type, stride, offset )
        bufferFn(buffer2, "vec4", 16, 0),
        bufferFn(buffer2, "vec4", 16, 4),
        bufferFn(buffer2, "vec4", 16, 8),
        bufferFn(buffer2, "vec4", 16, 12)
      ];
      instanceMatrixNode = mat4(...instanceBuffers);
      this.instanceMatrixNode = instanceMatrixNode;
    }
    const instanceColorAttribute = instanceMesh.instanceColor;
    if (instanceColorAttribute && this.instanceColorNode === null) {
      const buffer2 = new InstancedBufferAttribute(instanceColorAttribute.array, 3);
      const bufferFn = instanceColorAttribute.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;
      this.instanceColorNode = vec3(bufferFn(buffer2, "vec3", 3, 0));
    }
    const instancePosition = instanceMatrixNode.mul(positionLocal).xyz;
    const m = mat3(instanceMatrixNode[0].xyz, instanceMatrixNode[1].xyz, instanceMatrixNode[2].xyz);
    const transformedNormal = normalLocal.div(vec3(m[0].dot(m[0]), m[1].dot(m[1]), m[2].dot(m[2])));
    const instanceNormal = m.mul(transformedNormal).xyz;
    positionLocal.assign(instancePosition);
    normalLocal.assign(instanceNormal);
    if (this.instanceColorNode !== null) {
      varyingProperty("vec3", "vInstanceColor").assign(this.instanceColorNode);
    }
  }
};
var InstanceNode_default = InstanceNode;
var instance = nodeProxy(InstanceNode);
addNodeClass("InstanceNode", InstanceNode);

// node_modules/three/examples/jsm/nodes/accessors/TangentNode.js
var tangentGeometry = tslFn((stack2, builder) => {
  if (builder.geometry.hasAttribute("tangent") === false) {
    builder.geometry.computeTangents();
  }
  return attribute("tangent", "vec4");
})();
var tangentLocal = tangentGeometry.xyz.toVar("tangentLocal");
var tangentView = varying(modelViewMatrix.mul(vec4(tangentLocal, 0)).xyz, "v_tangentView").normalize().toVar("tangentView");
var tangentWorld = varying(tangentView.transformDirection(cameraViewMatrix), "v_tangentWorld").normalize().toVar("tangentWorld");
var transformedTangentView = tangentView.toVar("transformedTangentView");
var transformedTangentWorld = transformedTangentView.transformDirection(cameraViewMatrix).normalize().toVar("transformedTangentWorld");

// node_modules/three/examples/jsm/nodes/accessors/BatchNode.js
var BatchNode = class extends Node_default {
  constructor(batchMesh) {
    super("void");
    this.batchMesh = batchMesh;
    this.instanceColorNode = null;
    this.batchingIdNode = null;
  }
  setup(builder) {
    if (this.batchingIdNode === null) {
      this.batchingIdNode = attribute("batchId");
    }
    const matriceTexture = this.batchMesh._matricesTexture;
    const size = textureSize(textureLoad(matriceTexture), 0);
    const j = float(int(this.batchingIdNode)).mul(4).toVar();
    const x = int(j.mod(size));
    const y = int(j).div(int(size));
    const batchingMatrix = mat4(
      textureLoad(matriceTexture, ivec2(x, y)),
      textureLoad(matriceTexture, ivec2(x.add(1), y)),
      textureLoad(matriceTexture, ivec2(x.add(2), y)),
      textureLoad(matriceTexture, ivec2(x.add(3), y))
    );
    const bm = mat3(
      batchingMatrix[0].xyz,
      batchingMatrix[1].xyz,
      batchingMatrix[2].xyz
    );
    positionLocal.assign(batchingMatrix.mul(positionLocal));
    const transformedNormal = normalLocal.div(vec3(bm[0].dot(bm[0]), bm[1].dot(bm[1]), bm[2].dot(bm[2])));
    const batchingNormal = bm.mul(transformedNormal).xyz;
    normalLocal.assign(batchingNormal);
    if (builder.hasGeometryAttribute("tangent")) {
      tangentLocal.mulAssign(bm);
    }
  }
};
var BatchNode_default = BatchNode;
var batch = nodeProxy(BatchNode);
addNodeClass("batch", BatchNode);

// node_modules/three/examples/jsm/nodes/accessors/SkinningNode.js
var SkinningNode = class extends Node_default {
  constructor(skinnedMesh, useReference = false) {
    super("void");
    this.skinnedMesh = skinnedMesh;
    this.useReference = useReference;
    this.updateType = NodeUpdateType.OBJECT;
    this.skinIndexNode = attribute("skinIndex", "uvec4");
    this.skinWeightNode = attribute("skinWeight", "vec4");
    let bindMatrixNode, bindMatrixInverseNode, boneMatricesNode;
    if (useReference) {
      bindMatrixNode = reference("bindMatrix", "mat4");
      bindMatrixInverseNode = reference("bindMatrixInverse", "mat4");
      boneMatricesNode = referenceBuffer("skeleton.boneMatrices", "mat4", skinnedMesh.skeleton.bones.length);
    } else {
      bindMatrixNode = uniform(skinnedMesh.bindMatrix, "mat4");
      bindMatrixInverseNode = uniform(skinnedMesh.bindMatrixInverse, "mat4");
      boneMatricesNode = buffer(skinnedMesh.skeleton.boneMatrices, "mat4", skinnedMesh.skeleton.bones.length);
    }
    this.bindMatrixNode = bindMatrixNode;
    this.bindMatrixInverseNode = bindMatrixInverseNode;
    this.boneMatricesNode = boneMatricesNode;
  }
  setup(builder) {
    const { skinIndexNode, skinWeightNode, bindMatrixNode, bindMatrixInverseNode, boneMatricesNode } = this;
    const boneMatX = boneMatricesNode.element(skinIndexNode.x);
    const boneMatY = boneMatricesNode.element(skinIndexNode.y);
    const boneMatZ = boneMatricesNode.element(skinIndexNode.z);
    const boneMatW = boneMatricesNode.element(skinIndexNode.w);
    const skinVertex = bindMatrixNode.mul(positionLocal);
    const skinned = add(
      boneMatX.mul(skinWeightNode.x).mul(skinVertex),
      boneMatY.mul(skinWeightNode.y).mul(skinVertex),
      boneMatZ.mul(skinWeightNode.z).mul(skinVertex),
      boneMatW.mul(skinWeightNode.w).mul(skinVertex)
    );
    const skinPosition = bindMatrixInverseNode.mul(skinned).xyz;
    let skinMatrix = add(
      skinWeightNode.x.mul(boneMatX),
      skinWeightNode.y.mul(boneMatY),
      skinWeightNode.z.mul(boneMatZ),
      skinWeightNode.w.mul(boneMatW)
    );
    skinMatrix = bindMatrixInverseNode.mul(skinMatrix).mul(bindMatrixNode);
    const skinNormal = skinMatrix.transformDirection(normalLocal).xyz;
    positionLocal.assign(skinPosition);
    normalLocal.assign(skinNormal);
    if (builder.hasGeometryAttribute("tangent")) {
      tangentLocal.assign(skinNormal);
    }
  }
  generate(builder, output2) {
    if (output2 !== "void") {
      return positionLocal.build(builder, output2);
    }
  }
  update(frame) {
    const object = this.useReference ? frame.object : this.skinnedMesh;
    object.skeleton.update();
  }
};
var SkinningNode_default = SkinningNode;
var skinning = (skinnedMesh) => nodeObject(new SkinningNode(skinnedMesh));
var skinningReference = (skinnedMesh) => nodeObject(new SkinningNode(skinnedMesh, true));
addNodeClass("SkinningNode", SkinningNode);

// node_modules/three/examples/jsm/nodes/utils/LoopNode.js
var LoopNode = class extends Node_default {
  constructor(params = []) {
    super();
    this.params = params;
  }
  getVarName(index) {
    return String.fromCharCode("i".charCodeAt() + index);
  }
  getProperties(builder) {
    const properties = builder.getNodeProperties(this);
    if (properties.stackNode !== void 0)
      return properties;
    const inputs = {};
    for (let i = 0, l = this.params.length - 1; i < l; i++) {
      const param = this.params[i];
      const name = param.isNode !== true && param.name || this.getVarName(i);
      const type = param.isNode !== true && param.type || "int";
      inputs[name] = expression(name, type);
    }
    properties.returnsNode = this.params[this.params.length - 1](inputs, builder.addStack(), builder);
    properties.stackNode = builder.removeStack();
    return properties;
  }
  getNodeType(builder) {
    const { returnsNode } = this.getProperties(builder);
    return returnsNode ? returnsNode.getNodeType(builder) : "void";
  }
  setup(builder) {
    this.getProperties(builder);
  }
  generate(builder) {
    const properties = this.getProperties(builder);
    const contextData = { tempWrite: false };
    const params = this.params;
    const stackNode = properties.stackNode;
    for (let i = 0, l = params.length - 1; i < l; i++) {
      const param = params[i];
      let start = null, end = null, name = null, type = null, condition = null, update = null;
      if (param.isNode) {
        type = "int";
        name = this.getVarName(i);
        start = "0";
        end = param.build(builder, type);
        condition = "<";
      } else {
        type = param.type || "int";
        name = param.name || this.getVarName(i);
        start = param.start;
        end = param.end;
        condition = param.condition;
        update = param.update;
        if (typeof start === "number")
          start = start.toString();
        else if (start && start.isNode)
          start = start.build(builder, type);
        if (typeof end === "number")
          end = end.toString();
        else if (end && end.isNode)
          end = end.build(builder, type);
        if (start !== void 0 && end === void 0) {
          start = start + " - 1";
          end = "0";
          condition = ">=";
        } else if (end !== void 0 && start === void 0) {
          start = "0";
          condition = "<";
        }
        if (condition === void 0) {
          if (Number(start) > Number(end)) {
            condition = ">=";
          } else {
            condition = "<";
          }
        }
      }
      const internalParam = { start, end, condition };
      const startSnippet = internalParam.start;
      const endSnippet = internalParam.end;
      let declarationSnippet = "";
      let conditionalSnippet = "";
      let updateSnippet = "";
      if (!update) {
        if (type === "int" || type === "uint") {
          if (condition.includes("<"))
            update = "++";
          else
            update = "--";
        } else {
          if (condition.includes("<"))
            update = "+= 1.";
          else
            update = "-= 1.";
        }
      }
      declarationSnippet += builder.getVar(type, name) + " = " + startSnippet;
      conditionalSnippet += name + " " + condition + " " + endSnippet;
      updateSnippet += name + " " + update;
      const forSnippet = `for ( ${declarationSnippet}; ${conditionalSnippet}; ${updateSnippet} )`;
      builder.addFlowCode((i === 0 ? "\n" : "") + builder.tab + forSnippet + " {\n\n").addFlowTab();
    }
    const stackSnippet = context(stackNode, contextData).build(builder, "void");
    const returnsSnippet = properties.returnsNode ? properties.returnsNode.build(builder) : "";
    builder.removeFlowTab().addFlowCode("\n" + builder.tab + stackSnippet);
    for (let i = 0, l = this.params.length - 1; i < l; i++) {
      builder.addFlowCode((i === 0 ? "" : builder.tab) + "}\n\n").removeFlowTab();
    }
    builder.addFlowTab();
    return returnsSnippet;
  }
};
var LoopNode_default = LoopNode;
var loop = (...params) => nodeObject(new LoopNode(nodeArray(params, "int"))).append();
var Continue = () => expression("continue").append();
var Break = () => expression("break").append();
addNodeElement("loop", (returns, ...params) => bypass(returns, loop(...params)));
addNodeClass("LoopNode", LoopNode);

// node_modules/three/examples/jsm/nodes/accessors/MorphNode.js
var morphTextures = /* @__PURE__ */ new WeakMap();
var morphVec4 = new Vector4();
var getMorph = tslFn(({ bufferMap, influence, stride, width, depth: depth2, offset }) => {
  const texelIndex = int(vertexIndex).mul(stride).add(offset);
  const y = texelIndex.div(width);
  const x = texelIndex.sub(y.mul(width));
  const bufferAttrib = textureLoad(bufferMap, ivec2(x, y)).depth(depth2);
  return bufferAttrib.mul(influence);
});
function getEntry(geometry) {
  const hasMorphPosition = geometry.morphAttributes.position !== void 0;
  const hasMorphNormals = geometry.morphAttributes.normal !== void 0;
  const hasMorphColors = geometry.morphAttributes.color !== void 0;
  const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
  const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
  let entry = morphTextures.get(geometry);
  if (entry === void 0 || entry.count !== morphTargetsCount) {
    let disposeTexture = function() {
      bufferTexture.dispose();
      morphTextures.delete(geometry);
      geometry.removeEventListener("dispose", disposeTexture);
    };
    if (entry !== void 0)
      entry.texture.dispose();
    const morphTargets = geometry.morphAttributes.position || [];
    const morphNormals = geometry.morphAttributes.normal || [];
    const morphColors = geometry.morphAttributes.color || [];
    let vertexDataCount = 0;
    if (hasMorphPosition === true)
      vertexDataCount = 1;
    if (hasMorphNormals === true)
      vertexDataCount = 2;
    if (hasMorphColors === true)
      vertexDataCount = 3;
    let width = geometry.attributes.position.count * vertexDataCount;
    let height = 1;
    const maxTextureSize = 4096;
    if (width > maxTextureSize) {
      height = Math.ceil(width / maxTextureSize);
      width = maxTextureSize;
    }
    const buffer2 = new Float32Array(width * height * 4 * morphTargetsCount);
    const bufferTexture = new DataArrayTexture(buffer2, width, height, morphTargetsCount);
    bufferTexture.type = FloatType;
    bufferTexture.needsUpdate = true;
    const vertexDataStride = vertexDataCount * 4;
    for (let i = 0; i < morphTargetsCount; i++) {
      const morphTarget = morphTargets[i];
      const morphNormal = morphNormals[i];
      const morphColor = morphColors[i];
      const offset = width * height * 4 * i;
      for (let j = 0; j < morphTarget.count; j++) {
        const stride = j * vertexDataStride;
        if (hasMorphPosition === true) {
          morphVec4.fromBufferAttribute(morphTarget, j);
          buffer2[offset + stride + 0] = morphVec4.x;
          buffer2[offset + stride + 1] = morphVec4.y;
          buffer2[offset + stride + 2] = morphVec4.z;
          buffer2[offset + stride + 3] = 0;
        }
        if (hasMorphNormals === true) {
          morphVec4.fromBufferAttribute(morphNormal, j);
          buffer2[offset + stride + 4] = morphVec4.x;
          buffer2[offset + stride + 5] = morphVec4.y;
          buffer2[offset + stride + 6] = morphVec4.z;
          buffer2[offset + stride + 7] = 0;
        }
        if (hasMorphColors === true) {
          morphVec4.fromBufferAttribute(morphColor, j);
          buffer2[offset + stride + 8] = morphVec4.x;
          buffer2[offset + stride + 9] = morphVec4.y;
          buffer2[offset + stride + 10] = morphVec4.z;
          buffer2[offset + stride + 11] = morphColor.itemSize === 4 ? morphVec4.w : 1;
        }
      }
    }
    entry = {
      count: morphTargetsCount,
      texture: bufferTexture,
      stride: vertexDataCount,
      size: new Vector2(width, height)
    };
    morphTextures.set(geometry, entry);
    geometry.addEventListener("dispose", disposeTexture);
  }
  return entry;
}
var MorphNode = class extends Node_default {
  constructor(mesh) {
    super("void");
    this.mesh = mesh;
    this.morphBaseInfluence = uniform(1);
    this.updateType = NodeUpdateType.OBJECT;
  }
  setup(builder) {
    const { geometry } = builder;
    const hasMorphPosition = geometry.morphAttributes.position !== void 0;
    const hasMorphNormals = geometry.morphAttributes.normal !== void 0;
    const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
    const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
    const { texture: bufferMap, stride, size } = getEntry(geometry);
    if (hasMorphPosition === true)
      positionLocal.mulAssign(this.morphBaseInfluence);
    if (hasMorphNormals === true)
      normalLocal.mulAssign(this.morphBaseInfluence);
    const width = int(size.width);
    loop(morphTargetsCount, ({ i }) => {
      const influence = float(0).toVar();
      if (this.mesh.isInstancedMesh === true && (this.mesh.morphTexture !== null && this.mesh.morphTexture !== void 0)) {
        influence.assign(textureLoad(this.mesh.morphTexture, ivec2(int(i).add(1), int(instanceIndex))).r);
      } else {
        influence.assign(reference("morphTargetInfluences", "float").element(i).toVar());
      }
      if (hasMorphPosition === true) {
        positionLocal.addAssign(getMorph({
          bufferMap,
          influence,
          stride,
          width,
          depth: i,
          offset: int(0)
        }));
      }
      if (hasMorphNormals === true) {
        normalLocal.addAssign(getMorph({
          bufferMap,
          influence,
          stride,
          width,
          depth: i,
          offset: int(1)
        }));
      }
    });
  }
  update() {
    const morphBaseInfluence = this.morphBaseInfluence;
    if (this.mesh.geometry.morphTargetsRelative) {
      morphBaseInfluence.value = 1;
    } else {
      morphBaseInfluence.value = 1 - this.mesh.morphTargetInfluences.reduce((a, b) => a + b, 0);
    }
  }
};
var MorphNode_default = MorphNode;
var morphReference = nodeProxy(MorphNode);
addNodeClass("MorphNode", MorphNode);

// node_modules/three/examples/jsm/nodes/accessors/ReflectVectorNode.js
var reflectView = positionViewDirection.negate().reflect(transformedNormalView);
var reflectVector = reflectView.transformDirection(cameraViewMatrix).toVar("reflectVector");

// node_modules/three/examples/jsm/nodes/accessors/CubeTextureNode.js
var CubeTextureNode = class extends TextureNode_default {
  constructor(value, uvNode = null, levelNode = null) {
    super(value, uvNode, levelNode);
    this.isCubeTextureNode = true;
  }
  getInputType() {
    return "cubeTexture";
  }
  getDefaultUV() {
    return reflectVector;
  }
  setUpdateMatrix() {
  }
  // Ignore .updateMatrix for CubeTextureNode
  setupUV(builder, uvNode) {
    const texture2 = this.value;
    if (builder.renderer.coordinateSystem === WebGPUCoordinateSystem || !texture2.isRenderTargetTexture) {
      return vec3(uvNode.x.negate(), uvNode.yz);
    } else {
      return uvNode;
    }
  }
  generateUV(builder, cubeUV) {
    return cubeUV.build(builder, "vec3");
  }
};
var CubeTextureNode_default = CubeTextureNode;
var cubeTexture = nodeProxy(CubeTextureNode);
addNodeElement("cubeTexture", cubeTexture);
addNodeClass("CubeTextureNode", CubeTextureNode);

// node_modules/three/examples/jsm/nodes/lighting/LightingNode.js
var LightingNode = class extends Node_default {
  constructor() {
    super("vec3");
  }
  generate() {
    console.warn("Abstract function.");
  }
};
var LightingNode_default = LightingNode;
addNodeClass("LightingNode", LightingNode);

// node_modules/three/examples/jsm/nodes/lighting/AnalyticLightNode.js
var overrideMaterial = null;
var AnalyticLightNode = class extends LightingNode_default {
  constructor(light = null) {
    super();
    this.updateType = NodeUpdateType.FRAME;
    this.light = light;
    this.rtt = null;
    this.shadowNode = null;
    this.shadowMaskNode = null;
    this.color = new Color();
    this._defaultColorNode = uniform(this.color);
    this.colorNode = this._defaultColorNode;
    this.isAnalyticLightNode = true;
  }
  getCacheKey() {
    return super.getCacheKey() + "-" + (this.light.id + "-" + (this.light.castShadow ? "1" : "0"));
  }
  getHash() {
    return this.light.uuid;
  }
  setupShadow(builder) {
    const { object } = builder;
    if (object.receiveShadow === false)
      return;
    let shadowNode = this.shadowNode;
    if (shadowNode === null) {
      if (overrideMaterial === null) {
        overrideMaterial = builder.createNodeMaterial();
        overrideMaterial.fragmentNode = vec4(0, 0, 0, 1);
        overrideMaterial.isShadowNodeMaterial = true;
      }
      const shadow = this.light.shadow;
      const rtt = builder.createRenderTarget(shadow.mapSize.width, shadow.mapSize.height);
      const depthTexture2 = new DepthTexture();
      depthTexture2.minFilter = NearestFilter;
      depthTexture2.magFilter = NearestFilter;
      depthTexture2.image.width = shadow.mapSize.width;
      depthTexture2.image.height = shadow.mapSize.height;
      depthTexture2.compareFunction = LessCompare;
      rtt.depthTexture = depthTexture2;
      shadow.camera.updateProjectionMatrix();
      const bias = reference("bias", "float", shadow);
      const normalBias = reference("normalBias", "float", shadow);
      const position = object.material.shadowPositionNode || positionWorld;
      let shadowCoord = uniform(shadow.matrix).mul(position.add(normalWorld.mul(normalBias)));
      shadowCoord = shadowCoord.xyz.div(shadowCoord.w);
      const frustumTest = shadowCoord.x.greaterThanEqual(0).and(shadowCoord.x.lessThanEqual(1)).and(shadowCoord.y.greaterThanEqual(0)).and(shadowCoord.y.lessThanEqual(1)).and(shadowCoord.z.lessThanEqual(1));
      let coordZ = shadowCoord.z.add(bias);
      if (builder.renderer.coordinateSystem === WebGPUCoordinateSystem) {
        coordZ = coordZ.mul(2).sub(1);
      }
      shadowCoord = vec3(
        shadowCoord.x,
        shadowCoord.y.oneMinus(),
        // follow webgpu standards
        coordZ
      );
      const textureCompare = (depthTexture3, shadowCoord2, compare) => texture(depthTexture3, shadowCoord2).compare(compare);
      shadowNode = textureCompare(depthTexture2, shadowCoord.xy, shadowCoord.z);
      const shadowColor = texture(rtt.texture, shadowCoord);
      const shadowMaskNode = frustumTest.mix(1, shadowNode.mix(shadowColor.a.mix(1, shadowColor), 1));
      this.rtt = rtt;
      this.colorNode = this.colorNode.mul(shadowMaskNode);
      this.shadowNode = shadowNode;
      this.shadowMaskNode = shadowMaskNode;
      this.updateBeforeType = NodeUpdateType.RENDER;
    }
  }
  setup(builder) {
    if (this.light.castShadow)
      this.setupShadow(builder);
    else if (this.shadowNode !== null)
      this.disposeShadow();
  }
  updateShadow(frame) {
    const { rtt, light } = this;
    const { renderer, scene, camera } = frame;
    const currentOverrideMaterial = scene.overrideMaterial;
    scene.overrideMaterial = overrideMaterial;
    rtt.setSize(light.shadow.mapSize.width, light.shadow.mapSize.height);
    light.shadow.updateMatrices(light);
    light.shadow.camera.layers.mask = camera.layers.mask;
    const currentToneMapping = renderer.toneMapping;
    const currentRenderTarget = renderer.getRenderTarget();
    const currentRenderObjectFunction = renderer.getRenderObjectFunction();
    renderer.setRenderObjectFunction((object, ...params) => {
      if (object.castShadow === true) {
        renderer.renderObject(object, ...params);
      }
    });
    renderer.setRenderTarget(rtt);
    renderer.toneMapping = NoToneMapping;
    renderer.render(scene, light.shadow.camera);
    renderer.setRenderTarget(currentRenderTarget);
    renderer.setRenderObjectFunction(currentRenderObjectFunction);
    renderer.toneMapping = currentToneMapping;
    scene.overrideMaterial = currentOverrideMaterial;
  }
  disposeShadow() {
    this.rtt.dispose();
    this.shadowNode = null;
    this.shadowMaskNode = null;
    this.rtt = null;
    this.colorNode = this._defaultColorNode;
  }
  updateBefore(frame) {
    const { light } = this;
    if (light.castShadow)
      this.updateShadow(frame);
  }
  update() {
    const { light } = this;
    this.color.copy(light.color).multiplyScalar(light.intensity);
  }
};
var AnalyticLightNode_default = AnalyticLightNode;
addNodeClass("AnalyticLightNode", AnalyticLightNode);

// node_modules/three/examples/jsm/nodes/lighting/LightsNode.js
var LightNodes = /* @__PURE__ */ new WeakMap();
var sortLights = (lights2) => {
  return lights2.sort((a, b) => a.id - b.id);
};
var LightsNode = class extends Node_default {
  constructor(lightNodes = []) {
    super("vec3");
    this.totalDiffuseNode = vec3().temp("totalDiffuse");
    this.totalSpecularNode = vec3().temp("totalSpecular");
    this.outgoingLightNode = vec3().temp("outgoingLight");
    this.lightNodes = lightNodes;
    this._hash = null;
  }
  get hasLight() {
    return this.lightNodes.length > 0;
  }
  getHash() {
    if (this._hash === null) {
      const hash2 = [];
      for (const lightNode of this.lightNodes) {
        hash2.push(lightNode.getHash());
      }
      this._hash = "lights-" + hash2.join(",");
    }
    return this._hash;
  }
  analyze(builder) {
    const properties = builder.getDataFromNode(this);
    for (const node of properties.nodes) {
      node.build(builder);
    }
  }
  setup(builder) {
    const context2 = builder.context;
    const lightingModel = context2.lightingModel;
    let outgoingLightNode = this.outgoingLightNode;
    if (lightingModel) {
      const { lightNodes, totalDiffuseNode, totalSpecularNode } = this;
      context2.outgoingLight = outgoingLightNode;
      const stack2 = builder.addStack();
      const properties = builder.getDataFromNode(this);
      properties.nodes = stack2.nodes;
      lightingModel.start(context2, stack2, builder);
      for (const lightNode of lightNodes) {
        lightNode.build(builder);
      }
      lightingModel.indirectDiffuse(context2, stack2, builder);
      lightingModel.indirectSpecular(context2, stack2, builder);
      lightingModel.ambientOcclusion(context2, stack2, builder);
      const { backdrop, backdropAlpha } = context2;
      const { directDiffuse, directSpecular, indirectDiffuse, indirectSpecular } = context2.reflectedLight;
      let totalDiffuse = directDiffuse.add(indirectDiffuse);
      if (backdrop !== null) {
        if (backdropAlpha !== null) {
          totalDiffuse = vec3(backdropAlpha.mix(totalDiffuse, backdrop));
        } else {
          totalDiffuse = vec3(backdrop);
        }
        context2.material.transparent = true;
      }
      totalDiffuseNode.assign(totalDiffuse);
      totalSpecularNode.assign(directSpecular.add(indirectSpecular));
      outgoingLightNode.assign(totalDiffuseNode.add(totalSpecularNode));
      lightingModel.finish(context2, stack2, builder);
      outgoingLightNode = outgoingLightNode.bypass(builder.removeStack());
    }
    return outgoingLightNode;
  }
  _getLightNodeById(id2) {
    for (const lightNode of this.lightNodes) {
      if (lightNode.isAnalyticLightNode && lightNode.light.id === id2) {
        return lightNode;
      }
    }
    return null;
  }
  fromLights(lights2 = []) {
    const lightNodes = [];
    lights2 = sortLights(lights2);
    for (const light of lights2) {
      let lightNode = this._getLightNodeById(light.id);
      if (lightNode === null) {
        const lightClass = light.constructor;
        const lightNodeClass = LightNodes.has(lightClass) ? LightNodes.get(lightClass) : AnalyticLightNode_default;
        lightNode = nodeObject(new lightNodeClass(light));
      }
      lightNodes.push(lightNode);
    }
    this.lightNodes = lightNodes;
    this._hash = null;
    return this;
  }
};
var LightsNode_default = LightsNode;
var lights = (lights2) => nodeObject(new LightsNode().fromLights(lights2));
var lightsNode = nodeProxy(LightsNode);
function addLightNode(lightClass, lightNodeClass) {
  if (LightNodes.has(lightClass)) {
    console.warn(`Redefinition of light node ${lightNodeClass.type}`);
    return;
  }
  if (typeof lightClass !== "function")
    throw new Error(`Light ${lightClass.name} is not a class`);
  if (typeof lightNodeClass !== "function" || !lightNodeClass.type)
    throw new Error(`Light node ${lightNodeClass.type} is not a class`);
  LightNodes.set(lightClass, lightNodeClass);
}

// node_modules/three/examples/jsm/nodes/lighting/AONode.js
var AONode = class extends LightingNode_default {
  constructor(aoNode = null) {
    super();
    this.aoNode = aoNode;
  }
  setup(builder) {
    const aoIntensity = 1;
    const aoNode = this.aoNode.x.sub(1).mul(aoIntensity).add(1);
    builder.context.ambientOcclusion.mulAssign(aoNode);
  }
};
var AONode_default = AONode;
addNodeClass("AONode", AONode);

// node_modules/three/examples/jsm/nodes/lighting/LightingContextNode.js
var LightingContextNode = class extends ContextNode_default {
  constructor(node, lightingModel = null, backdropNode = null, backdropAlphaNode = null) {
    super(node);
    this.lightingModel = lightingModel;
    this.backdropNode = backdropNode;
    this.backdropAlphaNode = backdropAlphaNode;
    this._context = null;
  }
  getContext() {
    const { backdropNode, backdropAlphaNode } = this;
    const directDiffuse = vec3().temp("directDiffuse"), directSpecular = vec3().temp("directSpecular"), indirectDiffuse = vec3().temp("indirectDiffuse"), indirectSpecular = vec3().temp("indirectSpecular");
    const reflectedLight = {
      directDiffuse,
      directSpecular,
      indirectDiffuse,
      indirectSpecular
    };
    const context2 = {
      radiance: vec3().temp("radiance"),
      irradiance: vec3().temp("irradiance"),
      iblIrradiance: vec3().temp("iblIrradiance"),
      ambientOcclusion: float(1).temp("ambientOcclusion"),
      reflectedLight,
      backdrop: backdropNode,
      backdropAlpha: backdropAlphaNode
    };
    return context2;
  }
  setup(builder) {
    this.context = this._context || (this._context = this.getContext());
    this.context.lightingModel = this.lightingModel || builder.context.lightingModel;
    return super.setup(builder);
  }
};
var LightingContextNode_default = LightingContextNode;
var lightingContext = nodeProxy(LightingContextNode);
addNodeElement("lightingContext", lightingContext);
addNodeClass("LightingContextNode", LightingContextNode);

// node_modules/three/examples/jsm/nodes/accessors/BitangentNode.js
var getBitangent = (crossNormalTangent) => crossNormalTangent.mul(tangentGeometry.w).xyz;
var bitangentGeometry = varying(getBitangent(normalGeometry.cross(tangentGeometry)), "v_bitangentGeometry").normalize().toVar("bitangentGeometry");
var bitangentLocal = varying(getBitangent(normalLocal.cross(tangentLocal)), "v_bitangentLocal").normalize().toVar("bitangentLocal");
var bitangentView = varying(getBitangent(normalView.cross(tangentView)), "v_bitangentView").normalize().toVar("bitangentView");
var bitangentWorld = varying(getBitangent(normalWorld.cross(tangentWorld)), "v_bitangentWorld").normalize().toVar("bitangentWorld");
var transformedBitangentView = getBitangent(transformedNormalView.cross(transformedTangentView)).normalize().toVar("transformedBitangentView");
var transformedBitangentWorld = transformedBitangentView.transformDirection(cameraViewMatrix).normalize().toVar("transformedBitangentWorld");

// node_modules/three/examples/jsm/nodes/accessors/AccessorsUtils.js
var TBNViewMatrix = mat3(tangentView, bitangentView, normalView);
var parallaxDirection = positionViewDirection.mul(TBNViewMatrix);
var parallaxUV = (uv2, scale) => uv2.sub(parallaxDirection.mul(scale));
var transformedBentNormalView = (() => {
  let bentNormal = anisotropyB.cross(positionViewDirection);
  bentNormal = bentNormal.cross(anisotropyB).normalize();
  bentNormal = mix(bentNormal, transformedNormalView, anisotropy.mul(roughness.oneMinus()).oneMinus().pow2().pow2()).normalize();
  return bentNormal;
})();

// node_modules/three/examples/jsm/nodes/pmrem/PMREMUtils.js
var PMREMUtils_exports = {};
__export(PMREMUtils_exports, {
  blur: () => blur,
  getDirection: () => getDirection,
  textureCubeUV: () => textureCubeUV
});

// node_modules/three/examples/jsm/nodes/math/CondNode.js
var CondNode = class extends Node_default {
  constructor(condNode, ifNode, elseNode = null) {
    super();
    this.condNode = condNode;
    this.ifNode = ifNode;
    this.elseNode = elseNode;
  }
  getNodeType(builder) {
    const ifType = this.ifNode.getNodeType(builder);
    if (this.elseNode !== null) {
      const elseType = this.elseNode.getNodeType(builder);
      if (builder.getTypeLength(elseType) > builder.getTypeLength(ifType)) {
        return elseType;
      }
    }
    return ifType;
  }
  generate(builder, output2) {
    const type = this.getNodeType(builder);
    const context2 = { tempWrite: false };
    const nodeData = builder.getDataFromNode(this);
    if (nodeData.nodeProperty !== void 0) {
      return nodeData.nodeProperty;
    }
    const { ifNode, elseNode } = this;
    const needsOutput = output2 !== "void";
    const nodeProperty = needsOutput ? property(type).build(builder) : "";
    nodeData.nodeProperty = nodeProperty;
    const nodeSnippet = context(
      this.condNode
      /*, context*/
    ).build(builder, "bool");
    builder.addFlowCode(`
${builder.tab}if ( ${nodeSnippet} ) {

`).addFlowTab();
    let ifSnippet = context(ifNode, context2).build(builder, type);
    if (ifSnippet) {
      if (needsOutput) {
        ifSnippet = nodeProperty + " = " + ifSnippet + ";";
      } else {
        ifSnippet = "return " + ifSnippet + ";";
      }
    }
    builder.removeFlowTab().addFlowCode(builder.tab + "	" + ifSnippet + "\n\n" + builder.tab + "}");
    if (elseNode !== null) {
      builder.addFlowCode(" else {\n\n").addFlowTab();
      let elseSnippet = context(elseNode, context2).build(builder, type);
      if (elseSnippet) {
        if (needsOutput) {
          elseSnippet = nodeProperty + " = " + elseSnippet + ";";
        } else {
          elseSnippet = "return " + elseSnippet + ";";
        }
      }
      builder.removeFlowTab().addFlowCode(builder.tab + "	" + elseSnippet + "\n\n" + builder.tab + "}\n\n");
    } else {
      builder.addFlowCode("\n\n");
    }
    return builder.format(nodeProperty, type, output2);
  }
};
var CondNode_default = CondNode;
var cond = nodeProxy(CondNode);
addNodeElement("cond", cond);
addNodeClass("CondNode", CondNode);

// node_modules/three/examples/jsm/nodes/pmrem/PMREMUtils.js
var cubeUV_r0 = float(1);
var cubeUV_m0 = float(-2);
var cubeUV_r1 = float(0.8);
var cubeUV_m1 = float(-1);
var cubeUV_r4 = float(0.4);
var cubeUV_m4 = float(2);
var cubeUV_r5 = float(0.305);
var cubeUV_m5 = float(3);
var cubeUV_r6 = float(0.21);
var cubeUV_m6 = float(4);
var cubeUV_minMipLevel = float(4);
var cubeUV_minTileSize = float(16);
var getFace = tslFn(([direction2]) => {
  const absDirection = vec3(abs(direction2)).toVar();
  const face = float(-1).toVar();
  If(absDirection.x.greaterThan(absDirection.z), () => {
    If(absDirection.x.greaterThan(absDirection.y), () => {
      face.assign(cond(direction2.x.greaterThan(0), 0, 3));
    }).else(() => {
      face.assign(cond(direction2.y.greaterThan(0), 1, 4));
    });
  }).else(() => {
    If(absDirection.z.greaterThan(absDirection.y), () => {
      face.assign(cond(direction2.z.greaterThan(0), 2, 5));
    }).else(() => {
      face.assign(cond(direction2.y.greaterThan(0), 1, 4));
    });
  });
  return face;
}).setLayout({
  name: "getFace",
  type: "float",
  inputs: [
    { name: "direction", type: "vec3" }
  ]
});
var getUV = tslFn(([direction2, face]) => {
  const uv2 = vec2().toVar();
  If(face.equal(0), () => {
    uv2.assign(vec2(direction2.z, direction2.y).div(abs(direction2.x)));
  }).elseif(face.equal(1), () => {
    uv2.assign(vec2(direction2.x.negate(), direction2.z.negate()).div(abs(direction2.y)));
  }).elseif(face.equal(2), () => {
    uv2.assign(vec2(direction2.x.negate(), direction2.y).div(abs(direction2.z)));
  }).elseif(face.equal(3), () => {
    uv2.assign(vec2(direction2.z.negate(), direction2.y).div(abs(direction2.x)));
  }).elseif(face.equal(4), () => {
    uv2.assign(vec2(direction2.x.negate(), direction2.z).div(abs(direction2.y)));
  }).else(() => {
    uv2.assign(vec2(direction2.x, direction2.y).div(abs(direction2.z)));
  });
  return mul(0.5, uv2.add(1));
}).setLayout({
  name: "getUV",
  type: "vec2",
  inputs: [
    { name: "direction", type: "vec3" },
    { name: "face", type: "float" }
  ]
});
var roughnessToMip = tslFn(([roughness2]) => {
  const mip = float(0).toVar();
  If(roughness2.greaterThanEqual(cubeUV_r1), () => {
    mip.assign(cubeUV_r0.sub(roughness2).mul(cubeUV_m1.sub(cubeUV_m0)).div(cubeUV_r0.sub(cubeUV_r1)).add(cubeUV_m0));
  }).elseif(roughness2.greaterThanEqual(cubeUV_r4), () => {
    mip.assign(cubeUV_r1.sub(roughness2).mul(cubeUV_m4.sub(cubeUV_m1)).div(cubeUV_r1.sub(cubeUV_r4)).add(cubeUV_m1));
  }).elseif(roughness2.greaterThanEqual(cubeUV_r5), () => {
    mip.assign(cubeUV_r4.sub(roughness2).mul(cubeUV_m5.sub(cubeUV_m4)).div(cubeUV_r4.sub(cubeUV_r5)).add(cubeUV_m4));
  }).elseif(roughness2.greaterThanEqual(cubeUV_r6), () => {
    mip.assign(cubeUV_r5.sub(roughness2).mul(cubeUV_m6.sub(cubeUV_m5)).div(cubeUV_r5.sub(cubeUV_r6)).add(cubeUV_m5));
  }).else(() => {
    mip.assign(float(-2).mul(log2(mul(1.16, roughness2))));
  });
  return mip;
}).setLayout({
  name: "roughnessToMip",
  type: "float",
  inputs: [
    { name: "roughness", type: "float" }
  ]
});
var getDirection = tslFn(([uv_immutable, face]) => {
  const uv2 = uv_immutable.toVar();
  uv2.assign(mul(2, uv2).sub(1));
  const direction2 = vec3(uv2, 1).toVar();
  If(face.equal(0), () => {
    direction2.assign(direction2.zyx);
  }).elseif(face.equal(1), () => {
    direction2.assign(direction2.xzy);
    direction2.xz.mulAssign(-1);
  }).elseif(face.equal(2), () => {
    direction2.x.mulAssign(-1);
  }).elseif(face.equal(3), () => {
    direction2.assign(direction2.zyx);
    direction2.xz.mulAssign(-1);
  }).elseif(face.equal(4), () => {
    direction2.assign(direction2.xzy);
    direction2.xy.mulAssign(-1);
  }).elseif(face.equal(5), () => {
    direction2.z.mulAssign(-1);
  });
  return direction2;
}).setLayout({
  name: "getDirection",
  type: "vec3",
  inputs: [
    { name: "uv", type: "vec2" },
    { name: "face", type: "float" }
  ]
});
var textureCubeUV = tslFn(([envMap, sampleDir_immutable, roughness_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP]) => {
  const roughness2 = float(roughness_immutable);
  const sampleDir = vec3(sampleDir_immutable);
  const mip = clamp(roughnessToMip(roughness2), cubeUV_m0, CUBEUV_MAX_MIP);
  const mipF = fract(mip);
  const mipInt = floor(mip);
  const color0 = vec3(bilinearCubeUV(envMap, sampleDir, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP)).toVar();
  If(mipF.notEqual(0), () => {
    const color1 = vec3(bilinearCubeUV(envMap, sampleDir, mipInt.add(1), CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP)).toVar();
    color0.assign(mix(color0, color1, mipF));
  });
  return color0;
});
var bilinearCubeUV = tslFn(([envMap, direction_immutable, mipInt_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP]) => {
  const mipInt = float(mipInt_immutable).toVar();
  const direction2 = vec3(direction_immutable);
  const face = float(getFace(direction2)).toVar();
  const filterInt = float(max(cubeUV_minMipLevel.sub(mipInt), 0)).toVar();
  mipInt.assign(max(mipInt, cubeUV_minMipLevel));
  const faceSize = float(exp2(mipInt)).toVar();
  const uv2 = vec2(getUV(direction2, face).mul(faceSize.sub(2)).add(1)).toVar();
  If(face.greaterThan(2), () => {
    uv2.y.addAssign(faceSize);
    face.subAssign(3);
  });
  uv2.x.addAssign(face.mul(faceSize));
  uv2.x.addAssign(filterInt.mul(mul(3, cubeUV_minTileSize)));
  uv2.y.addAssign(mul(4, exp2(CUBEUV_MAX_MIP).sub(faceSize)));
  uv2.x.mulAssign(CUBEUV_TEXEL_WIDTH);
  uv2.y.mulAssign(CUBEUV_TEXEL_HEIGHT);
  return envMap.uv(uv2).grad(vec2(), vec2());
});
var getSample = tslFn(({ envMap, mipInt, outputDirection: outputDirection2, theta, axis, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP }) => {
  const cosTheta = cos(theta);
  const sampleDirection = outputDirection2.mul(cosTheta).add(axis.cross(outputDirection2).mul(sin(theta))).add(axis.mul(axis.dot(outputDirection2).mul(cosTheta.oneMinus())));
  return bilinearCubeUV(envMap, sampleDirection, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP);
});
var blur = tslFn(({ n, latitudinal, poleAxis, outputDirection: outputDirection2, weights, samples, dTheta, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP }) => {
  const axis = vec3(cond(latitudinal, poleAxis, cross(poleAxis, outputDirection2))).toVar();
  If(all(axis.equals(vec3(0))), () => {
    axis.assign(vec3(outputDirection2.z, 0, outputDirection2.x.negate()));
  });
  axis.assign(normalize(axis));
  const gl_FragColor = vec3().toVar();
  gl_FragColor.addAssign(weights.element(int(0)).mul(getSample({ theta: 0, axis, outputDirection: outputDirection2, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP })));
  loop({ start: int(1), end: n }, ({ i }) => {
    If(i.greaterThanEqual(samples), () => {
      Break();
    });
    const theta = float(dTheta.mul(float(i))).toVar();
    gl_FragColor.addAssign(weights.element(i).mul(getSample({ theta: theta.mul(-1), axis, outputDirection: outputDirection2, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP })));
    gl_FragColor.addAssign(weights.element(i).mul(getSample({ theta, axis, outputDirection: outputDirection2, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP })));
  });
  return vec4(gl_FragColor, 1);
});

// node_modules/three/examples/jsm/nodes/pmrem/PMREMNode.js
var _generator = null;
var _cache = /* @__PURE__ */ new WeakMap();
function _generateCubeUVSize(imageHeight) {
  const maxMip = Math.log2(imageHeight) - 2;
  const texelHeight = 1 / imageHeight;
  const texelWidth = 1 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));
  return { texelWidth, texelHeight, maxMip };
}
function _getPMREMFromTexture(texture2) {
  let cacheTexture = _cache.get(texture2);
  const pmremVersion = cacheTexture !== void 0 ? cacheTexture.pmremVersion : -1;
  if (pmremVersion !== texture2.pmremVersion) {
    if (texture2.isCubeTexture) {
      if (texture2.source.data.some((texture3) => texture3 === void 0)) {
        throw new Error("PMREMNode: Undefined texture in CubeTexture. Use onLoad callback or async loader");
      }
      cacheTexture = _generator.fromCubemap(texture2, cacheTexture);
    } else {
      if (texture2.image === void 0) {
        throw new Error("PMREMNode: Undefined image in Texture. Use onLoad callback or async loader");
      }
      cacheTexture = _generator.fromEquirectangular(texture2, cacheTexture);
    }
    cacheTexture.pmremVersion = texture2.pmremVersion;
    _cache.set(texture2, cacheTexture);
  }
  return cacheTexture.texture;
}
var PMREMNode = class extends TempNode_default {
  constructor(value, uvNode = null, levelNode = null) {
    super("vec3");
    this._value = value;
    this._pmrem = null;
    this.uvNode = uvNode;
    this.levelNode = levelNode;
    this._generator = null;
    this._texture = texture(null);
    this._width = uniform(0);
    this._height = uniform(0);
    this._maxMip = uniform(0);
    this.updateBeforeType = NodeUpdateType.RENDER;
  }
  set value(value) {
    this._value = value;
    this._pmrem = null;
  }
  get value() {
    return this._value;
  }
  updateFromTexture(texture2) {
    const cubeUVSize = _generateCubeUVSize(texture2.image.height);
    this._texture.value = texture2;
    this._width.value = cubeUVSize.texelWidth;
    this._height.value = cubeUVSize.texelHeight;
    this._maxMip.value = cubeUVSize.maxMip;
  }
  updateBefore() {
    let pmrem = this._pmrem;
    const pmremVersion = pmrem ? pmrem.pmremVersion : -1;
    const texture2 = this._value;
    if (pmremVersion !== texture2.pmremVersion) {
      if (texture2.isPMREMTexture === true) {
        pmrem = texture2;
      } else {
        pmrem = _getPMREMFromTexture(texture2);
      }
      this._pmrem = pmrem;
      this.updateFromTexture(pmrem);
    }
  }
  setup(builder) {
    if (_generator === null) {
      _generator = builder.createPMREMGenerator();
    }
    this.updateBefore(builder);
    let uvNode = this.uvNode;
    if (uvNode === null && builder.context.getUV) {
      uvNode = builder.context.getUV(this);
    }
    const texture2 = this.value;
    if (builder.renderer.coordinateSystem === WebGLCoordinateSystem && texture2.isPMREMTexture !== true && texture2.isRenderTargetTexture === true) {
      uvNode = vec3(uvNode.x.negate(), uvNode.yz);
    }
    let levelNode = this.levelNode;
    if (levelNode === null && builder.context.getTextureLevel) {
      levelNode = builder.context.getTextureLevel(this);
    }
    return textureCubeUV(this._texture, uvNode, levelNode, this._width, this._height, this._maxMip);
  }
};
var pmremTexture = nodeProxy(PMREMNode);
addNodeClass("PMREMNode", PMREMNode);
var PMREMNode_default = PMREMNode;

// node_modules/three/examples/jsm/nodes/lighting/EnvironmentNode.js
var envNodeCache = /* @__PURE__ */ new WeakMap();
var EnvironmentNode = class extends LightingNode_default {
  constructor(envNode = null) {
    super();
    this.envNode = envNode;
  }
  setup(builder) {
    let envNode = this.envNode;
    if (envNode.isTextureNode) {
      let cacheEnvNode = envNodeCache.get(envNode.value);
      if (cacheEnvNode === void 0) {
        cacheEnvNode = pmremTexture(envNode.value);
        envNodeCache.set(envNode.value, cacheEnvNode);
      }
      envNode = cacheEnvNode;
    }
    const { material } = builder;
    const envMap = material.envMap;
    const intensity = envMap ? reference("envMapIntensity", "float", builder.material) : reference("environmentIntensity", "float", builder.scene);
    const useAnisotropy = material.useAnisotropy === true || material.anisotropy > 0;
    const radianceNormalView = useAnisotropy ? transformedBentNormalView : transformedNormalView;
    const radiance = context(envNode, createRadianceContext(roughness, radianceNormalView)).mul(intensity);
    const irradiance = context(envNode, createIrradianceContext(transformedNormalWorld)).mul(Math.PI).mul(intensity);
    const isolateRadiance = cache(radiance);
    builder.context.radiance.addAssign(isolateRadiance);
    builder.context.iblIrradiance.addAssign(irradiance);
    const clearcoatRadiance = builder.context.lightingModel.clearcoatRadiance;
    if (clearcoatRadiance) {
      const clearcoatRadianceContext = context(envNode, createRadianceContext(clearcoatRoughness, transformedClearcoatNormalView)).mul(intensity);
      const isolateClearcoatRadiance = cache(clearcoatRadianceContext);
      clearcoatRadiance.addAssign(isolateClearcoatRadiance);
    }
  }
};
var createRadianceContext = (roughnessNode, normalViewNode) => {
  let reflectVec = null;
  return {
    getUV: () => {
      if (reflectVec === null) {
        reflectVec = positionViewDirection.negate().reflect(normalViewNode);
        reflectVec = roughnessNode.mul(roughnessNode).mix(reflectVec, normalViewNode).normalize();
        reflectVec = reflectVec.transformDirection(cameraViewMatrix);
      }
      return reflectVec;
    },
    getTextureLevel: () => {
      return roughnessNode;
    }
  };
};
var createIrradianceContext = (normalWorldNode) => {
  return {
    getUV: () => {
      return normalWorldNode;
    },
    getTextureLevel: () => {
      return float(1);
    }
  };
};
var EnvironmentNode_default = EnvironmentNode;
addNodeClass("EnvironmentNode", EnvironmentNode);

// node_modules/three/examples/jsm/nodes/lighting/IrradianceNode.js
var IrradianceNode = class extends LightingNode_default {
  constructor(node) {
    super();
    this.node = node;
  }
  setup(builder) {
    builder.context.irradiance.addAssign(this.node);
  }
};
var IrradianceNode_default = IrradianceNode;
addNodeClass("IrradianceNode", IrradianceNode);

// node_modules/three/examples/jsm/nodes/display/ViewportNode.js
var resolution;
var viewportResult;
var ViewportNode = class _ViewportNode extends Node_default {
  constructor(scope) {
    super();
    this.scope = scope;
    this.isViewportNode = true;
  }
  getNodeType() {
    if (this.scope === _ViewportNode.VIEWPORT)
      return "vec4";
    else if (this.scope === _ViewportNode.COORDINATE)
      return "vec3";
    else
      return "vec2";
  }
  getUpdateType() {
    let updateType = NodeUpdateType.NONE;
    if (this.scope === _ViewportNode.RESOLUTION || this.scope === _ViewportNode.VIEWPORT) {
      updateType = NodeUpdateType.RENDER;
    }
    this.updateType = updateType;
    return updateType;
  }
  update({ renderer }) {
    if (this.scope === _ViewportNode.VIEWPORT) {
      renderer.getViewport(viewportResult);
    } else {
      renderer.getDrawingBufferSize(resolution);
    }
  }
  setup() {
    const scope = this.scope;
    let output2 = null;
    if (scope === _ViewportNode.RESOLUTION) {
      output2 = uniform(resolution || (resolution = new Vector2()));
    } else if (scope === _ViewportNode.VIEWPORT) {
      output2 = uniform(viewportResult || (viewportResult = new Vector4()));
    } else {
      output2 = viewportCoordinate.div(viewportResolution);
      let outX = output2.x;
      let outY = output2.y;
      if (/bottom/i.test(scope))
        outY = outY.oneMinus();
      if (/right/i.test(scope))
        outX = outX.oneMinus();
      output2 = vec2(outX, outY);
    }
    return output2;
  }
  generate(builder) {
    if (this.scope === _ViewportNode.COORDINATE) {
      let coord = builder.getFragCoord();
      if (builder.isFlipY()) {
        const resolution2 = builder.getNodeProperties(viewportResolution).outputNode.build(builder);
        coord = `${builder.getType("vec3")}( ${coord}.x, ${resolution2}.y - ${coord}.y, ${coord}.z )`;
      }
      return coord;
    }
    return super.generate(builder);
  }
};
ViewportNode.COORDINATE = "coordinate";
ViewportNode.RESOLUTION = "resolution";
ViewportNode.VIEWPORT = "viewport";
ViewportNode.TOP_LEFT = "topLeft";
ViewportNode.BOTTOM_LEFT = "bottomLeft";
ViewportNode.TOP_RIGHT = "topRight";
ViewportNode.BOTTOM_RIGHT = "bottomRight";
var ViewportNode_default = ViewportNode;
var viewportCoordinate = nodeImmutable(ViewportNode, ViewportNode.COORDINATE);
var viewportResolution = nodeImmutable(ViewportNode, ViewportNode.RESOLUTION);
var viewport = nodeImmutable(ViewportNode, ViewportNode.VIEWPORT);
var viewportTopLeft = nodeImmutable(ViewportNode, ViewportNode.TOP_LEFT);
var viewportBottomLeft = nodeImmutable(ViewportNode, ViewportNode.BOTTOM_LEFT);
var viewportTopRight = nodeImmutable(ViewportNode, ViewportNode.TOP_RIGHT);
var viewportBottomRight = nodeImmutable(ViewportNode, ViewportNode.BOTTOM_RIGHT);
addNodeClass("ViewportNode", ViewportNode);

// node_modules/three/examples/jsm/nodes/display/ViewportTextureNode.js
var _size = new Vector2();
var ViewportTextureNode = class extends TextureNode_default {
  constructor(uvNode = viewportTopLeft, levelNode = null, framebufferTexture = null) {
    if (framebufferTexture === null) {
      framebufferTexture = new FramebufferTexture();
      framebufferTexture.minFilter = LinearMipmapLinearFilter;
    }
    super(framebufferTexture, uvNode, levelNode);
    this.generateMipmaps = false;
    this.isOutputTextureNode = true;
    this.updateBeforeType = NodeUpdateType.FRAME;
  }
  updateBefore(frame) {
    const renderer = frame.renderer;
    renderer.getDrawingBufferSize(_size);
    const framebufferTexture = this.value;
    if (framebufferTexture.image.width !== _size.width || framebufferTexture.image.height !== _size.height) {
      framebufferTexture.image.width = _size.width;
      framebufferTexture.image.height = _size.height;
      framebufferTexture.needsUpdate = true;
    }
    const currentGenerateMipmaps = framebufferTexture.generateMipmaps;
    framebufferTexture.generateMipmaps = this.generateMipmaps;
    renderer.copyFramebufferToTexture(framebufferTexture);
    framebufferTexture.generateMipmaps = currentGenerateMipmaps;
  }
  clone() {
    const viewportTextureNode = new this.constructor(this.uvNode, this.levelNode, this.value);
    viewportTextureNode.generateMipmaps = this.generateMipmaps;
    return viewportTextureNode;
  }
};
var ViewportTextureNode_default = ViewportTextureNode;
var viewportTexture = nodeProxy(ViewportTextureNode);
var viewportMipTexture = nodeProxy(ViewportTextureNode, null, null, { generateMipmaps: true });
addNodeElement("viewportTexture", viewportTexture);
addNodeElement("viewportMipTexture", viewportMipTexture);
addNodeClass("ViewportTextureNode", ViewportTextureNode);

// node_modules/three/examples/jsm/nodes/display/ViewportDepthTextureNode.js
var sharedDepthbuffer = null;
var ViewportDepthTextureNode = class extends ViewportTextureNode_default {
  constructor(uvNode = viewportTopLeft, levelNode = null) {
    if (sharedDepthbuffer === null) {
      sharedDepthbuffer = new DepthTexture();
    }
    super(uvNode, levelNode, sharedDepthbuffer);
  }
};
var ViewportDepthTextureNode_default = ViewportDepthTextureNode;
var viewportDepthTexture = nodeProxy(ViewportDepthTextureNode);
addNodeElement("viewportDepthTexture", viewportDepthTexture);
addNodeClass("ViewportDepthTextureNode", ViewportDepthTextureNode);

// node_modules/three/examples/jsm/nodes/display/ViewportDepthNode.js
var ViewportDepthNode = class _ViewportDepthNode extends Node_default {
  constructor(scope, valueNode = null) {
    super("float");
    this.scope = scope;
    this.valueNode = valueNode;
    this.isViewportDepthNode = true;
  }
  generate(builder) {
    const { scope } = this;
    if (scope === _ViewportDepthNode.DEPTH_PIXEL) {
      return builder.getFragDepth();
    }
    return super.generate(builder);
  }
  setup() {
    const { scope } = this;
    let node = null;
    if (scope === _ViewportDepthNode.DEPTH) {
      node = viewZToOrthographicDepth(positionView.z, cameraNear, cameraFar);
    } else if (scope === _ViewportDepthNode.DEPTH_TEXTURE) {
      const texture2 = this.valueNode || viewportDepthTexture();
      const viewZ = perspectiveDepthToViewZ(texture2, cameraNear, cameraFar);
      node = viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);
    } else if (scope === _ViewportDepthNode.DEPTH_PIXEL) {
      if (this.valueNode !== null) {
        node = depthPixelBase().assign(this.valueNode);
      }
    }
    return node;
  }
};
var viewZToOrthographicDepth = (viewZ, near, far) => viewZ.add(near).div(near.sub(far));
var orthographicDepthToViewZ = (depth2, near, far) => near.sub(far).mul(depth2).sub(near);
var viewZToPerspectiveDepth = (viewZ, near, far) => near.add(viewZ).mul(far).div(far.sub(near).mul(viewZ));
var perspectiveDepthToViewZ = (depth2, near, far) => near.mul(far).div(far.sub(near).mul(depth2).sub(far));
ViewportDepthNode.DEPTH = "depth";
ViewportDepthNode.DEPTH_TEXTURE = "depthTexture";
ViewportDepthNode.DEPTH_PIXEL = "depthPixel";
var ViewportDepthNode_default = ViewportDepthNode;
var depthPixelBase = nodeProxy(ViewportDepthNode, ViewportDepthNode.DEPTH_PIXEL);
var depth = nodeImmutable(ViewportDepthNode, ViewportDepthNode.DEPTH);
var depthTexture = nodeProxy(ViewportDepthNode, ViewportDepthNode.DEPTH_TEXTURE);
var depthPixel = nodeImmutable(ViewportDepthNode, ViewportDepthNode.DEPTH_PIXEL);
depthPixel.assign = (value) => depthPixelBase(value);
addNodeClass("ViewportDepthNode", ViewportDepthNode);

// node_modules/three/examples/jsm/nodes/accessors/ClippingNode.js
var ClippingNode = class _ClippingNode extends Node_default {
  constructor(scope = _ClippingNode.DEFAULT) {
    super();
    this.scope = scope;
  }
  setup(builder) {
    super.setup(builder);
    const clippingContext = builder.clippingContext;
    const { localClipIntersection, localClippingCount, globalClippingCount } = clippingContext;
    const numClippingPlanes = globalClippingCount + localClippingCount;
    const numUnionClippingPlanes = localClipIntersection ? numClippingPlanes - localClippingCount : numClippingPlanes;
    if (this.scope === _ClippingNode.ALPHA_TO_COVERAGE) {
      return this.setupAlphaToCoverage(clippingContext.planes, numClippingPlanes, numUnionClippingPlanes);
    } else {
      return this.setupDefault(clippingContext.planes, numClippingPlanes, numUnionClippingPlanes);
    }
  }
  setupAlphaToCoverage(planes, numClippingPlanes, numUnionClippingPlanes) {
    return tslFn(() => {
      const clippingPlanes = uniforms(planes);
      const distanceToPlane = property("float", "distanceToPlane");
      const distanceGradient = property("float", "distanceToGradient");
      const clipOpacity = property("float", "clipOpacity");
      clipOpacity.assign(1);
      let plane;
      loop(numUnionClippingPlanes, ({ i }) => {
        plane = clippingPlanes.element(i);
        distanceToPlane.assign(positionView.dot(plane.xyz).negate().add(plane.w));
        distanceGradient.assign(distanceToPlane.fwidth().div(2));
        clipOpacity.mulAssign(smoothstep(distanceGradient.negate(), distanceGradient, distanceToPlane));
        clipOpacity.equal(0).discard();
      });
      if (numUnionClippingPlanes < numClippingPlanes) {
        const unionClipOpacity = property("float", "unionclipOpacity");
        unionClipOpacity.assign(1);
        loop({ start: numUnionClippingPlanes, end: numClippingPlanes }, ({ i }) => {
          plane = clippingPlanes.element(i);
          distanceToPlane.assign(positionView.dot(plane.xyz).negate().add(plane.w));
          distanceGradient.assign(distanceToPlane.fwidth().div(2));
          unionClipOpacity.mulAssign(smoothstep(distanceGradient.negate(), distanceGradient, distanceToPlane).oneMinus());
        });
        clipOpacity.mulAssign(unionClipOpacity.oneMinus());
      }
      diffuseColor.a.mulAssign(clipOpacity);
      diffuseColor.a.equal(0).discard();
    })();
  }
  setupDefault(planes, numClippingPlanes, numUnionClippingPlanes) {
    return tslFn(() => {
      const clippingPlanes = uniforms(planes);
      let plane;
      loop(numUnionClippingPlanes, ({ i }) => {
        plane = clippingPlanes.element(i);
        positionView.dot(plane.xyz).greaterThan(plane.w).discard();
      });
      if (numUnionClippingPlanes < numClippingPlanes) {
        const clipped = property("bool", "clipped");
        clipped.assign(true);
        loop({ start: numUnionClippingPlanes, end: numClippingPlanes }, ({ i }) => {
          plane = clippingPlanes.element(i);
          clipped.assign(positionView.dot(plane.xyz).greaterThan(plane.w).and(clipped));
        });
        clipped.discard();
      }
    })();
  }
};
ClippingNode.ALPHA_TO_COVERAGE = "alphaToCoverage";
ClippingNode.DEFAULT = "default";
var clipping = () => nodeObject(new ClippingNode());
var clippingAlpha = () => nodeObject(new ClippingNode(ClippingNode.ALPHA_TO_COVERAGE));

// node_modules/three/examples/jsm/nodes/display/FrontFacingNode.js
var FrontFacingNode = class extends Node_default {
  constructor() {
    super("bool");
    this.isFrontFacingNode = true;
  }
  generate(builder) {
    const { renderer, material } = builder;
    if (renderer.coordinateSystem === WebGLCoordinateSystem) {
      if (material.side === BackSide) {
        return "false";
      }
    }
    return builder.getFrontFacing();
  }
};
var FrontFacingNode_default = FrontFacingNode;
var frontFacing = nodeImmutable(FrontFacingNode);
var faceDirection = float(frontFacing).mul(2).sub(1);
addNodeClass("FrontFacingNode", FrontFacingNode);

// node_modules/three/examples/jsm/nodes/materials/NodeMaterial.js
var NodeMaterials = /* @__PURE__ */ new Map();
var NodeMaterial = class extends Material {
  constructor() {
    super();
    this.isNodeMaterial = true;
    this.type = this.constructor.type;
    this.forceSinglePass = false;
    this.fog = true;
    this.lights = true;
    this.normals = true;
    this.lightsNode = null;
    this.envNode = null;
    this.aoNode = null;
    this.colorNode = null;
    this.normalNode = null;
    this.opacityNode = null;
    this.backdropNode = null;
    this.backdropAlphaNode = null;
    this.alphaTestNode = null;
    this.positionNode = null;
    this.depthNode = null;
    this.shadowNode = null;
    this.shadowPositionNode = null;
    this.outputNode = null;
    this.fragmentNode = null;
    this.vertexNode = null;
  }
  customProgramCacheKey() {
    return this.type + getCacheKey(this);
  }
  build(builder) {
    this.setup(builder);
  }
  setup(builder) {
    builder.addStack();
    builder.stack.outputNode = this.vertexNode || this.setupPosition(builder);
    builder.addFlow("vertex", builder.removeStack());
    builder.addStack();
    let resultNode;
    const clippingNode = this.setupClipping(builder);
    if (this.depthWrite === true)
      this.setupDepth(builder);
    if (this.fragmentNode === null) {
      if (this.normals === true)
        this.setupNormal(builder);
      this.setupDiffuseColor(builder);
      this.setupVariants(builder);
      const outgoingLightNode = this.setupLighting(builder);
      if (clippingNode !== null)
        builder.stack.add(clippingNode);
      const basicOutput = vec4(outgoingLightNode, diffuseColor.a).max(0);
      resultNode = this.setupOutput(builder, basicOutput);
      output.assign(resultNode);
      if (this.outputNode !== null)
        resultNode = this.outputNode;
    } else {
      let fragmentNode = this.fragmentNode;
      if (fragmentNode.isOutputStructNode !== true) {
        fragmentNode = vec4(fragmentNode);
      }
      resultNode = this.setupOutput(builder, fragmentNode);
    }
    builder.stack.outputNode = resultNode;
    builder.addFlow("fragment", builder.removeStack());
  }
  setupClipping(builder) {
    if (builder.clippingContext === null)
      return null;
    const { globalClippingCount, localClippingCount } = builder.clippingContext;
    let result = null;
    if (globalClippingCount || localClippingCount) {
      if (this.alphaToCoverage) {
        result = clippingAlpha();
      } else {
        builder.stack.add(clipping());
      }
    }
    return result;
  }
  setupDepth(builder) {
    const { renderer } = builder;
    let depthNode = this.depthNode;
    if (depthNode === null && renderer.logarithmicDepthBuffer === true) {
      const fragDepth = modelViewProjection().w.add(1);
      depthNode = fragDepth.log2().mul(cameraLogDepth).mul(0.5);
    }
    if (depthNode !== null) {
      depthPixel.assign(depthNode).append();
    }
  }
  setupPosition(builder) {
    const { object } = builder;
    const geometry = object.geometry;
    builder.addStack();
    if (geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color) {
      morphReference(object).append();
    }
    if (object.isSkinnedMesh === true) {
      skinningReference(object).append();
    }
    if (this.displacementMap) {
      const displacementMap = materialReference("displacementMap", "texture");
      const displacementScale = materialReference("displacementScale", "float");
      const displacementBias = materialReference("displacementBias", "float");
      positionLocal.addAssign(normalLocal.normalize().mul(displacementMap.x.mul(displacementScale).add(displacementBias)));
    }
    if (object.isBatchedMesh) {
      batch(object).append();
    }
    if (object.instanceMatrix && object.instanceMatrix.isInstancedBufferAttribute === true && builder.isAvailable("instance") === true) {
      instance(object).append();
    }
    if (this.positionNode !== null) {
      positionLocal.assign(this.positionNode);
    }
    const mvp = modelViewProjection();
    builder.context.vertex = builder.removeStack();
    builder.context.mvp = mvp;
    return mvp;
  }
  setupDiffuseColor({ object, geometry }) {
    let colorNode = this.colorNode ? vec4(this.colorNode) : materialColor;
    if (this.vertexColors === true && geometry.hasAttribute("color")) {
      colorNode = vec4(colorNode.xyz.mul(attribute("color", "vec3")), colorNode.a);
    }
    if (object.instanceColor) {
      const instanceColor = varyingProperty("vec3", "vInstanceColor");
      colorNode = instanceColor.mul(colorNode);
    }
    diffuseColor.assign(colorNode);
    const opacityNode = this.opacityNode ? float(this.opacityNode) : materialOpacity;
    diffuseColor.a.assign(diffuseColor.a.mul(opacityNode));
    if (this.alphaTestNode !== null || this.alphaTest > 0) {
      const alphaTestNode = this.alphaTestNode !== null ? float(this.alphaTestNode) : materialAlphaTest;
      diffuseColor.a.lessThanEqual(alphaTestNode).discard();
    }
  }
  setupVariants() {
  }
  setupNormal() {
    if (this.flatShading === true) {
      const normalNode = positionView.dFdx().cross(positionView.dFdy()).normalize();
      transformedNormalView.assign(normalNode.mul(faceDirection));
    } else {
      const normalNode = this.normalNode ? vec3(this.normalNode) : materialNormal;
      transformedNormalView.assign(normalNode.mul(faceDirection));
    }
  }
  getEnvNode(builder) {
    let node = null;
    if (this.envNode) {
      node = this.envNode;
    } else if (this.envMap) {
      node = this.envMap.isCubeTexture ? cubeTexture(this.envMap) : texture(this.envMap);
    } else if (builder.environmentNode) {
      node = builder.environmentNode;
    }
    return node;
  }
  setupLights(builder) {
    const envNode = this.getEnvNode(builder);
    const materialLightsNode = [];
    if (envNode) {
      materialLightsNode.push(new EnvironmentNode_default(envNode));
    }
    if (builder.material.lightMap) {
      materialLightsNode.push(new IrradianceNode_default(materialReference("lightMap", "texture")));
    }
    if (this.aoNode !== null || builder.material.aoMap) {
      const aoNode = this.aoNode !== null ? this.aoNode : texture(builder.material.aoMap);
      materialLightsNode.push(new AONode_default(aoNode));
    }
    let lightsN = this.lightsNode || builder.lightsNode;
    if (materialLightsNode.length > 0) {
      lightsN = lightsNode([...lightsN.lightNodes, ...materialLightsNode]);
    }
    return lightsN;
  }
  setupLightingModel() {
  }
  setupLighting(builder) {
    const { material } = builder;
    const { backdropNode, backdropAlphaNode, emissiveNode } = this;
    const lights2 = this.lights === true || this.lightsNode !== null;
    const lightsNode2 = lights2 ? this.setupLights(builder) : null;
    let outgoingLightNode = diffuseColor.rgb;
    if (lightsNode2 && lightsNode2.hasLight !== false) {
      const lightingModel = this.setupLightingModel(builder);
      outgoingLightNode = lightingContext(lightsNode2, lightingModel, backdropNode, backdropAlphaNode);
    } else if (backdropNode !== null) {
      outgoingLightNode = vec3(backdropAlphaNode !== null ? mix(outgoingLightNode, backdropNode, backdropAlphaNode) : backdropNode);
    }
    if (emissiveNode && emissiveNode.isNode === true || material.emissive && material.emissive.isColor === true) {
      outgoingLightNode = outgoingLightNode.add(vec3(emissiveNode ? emissiveNode : materialEmissive));
    }
    return outgoingLightNode;
  }
  setupOutput(builder, outputNode) {
    const fogNode = builder.fogNode;
    if (fogNode)
      outputNode = vec4(fogNode.mix(outputNode.rgb, fogNode.colorNode), outputNode.a);
    return outputNode;
  }
  setDefaultValues(material) {
    for (const property2 in material) {
      const value = material[property2];
      if (this[property2] === void 0) {
        this[property2] = value;
        if (value && value.clone)
          this[property2] = value.clone();
      }
    }
    const descriptors = Object.getOwnPropertyDescriptors(material.constructor.prototype);
    for (const key in descriptors) {
      if (Object.getOwnPropertyDescriptor(this.constructor.prototype, key) === void 0 && descriptors[key].get !== void 0) {
        Object.defineProperty(this.constructor.prototype, key, descriptors[key]);
      }
    }
  }
  toJSON(meta) {
    const isRoot = meta === void 0 || typeof meta === "string";
    if (isRoot) {
      meta = {
        textures: {},
        images: {},
        nodes: {}
      };
    }
    const data = Material.prototype.toJSON.call(this, meta);
    const nodeChildren = getNodeChildren(this);
    data.inputNodes = {};
    for (const { property: property2, childNode } of nodeChildren) {
      data.inputNodes[property2] = childNode.toJSON(meta).uuid;
    }
    function extractFromCache(cache2) {
      const values = [];
      for (const key in cache2) {
        const data2 = cache2[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const nodes = extractFromCache(meta.nodes);
      if (textures.length > 0)
        data.textures = textures;
      if (images.length > 0)
        data.images = images;
      if (nodes.length > 0)
        data.nodes = nodes;
    }
    return data;
  }
  copy(source) {
    this.lightsNode = source.lightsNode;
    this.envNode = source.envNode;
    this.colorNode = source.colorNode;
    this.normalNode = source.normalNode;
    this.opacityNode = source.opacityNode;
    this.backdropNode = source.backdropNode;
    this.backdropAlphaNode = source.backdropAlphaNode;
    this.alphaTestNode = source.alphaTestNode;
    this.positionNode = source.positionNode;
    this.depthNode = source.depthNode;
    this.shadowNode = source.shadowNode;
    this.shadowPositionNode = source.shadowPositionNode;
    this.outputNode = source.outputNode;
    this.fragmentNode = source.fragmentNode;
    this.vertexNode = source.vertexNode;
    return super.copy(source);
  }
  static fromMaterial(material) {
    if (material.isNodeMaterial === true) {
      return material;
    }
    const type = material.type.replace("Material", "NodeMaterial");
    const nodeMaterial = createNodeMaterialFromType(type);
    if (nodeMaterial === void 0) {
      throw new Error(`NodeMaterial: Material "${material.type}" is not compatible.`);
    }
    for (const key in material) {
      nodeMaterial[key] = material[key];
    }
    return nodeMaterial;
  }
};
var NodeMaterial_default = NodeMaterial;
function addNodeMaterial(type, nodeMaterial) {
  if (typeof nodeMaterial !== "function" || !type)
    throw new Error(`Node material ${type} is not a class`);
  if (NodeMaterials.has(type)) {
    console.warn(`Redefinition of node material ${type}`);
    return;
  }
  NodeMaterials.set(type, nodeMaterial);
  nodeMaterial.type = type;
}
function createNodeMaterialFromType(type) {
  const Material2 = NodeMaterials.get(type);
  if (Material2 !== void 0) {
    return new Material2();
  }
}
addNodeMaterial("NodeMaterial", NodeMaterial);

// node_modules/three/examples/jsm/renderers/common/Uniform.js
var Uniform = class {
  constructor(name, value) {
    this.name = name;
    this.value = value;
    this.boundary = 0;
    this.itemSize = 0;
    this.offset = 0;
  }
  setValue(value) {
    this.value = value;
  }
  getValue() {
    return this.value;
  }
};
var FloatUniform = class extends Uniform {
  constructor(name, value = 0) {
    super(name, value);
    this.isFloatUniform = true;
    this.boundary = 4;
    this.itemSize = 1;
  }
};
var Vector2Uniform = class extends Uniform {
  constructor(name, value = new Vector2()) {
    super(name, value);
    this.isVector2Uniform = true;
    this.boundary = 8;
    this.itemSize = 2;
  }
};
var Vector3Uniform = class extends Uniform {
  constructor(name, value = new Vector3()) {
    super(name, value);
    this.isVector3Uniform = true;
    this.boundary = 16;
    this.itemSize = 3;
  }
};
var Vector4Uniform = class extends Uniform {
  constructor(name, value = new Vector4()) {
    super(name, value);
    this.isVector4Uniform = true;
    this.boundary = 16;
    this.itemSize = 4;
  }
};
var ColorUniform = class extends Uniform {
  constructor(name, value = new Color()) {
    super(name, value);
    this.isColorUniform = true;
    this.boundary = 16;
    this.itemSize = 3;
  }
};
var Matrix3Uniform = class extends Uniform {
  constructor(name, value = new Matrix3()) {
    super(name, value);
    this.isMatrix3Uniform = true;
    this.boundary = 48;
    this.itemSize = 12;
  }
};
var Matrix4Uniform = class extends Uniform {
  constructor(name, value = new Matrix4()) {
    super(name, value);
    this.isMatrix4Uniform = true;
    this.boundary = 64;
    this.itemSize = 16;
  }
};

// node_modules/three/examples/jsm/renderers/common/nodes/NodeUniform.js
var FloatNodeUniform = class extends FloatUniform {
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  getValue() {
    return this.nodeUniform.value;
  }
};
var Vector2NodeUniform = class extends Vector2Uniform {
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  getValue() {
    return this.nodeUniform.value;
  }
};
var Vector3NodeUniform = class extends Vector3Uniform {
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  getValue() {
    return this.nodeUniform.value;
  }
};
var Vector4NodeUniform = class extends Vector4Uniform {
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  getValue() {
    return this.nodeUniform.value;
  }
};
var ColorNodeUniform = class extends ColorUniform {
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  getValue() {
    return this.nodeUniform.value;
  }
};
var Matrix3NodeUniform = class extends Matrix3Uniform {
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  getValue() {
    return this.nodeUniform.value;
  }
};
var Matrix4NodeUniform = class extends Matrix4Uniform {
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  getValue() {
    return this.nodeUniform.value;
  }
};

// node_modules/three/examples/jsm/nodes/core/StackNode.js
var StackNode = class extends Node_default {
  constructor(parent = null) {
    super();
    this.nodes = [];
    this.outputNode = null;
    this.parent = parent;
    this._currentCond = null;
    this.isStackNode = true;
  }
  getNodeType(builder) {
    return this.outputNode ? this.outputNode.getNodeType(builder) : "void";
  }
  add(node) {
    this.nodes.push(node);
    return this;
  }
  if(boolNode, method) {
    const methodNode = new ShaderNode(method);
    this._currentCond = cond(boolNode, methodNode);
    return this.add(this._currentCond);
  }
  elseif(boolNode, method) {
    const methodNode = new ShaderNode(method);
    const ifNode = cond(boolNode, methodNode);
    this._currentCond.elseNode = ifNode;
    this._currentCond = ifNode;
    return this;
  }
  else(method) {
    this._currentCond.elseNode = new ShaderNode(method);
    return this;
  }
  build(builder, ...params) {
    const previousStack = getCurrentStack();
    setCurrentStack(this);
    for (const node of this.nodes) {
      node.build(builder, "void");
    }
    setCurrentStack(previousStack);
    return this.outputNode ? this.outputNode.build(builder, ...params) : super.build(builder, ...params);
  }
};
var StackNode_default = StackNode;
var stack = nodeProxy(StackNode);
addNodeClass("StackNode", StackNode);

// node_modules/three/examples/jsm/nodes/utils/EquirectUVNode.js
var EquirectUVNode = class extends TempNode_default {
  constructor(dirNode = positionWorldDirection) {
    super("vec2");
    this.dirNode = dirNode;
  }
  setup() {
    const dir = this.dirNode;
    const u = dir.z.atan2(dir.x).mul(1 / (Math.PI * 2)).add(0.5);
    const v = dir.y.clamp(-1, 1).asin().mul(1 / Math.PI).add(0.5);
    return vec2(u, v);
  }
};
var EquirectUVNode_default = EquirectUVNode;
var equirectUV = nodeProxy(EquirectUVNode);
addNodeClass("EquirectUVNode", EquirectUVNode);

// node_modules/three/examples/jsm/renderers/common/CubeRenderTarget.js
var CubeRenderTarget = class extends WebGLCubeRenderTarget {
  constructor(size = 1, options = {}) {
    super(size, options);
    this.isCubeRenderTarget = true;
  }
  fromEquirectangularTexture(renderer, texture2) {
    const currentMinFilter = texture2.minFilter;
    const currentGenerateMipmaps = texture2.generateMipmaps;
    texture2.generateMipmaps = true;
    this.texture.type = texture2.type;
    this.texture.colorSpace = texture2.colorSpace;
    this.texture.generateMipmaps = texture2.generateMipmaps;
    this.texture.minFilter = texture2.minFilter;
    this.texture.magFilter = texture2.magFilter;
    const geometry = new BoxGeometry(5, 5, 5);
    const uvNode = equirectUV(positionWorldDirection);
    const material = createNodeMaterialFromType("MeshBasicNodeMaterial");
    material.colorNode = texture(texture2, uvNode, 0);
    material.side = BackSide;
    material.blending = NoBlending;
    const mesh = new Mesh(geometry, material);
    const scene = new Scene();
    scene.add(mesh);
    if (texture2.minFilter === LinearMipmapLinearFilter)
      texture2.minFilter = LinearFilter;
    const camera = new CubeCamera(1, 10, this);
    camera.update(renderer, scene);
    texture2.minFilter = currentMinFilter;
    texture2.currentGenerateMipmaps = currentGenerateMipmaps;
    mesh.geometry.dispose();
    mesh.material.dispose();
    return this;
  }
};
var CubeRenderTarget_default = CubeRenderTarget;

// node_modules/three/examples/jsm/renderers/common/ChainMap.js
var ChainMap = class {
  constructor() {
    this.weakMap = /* @__PURE__ */ new WeakMap();
  }
  get(keys) {
    let map = this.weakMap;
    for (let i = 0; i < keys.length; i++) {
      map = map.get(keys[i]);
      if (map === void 0)
        return void 0;
    }
    return map.get(keys[keys.length - 1]);
  }
  set(keys, value) {
    let map = this.weakMap;
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if (map.has(key) === false)
        map.set(key, /* @__PURE__ */ new WeakMap());
      map = map.get(key);
    }
    return map.set(keys[keys.length - 1], value);
  }
  delete(keys) {
    let map = this.weakMap;
    for (let i = 0; i < keys.length; i++) {
      map = map.get(keys[i]);
      if (map === void 0)
        return false;
    }
    return map.delete(keys[keys.length - 1]);
  }
};

// node_modules/three/examples/jsm/renderers/common/extras/PMREMGenerator.js
var LOD_MIN = 4;
var EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
var MAX_SAMPLES = 20;
var _flatCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
var _cubeCamera = new PerspectiveCamera(90, 1);
var _clearColor = new Color();
var _oldTarget = null;
var _oldActiveCubeFace = 0;
var _oldActiveMipmapLevel = 0;
var PHI = (1 + Math.sqrt(5)) / 2;
var INV_PHI = 1 / PHI;
var _axisDirections = [
  new Vector3(-PHI, INV_PHI, 0),
  new Vector3(PHI, INV_PHI, 0),
  new Vector3(-INV_PHI, 0, PHI),
  new Vector3(INV_PHI, 0, PHI),
  new Vector3(0, PHI, -INV_PHI),
  new Vector3(0, PHI, INV_PHI),
  new Vector3(-1, 1, -1),
  new Vector3(1, 1, -1),
  new Vector3(-1, 1, 1),
  new Vector3(1, 1, 1)
];
var _faceLib = [
  3,
  1,
  5,
  0,
  4,
  2
];
var direction = getDirection(uv(), attribute("faceIndex")).normalize();
var outputDirection = vec3(direction.x, direction.y.negate(), direction.z);
var PMREMGenerator = class {
  constructor(renderer) {
    this._renderer = renderer;
    this._pingPongRenderTarget = null;
    this._lodMax = 0;
    this._cubeSize = 0;
    this._lodPlanes = [];
    this._sizeLods = [];
    this._sigmas = [];
    this._lodMeshes = [];
    this._blurMaterial = null;
    this._cubemapMaterial = null;
    this._equirectMaterial = null;
    this._backgroundBox = null;
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(scene, sigma = 0, near = 0.1, far = 100) {
    _oldTarget = this._renderer.getRenderTarget();
    _oldActiveCubeFace = this._renderer.getActiveCubeFace();
    _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
    this._setSize(256);
    const cubeUVRenderTarget = this._allocateTargets();
    cubeUVRenderTarget.depthBuffer = true;
    this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
    if (sigma > 0) {
      this._blur(cubeUVRenderTarget, 0, 0, sigma);
    }
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromEquirectangular(equirectangular, renderTarget = null) {
    return this._fromTexture(equirectangular, renderTarget);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromCubemap(cubemap, renderTarget = null) {
    return this._fromTexture(cubemap, renderTarget);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    if (this._cubemapMaterial === null) {
      this._cubemapMaterial = _getCubemapMaterial();
      this._compileMaterial(this._cubemapMaterial);
    }
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    if (this._equirectMaterial === null) {
      this._equirectMaterial = _getEquirectMaterial();
      this._compileMaterial(this._equirectMaterial);
    }
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose();
    if (this._cubemapMaterial !== null)
      this._cubemapMaterial.dispose();
    if (this._equirectMaterial !== null)
      this._equirectMaterial.dispose();
    if (this._backgroundBox !== null) {
      this._backgroundBox.geometry.dispose();
      this._backgroundBox.material.dispose();
    }
  }
  // private interface
  _setSize(cubeSize) {
    this._lodMax = Math.floor(Math.log2(cubeSize));
    this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    if (this._blurMaterial !== null)
      this._blurMaterial.dispose();
    if (this._pingPongRenderTarget !== null)
      this._pingPongRenderTarget.dispose();
    for (let i = 0; i < this._lodPlanes.length; i++) {
      this._lodPlanes[i].dispose();
    }
  }
  _cleanup(outputTarget) {
    this._renderer.setRenderTarget(_oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel);
    outputTarget.scissorTest = false;
    _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
  }
  _fromTexture(texture2, renderTarget) {
    if (texture2.mapping === CubeReflectionMapping || texture2.mapping === CubeRefractionMapping) {
      this._setSize(texture2.image.length === 0 ? 16 : texture2.image[0].width || texture2.image[0].image.width);
    } else {
      this._setSize(texture2.image.width / 4);
    }
    _oldTarget = this._renderer.getRenderTarget();
    _oldActiveCubeFace = this._renderer.getActiveCubeFace();
    _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
    const cubeUVRenderTarget = renderTarget || this._allocateTargets();
    this._textureToCubeUV(texture2, cubeUVRenderTarget);
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  _allocateTargets() {
    const width = 3 * Math.max(this._cubeSize, 16 * 7);
    const height = 4 * this._cubeSize;
    const params = {
      magFilter: LinearFilter,
      minFilter: LinearFilter,
      generateMipmaps: false,
      type: HalfFloatType,
      format: RGBAFormat,
      colorSpace: LinearSRGBColorSpace
      //depthBuffer: false
    };
    const cubeUVRenderTarget = _createRenderTarget(width, height, params);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height) {
      if (this._pingPongRenderTarget !== null) {
        this._dispose();
      }
      this._pingPongRenderTarget = _createRenderTarget(width, height, params);
      const { _lodMax } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas, lodMeshes: this._lodMeshes } = _createPlanes(_lodMax));
      this._blurMaterial = _getBlurShader(_lodMax, width, height);
    }
    return cubeUVRenderTarget;
  }
  _compileMaterial(material) {
    const tmpMesh = this._lodMeshes[0];
    tmpMesh.material = material;
    this._renderer.compile(tmpMesh, _flatCamera);
  }
  _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
    const cubeCamera = _cubeCamera;
    cubeCamera.near = near;
    cubeCamera.far = far;
    const upSign = [-1, 1, -1, -1, -1, -1];
    const forwardSign = [1, 1, 1, -1, -1, -1];
    const renderer = this._renderer;
    const originalAutoClear = renderer.autoClear;
    renderer.getClearColor(_clearColor);
    renderer.autoClear = false;
    let backgroundBox = this._backgroundBox;
    if (backgroundBox === null) {
      const backgroundMaterial = new MeshBasicMaterial({
        name: "PMREM.Background",
        side: BackSide,
        depthWrite: false,
        depthTest: false
      });
      backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
    }
    let useSolidColor = false;
    const background = scene.background;
    if (background) {
      if (background.isColor) {
        backgroundBox.material.color.copy(background);
        scene.background = null;
        useSolidColor = true;
      }
    } else {
      backgroundBox.material.color.copy(_clearColor);
      useSolidColor = true;
    }
    renderer.setRenderTarget(cubeUVRenderTarget);
    renderer.clear();
    if (useSolidColor) {
      renderer.render(backgroundBox, cubeCamera);
    }
    for (let i = 0; i < 6; i++) {
      const col = i % 3;
      if (col === 0) {
        cubeCamera.up.set(0, upSign[i], 0);
        cubeCamera.lookAt(forwardSign[i], 0, 0);
      } else if (col === 1) {
        cubeCamera.up.set(0, 0, upSign[i]);
        cubeCamera.lookAt(0, forwardSign[i], 0);
      } else {
        cubeCamera.up.set(0, upSign[i], 0);
        cubeCamera.lookAt(0, 0, forwardSign[i]);
      }
      const size = this._cubeSize;
      _setViewport(cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size);
      renderer.render(scene, cubeCamera);
    }
    renderer.autoClear = originalAutoClear;
    scene.background = background;
  }
  _textureToCubeUV(texture2, cubeUVRenderTarget) {
    const renderer = this._renderer;
    const isCubeTexture = texture2.mapping === CubeReflectionMapping || texture2.mapping === CubeRefractionMapping;
    if (isCubeTexture) {
      if (this._cubemapMaterial === null) {
        this._cubemapMaterial = _getCubemapMaterial(texture2);
      }
    } else {
      if (this._equirectMaterial === null) {
        this._equirectMaterial = _getEquirectMaterial(texture2);
      }
    }
    const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
    material.fragmentNode.value = texture2;
    const mesh = this._lodMeshes[0];
    mesh.material = material;
    const size = this._cubeSize;
    _setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);
    renderer.setRenderTarget(cubeUVRenderTarget);
    renderer.render(mesh, _flatCamera);
  }
  _applyPMREM(cubeUVRenderTarget) {
    const renderer = this._renderer;
    const autoClear = renderer.autoClear;
    renderer.autoClear = false;
    const n = this._lodPlanes.length;
    for (let i = 1; i < n; i++) {
      const sigma = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]);
      const poleAxis = _axisDirections[(n - i - 1) % _axisDirections.length];
      this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);
    }
    renderer.autoClear = autoClear;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
    const pingPongRenderTarget = this._pingPongRenderTarget;
    this._halfBlur(
      cubeUVRenderTarget,
      pingPongRenderTarget,
      lodIn,
      lodOut,
      sigma,
      "latitudinal",
      poleAxis
    );
    this._halfBlur(
      pingPongRenderTarget,
      cubeUVRenderTarget,
      lodOut,
      lodOut,
      sigma,
      "longitudinal",
      poleAxis
    );
  }
  _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction2, poleAxis) {
    const renderer = this._renderer;
    const blurMaterial = this._blurMaterial;
    if (direction2 !== "latitudinal" && direction2 !== "longitudinal") {
      console.error("blur direction must be either latitudinal or longitudinal!");
    }
    const STANDARD_DEVIATIONS = 3;
    const blurMesh = this._lodMeshes[lodOut];
    blurMesh.material = blurMaterial;
    const blurUniforms = blurMaterial.uniforms;
    const pixels = this._sizeLods[lodIn] - 1;
    const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
    const sigmaPixels = sigmaRadians / radiansPerPixel;
    const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
    if (samples > MAX_SAMPLES) {
      console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
    }
    const weights = [];
    let sum = 0;
    for (let i = 0; i < MAX_SAMPLES; ++i) {
      const x2 = i / sigmaPixels;
      const weight = Math.exp(-x2 * x2 / 2);
      weights.push(weight);
      if (i === 0) {
        sum += weight;
      } else if (i < samples) {
        sum += 2 * weight;
      }
    }
    for (let i = 0; i < weights.length; i++) {
      weights[i] = weights[i] / sum;
    }
    targetIn.texture.frame = (targetIn.texture.frame || 0) + 1;
    blurUniforms.envMap.value = targetIn.texture;
    blurUniforms.samples.value = samples;
    blurUniforms.weights.array = weights;
    blurUniforms.latitudinal.value = direction2 === "latitudinal" ? 1 : 0;
    if (poleAxis) {
      blurUniforms.poleAxis.value = poleAxis;
    }
    const { _lodMax } = this;
    blurUniforms.dTheta.value = radiansPerPixel;
    blurUniforms.mipInt.value = _lodMax - lodIn;
    const outputSize = this._sizeLods[lodOut];
    const x = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);
    const y = 4 * (this._cubeSize - outputSize);
    _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);
    renderer.setRenderTarget(targetOut);
    renderer.render(blurMesh, _flatCamera);
  }
};
function _createPlanes(lodMax) {
  const lodPlanes = [];
  const sizeLods = [];
  const sigmas = [];
  const lodMeshes = [];
  let lod = lodMax;
  const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
  for (let i = 0; i < totalLods; i++) {
    const sizeLod = Math.pow(2, lod);
    sizeLods.push(sizeLod);
    let sigma = 1 / sizeLod;
    if (i > lodMax - LOD_MIN) {
      sigma = EXTRA_LOD_SIGMA[i - lodMax + LOD_MIN - 1];
    } else if (i === 0) {
      sigma = 0;
    }
    sigmas.push(sigma);
    const texelSize = 1 / (sizeLod - 2);
    const min3 = -texelSize;
    const max3 = 1 + texelSize;
    const uv1 = [min3, min3, max3, min3, max3, max3, min3, min3, max3, max3, min3, max3];
    const cubeFaces = 6;
    const vertices = 6;
    const positionSize = 3;
    const uvSize = 2;
    const faceIndexSize = 1;
    const position = new Float32Array(positionSize * vertices * cubeFaces);
    const uv2 = new Float32Array(uvSize * vertices * cubeFaces);
    const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
    for (let face = 0; face < cubeFaces; face++) {
      const x = face % 3 * 2 / 3 - 1;
      const y = face > 2 ? 0 : -1;
      const coordinates = [
        x,
        y,
        0,
        x + 2 / 3,
        y,
        0,
        x + 2 / 3,
        y + 1,
        0,
        x,
        y,
        0,
        x + 2 / 3,
        y + 1,
        0,
        x,
        y + 1,
        0
      ];
      const faceIdx = _faceLib[face];
      position.set(coordinates, positionSize * vertices * faceIdx);
      uv2.set(uv1, uvSize * vertices * faceIdx);
      const fill = [faceIdx, faceIdx, faceIdx, faceIdx, faceIdx, faceIdx];
      faceIndex.set(fill, faceIndexSize * vertices * faceIdx);
    }
    const planes = new BufferGeometry();
    planes.setAttribute("position", new BufferAttribute(position, positionSize));
    planes.setAttribute("uv", new BufferAttribute(uv2, uvSize));
    planes.setAttribute("faceIndex", new BufferAttribute(faceIndex, faceIndexSize));
    lodPlanes.push(planes);
    lodMeshes.push(new Mesh(planes, null));
    if (lod > LOD_MIN) {
      lod--;
    }
  }
  return { lodPlanes, sizeLods, sigmas, lodMeshes };
}
function _createRenderTarget(width, height, params) {
  const cubeUVRenderTarget = new RenderTarget(width, height, params);
  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
  cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
  cubeUVRenderTarget.texture.isPMREMTexture = true;
  cubeUVRenderTarget.scissorTest = true;
  return cubeUVRenderTarget;
}
function _setViewport(target, x, y, width, height) {
  const viewY = target.height - height - y;
  target.viewport.set(x, viewY, width, height);
  target.scissor.set(x, viewY, width, height);
}
function _getMaterial() {
  const material = new NodeMaterial_default();
  material.depthTest = false;
  material.depthWrite = false;
  material.blending = NoBlending;
  return material;
}
function _getBlurShader(lodMax, width, height) {
  const weights = uniforms(new Array(MAX_SAMPLES).fill(0));
  const poleAxis = uniform(new Vector3(0, 1, 0));
  const dTheta = uniform(0);
  const n = float(MAX_SAMPLES);
  const latitudinal = uniform(0);
  const samples = uniform(1);
  const envMap = texture(null);
  const mipInt = uniform(0);
  const CUBEUV_TEXEL_WIDTH = float(1 / width);
  const CUBEUV_TEXEL_HEIGHT = float(1 / height);
  const CUBEUV_MAX_MIP = float(lodMax);
  const materialUniforms = {
    n,
    latitudinal,
    weights,
    poleAxis,
    outputDirection,
    dTheta,
    samples,
    envMap,
    mipInt,
    CUBEUV_TEXEL_WIDTH,
    CUBEUV_TEXEL_HEIGHT,
    CUBEUV_MAX_MIP
  };
  const material = _getMaterial();
  material.uniforms = materialUniforms;
  material.fragmentNode = blur({ ...materialUniforms, latitudinal: latitudinal.equal(1) });
  return material;
}
function _getCubemapMaterial(envTexture) {
  const material = _getMaterial();
  material.fragmentNode = cubeTexture(envTexture, outputDirection);
  return material;
}
function _getEquirectMaterial(envTexture) {
  const material = _getMaterial();
  material.fragmentNode = texture(envTexture, equirectUV(outputDirection), 0);
  return material;
}
var PMREMGenerator_default = PMREMGenerator;

// node_modules/three/examples/jsm/nodes/core/NodeBuilder.js
var uniformsGroupCache = new ChainMap();
var typeFromLength = /* @__PURE__ */ new Map([
  [2, "vec2"],
  [3, "vec3"],
  [4, "vec4"],
  [9, "mat3"],
  [16, "mat4"]
]);
var typeFromArray = /* @__PURE__ */ new Map([
  [Int8Array, "int"],
  [Int16Array, "int"],
  [Int32Array, "int"],
  [Uint8Array, "uint"],
  [Uint16Array, "uint"],
  [Uint32Array, "uint"],
  [Float32Array, "float"]
]);
var toFloat = (value) => {
  value = Number(value);
  return value + (value % 1 ? "" : ".0");
};
var NodeBuilder = class {
  constructor(object, renderer, parser, scene = null, material = null) {
    this.object = object;
    this.material = material || object && object.material || null;
    this.geometry = object && object.geometry || null;
    this.renderer = renderer;
    this.parser = parser;
    this.scene = scene;
    this.nodes = [];
    this.updateNodes = [];
    this.updateBeforeNodes = [];
    this.hashNodes = {};
    this.lightsNode = null;
    this.environmentNode = null;
    this.fogNode = null;
    this.clippingContext = null;
    this.vertexShader = null;
    this.fragmentShader = null;
    this.computeShader = null;
    this.flowNodes = { vertex: [], fragment: [], compute: [] };
    this.flowCode = { vertex: "", fragment: "", compute: "" };
    this.uniforms = { vertex: [], fragment: [], compute: [], index: 0 };
    this.structs = { vertex: [], fragment: [], compute: [], index: 0 };
    this.bindings = { vertex: [], fragment: [], compute: [] };
    this.bindingsOffset = { vertex: 0, fragment: 0, compute: 0 };
    this.bindingsArray = null;
    this.attributes = [];
    this.bufferAttributes = [];
    this.varyings = [];
    this.codes = {};
    this.vars = {};
    this.flow = { code: "" };
    this.chaining = [];
    this.stack = stack();
    this.stacks = [];
    this.tab = "	";
    this.currentFunctionNode = null;
    this.context = {
      keywords: new NodeKeywords_default(),
      material: this.material
    };
    this.cache = new NodeCache_default();
    this.globalCache = this.cache;
    this.flowsData = /* @__PURE__ */ new WeakMap();
    this.shaderStage = null;
    this.buildStage = null;
  }
  createRenderTarget(width, height, options) {
    return new RenderTarget(width, height, options);
  }
  createCubeRenderTarget(size, options) {
    return new CubeRenderTarget_default(size, options);
  }
  createPMREMGenerator() {
    return new PMREMGenerator_default(this.renderer);
  }
  includes(node) {
    return this.nodes.includes(node);
  }
  _getSharedBindings(bindings) {
    const shared = [];
    for (const binding of bindings) {
      if (binding.shared === true) {
        const nodes = binding.getNodes();
        let sharedBinding = uniformsGroupCache.get(nodes);
        if (sharedBinding === void 0) {
          uniformsGroupCache.set(nodes, binding);
          sharedBinding = binding;
        }
        shared.push(sharedBinding);
      } else {
        shared.push(binding);
      }
    }
    return shared;
  }
  getBindings() {
    let bindingsArray = this.bindingsArray;
    if (bindingsArray === null) {
      const bindings = this.bindings;
      this.bindingsArray = bindingsArray = this._getSharedBindings(this.material !== null ? [...bindings.vertex, ...bindings.fragment] : bindings.compute);
    }
    return bindingsArray;
  }
  setHashNode(node, hash2) {
    this.hashNodes[hash2] = node;
  }
  addNode(node) {
    if (this.nodes.includes(node) === false) {
      this.nodes.push(node);
      this.setHashNode(node, node.getHash(this));
    }
  }
  buildUpdateNodes() {
    for (const node of this.nodes) {
      const updateType = node.getUpdateType();
      const updateBeforeType = node.getUpdateBeforeType();
      if (updateType !== NodeUpdateType.NONE) {
        this.updateNodes.push(node.getSelf());
      }
      if (updateBeforeType !== NodeUpdateType.NONE) {
        this.updateBeforeNodes.push(node);
      }
    }
  }
  get currentNode() {
    return this.chaining[this.chaining.length - 1];
  }
  addChain(node) {
    this.chaining.push(node);
  }
  removeChain(node) {
    const lastChain = this.chaining.pop();
    if (lastChain !== node) {
      throw new Error("NodeBuilder: Invalid node chaining!");
    }
  }
  getMethod(method) {
    return method;
  }
  getNodeFromHash(hash2) {
    return this.hashNodes[hash2];
  }
  addFlow(shaderStage, node) {
    this.flowNodes[shaderStage].push(node);
    return node;
  }
  setContext(context2) {
    this.context = context2;
  }
  getContext() {
    return this.context;
  }
  setCache(cache2) {
    this.cache = cache2;
  }
  getCache() {
    return this.cache;
  }
  isAvailable() {
    return false;
  }
  getVertexIndex() {
    console.warn("Abstract function.");
  }
  getInstanceIndex() {
    console.warn("Abstract function.");
  }
  getFrontFacing() {
    console.warn("Abstract function.");
  }
  getFragCoord() {
    console.warn("Abstract function.");
  }
  isFlipY() {
    return false;
  }
  generateTexture() {
    console.warn("Abstract function.");
  }
  generateTextureLod() {
    console.warn("Abstract function.");
  }
  generateConst(type, value = null) {
    if (value === null) {
      if (type === "float" || type === "int" || type === "uint")
        value = 0;
      else if (type === "bool")
        value = false;
      else if (type === "color")
        value = new Color();
      else if (type === "vec2")
        value = new Vector2();
      else if (type === "vec3")
        value = new Vector3();
      else if (type === "vec4")
        value = new Vector4();
    }
    if (type === "float")
      return toFloat(value);
    if (type === "int")
      return `${Math.round(value)}`;
    if (type === "uint")
      return value >= 0 ? `${Math.round(value)}u` : "0u";
    if (type === "bool")
      return value ? "true" : "false";
    if (type === "color")
      return `${this.getType("vec3")}( ${toFloat(value.r)}, ${toFloat(value.g)}, ${toFloat(value.b)} )`;
    const typeLength = this.getTypeLength(type);
    const componentType = this.getComponentType(type);
    const generateConst = (value2) => this.generateConst(componentType, value2);
    if (typeLength === 2) {
      return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)} )`;
    } else if (typeLength === 3) {
      return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)}, ${generateConst(value.z)} )`;
    } else if (typeLength === 4) {
      return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)}, ${generateConst(value.z)}, ${generateConst(value.w)} )`;
    } else if (typeLength > 4 && value && (value.isMatrix3 || value.isMatrix4)) {
      return `${this.getType(type)}( ${value.elements.map(generateConst).join(", ")} )`;
    } else if (typeLength > 4) {
      return `${this.getType(type)}()`;
    }
    throw new Error(`NodeBuilder: Type '${type}' not found in generate constant attempt.`);
  }
  getType(type) {
    if (type === "color")
      return "vec3";
    return type;
  }
  hasGeometryAttribute(name) {
    return this.geometry && this.geometry.getAttribute(name) !== void 0;
  }
  getAttribute(name, type) {
    const attributes = this.attributes;
    for (const attribute3 of attributes) {
      if (attribute3.name === name) {
        return attribute3;
      }
    }
    const attribute2 = new NodeAttribute_default(name, type);
    attributes.push(attribute2);
    return attribute2;
  }
  getPropertyName(node) {
    return node.name;
  }
  isVector(type) {
    return /vec\d/.test(type);
  }
  isMatrix(type) {
    return /mat\d/.test(type);
  }
  isReference(type) {
    return type === "void" || type === "property" || type === "sampler" || type === "texture" || type === "cubeTexture" || type === "storageTexture" || type === "texture3D";
  }
  needsColorSpaceToLinear() {
    return false;
  }
  getComponentTypeFromTexture(texture2) {
    const type = texture2.type;
    if (texture2.isDataTexture) {
      if (type === IntType)
        return "int";
      if (type === UnsignedIntType)
        return "uint";
    }
    return "float";
  }
  getElementType(type) {
    if (type === "mat2")
      return "vec2";
    if (type === "mat3")
      return "vec3";
    if (type === "mat4")
      return "vec4";
    return this.getComponentType(type);
  }
  getComponentType(type) {
    type = this.getVectorType(type);
    if (type === "float" || type === "bool" || type === "int" || type === "uint")
      return type;
    const componentType = /(b|i|u|)(vec|mat)([2-4])/.exec(type);
    if (componentType === null)
      return null;
    if (componentType[1] === "b")
      return "bool";
    if (componentType[1] === "i")
      return "int";
    if (componentType[1] === "u")
      return "uint";
    return "float";
  }
  getVectorType(type) {
    if (type === "color")
      return "vec3";
    if (type === "texture" || type === "cubeTexture" || type === "storageTexture" || type === "texture3D")
      return "vec4";
    return type;
  }
  getTypeFromLength(length2, componentType = "float") {
    if (length2 === 1)
      return componentType;
    const baseType = typeFromLength.get(length2);
    const prefix = componentType === "float" ? "" : componentType[0];
    return prefix + baseType;
  }
  getTypeFromArray(array) {
    return typeFromArray.get(array.constructor);
  }
  getTypeFromAttribute(attribute2) {
    let dataAttribute = attribute2;
    if (attribute2.isInterleavedBufferAttribute)
      dataAttribute = attribute2.data;
    const array = dataAttribute.array;
    const itemSize = attribute2.itemSize;
    const normalized = attribute2.normalized;
    let arrayType;
    if (!(attribute2 instanceof Float16BufferAttribute) && normalized !== true) {
      arrayType = this.getTypeFromArray(array);
    }
    return this.getTypeFromLength(itemSize, arrayType);
  }
  getTypeLength(type) {
    const vecType = this.getVectorType(type);
    const vecNum = /vec([2-4])/.exec(vecType);
    if (vecNum !== null)
      return Number(vecNum[1]);
    if (vecType === "float" || vecType === "bool" || vecType === "int" || vecType === "uint")
      return 1;
    if (/mat2/.test(type) === true)
      return 4;
    if (/mat3/.test(type) === true)
      return 9;
    if (/mat4/.test(type) === true)
      return 16;
    return 0;
  }
  getVectorFromMatrix(type) {
    return type.replace("mat", "vec");
  }
  changeComponentType(type, newComponentType) {
    return this.getTypeFromLength(this.getTypeLength(type), newComponentType);
  }
  getIntegerType(type) {
    const componentType = this.getComponentType(type);
    if (componentType === "int" || componentType === "uint")
      return type;
    return this.changeComponentType(type, "int");
  }
  addStack() {
    this.stack = stack(this.stack);
    this.stacks.push(getCurrentStack() || this.stack);
    setCurrentStack(this.stack);
    return this.stack;
  }
  removeStack() {
    const lastStack = this.stack;
    this.stack = lastStack.parent;
    setCurrentStack(this.stacks.pop());
    return lastStack;
  }
  getDataFromNode(node, shaderStage = this.shaderStage, cache2 = null) {
    cache2 = cache2 === null ? node.isGlobal(this) ? this.globalCache : this.cache : cache2;
    let nodeData = cache2.getNodeData(node);
    if (nodeData === void 0) {
      nodeData = {};
      cache2.setNodeData(node, nodeData);
    }
    if (nodeData[shaderStage] === void 0)
      nodeData[shaderStage] = {};
    return nodeData[shaderStage];
  }
  getNodeProperties(node, shaderStage = "any") {
    const nodeData = this.getDataFromNode(node, shaderStage);
    return nodeData.properties || (nodeData.properties = { outputNode: null });
  }
  getBufferAttributeFromNode(node, type) {
    const nodeData = this.getDataFromNode(node);
    let bufferAttribute2 = nodeData.bufferAttribute;
    if (bufferAttribute2 === void 0) {
      const index = this.uniforms.index++;
      bufferAttribute2 = new NodeAttribute_default("nodeAttribute" + index, type, node);
      this.bufferAttributes.push(bufferAttribute2);
      nodeData.bufferAttribute = bufferAttribute2;
    }
    return bufferAttribute2;
  }
  getStructTypeFromNode(node, shaderStage = this.shaderStage) {
    const nodeData = this.getDataFromNode(node, shaderStage);
    if (nodeData.structType === void 0) {
      const index = this.structs.index++;
      node.name = `StructType${index}`;
      this.structs[shaderStage].push(node);
      nodeData.structType = node;
    }
    return node;
  }
  getUniformFromNode(node, type, shaderStage = this.shaderStage, name = null) {
    const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
    let nodeUniform = nodeData.uniform;
    if (nodeUniform === void 0) {
      const index = this.uniforms.index++;
      nodeUniform = new NodeUniform_default(name || "nodeUniform" + index, type, node);
      this.uniforms[shaderStage].push(nodeUniform);
      nodeData.uniform = nodeUniform;
    }
    return nodeUniform;
  }
  getVarFromNode(node, name = null, type = node.getNodeType(this), shaderStage = this.shaderStage) {
    const nodeData = this.getDataFromNode(node, shaderStage);
    let nodeVar = nodeData.variable;
    if (nodeVar === void 0) {
      const vars = this.vars[shaderStage] || (this.vars[shaderStage] = []);
      if (name === null)
        name = "nodeVar" + vars.length;
      nodeVar = new NodeVar_default(name, type);
      vars.push(nodeVar);
      nodeData.variable = nodeVar;
    }
    return nodeVar;
  }
  getVaryingFromNode(node, name = null, type = node.getNodeType(this)) {
    const nodeData = this.getDataFromNode(node, "any");
    let nodeVarying = nodeData.varying;
    if (nodeVarying === void 0) {
      const varyings = this.varyings;
      const index = varyings.length;
      if (name === null)
        name = "nodeVarying" + index;
      nodeVarying = new NodeVarying_default(name, type);
      varyings.push(nodeVarying);
      nodeData.varying = nodeVarying;
    }
    return nodeVarying;
  }
  getCodeFromNode(node, type, shaderStage = this.shaderStage) {
    const nodeData = this.getDataFromNode(node);
    let nodeCode = nodeData.code;
    if (nodeCode === void 0) {
      const codes = this.codes[shaderStage] || (this.codes[shaderStage] = []);
      const index = codes.length;
      nodeCode = new NodeCode_default("nodeCode" + index, type);
      codes.push(nodeCode);
      nodeData.code = nodeCode;
    }
    return nodeCode;
  }
  addLineFlowCode(code2) {
    if (code2 === "")
      return this;
    code2 = this.tab + code2;
    if (!/;\s*$/.test(code2)) {
      code2 = code2 + ";\n";
    }
    this.flow.code += code2;
    return this;
  }
  addFlowCode(code2) {
    this.flow.code += code2;
    return this;
  }
  addFlowTab() {
    this.tab += "	";
    return this;
  }
  removeFlowTab() {
    this.tab = this.tab.slice(0, -1);
    return this;
  }
  getFlowData(node) {
    return this.flowsData.get(node);
  }
  flowNode(node) {
    const output2 = node.getNodeType(this);
    const flowData = this.flowChildNode(node, output2);
    this.flowsData.set(node, flowData);
    return flowData;
  }
  buildFunctionNode(shaderNode) {
    const fn = new FunctionNode_default();
    const previous = this.currentFunctionNode;
    this.currentFunctionNode = fn;
    fn.code = this.buildFunctionCode(shaderNode);
    this.currentFunctionNode = previous;
    return fn;
  }
  flowShaderNode(shaderNode) {
    const layout = shaderNode.layout;
    let inputs;
    if (shaderNode.isArrayInput) {
      inputs = [];
      for (const input of layout.inputs) {
        inputs.push(new ParameterNode_default(input.type, input.name));
      }
    } else {
      inputs = {};
      for (const input of layout.inputs) {
        inputs[input.name] = new ParameterNode_default(input.type, input.name);
      }
    }
    shaderNode.layout = null;
    const callNode = shaderNode.call(inputs);
    const flowData = this.flowStagesNode(callNode, layout.type);
    shaderNode.layout = layout;
    return flowData;
  }
  flowStagesNode(node, output2 = null) {
    const previousFlow = this.flow;
    const previousVars = this.vars;
    const previousCache = this.cache;
    const previousBuildStage = this.buildStage;
    const previousStack = this.stack;
    const flow = {
      code: ""
    };
    this.flow = flow;
    this.vars = {};
    this.cache = new NodeCache_default();
    this.stack = stack();
    for (const buildStage of defaultBuildStages) {
      this.setBuildStage(buildStage);
      flow.result = node.build(this, output2);
    }
    flow.vars = this.getVars(this.shaderStage);
    this.flow = previousFlow;
    this.vars = previousVars;
    this.cache = previousCache;
    this.stack = previousStack;
    this.setBuildStage(previousBuildStage);
    return flow;
  }
  getFunctionOperator() {
    return null;
  }
  flowChildNode(node, output2 = null) {
    const previousFlow = this.flow;
    const flow = {
      code: ""
    };
    this.flow = flow;
    flow.result = node.build(this, output2);
    this.flow = previousFlow;
    return flow;
  }
  flowNodeFromShaderStage(shaderStage, node, output2 = null, propertyName = null) {
    const previousShaderStage = this.shaderStage;
    this.setShaderStage(shaderStage);
    const flowData = this.flowChildNode(node, output2);
    if (propertyName !== null) {
      flowData.code += `${this.tab + propertyName} = ${flowData.result};
`;
    }
    this.flowCode[shaderStage] = this.flowCode[shaderStage] + flowData.code;
    this.setShaderStage(previousShaderStage);
    return flowData;
  }
  getAttributesArray() {
    return this.attributes.concat(this.bufferAttributes);
  }
  getAttributes() {
    console.warn("Abstract function.");
  }
  getVaryings() {
    console.warn("Abstract function.");
  }
  getVar(type, name) {
    return `${this.getType(type)} ${name}`;
  }
  getVars(shaderStage) {
    let snippet = "";
    const vars = this.vars[shaderStage];
    if (vars !== void 0) {
      for (const variable of vars) {
        snippet += `${this.getVar(variable.type, variable.name)}; `;
      }
    }
    return snippet;
  }
  getUniforms() {
    console.warn("Abstract function.");
  }
  getCodes(shaderStage) {
    const codes = this.codes[shaderStage];
    let code2 = "";
    if (codes !== void 0) {
      for (const nodeCode of codes) {
        code2 += nodeCode.code + "\n";
      }
    }
    return code2;
  }
  getHash() {
    return this.vertexShader + this.fragmentShader + this.computeShader;
  }
  setShaderStage(shaderStage) {
    this.shaderStage = shaderStage;
  }
  getShaderStage() {
    return this.shaderStage;
  }
  setBuildStage(buildStage) {
    this.buildStage = buildStage;
  }
  getBuildStage() {
    return this.buildStage;
  }
  buildCode() {
    console.warn("Abstract function.");
  }
  build() {
    const { object, material } = this;
    if (material !== null) {
      NodeMaterial_default.fromMaterial(material).build(this);
    } else {
      this.addFlow("compute", object);
    }
    for (const buildStage of defaultBuildStages) {
      this.setBuildStage(buildStage);
      if (this.context.vertex && this.context.vertex.isNode) {
        this.flowNodeFromShaderStage("vertex", this.context.vertex);
      }
      for (const shaderStage of shaderStages) {
        this.setShaderStage(shaderStage);
        const flowNodes = this.flowNodes[shaderStage];
        for (const node of flowNodes) {
          if (buildStage === "generate") {
            this.flowNode(node);
          } else {
            node.build(this);
          }
        }
      }
    }
    this.setBuildStage(null);
    this.setShaderStage(null);
    this.buildCode();
    this.buildUpdateNodes();
    return this;
  }
  getNodeUniform(uniformNode, type) {
    if (type === "float")
      return new FloatNodeUniform(uniformNode);
    if (type === "vec2")
      return new Vector2NodeUniform(uniformNode);
    if (type === "vec3")
      return new Vector3NodeUniform(uniformNode);
    if (type === "vec4")
      return new Vector4NodeUniform(uniformNode);
    if (type === "color")
      return new ColorNodeUniform(uniformNode);
    if (type === "mat3")
      return new Matrix3NodeUniform(uniformNode);
    if (type === "mat4")
      return new Matrix4NodeUniform(uniformNode);
    throw new Error(`Uniform "${type}" not declared.`);
  }
  createNodeMaterial(type = "NodeMaterial") {
    return createNodeMaterialFromType(type);
  }
  format(snippet, fromType, toType) {
    fromType = this.getVectorType(fromType);
    toType = this.getVectorType(toType);
    if (fromType === toType || toType === null || this.isReference(toType)) {
      return snippet;
    }
    const fromTypeLength = this.getTypeLength(fromType);
    const toTypeLength = this.getTypeLength(toType);
    if (fromTypeLength > 4) {
      return snippet;
    }
    if (toTypeLength > 4 || toTypeLength === 0) {
      return snippet;
    }
    if (fromTypeLength === toTypeLength) {
      return `${this.getType(toType)}( ${snippet} )`;
    }
    if (fromTypeLength > toTypeLength) {
      return this.format(`${snippet}.${"xyz".slice(0, toTypeLength)}`, this.getTypeFromLength(toTypeLength, this.getComponentType(fromType)), toType);
    }
    if (toTypeLength === 4 && fromTypeLength > 1) {
      return `${this.getType(toType)}( ${this.format(snippet, fromType, "vec3")}, 1.0 )`;
    }
    if (fromTypeLength === 2) {
      return `${this.getType(toType)}( ${this.format(snippet, fromType, "vec2")}, 0.0 )`;
    }
    if (fromTypeLength === 1 && toTypeLength > 1 && fromType[0] !== toType[0]) {
      snippet = `${this.getType(this.getComponentType(toType))}( ${snippet} )`;
    }
    return `${this.getType(toType)}( ${snippet} )`;
  }
  getSignature() {
    return `// Three.js r${REVISION} - NodeMaterial System
`;
  }
};
var NodeBuilder_default = NodeBuilder;

// node_modules/three/examples/jsm/nodes/core/NodeFrame.js
var NodeFrame = class {
  constructor() {
    this.time = 0;
    this.deltaTime = 0;
    this.frameId = 0;
    this.renderId = 0;
    this.startTime = null;
    this.updateMap = /* @__PURE__ */ new WeakMap();
    this.updateBeforeMap = /* @__PURE__ */ new WeakMap();
    this.renderer = null;
    this.material = null;
    this.camera = null;
    this.object = null;
    this.scene = null;
  }
  _getMaps(referenceMap, nodeRef) {
    let maps = referenceMap.get(nodeRef);
    if (maps === void 0) {
      maps = {
        renderMap: /* @__PURE__ */ new WeakMap(),
        frameMap: /* @__PURE__ */ new WeakMap()
      };
      referenceMap.set(nodeRef, maps);
    }
    return maps;
  }
  updateBeforeNode(node) {
    const updateType = node.getUpdateBeforeType();
    const reference2 = node.updateReference(this);
    if (updateType === NodeUpdateType.FRAME) {
      const { frameMap } = this._getMaps(this.updateBeforeMap, reference2);
      if (frameMap.get(reference2) !== this.frameId) {
        if (node.updateBefore(this) !== false) {
          frameMap.set(reference2, this.frameId);
        }
      }
    } else if (updateType === NodeUpdateType.RENDER) {
      const { renderMap } = this._getMaps(this.updateBeforeMap, reference2);
      if (renderMap.get(reference2) !== this.renderId) {
        if (node.updateBefore(this) !== false) {
          renderMap.set(reference2, this.renderId);
        }
      }
    } else if (updateType === NodeUpdateType.OBJECT) {
      node.updateBefore(this);
    }
  }
  updateNode(node) {
    const updateType = node.getUpdateType();
    const reference2 = node.updateReference(this);
    if (updateType === NodeUpdateType.FRAME) {
      const { frameMap } = this._getMaps(this.updateMap, reference2);
      if (frameMap.get(reference2) !== this.frameId) {
        if (node.update(this) !== false) {
          frameMap.set(reference2, this.frameId);
        }
      }
    } else if (updateType === NodeUpdateType.RENDER) {
      const { renderMap } = this._getMaps(this.updateMap, reference2);
      if (renderMap.get(reference2) !== this.renderId) {
        if (node.update(this) !== false) {
          renderMap.set(reference2, this.renderId);
        }
      }
    } else if (updateType === NodeUpdateType.OBJECT) {
      node.update(this);
    }
  }
  update() {
    this.frameId++;
    if (this.lastTime === void 0)
      this.lastTime = performance.now();
    this.deltaTime = (performance.now() - this.lastTime) / 1e3;
    this.lastTime = performance.now();
    this.time += this.deltaTime;
  }
};
var NodeFrame_default = NodeFrame;

// node_modules/three/examples/jsm/nodes/core/NodeFunctionInput.js
var NodeFunctionInput = class {
  constructor(type, name, count = null, qualifier = "", isConst = false) {
    this.type = type;
    this.name = name;
    this.count = count;
    this.qualifier = qualifier;
    this.isConst = isConst;
  }
};
NodeFunctionInput.isNodeFunctionInput = true;
var NodeFunctionInput_default = NodeFunctionInput;

// node_modules/three/examples/jsm/nodes/core/StructTypeNode.js
var StructTypeNode = class extends Node_default {
  constructor(types) {
    super();
    this.types = types;
    this.isStructTypeNode = true;
  }
  getMemberTypes() {
    return this.types;
  }
};
var StructTypeNode_default = StructTypeNode;
addNodeClass("StructTypeNode", StructTypeNode);

// node_modules/three/examples/jsm/nodes/core/OutputStructNode.js
var OutputStructNode = class extends Node_default {
  constructor(...members) {
    super();
    this.members = members;
    this.isOutputStructNode = true;
  }
  setup(builder) {
    super.setup(builder);
    const members = this.members;
    const types = [];
    for (let i = 0; i < members.length; i++) {
      types.push(members[i].getNodeType(builder));
    }
    this.nodeType = builder.getStructTypeFromNode(new StructTypeNode_default(types)).name;
  }
  generate(builder, output2) {
    const propertyName = builder.getOutputStructName();
    const members = this.members;
    const structPrefix = propertyName !== "" ? propertyName + "." : "";
    for (let i = 0; i < members.length; i++) {
      const snippet = members[i].build(builder, output2);
      builder.addLineFlowCode(`${structPrefix}m${i} = ${snippet}`);
    }
    return propertyName;
  }
};
var OutputStructNode_default = OutputStructNode;
var outputStruct = nodeProxy(OutputStructNode);
addNodeClass("OutputStructNode", OutputStructNode);

// node_modules/three/examples/jsm/nodes/math/HashNode.js
var HashNode = class extends Node_default {
  constructor(seedNode) {
    super();
    this.seedNode = seedNode;
  }
  setup() {
    const state = this.seedNode.toUint().mul(747796405).add(2891336453);
    const word = state.shiftRight(state.shiftRight(28).add(4)).bitXor(state).mul(277803737);
    const result = word.shiftRight(22).bitXor(word);
    return result.toFloat().mul(1 / 2 ** 32);
  }
};
var HashNode_default = HashNode;
var hash = nodeProxy(HashNode);
addNodeElement("hash", hash);
addNodeClass("HashNode", HashNode);

// node_modules/three/examples/jsm/nodes/math/MathUtils.js
var parabola = (x, k) => pow(mul(4, x.mul(sub(1, x))), k);
var gain = (x, k) => x.lessThan(0.5) ? parabola(x.mul(2), k).div(2) : sub(1, parabola(mul(sub(1, x), 2), k).div(2));
var pcurve = (x, a, b) => pow(div(pow(x, a), add(pow(x, a), pow(sub(1, x), b))), 1 / a);
var sinc = (x, k) => sin(PI.mul(k.mul(x).sub(1))).div(PI.mul(k.mul(x).sub(1)));
addNodeElement("parabola", parabola);
addNodeElement("gain", gain);
addNodeElement("pcurve", pcurve);
addNodeElement("sinc", sinc);

// node_modules/three/examples/jsm/nodes/math/TriNoise3D.js
var tri = tslFn(([x]) => {
  return x.fract().sub(0.5).abs();
});
var tri3 = tslFn(([p]) => {
  return vec3(tri(p.z.add(tri(p.y.mul(1)))), tri(p.z.add(tri(p.x.mul(1)))), tri(p.y.add(tri(p.x.mul(1)))));
});
var triNoise3D = tslFn(([p_immutable, spd, time]) => {
  const p = vec3(p_immutable).toVar();
  const z = float(1.4).toVar();
  const rz = float(0).toVar();
  const bp = vec3(p).toVar();
  loop({ start: float(0), end: float(3), type: "float", condition: "<=" }, () => {
    const dg = vec3(tri3(bp.mul(2))).toVar();
    p.addAssign(dg.add(time.mul(float(0.1).mul(spd))));
    bp.mulAssign(1.8);
    z.mulAssign(1.5);
    p.mulAssign(1.2);
    const t = float(tri(p.z.add(tri(p.x.add(tri(p.y)))))).toVar();
    rz.addAssign(t.div(z));
    bp.addAssign(0.14);
  });
  return rz;
});
tri.setLayout({
  name: "tri",
  type: "float",
  inputs: [
    { name: "x", type: "float" }
  ]
});
tri3.setLayout({
  name: "tri3",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec3" }
  ]
});
triNoise3D.setLayout({
  name: "triNoise3D",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "spd", type: "float" },
    { name: "time", type: "float" }
  ]
});

// node_modules/three/examples/jsm/nodes/utils/DiscardNode.js
var discardExpression;
var DiscardNode = class extends CondNode_default {
  constructor(condNode) {
    discardExpression = discardExpression || expression("discard");
    super(condNode, discardExpression);
  }
};
var DiscardNode_default = DiscardNode;
var inlineDiscard = nodeProxy(DiscardNode);
var discard = (condNode) => inlineDiscard(condNode).append();
addNodeElement("discard", discard);
addNodeClass("DiscardNode", DiscardNode);

// node_modules/three/examples/jsm/nodes/utils/FunctionOverloadingNode.js
var FunctionOverloadingNode = class extends Node_default {
  constructor(functionNodes = [], ...parametersNodes) {
    super();
    this.functionNodes = functionNodes;
    this.parametersNodes = parametersNodes;
    this._candidateFnCall = null;
  }
  getNodeType() {
    return this.functionNodes[0].shaderNode.layout.type;
  }
  setup(builder) {
    const params = this.parametersNodes;
    let candidateFnCall = this._candidateFnCall;
    if (candidateFnCall === null) {
      let candidateFn = null;
      let candidateScore = -1;
      for (const functionNode of this.functionNodes) {
        const shaderNode = functionNode.shaderNode;
        const layout = shaderNode.layout;
        if (layout === null) {
          throw new Error("FunctionOverloadingNode: FunctionNode must be a layout.");
        }
        const inputs = layout.inputs;
        if (params.length === inputs.length) {
          let score = 0;
          for (let i = 0; i < params.length; i++) {
            const param = params[i];
            const input = inputs[i];
            if (param.getNodeType(builder) === input.type) {
              score++;
            } else {
              score = 0;
            }
          }
          if (score > candidateScore) {
            candidateFn = functionNode;
            candidateScore = score;
          }
        }
      }
      this._candidateFnCall = candidateFnCall = candidateFn(...params);
    }
    return candidateFnCall;
  }
};
var FunctionOverloadingNode_default = FunctionOverloadingNode;
var overloadingBaseFn = nodeProxy(FunctionOverloadingNode);
var overloadingFn = (functionNodes) => (...params) => overloadingBaseFn(functionNodes, ...params);
addNodeClass("FunctionOverloadingNode", FunctionOverloadingNode);

// node_modules/three/examples/jsm/nodes/utils/MatcapUVNode.js
var MatcapUVNode = class extends TempNode_default {
  constructor() {
    super("vec2");
  }
  setup() {
    const x = vec3(positionViewDirection.z, 0, positionViewDirection.x.negate()).normalize();
    const y = positionViewDirection.cross(x);
    return vec2(x.dot(transformedNormalView), y.dot(transformedNormalView)).mul(0.495).add(0.5);
  }
};
var MatcapUVNode_default = MatcapUVNode;
var matcapUV = nodeImmutable(MatcapUVNode);
addNodeClass("MatcapUVNode", MatcapUVNode);

// node_modules/three/examples/jsm/nodes/utils/TimerNode.js
var TimerNode = class _TimerNode extends UniformNode_default {
  constructor(scope = _TimerNode.LOCAL, scale = 1, value = 0) {
    super(value);
    this.scope = scope;
    this.scale = scale;
    this.updateType = NodeUpdateType.FRAME;
  }
  /*
  	@TODO:
  	getNodeType( builder ) {
  
  		const scope = this.scope;
  
  		if ( scope === TimerNode.FRAME ) {
  
  			return 'uint';
  
  		}
  
  		return 'float';
  
  	}
  */
  update(frame) {
    const scope = this.scope;
    const scale = this.scale;
    if (scope === _TimerNode.LOCAL) {
      this.value += frame.deltaTime * scale;
    } else if (scope === _TimerNode.DELTA) {
      this.value = frame.deltaTime * scale;
    } else if (scope === _TimerNode.FRAME) {
      this.value = frame.frameId;
    } else {
      this.value = frame.time * scale;
    }
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
    data.scale = this.scale;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
    this.scale = data.scale;
  }
};
TimerNode.LOCAL = "local";
TimerNode.GLOBAL = "global";
TimerNode.DELTA = "delta";
TimerNode.FRAME = "frame";
var TimerNode_default = TimerNode;
var timerLocal = (timeScale, value = 0) => nodeObject(new TimerNode(TimerNode.LOCAL, timeScale, value));
var timerGlobal = (timeScale, value = 0) => nodeObject(new TimerNode(TimerNode.GLOBAL, timeScale, value));
var timerDelta = (timeScale, value = 0) => nodeObject(new TimerNode(TimerNode.DELTA, timeScale, value));
var frameId = nodeImmutable(TimerNode, TimerNode.FRAME).toUint();
addNodeClass("TimerNode", TimerNode);

// node_modules/three/examples/jsm/nodes/utils/OscNode.js
var OscNode = class _OscNode extends Node_default {
  constructor(method = _OscNode.SINE, timeNode = timerLocal()) {
    super();
    this.method = method;
    this.timeNode = timeNode;
  }
  getNodeType(builder) {
    return this.timeNode.getNodeType(builder);
  }
  setup() {
    const method = this.method;
    const timeNode = nodeObject(this.timeNode);
    let outputNode = null;
    if (method === _OscNode.SINE) {
      outputNode = timeNode.add(0.75).mul(Math.PI * 2).sin().mul(0.5).add(0.5);
    } else if (method === _OscNode.SQUARE) {
      outputNode = timeNode.fract().round();
    } else if (method === _OscNode.TRIANGLE) {
      outputNode = timeNode.add(0.5).fract().mul(2).sub(1).abs();
    } else if (method === _OscNode.SAWTOOTH) {
      outputNode = timeNode.fract();
    }
    return outputNode;
  }
  serialize(data) {
    super.serialize(data);
    data.method = this.method;
  }
  deserialize(data) {
    super.deserialize(data);
    this.method = data.method;
  }
};
OscNode.SINE = "sine";
OscNode.SQUARE = "square";
OscNode.TRIANGLE = "triangle";
OscNode.SAWTOOTH = "sawtooth";
var OscNode_default = OscNode;
var oscSine = nodeProxy(OscNode, OscNode.SINE);
var oscSquare = nodeProxy(OscNode, OscNode.SQUARE);
var oscTriangle = nodeProxy(OscNode, OscNode.TRIANGLE);
var oscSawtooth = nodeProxy(OscNode, OscNode.SAWTOOTH);
addNodeClass("OscNode", OscNode);

// node_modules/three/examples/jsm/nodes/utils/PackingNode.js
var PackingNode = class _PackingNode extends TempNode_default {
  constructor(scope, node) {
    super();
    this.scope = scope;
    this.node = node;
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  setup() {
    const { scope, node } = this;
    let result = null;
    if (scope === _PackingNode.DIRECTION_TO_COLOR) {
      result = node.mul(0.5).add(0.5);
    } else if (scope === _PackingNode.COLOR_TO_DIRECTION) {
      result = node.mul(2).sub(1);
    }
    return result;
  }
};
PackingNode.DIRECTION_TO_COLOR = "directionToColor";
PackingNode.COLOR_TO_DIRECTION = "colorToDirection";
var PackingNode_default = PackingNode;
var directionToColor = nodeProxy(PackingNode, PackingNode.DIRECTION_TO_COLOR);
var colorToDirection = nodeProxy(PackingNode, PackingNode.COLOR_TO_DIRECTION);
addNodeElement("directionToColor", directionToColor);
addNodeElement("colorToDirection", colorToDirection);
addNodeClass("PackingNode", PackingNode);

// node_modules/three/examples/jsm/nodes/utils/RemapNode.js
var RemapNode = class extends Node_default {
  constructor(node, inLowNode, inHighNode, outLowNode = float(0), outHighNode = float(1)) {
    super();
    this.node = node;
    this.inLowNode = inLowNode;
    this.inHighNode = inHighNode;
    this.outLowNode = outLowNode;
    this.outHighNode = outHighNode;
    this.doClamp = true;
  }
  setup() {
    const { node, inLowNode, inHighNode, outLowNode, outHighNode, doClamp } = this;
    let t = node.sub(inLowNode).div(inHighNode.sub(inLowNode));
    if (doClamp === true)
      t = t.clamp();
    return t.mul(outHighNode.sub(outLowNode)).add(outLowNode);
  }
};
var RemapNode_default = RemapNode;
var remap = nodeProxy(RemapNode, null, null, { doClamp: false });
var remapClamp = nodeProxy(RemapNode);
addNodeElement("remap", remap);
addNodeElement("remapClamp", remapClamp);
addNodeClass("RemapNode", RemapNode);

// node_modules/three/examples/jsm/nodes/utils/RotateUVNode.js
var RotateUVNode = class extends TempNode_default {
  constructor(uvNode, rotationNode, centerNode = vec2(0.5)) {
    super("vec2");
    this.uvNode = uvNode;
    this.rotationNode = rotationNode;
    this.centerNode = centerNode;
  }
  setup() {
    const { uvNode, rotationNode, centerNode } = this;
    const vector = uvNode.sub(centerNode);
    return vector.rotate(rotationNode).add(centerNode);
  }
};
var RotateUVNode_default = RotateUVNode;
var rotateUV = nodeProxy(RotateUVNode);
addNodeElement("rotateUV", rotateUV);
addNodeClass("RotateUVNode", RotateUVNode);

// node_modules/three/examples/jsm/nodes/utils/RotateNode.js
var RotateNode = class extends TempNode_default {
  constructor(positionNode, rotationNode) {
    super();
    this.positionNode = positionNode;
    this.rotationNode = rotationNode;
  }
  getNodeType(builder) {
    return this.positionNode.getNodeType(builder);
  }
  setup(builder) {
    const { rotationNode, positionNode } = this;
    const nodeType = this.getNodeType(builder);
    if (nodeType === "vec2") {
      const cosAngle = rotationNode.cos();
      const sinAngle = rotationNode.sin();
      const rotationMatrix = mat2(
        cosAngle,
        sinAngle,
        sinAngle.negate(),
        cosAngle
      );
      return rotationMatrix.mul(positionNode);
    } else {
      const rotation = rotationNode;
      const rotationXMatrix = mat4(vec4(1, 0, 0, 0), vec4(0, cos(rotation.x), sin(rotation.x).negate(), 0), vec4(0, sin(rotation.x), cos(rotation.x), 0), vec4(0, 0, 0, 1));
      const rotationYMatrix = mat4(vec4(cos(rotation.y), 0, sin(rotation.y), 0), vec4(0, 1, 0, 0), vec4(sin(rotation.y).negate(), 0, cos(rotation.y), 0), vec4(0, 0, 0, 1));
      const rotationZMatrix = mat4(vec4(cos(rotation.z), sin(rotation.z).negate(), 0, 0), vec4(sin(rotation.z), cos(rotation.z), 0, 0), vec4(0, 0, 1, 0), vec4(0, 0, 0, 1));
      return rotationXMatrix.mul(rotationYMatrix).mul(rotationZMatrix).mul(vec4(positionNode, 1)).xyz;
    }
  }
};
var RotateNode_default = RotateNode;
var rotate = nodeProxy(RotateNode);
addNodeElement("rotate", rotate);
addNodeClass("RotateNode", RotateNode);

// node_modules/three/examples/jsm/nodes/utils/SpriteSheetUVNode.js
var SpriteSheetUVNode = class extends Node_default {
  constructor(countNode, uvNode = uv(), frameNode = float(0)) {
    super("vec2");
    this.countNode = countNode;
    this.uvNode = uvNode;
    this.frameNode = frameNode;
  }
  setup() {
    const { frameNode, uvNode, countNode } = this;
    const { width, height } = countNode;
    const frameNum = frameNode.mod(width.mul(height)).floor();
    const column = frameNum.mod(width);
    const row = height.sub(frameNum.add(1).div(width).ceil());
    const scale = countNode.reciprocal();
    const uvFrameOffset = vec2(column, row);
    return uvNode.add(uvFrameOffset).mul(scale);
  }
};
var SpriteSheetUVNode_default = SpriteSheetUVNode;
var spritesheetUV = nodeProxy(SpriteSheetUVNode);
addNodeClass("SpriteSheetUVNode", SpriteSheetUVNode);

// node_modules/three/examples/jsm/nodes/utils/StorageArrayElementNode.js
var StorageArrayElementNode = class extends ArrayElementNode_default {
  constructor(storageBufferNode, indexNode) {
    super(storageBufferNode, indexNode);
    this.isStorageArrayElementNode = true;
  }
  set storageBufferNode(value) {
    this.node = value;
  }
  get storageBufferNode() {
    return this.node;
  }
  setup(builder) {
    if (builder.isAvailable("storageBuffer") === false) {
      if (!this.node.instanceIndex && this.node.bufferObject === true) {
        builder.setupPBO(this.node);
      }
    }
    return super.setup(builder);
  }
  generate(builder, output2) {
    let snippet;
    const isAssignContext = builder.context.assign;
    if (builder.isAvailable("storageBuffer") === false) {
      const { node } = this;
      if (!node.instanceIndex && this.node.bufferObject === true && isAssignContext !== true) {
        snippet = builder.generatePBO(this);
      } else {
        snippet = node.build(builder);
      }
    } else {
      snippet = super.generate(builder);
    }
    if (isAssignContext !== true) {
      const type = this.getNodeType(builder);
      snippet = builder.format(snippet, type, output2);
    }
    return snippet;
  }
};
var StorageArrayElementNode_default = StorageArrayElementNode;
var storageElement = nodeProxy(StorageArrayElementNode);
addNodeElement("storageElement", storageElement);
addNodeClass("StorageArrayElementNode", StorageArrayElementNode);

// node_modules/three/examples/jsm/nodes/utils/TriplanarTexturesNode.js
var TriplanarTexturesNode = class extends Node_default {
  constructor(textureXNode, textureYNode = null, textureZNode = null, scaleNode = float(1), positionNode = positionLocal, normalNode = normalLocal) {
    super("vec4");
    this.textureXNode = textureXNode;
    this.textureYNode = textureYNode;
    this.textureZNode = textureZNode;
    this.scaleNode = scaleNode;
    this.positionNode = positionNode;
    this.normalNode = normalNode;
  }
  setup() {
    const { textureXNode, textureYNode, textureZNode, scaleNode, positionNode, normalNode } = this;
    let bf = normalNode.abs().normalize();
    bf = bf.div(bf.dot(vec3(1)));
    const tx = positionNode.yz.mul(scaleNode);
    const ty = positionNode.zx.mul(scaleNode);
    const tz = positionNode.xy.mul(scaleNode);
    const textureX = textureXNode.value;
    const textureY = textureYNode !== null ? textureYNode.value : textureX;
    const textureZ = textureZNode !== null ? textureZNode.value : textureX;
    const cx = texture(textureX, tx).mul(bf.x);
    const cy = texture(textureY, ty).mul(bf.y);
    const cz = texture(textureZ, tz).mul(bf.z);
    return add(cx, cy, cz);
  }
};
var TriplanarTexturesNode_default = TriplanarTexturesNode;
var triplanarTextures = nodeProxy(TriplanarTexturesNode);
var triplanarTexture = (...params) => triplanarTextures(...params);
addNodeElement("triplanarTexture", triplanarTexture);
addNodeClass("TriplanarTexturesNode", TriplanarTexturesNode);

// node_modules/three/examples/jsm/nodes/utils/ReflectorNode.js
var _reflectorPlane = new Plane();
var _normal = new Vector3();
var _reflectorWorldPosition = new Vector3();
var _cameraWorldPosition = new Vector3();
var _rotationMatrix = new Matrix4();
var _lookAtPosition = new Vector3(0, 0, -1);
var clipPlane = new Vector4();
var _view = new Vector3();
var _target = new Vector3();
var _q = new Vector4();
var _size2 = new Vector2();
var _defaultRT = new RenderTarget();
var _defaultUV = vec2(viewportTopLeft.x.oneMinus(), viewportTopLeft.y);
var _inReflector = false;
var ReflectorNode = class extends TextureNode_default {
  constructor(parameters = {}) {
    super(_defaultRT.texture, _defaultUV);
    const {
      target = new Object3D(),
      resolution: resolution2 = 1,
      generateMipmaps = false,
      bounces = true
    } = parameters;
    this.target = target;
    this.resolution = resolution2;
    this.generateMipmaps = generateMipmaps;
    this.bounces = bounces;
    this.updateBeforeType = bounces ? NodeUpdateType.RENDER : NodeUpdateType.FRAME;
    this.virtualCameras = /* @__PURE__ */ new WeakMap();
    this.renderTargets = /* @__PURE__ */ new WeakMap();
  }
  _updateResolution(renderTarget, renderer) {
    const resolution2 = this.resolution;
    renderer.getDrawingBufferSize(_size2);
    renderTarget.setSize(Math.round(_size2.width * resolution2), Math.round(_size2.height * resolution2));
  }
  setup(builder) {
    this._updateResolution(_defaultRT, builder.renderer);
    return super.setup(builder);
  }
  getTextureNode() {
    return this.textureNode;
  }
  getVirtualCamera(camera) {
    let virtualCamera = this.virtualCameras.get(camera);
    if (virtualCamera === void 0) {
      virtualCamera = camera.clone();
      this.virtualCameras.set(camera, virtualCamera);
    }
    return virtualCamera;
  }
  getRenderTarget(camera) {
    let renderTarget = this.renderTargets.get(camera);
    if (renderTarget === void 0) {
      renderTarget = new RenderTarget(0, 0, { type: HalfFloatType });
      if (this.generateMipmaps === true) {
        renderTarget.texture.minFilter = LinearMipMapLinearFilter;
        renderTarget.texture.generateMipmaps = true;
      }
      this.renderTargets.set(camera, renderTarget);
    }
    return renderTarget;
  }
  updateBefore(frame) {
    if (this.bounces === false && _inReflector)
      return false;
    _inReflector = true;
    const { scene, camera, renderer, material } = frame;
    const { target } = this;
    const virtualCamera = this.getVirtualCamera(camera);
    const renderTarget = this.getRenderTarget(virtualCamera);
    renderer.getDrawingBufferSize(_size2);
    this._updateResolution(renderTarget, renderer);
    _reflectorWorldPosition.setFromMatrixPosition(target.matrixWorld);
    _cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);
    _rotationMatrix.extractRotation(target.matrixWorld);
    _normal.set(0, 0, 1);
    _normal.applyMatrix4(_rotationMatrix);
    _view.subVectors(_reflectorWorldPosition, _cameraWorldPosition);
    if (_view.dot(_normal) > 0)
      return;
    _view.reflect(_normal).negate();
    _view.add(_reflectorWorldPosition);
    _rotationMatrix.extractRotation(camera.matrixWorld);
    _lookAtPosition.set(0, 0, -1);
    _lookAtPosition.applyMatrix4(_rotationMatrix);
    _lookAtPosition.add(_cameraWorldPosition);
    _target.subVectors(_reflectorWorldPosition, _lookAtPosition);
    _target.reflect(_normal).negate();
    _target.add(_reflectorWorldPosition);
    virtualCamera.coordinateSystem = camera.coordinateSystem;
    virtualCamera.position.copy(_view);
    virtualCamera.up.set(0, 1, 0);
    virtualCamera.up.applyMatrix4(_rotationMatrix);
    virtualCamera.up.reflect(_normal);
    virtualCamera.lookAt(_target);
    virtualCamera.near = camera.near;
    virtualCamera.far = camera.far;
    virtualCamera.updateMatrixWorld();
    virtualCamera.projectionMatrix.copy(camera.projectionMatrix);
    _reflectorPlane.setFromNormalAndCoplanarPoint(_normal, _reflectorWorldPosition);
    _reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);
    clipPlane.set(_reflectorPlane.normal.x, _reflectorPlane.normal.y, _reflectorPlane.normal.z, _reflectorPlane.constant);
    const projectionMatrix = virtualCamera.projectionMatrix;
    _q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];
    _q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];
    _q.z = -1;
    _q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];
    clipPlane.multiplyScalar(1 / clipPlane.dot(_q));
    const clipBias = 0;
    projectionMatrix.elements[2] = clipPlane.x;
    projectionMatrix.elements[6] = clipPlane.y;
    projectionMatrix.elements[10] = clipPlane.z - clipBias;
    projectionMatrix.elements[14] = clipPlane.w;
    this.value = renderTarget.texture;
    material.visible = false;
    const currentRenderTarget = renderer.getRenderTarget();
    renderer.setRenderTarget(renderTarget);
    renderer.render(scene, virtualCamera);
    renderer.setRenderTarget(currentRenderTarget);
    material.visible = true;
    _inReflector = false;
  }
};
var reflector = (parameters) => nodeObject(new ReflectorNode(parameters));
var ReflectorNode_default = ReflectorNode;

// node_modules/three/examples/jsm/nodes/accessors/VertexColorNode.js
var VertexColorNode = class extends AttributeNode_default {
  constructor(index = 0) {
    super(null, "vec4");
    this.isVertexColorNode = true;
    this.index = index;
  }
  getAttributeName() {
    const index = this.index;
    return "color" + (index > 0 ? index : "");
  }
  generate(builder) {
    const attributeName = this.getAttributeName(builder);
    const geometryAttribute = builder.hasGeometryAttribute(attributeName);
    let result;
    if (geometryAttribute === true) {
      result = super.generate(builder);
    } else {
      result = builder.generateConst(this.nodeType, new Vector4(1, 1, 1, 1));
    }
    return result;
  }
  serialize(data) {
    super.serialize(data);
    data.index = this.index;
  }
  deserialize(data) {
    super.deserialize(data);
    this.index = data.index;
  }
};
var VertexColorNode_default = VertexColorNode;
var vertexColor = (...params) => nodeObject(new VertexColorNode(...params));
addNodeClass("VertexColorNode", VertexColorNode);

// node_modules/three/examples/jsm/nodes/accessors/RendererReferenceNode.js
var RendererReferenceNode = class extends ReferenceNode_default {
  constructor(property2, inputType, renderer = null) {
    super(property2, inputType, renderer);
    this.renderer = renderer;
  }
  updateReference(state) {
    this.reference = this.renderer !== null ? this.renderer : state.renderer;
    return this.reference;
  }
};
var RendererReferenceNode_default = RendererReferenceNode;
var rendererReference = (name, type, renderer) => nodeObject(new RendererReferenceNode(name, type, renderer));
addNodeClass("RendererReferenceNode", RendererReferenceNode);

// node_modules/three/examples/jsm/nodes/accessors/TextureBicubicNode.js
var bC = 1 / 6;
var w0 = (a) => mul(bC, mul(a, mul(a, a.negate().add(3)).sub(3)).add(1));
var w1 = (a) => mul(bC, mul(a, mul(a, mul(3, a).sub(6))).add(4));
var w2 = (a) => mul(bC, mul(a, mul(a, mul(-3, a).add(3)).add(3)).add(1));
var w3 = (a) => mul(bC, pow(a, 3));
var g0 = (a) => w0(a).add(w1(a));
var g1 = (a) => w2(a).add(w3(a));
var h0 = (a) => add(-1, w1(a).div(w0(a).add(w1(a))));
var h1 = (a) => add(1, w3(a).div(w2(a).add(w3(a))));
var bicubic = (textureNode, texelSize, lod) => {
  const uv2 = textureNode.uvNode;
  const uvScaled = mul(uv2, texelSize.zw).add(0.5);
  const iuv = floor(uvScaled);
  const fuv = fract(uvScaled);
  const g0x = g0(fuv.x);
  const g1x = g1(fuv.x);
  const h0x = h0(fuv.x);
  const h1x = h1(fuv.x);
  const h0y = h0(fuv.y);
  const h1y = h1(fuv.y);
  const p0 = vec2(iuv.x.add(h0x), iuv.y.add(h0y)).sub(0.5).mul(texelSize.xy);
  const p1 = vec2(iuv.x.add(h1x), iuv.y.add(h0y)).sub(0.5).mul(texelSize.xy);
  const p2 = vec2(iuv.x.add(h0x), iuv.y.add(h1y)).sub(0.5).mul(texelSize.xy);
  const p3 = vec2(iuv.x.add(h1x), iuv.y.add(h1y)).sub(0.5).mul(texelSize.xy);
  const a = g0(fuv.y).mul(add(g0x.mul(textureNode.uv(p0).level(lod)), g1x.mul(textureNode.uv(p1).level(lod))));
  const b = g1(fuv.y).mul(add(g0x.mul(textureNode.uv(p2).level(lod)), g1x.mul(textureNode.uv(p3).level(lod))));
  return a.add(b);
};
var textureBicubicMethod = (textureNode, lodNode) => {
  const fLodSize = vec2(textureNode.size(int(lodNode)));
  const cLodSize = vec2(textureNode.size(int(lodNode.add(1))));
  const fLodSizeInv = div(1, fLodSize);
  const cLodSizeInv = div(1, cLodSize);
  const fSample = bicubic(textureNode, vec4(fLodSizeInv, fLodSize), floor(lodNode));
  const cSample = bicubic(textureNode, vec4(cLodSizeInv, cLodSize), ceil(lodNode));
  return fract(lodNode).mix(fSample, cSample);
};
var TextureBicubicNode = class extends TempNode_default {
  constructor(textureNode, blurNode = float(3)) {
    super("vec4");
    this.textureNode = textureNode;
    this.blurNode = blurNode;
  }
  setup() {
    return textureBicubicMethod(this.textureNode, this.blurNode);
  }
};
var TextureBicubicNode_default = TextureBicubicNode;
var textureBicubic = nodeProxy(TextureBicubicNode);
addNodeElement("bicubic", textureBicubic);
addNodeClass("TextureBicubicNode", TextureBicubicNode);

// node_modules/three/examples/jsm/nodes/accessors/PointUVNode.js
var PointUVNode = class extends Node_default {
  constructor() {
    super("vec2");
    this.isPointUVNode = true;
  }
  generate() {
    return "vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )";
  }
};
var PointUVNode_default = PointUVNode;
var pointUV = nodeImmutable(PointUVNode);
addNodeClass("PointUVNode", PointUVNode);

// node_modules/three/examples/jsm/nodes/accessors/SceneNode.js
var SceneNode = class _SceneNode extends Node_default {
  constructor(scope = _SceneNode.BACKGROUND_BLURRINESS, scene = null) {
    super();
    this.scope = scope;
    this.scene = scene;
  }
  setup(builder) {
    const scope = this.scope;
    const scene = this.scene !== null ? this.scene : builder.scene;
    let output2;
    if (scope === _SceneNode.BACKGROUND_BLURRINESS) {
      output2 = reference("backgroundBlurriness", "float", scene);
    } else if (scope === _SceneNode.BACKGROUND_INTENSITY) {
      output2 = reference("backgroundIntensity", "float", scene);
    } else {
      console.error("THREE.SceneNode: Unknown scope:", scope);
    }
    return output2;
  }
};
SceneNode.BACKGROUND_BLURRINESS = "backgroundBlurriness";
SceneNode.BACKGROUND_INTENSITY = "backgroundIntensity";
var SceneNode_default = SceneNode;
var backgroundBlurriness = nodeImmutable(SceneNode, SceneNode.BACKGROUND_BLURRINESS);
var backgroundIntensity = nodeImmutable(SceneNode, SceneNode.BACKGROUND_INTENSITY);
addNodeClass("SceneNode", SceneNode);

// node_modules/three/examples/jsm/nodes/accessors/StorageBufferNode.js
var StorageBufferNode = class extends BufferNode_default {
  constructor(value, bufferType, bufferCount = 0) {
    super(value, bufferType, bufferCount);
    this.isStorageBufferNode = true;
    this.bufferObject = false;
    this._attribute = null;
    this._varying = null;
    if (value.isStorageBufferAttribute !== true && value.isStorageInstancedBufferAttribute !== true) {
      if (value.isInstancedBufferAttribute)
        value.isStorageInstancedBufferAttribute = true;
      else
        value.isStorageBufferAttribute = true;
    }
  }
  getInputType() {
    return "storageBuffer";
  }
  element(indexNode) {
    return storageElement(this, indexNode);
  }
  setBufferObject(value) {
    this.bufferObject = value;
    return this;
  }
  generate(builder) {
    if (builder.isAvailable("storageBuffer"))
      return super.generate(builder);
    const nodeType = this.getNodeType(builder);
    if (this._attribute === null) {
      this._attribute = bufferAttribute(this.value);
      this._varying = varying(this._attribute);
    }
    const output2 = this._varying.build(builder, nodeType);
    builder.registerTransform(output2, this._attribute);
    return output2;
  }
};
var StorageBufferNode_default = StorageBufferNode;
var storage = (value, type, count) => nodeObject(new StorageBufferNode(value, type, count));
var storageObject = (value, type, count) => nodeObject(new StorageBufferNode(value, type, count).setBufferObject(true));
addNodeClass("StorageBufferNode", StorageBufferNode);

// node_modules/three/examples/jsm/renderers/webgpu/utils/WebGPUConstants.js
var GPUStorageTextureAccess = {
  WriteOnly: "write-only",
  ReadOnly: "read-only",
  ReadWrite: "read-write"
};

// node_modules/three/examples/jsm/nodes/accessors/StorageTextureNode.js
var StorageTextureNode = class extends TextureNode_default {
  constructor(value, uvNode, storeNode = null) {
    super(value, uvNode);
    this.storeNode = storeNode;
    this.isStorageTextureNode = true;
    this.access = GPUStorageTextureAccess.WriteOnly;
  }
  getInputType() {
    return "storageTexture";
  }
  setup(builder) {
    super.setup(builder);
    const properties = builder.getNodeProperties(this);
    properties.storeNode = this.storeNode;
  }
  setAccess(value) {
    this.access = value;
    return this;
  }
  generate(builder, output2) {
    let snippet;
    if (this.storeNode !== null) {
      snippet = this.generateStore(builder);
    } else {
      snippet = super.generate(builder, output2);
    }
    return snippet;
  }
  generateStore(builder) {
    const properties = builder.getNodeProperties(this);
    const { uvNode, storeNode } = properties;
    const textureProperty = super.generate(builder, "property");
    const uvSnippet = uvNode.build(builder, "uvec2");
    const storeSnippet = storeNode.build(builder, "vec4");
    const snippet = builder.generateTextureStore(builder, textureProperty, uvSnippet, storeSnippet);
    builder.addLineFlowCode(snippet);
  }
};
var StorageTextureNode_default = StorageTextureNode;
var storageTexture = nodeProxy(StorageTextureNode);
var storageTextureReadOnly = (value, uvNode, storeNode) => storageTexture(value, uvNode, storeNode).setAccess("read-only");
var storageTextureReadWrite = (value, uvNode, storeNode) => storageTexture(value, uvNode, storeNode).setAccess("read-write");
var textureStore = (value, uvNode, storeNode) => {
  const node = storageTexture(value, uvNode, storeNode);
  if (storeNode !== null)
    node.append();
  return node;
};
addNodeClass("StorageTextureNode", StorageTextureNode);

// node_modules/three/examples/jsm/nodes/accessors/Texture3DNode.js
var normal = tslFn(({ texture: texture2, uv: uv2 }) => {
  const epsilon = 1e-4;
  const ret = vec3().temp();
  If(uv2.x.lessThan(epsilon), () => {
    ret.assign(vec3(1, 0, 0));
  }).elseif(uv2.y.lessThan(epsilon), () => {
    ret.assign(vec3(0, 1, 0));
  }).elseif(uv2.z.lessThan(epsilon), () => {
    ret.assign(vec3(0, 0, 1));
  }).elseif(uv2.x.greaterThan(1 - epsilon), () => {
    ret.assign(vec3(-1, 0, 0));
  }).elseif(uv2.y.greaterThan(1 - epsilon), () => {
    ret.assign(vec3(0, -1, 0));
  }).elseif(uv2.z.greaterThan(1 - epsilon), () => {
    ret.assign(vec3(0, 0, -1));
  }).else(() => {
    const step2 = 0.01;
    const x = texture2.uv(uv2.add(vec3(-step2, 0, 0))).r.sub(texture2.uv(uv2.add(vec3(step2, 0, 0))).r);
    const y = texture2.uv(uv2.add(vec3(0, -step2, 0))).r.sub(texture2.uv(uv2.add(vec3(0, step2, 0))).r);
    const z = texture2.uv(uv2.add(vec3(0, 0, -step2))).r.sub(texture2.uv(uv2.add(vec3(0, 0, step2))).r);
    ret.assign(vec3(x, y, z));
  });
  return ret.normalize();
});
var Texture3DNode = class extends TextureNode_default {
  constructor(value, uvNode = null, levelNode = null) {
    super(value, uvNode, levelNode);
    this.isTexture3DNode = true;
  }
  getInputType() {
    return "texture3D";
  }
  getDefaultUV() {
    return vec3(0.5, 0.5, 0.5);
  }
  setUpdateMatrix() {
  }
  // Ignore .updateMatrix for 3d TextureNode
  setupUV(builder, uvNode) {
    return uvNode;
  }
  generateUV(builder, uvNode) {
    return uvNode.build(builder, "vec3");
  }
  normal(uvNode) {
    return normal({ texture: this, uv: uvNode });
  }
};
var Texture3DNode_default = Texture3DNode;
var texture3D = nodeProxy(Texture3DNode);
addNodeClass("Texture3DNode", Texture3DNode);

// node_modules/three/examples/jsm/nodes/accessors/UserDataNode.js
var UserDataNode = class extends ReferenceNode_default {
  constructor(property2, inputType, userData2 = null) {
    super(property2, inputType, userData2);
    this.userData = userData2;
  }
  update(frame) {
    this.reference = this.userData !== null ? this.userData : frame.object.userData;
    super.update(frame);
  }
};
var UserDataNode_default = UserDataNode;
var userData = (name, inputType, userData2) => nodeObject(new UserDataNode(name, inputType, userData2));
addNodeClass("UserDataNode", UserDataNode);

// node_modules/three/examples/jsm/nodes/display/BlendModeNode.js
var BurnNode = tslFn(({ base, blend }) => {
  const fn = (c) => blend[c].lessThan(EPSILON).cond(blend[c], base[c].oneMinus().div(blend[c]).oneMinus().max(0));
  return vec3(fn("x"), fn("y"), fn("z"));
}).setLayout({
  name: "burnColor",
  type: "vec3",
  inputs: [
    { name: "base", type: "vec3" },
    { name: "blend", type: "vec3" }
  ]
});
var DodgeNode = tslFn(({ base, blend }) => {
  const fn = (c) => blend[c].equal(1).cond(blend[c], base[c].div(blend[c].oneMinus()).max(0));
  return vec3(fn("x"), fn("y"), fn("z"));
}).setLayout({
  name: "dodgeColor",
  type: "vec3",
  inputs: [
    { name: "base", type: "vec3" },
    { name: "blend", type: "vec3" }
  ]
});
var ScreenNode = tslFn(({ base, blend }) => {
  const fn = (c) => base[c].oneMinus().mul(blend[c].oneMinus()).oneMinus();
  return vec3(fn("x"), fn("y"), fn("z"));
}).setLayout({
  name: "screenColor",
  type: "vec3",
  inputs: [
    { name: "base", type: "vec3" },
    { name: "blend", type: "vec3" }
  ]
});
var OverlayNode = tslFn(({ base, blend }) => {
  const fn = (c) => base[c].lessThan(0.5).cond(base[c].mul(blend[c], 2), base[c].oneMinus().mul(blend[c].oneMinus()).oneMinus());
  return vec3(fn("x"), fn("y"), fn("z"));
}).setLayout({
  name: "overlayColor",
  type: "vec3",
  inputs: [
    { name: "base", type: "vec3" },
    { name: "blend", type: "vec3" }
  ]
});
var BlendModeNode = class _BlendModeNode extends TempNode_default {
  constructor(blendMode, baseNode, blendNode) {
    super();
    this.blendMode = blendMode;
    this.baseNode = baseNode;
    this.blendNode = blendNode;
  }
  setup() {
    const { blendMode, baseNode, blendNode } = this;
    const params = { base: baseNode, blend: blendNode };
    let outputNode = null;
    if (blendMode === _BlendModeNode.BURN) {
      outputNode = BurnNode(params);
    } else if (blendMode === _BlendModeNode.DODGE) {
      outputNode = DodgeNode(params);
    } else if (blendMode === _BlendModeNode.SCREEN) {
      outputNode = ScreenNode(params);
    } else if (blendMode === _BlendModeNode.OVERLAY) {
      outputNode = OverlayNode(params);
    }
    return outputNode;
  }
};
BlendModeNode.BURN = "burn";
BlendModeNode.DODGE = "dodge";
BlendModeNode.SCREEN = "screen";
BlendModeNode.OVERLAY = "overlay";
var BlendModeNode_default = BlendModeNode;
var burn = nodeProxy(BlendModeNode, BlendModeNode.BURN);
var dodge = nodeProxy(BlendModeNode, BlendModeNode.DODGE);
var overlay = nodeProxy(BlendModeNode, BlendModeNode.OVERLAY);
var screen = nodeProxy(BlendModeNode, BlendModeNode.SCREEN);
addNodeElement("burn", burn);
addNodeElement("dodge", dodge);
addNodeElement("overlay", overlay);
addNodeElement("screen", screen);
addNodeClass("BlendModeNode", BlendModeNode);

// node_modules/three/examples/jsm/nodes/display/BumpMapNode.js
var dHdxy_fwd = tslFn(({ textureNode, bumpScale }) => {
  const sampleTexture = (callback) => textureNode.cache().context({ getUV: (texNode) => callback(texNode.uvNode || uv()), forceUVContext: true });
  const Hll = float(sampleTexture((uvNode) => uvNode));
  return vec2(
    float(sampleTexture((uvNode) => uvNode.add(uvNode.dFdx()))).sub(Hll),
    float(sampleTexture((uvNode) => uvNode.add(uvNode.dFdy()))).sub(Hll)
  ).mul(bumpScale);
});
var perturbNormalArb = tslFn((inputs) => {
  const { surf_pos, surf_norm, dHdxy } = inputs;
  const vSigmaX = surf_pos.dFdx().normalize();
  const vSigmaY = surf_pos.dFdy().normalize();
  const vN = surf_norm;
  const R1 = vSigmaY.cross(vN);
  const R2 = vN.cross(vSigmaX);
  const fDet = vSigmaX.dot(R1).mul(faceDirection);
  const vGrad = fDet.sign().mul(dHdxy.x.mul(R1).add(dHdxy.y.mul(R2)));
  return fDet.abs().mul(surf_norm).sub(vGrad).normalize();
});
var BumpMapNode = class extends TempNode_default {
  constructor(textureNode, scaleNode = null) {
    super("vec3");
    this.textureNode = textureNode;
    this.scaleNode = scaleNode;
  }
  setup() {
    const bumpScale = this.scaleNode !== null ? this.scaleNode : 1;
    const dHdxy = dHdxy_fwd({ textureNode: this.textureNode, bumpScale });
    return perturbNormalArb({
      surf_pos: positionView,
      surf_norm: normalView,
      dHdxy
    });
  }
};
var BumpMapNode_default = BumpMapNode;
var bumpMap = nodeProxy(BumpMapNode);
addNodeElement("bumpMap", bumpMap);
addNodeClass("BumpMapNode", BumpMapNode);

// node_modules/three/examples/jsm/nodes/display/ColorAdjustmentNode.js
var saturationNode = tslFn(({ color: color2, adjustment }) => {
  return adjustment.mix(luminance(color2.rgb), color2.rgb);
});
var vibranceNode = tslFn(({ color: color2, adjustment }) => {
  const average = add(color2.r, color2.g, color2.b).div(3);
  const mx = color2.r.max(color2.g.max(color2.b));
  const amt = mx.sub(average).mul(adjustment).mul(-3);
  return mix(color2.rgb, mx, amt);
});
var hueNode = tslFn(({ color: color2, adjustment }) => {
  const k = vec3(0.57735, 0.57735, 0.57735);
  const cosAngle = adjustment.cos();
  return vec3(color2.rgb.mul(cosAngle).add(k.cross(color2.rgb).mul(adjustment.sin()).add(k.mul(dot(k, color2.rgb).mul(cosAngle.oneMinus())))));
});
var ColorAdjustmentNode = class _ColorAdjustmentNode extends TempNode_default {
  constructor(method, colorNode, adjustmentNode = float(1)) {
    super("vec3");
    this.method = method;
    this.colorNode = colorNode;
    this.adjustmentNode = adjustmentNode;
  }
  setup() {
    const { method, colorNode, adjustmentNode } = this;
    const callParams = { color: colorNode, adjustment: adjustmentNode };
    let outputNode = null;
    if (method === _ColorAdjustmentNode.SATURATION) {
      outputNode = saturationNode(callParams);
    } else if (method === _ColorAdjustmentNode.VIBRANCE) {
      outputNode = vibranceNode(callParams);
    } else if (method === _ColorAdjustmentNode.HUE) {
      outputNode = hueNode(callParams);
    } else {
      console.error(`${this.type}: Method "${this.method}" not supported!`);
    }
    return outputNode;
  }
};
ColorAdjustmentNode.SATURATION = "saturation";
ColorAdjustmentNode.VIBRANCE = "vibrance";
ColorAdjustmentNode.HUE = "hue";
var ColorAdjustmentNode_default = ColorAdjustmentNode;
var saturation = nodeProxy(ColorAdjustmentNode, ColorAdjustmentNode.SATURATION);
var vibrance = nodeProxy(ColorAdjustmentNode, ColorAdjustmentNode.VIBRANCE);
var hue = nodeProxy(ColorAdjustmentNode, ColorAdjustmentNode.HUE);
var lumaCoeffs = vec3(0.2125, 0.7154, 0.0721);
var luminance = (color2, luma = lumaCoeffs) => dot(color2, luma);
var threshold = (color2, threshold2) => mix(vec3(0), color2, luminance(color2).sub(threshold2).max(0));
addNodeElement("saturation", saturation);
addNodeElement("vibrance", vibrance);
addNodeElement("hue", hue);
addNodeElement("threshold", threshold);
addNodeClass("ColorAdjustmentNode", ColorAdjustmentNode);

// node_modules/three/examples/jsm/nodes/display/NormalMapNode.js
var perturbNormal2Arb = tslFn((inputs) => {
  const { eye_pos, surf_norm, mapN, uv: uv2 } = inputs;
  const q0 = eye_pos.dFdx();
  const q1 = eye_pos.dFdy();
  const st0 = uv2.dFdx();
  const st1 = uv2.dFdy();
  const N = surf_norm;
  const q1perp = q1.cross(N);
  const q0perp = N.cross(q0);
  const T = q1perp.mul(st0.x).add(q0perp.mul(st1.x));
  const B = q1perp.mul(st0.y).add(q0perp.mul(st1.y));
  const det = T.dot(T).max(B.dot(B));
  const scale = faceDirection.mul(det.inverseSqrt());
  return add(T.mul(mapN.x, scale), B.mul(mapN.y, scale), N.mul(mapN.z)).normalize();
});
var NormalMapNode = class extends TempNode_default {
  constructor(node, scaleNode = null) {
    super("vec3");
    this.node = node;
    this.scaleNode = scaleNode;
    this.normalMapType = TangentSpaceNormalMap;
  }
  setup(builder) {
    const { normalMapType, scaleNode } = this;
    let normalMap2 = this.node.mul(2).sub(1);
    if (scaleNode !== null) {
      normalMap2 = vec3(normalMap2.xy.mul(scaleNode), normalMap2.z);
    }
    let outputNode = null;
    if (normalMapType === ObjectSpaceNormalMap) {
      outputNode = modelNormalMatrix.mul(normalMap2).normalize();
    } else if (normalMapType === TangentSpaceNormalMap) {
      const tangent = builder.hasGeometryAttribute("tangent");
      if (tangent === true) {
        outputNode = TBNViewMatrix.mul(normalMap2).normalize();
      } else {
        outputNode = perturbNormal2Arb({
          eye_pos: positionView,
          surf_norm: normalView,
          mapN: normalMap2,
          uv: uv()
        });
      }
    }
    return outputNode;
  }
};
var NormalMapNode_default = NormalMapNode;
var normalMap = nodeProxy(NormalMapNode);
addNodeElement("normalMap", normalMap);
addNodeClass("NormalMapNode", NormalMapNode);

// node_modules/three/examples/jsm/nodes/display/PosterizeNode.js
var PosterizeNode = class extends TempNode_default {
  constructor(sourceNode, stepsNode) {
    super();
    this.sourceNode = sourceNode;
    this.stepsNode = stepsNode;
  }
  setup() {
    const { sourceNode, stepsNode } = this;
    return sourceNode.mul(stepsNode).floor().div(stepsNode);
  }
};
var PosterizeNode_default = PosterizeNode;
var posterize = nodeProxy(PosterizeNode);
addNodeElement("posterize", posterize);
addNodeClass("PosterizeNode", PosterizeNode);

// node_modules/three/examples/jsm/nodes/display/ToneMappingNode.js
var LinearToneMappingNode = tslFn(({ color: color2, exposure }) => {
  return color2.mul(exposure).clamp();
});
var ReinhardToneMappingNode = tslFn(({ color: color2, exposure }) => {
  color2 = color2.mul(exposure);
  return color2.div(color2.add(1)).clamp();
});
var OptimizedCineonToneMappingNode = tslFn(({ color: color2, exposure }) => {
  color2 = color2.mul(exposure);
  color2 = color2.sub(4e-3).max(0);
  const a = color2.mul(color2.mul(6.2).add(0.5));
  const b = color2.mul(color2.mul(6.2).add(1.7)).add(0.06);
  return a.div(b).pow(2.2);
});
var RRTAndODTFit = tslFn(({ color: color2 }) => {
  const a = color2.mul(color2.add(0.0245786)).sub(90537e-9);
  const b = color2.mul(color2.add(0.432951).mul(0.983729)).add(0.238081);
  return a.div(b);
});
var ACESFilmicToneMappingNode = tslFn(({ color: color2, exposure }) => {
  const ACESInputMat = mat3(
    0.59719,
    0.35458,
    0.04823,
    0.076,
    0.90834,
    0.01566,
    0.0284,
    0.13383,
    0.83777
  );
  const ACESOutputMat = mat3(
    1.60475,
    -0.53108,
    -0.07367,
    -0.10208,
    1.10813,
    -605e-5,
    -327e-5,
    -0.07276,
    1.07602
  );
  color2 = color2.mul(exposure).div(0.6);
  color2 = ACESInputMat.mul(color2);
  color2 = RRTAndODTFit({ color: color2 });
  color2 = ACESOutputMat.mul(color2);
  return color2.clamp();
});
var LINEAR_REC2020_TO_LINEAR_SRGB = mat3(vec3(1.6605, -0.1246, -0.0182), vec3(-0.5876, 1.1329, -0.1006), vec3(-0.0728, -83e-4, 1.1187));
var LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(vec3(0.6274, 0.0691, 0.0164), vec3(0.3293, 0.9195, 0.088), vec3(0.0433, 0.0113, 0.8956));
var agxDefaultContrastApprox = tslFn(([x_immutable]) => {
  const x = vec3(x_immutable).toVar();
  const x2 = vec3(x.mul(x)).toVar();
  const x4 = vec3(x2.mul(x2)).toVar();
  return float(15.5).mul(x4.mul(x2)).sub(mul(40.14, x4.mul(x))).add(mul(31.96, x4).sub(mul(6.868, x2.mul(x))).add(mul(0.4298, x2).add(mul(0.1191, x).sub(232e-5))));
});
var AGXToneMappingNode = tslFn(({ color: color2, exposure }) => {
  const colortone = vec3(color2).toVar();
  const AgXInsetMatrix = mat3(vec3(0.856627153315983, 0.137318972929847, 0.11189821299995), vec3(0.0951212405381588, 0.761241990602591, 0.0767994186031903), vec3(0.0482516061458583, 0.101439036467562, 0.811302368396859));
  const AgXOutsetMatrix = mat3(vec3(1.1271005818144368, -0.1413297634984383, -0.14132976349843826), vec3(-0.11060664309660323, 1.157823702216272, -0.11060664309660294), vec3(-0.016493938717834573, -0.016493938717834257, 1.2519364065950405));
  const AgxMinEv = float(-12.47393);
  const AgxMaxEv = float(4.026069);
  colortone.mulAssign(exposure);
  colortone.assign(LINEAR_SRGB_TO_LINEAR_REC2020.mul(colortone));
  colortone.assign(AgXInsetMatrix.mul(colortone));
  colortone.assign(max(colortone, 1e-10));
  colortone.assign(log2(colortone));
  colortone.assign(colortone.sub(AgxMinEv).div(AgxMaxEv.sub(AgxMinEv)));
  colortone.assign(clamp(colortone, 0, 1));
  colortone.assign(agxDefaultContrastApprox(colortone));
  colortone.assign(AgXOutsetMatrix.mul(colortone));
  colortone.assign(pow(max(vec3(0), colortone), vec3(2.2)));
  colortone.assign(LINEAR_REC2020_TO_LINEAR_SRGB.mul(colortone));
  colortone.assign(clamp(colortone, 0, 1));
  return colortone;
});
var toneMappingLib = {
  [LinearToneMapping]: LinearToneMappingNode,
  [ReinhardToneMapping]: ReinhardToneMappingNode,
  [CineonToneMapping]: OptimizedCineonToneMappingNode,
  [ACESFilmicToneMapping]: ACESFilmicToneMappingNode,
  [AgXToneMapping]: AGXToneMappingNode
};
var ToneMappingNode = class extends TempNode_default {
  constructor(toneMapping2 = NoToneMapping, exposureNode = toneMappingExposure, colorNode = null) {
    super("vec3");
    this.toneMapping = toneMapping2;
    this.exposureNode = exposureNode;
    this.colorNode = colorNode;
  }
  getCacheKey() {
    let cacheKey = super.getCacheKey();
    cacheKey = "{toneMapping:" + this.toneMapping + ",nodes:" + cacheKey + "}";
    return cacheKey;
  }
  setup(builder) {
    const colorNode = this.colorNode || builder.context.color;
    const toneMapping2 = this.toneMapping;
    if (toneMapping2 === NoToneMapping)
      return colorNode;
    const toneMappingParams = { exposure: this.exposureNode, color: colorNode };
    const toneMappingNode = toneMappingLib[toneMapping2];
    let outputNode = null;
    if (toneMappingNode) {
      outputNode = toneMappingNode(toneMappingParams);
    } else {
      console.error("ToneMappingNode: Unsupported Tone Mapping configuration.", toneMapping2);
      outputNode = colorNode;
    }
    return outputNode;
  }
};
var ToneMappingNode_default = ToneMappingNode;
var toneMapping = (mapping, exposure, color2) => nodeObject(new ToneMappingNode(mapping, nodeObject(exposure), nodeObject(color2)));
var toneMappingExposure = rendererReference("toneMappingExposure", "float");
addNodeElement("toneMapping", (color2, mapping, exposure) => toneMapping(mapping, exposure, color2));
addNodeClass("ToneMappingNode", ToneMappingNode);

// node_modules/three/examples/jsm/nodes/display/ViewportSharedTextureNode.js
var _sharedFramebuffer = null;
var ViewportSharedTextureNode = class extends ViewportTextureNode_default {
  constructor(uvNode = viewportTopLeft, levelNode = null) {
    if (_sharedFramebuffer === null) {
      _sharedFramebuffer = new FramebufferTexture();
    }
    super(uvNode, levelNode, _sharedFramebuffer);
  }
  updateReference() {
    return this;
  }
};
var ViewportSharedTextureNode_default = ViewportSharedTextureNode;
var viewportSharedTexture = nodeProxy(ViewportSharedTextureNode);
addNodeElement("viewportSharedTexture", viewportSharedTexture);
addNodeClass("ViewportSharedTextureNode", ViewportSharedTextureNode);

// node_modules/three/examples/jsm/nodes/display/PassNode.js
var _size3 = new Vector2();
var PassTextureNode = class extends TextureNode_default {
  constructor(passNode, texture2) {
    super(texture2);
    this.passNode = passNode;
    this.setUpdateMatrix(false);
  }
  setup(builder) {
    this.passNode.build(builder);
    return super.setup(builder);
  }
  clone() {
    return new this.constructor(this.passNode, this.value);
  }
};
var PassNode = class _PassNode extends TempNode_default {
  constructor(scope, scene, camera) {
    super("vec4");
    this.scope = scope;
    this.scene = scene;
    this.camera = camera;
    this._pixelRatio = 1;
    this._width = 1;
    this._height = 1;
    const depthTexture2 = new DepthTexture();
    depthTexture2.isRenderTargetTexture = true;
    depthTexture2.name = "PostProcessingDepth";
    const renderTarget = new RenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio, { type: HalfFloatType });
    renderTarget.texture.name = "PostProcessing";
    renderTarget.depthTexture = depthTexture2;
    this.renderTarget = renderTarget;
    this.updateBeforeType = NodeUpdateType.FRAME;
    this._textureNode = nodeObject(new PassTextureNode(this, renderTarget.texture));
    this._depthTextureNode = nodeObject(new PassTextureNode(this, depthTexture2));
    this._depthNode = null;
    this._viewZNode = null;
    this._cameraNear = uniform(0);
    this._cameraFar = uniform(0);
    this.isPassNode = true;
  }
  isGlobal() {
    return true;
  }
  getTextureNode() {
    return this._textureNode;
  }
  getTextureDepthNode() {
    return this._depthTextureNode;
  }
  getViewZNode() {
    if (this._viewZNode === null) {
      const cameraNear2 = this._cameraNear;
      const cameraFar2 = this._cameraFar;
      this._viewZNode = perspectiveDepthToViewZ(this._depthTextureNode, cameraNear2, cameraFar2);
    }
    return this._viewZNode;
  }
  getDepthNode() {
    if (this._depthNode === null) {
      const cameraNear2 = this._cameraNear;
      const cameraFar2 = this._cameraFar;
      this._depthNode = viewZToOrthographicDepth(this.getViewZNode(), cameraNear2, cameraFar2);
    }
    return this._depthNode;
  }
  setup() {
    return this.scope === _PassNode.COLOR ? this.getTextureNode() : this.getDepthNode();
  }
  updateBefore(frame) {
    const { renderer } = frame;
    const { scene, camera } = this;
    this._pixelRatio = renderer.getPixelRatio();
    const size = renderer.getSize(_size3);
    this.setSize(size.width, size.height);
    const currentToneMapping = renderer.toneMapping;
    const currentToneMappingNode = renderer.toneMappingNode;
    const currentRenderTarget = renderer.getRenderTarget();
    this._cameraNear.value = camera.near;
    this._cameraFar.value = camera.far;
    renderer.toneMapping = NoToneMapping;
    renderer.toneMappingNode = null;
    renderer.setRenderTarget(this.renderTarget);
    renderer.render(scene, camera);
    renderer.toneMapping = currentToneMapping;
    renderer.toneMappingNode = currentToneMappingNode;
    renderer.setRenderTarget(currentRenderTarget);
  }
  setSize(width, height) {
    this._width = width;
    this._height = height;
    const effectiveWidth = this._width * this._pixelRatio;
    const effectiveHeight = this._height * this._pixelRatio;
    this.renderTarget.setSize(effectiveWidth, effectiveHeight);
  }
  setPixelRatio(pixelRatio) {
    this._pixelRatio = pixelRatio;
    this.setSize(this._width, this._height);
  }
  dispose() {
    this.renderTarget.dispose();
  }
};
PassNode.COLOR = "color";
PassNode.DEPTH = "depth";
var PassNode_default = PassNode;
var pass = (scene, camera) => nodeObject(new PassNode(PassNode.COLOR, scene, camera));
var texturePass = (pass2, texture2) => nodeObject(new PassTextureNode(pass2, texture2));
var depthPass = (scene, camera) => nodeObject(new PassNode(PassNode.DEPTH, scene, camera));
addNodeClass("PassNode", PassNode);

// node_modules/three/examples/jsm/objects/QuadMesh.js
var _camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
var QuadGeometry = class extends BufferGeometry {
  constructor(flipY = false) {
    super();
    const uv2 = flipY === false ? [0, -1, 0, 1, 2, 1] : [0, 2, 0, 0, 2, 0];
    this.setAttribute("position", new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
    this.setAttribute("uv", new Float32BufferAttribute(uv2, 2));
  }
};
var _geometry = new QuadGeometry();
var QuadMesh = class extends Mesh {
  constructor(material = null) {
    super(_geometry, material);
    this.camera = _camera;
  }
  renderAsync(renderer) {
    return renderer.renderAsync(this, _camera);
  }
  render(renderer) {
    renderer.render(this, _camera);
  }
};
var QuadMesh_default = QuadMesh;

// node_modules/three/examples/jsm/nodes/display/GaussianBlurNode.js
var quadMesh1 = new QuadMesh_default();
var quadMesh2 = new QuadMesh_default();
var GaussianBlurNode = class extends TempNode_default {
  constructor(textureNode, sigma = 2) {
    super("vec4");
    this.textureNode = textureNode;
    this.sigma = sigma;
    this.directionNode = vec2(1);
    this._invSize = uniform(new Vector2());
    this._passDirection = uniform(new Vector2());
    this._horizontalRT = new RenderTarget();
    this._horizontalRT.texture.name = "GaussianBlurNode.horizontal";
    this._verticalRT = new RenderTarget();
    this._verticalRT.texture.name = "GaussianBlurNode.vertical";
    this._textureNode = texturePass(this, this._verticalRT.texture);
    this.updateBeforeType = NodeUpdateType.RENDER;
    this.resolution = new Vector2(1, 1);
  }
  setSize(width, height) {
    width = Math.max(Math.round(width * this.resolution.x), 1);
    height = Math.max(Math.round(height * this.resolution.y), 1);
    this._invSize.value.set(1 / width, 1 / height);
    this._horizontalRT.setSize(width, height);
    this._verticalRT.setSize(width, height);
  }
  updateBefore(frame) {
    const { renderer } = frame;
    const textureNode = this.textureNode;
    const map = textureNode.value;
    const currentRenderTarget = renderer.getRenderTarget();
    const currentTexture = textureNode.value;
    quadMesh1.material = this._material;
    quadMesh2.material = this._material;
    this.setSize(map.image.width, map.image.height);
    const textureType = map.type;
    this._horizontalRT.texture.type = textureType;
    this._verticalRT.texture.type = textureType;
    renderer.setRenderTarget(this._horizontalRT);
    this._passDirection.value.set(1, 0);
    quadMesh1.render(renderer);
    textureNode.value = this._horizontalRT.texture;
    renderer.setRenderTarget(this._verticalRT);
    this._passDirection.value.set(0, 1);
    quadMesh2.render(renderer);
    renderer.setRenderTarget(currentRenderTarget);
    textureNode.value = currentTexture;
  }
  getTextureNode() {
    return this._textureNode;
  }
  setup(builder) {
    const textureNode = this.textureNode;
    if (textureNode.isTextureNode !== true) {
      console.error("GaussianBlurNode requires a TextureNode.");
      return vec4();
    }
    const uvNode = textureNode.uvNode || uv();
    const sampleTexture = (uv2) => textureNode.cache().context({ getUV: () => uv2, forceUVContext: true });
    const blur2 = tslFn(() => {
      const kernelSize = 3 + 2 * this.sigma;
      const gaussianCoefficients = this._getCoefficients(kernelSize);
      const invSize = this._invSize;
      const direction2 = vec2(this.directionNode).mul(this._passDirection);
      const weightSum = float(gaussianCoefficients[0]).toVar();
      const diffuseSum = vec4(sampleTexture(uvNode).mul(weightSum)).toVar();
      for (let i = 1; i < kernelSize; i++) {
        const x = float(i);
        const w = float(gaussianCoefficients[i]);
        const uvOffset = vec2(direction2.mul(invSize.mul(x))).toVar();
        const sample1 = vec4(sampleTexture(uvNode.add(uvOffset)));
        const sample2 = vec4(sampleTexture(uvNode.sub(uvOffset)));
        diffuseSum.addAssign(sample1.add(sample2).mul(w));
        weightSum.addAssign(mul(2, w));
      }
      return diffuseSum.div(weightSum);
    });
    const material = this._material || (this._material = builder.createNodeMaterial());
    material.fragmentNode = blur2();
    const properties = builder.getNodeProperties(this);
    properties.textureNode = textureNode;
    return this._textureNode;
  }
  _getCoefficients(kernelRadius) {
    const coefficients = [];
    for (let i = 0; i < kernelRadius; i++) {
      coefficients.push(0.39894 * Math.exp(-0.5 * i * i / (kernelRadius * kernelRadius)) / kernelRadius);
    }
    return coefficients;
  }
};
var gaussianBlur = (node, sigma) => nodeObject(new GaussianBlurNode(nodeObject(node), sigma));
addNodeElement("gaussianBlur", gaussianBlur);
var GaussianBlurNode_default = GaussianBlurNode;

// node_modules/three/examples/jsm/nodes/display/AfterImageNode.js
var _size4 = new Vector2();
var quadMeshComp = new QuadMesh_default();
var AfterImageNode = class extends TempNode_default {
  constructor(textureNode, damp = 0.96) {
    super(textureNode);
    this.textureNode = textureNode;
    this.textureNodeOld = texture();
    this.damp = uniform(damp);
    this._compRT = new RenderTarget();
    this._compRT.texture.name = "AfterImageNode.comp";
    this._oldRT = new RenderTarget();
    this._oldRT.texture.name = "AfterImageNode.old";
    this._textureNode = texturePass(this, this._compRT.texture);
    this.updateBeforeType = NodeUpdateType.RENDER;
  }
  getTextureNode() {
    return this._textureNode;
  }
  setSize(width, height) {
    this._compRT.setSize(width, height);
    this._oldRT.setSize(width, height);
  }
  updateBefore(frame) {
    const { renderer } = frame;
    const textureNode = this.textureNode;
    const map = textureNode.value;
    const textureType = map.type;
    this._compRT.texture.type = textureType;
    this._oldRT.texture.type = textureType;
    renderer.getDrawingBufferSize(_size4);
    this.setSize(_size4.x, _size4.y);
    const currentToneMapping = renderer.toneMapping;
    const currentToneMappingNode = renderer.toneMappingNode;
    const currentRenderTarget = renderer.getRenderTarget();
    const currentTexture = textureNode.value;
    this.textureNodeOld.value = this._oldRT.texture;
    renderer.toneMapping = NoToneMapping;
    renderer.toneMappingNode = null;
    renderer.setRenderTarget(this._compRT);
    quadMeshComp.render(renderer);
    const temp2 = this._oldRT;
    this._oldRT = this._compRT;
    this._compRT = temp2;
    renderer.toneMapping = currentToneMapping;
    renderer.toneMappingNode = currentToneMappingNode;
    renderer.setRenderTarget(currentRenderTarget);
    textureNode.value = currentTexture;
  }
  setup(builder) {
    const textureNode = this.textureNode;
    const textureNodeOld = this.textureNodeOld;
    if (textureNode.isTextureNode !== true) {
      console.error("AfterImageNode requires a TextureNode.");
      return vec4();
    }
    const uvNode = textureNode.uvNode || uv();
    textureNodeOld.uvNode = uvNode;
    const sampleTexture = (uv2) => textureNode.cache().context({ getUV: () => uv2, forceUVContext: true });
    const when_gt = tslFn(([x_immutable, y_immutable]) => {
      const y = float(y_immutable).toVar();
      const x = vec4(x_immutable).toVar();
      return max(sign(x.sub(y)), 0);
    });
    const afterImg = tslFn(() => {
      const texelOld = vec4(textureNodeOld);
      const texelNew = vec4(sampleTexture(uvNode));
      texelOld.mulAssign(this.damp.mul(when_gt(texelOld, 0.1)));
      return max(texelNew, texelOld);
    });
    const materialComposed = this._materialComposed || (this._materialComposed = builder.createNodeMaterial());
    materialComposed.fragmentNode = afterImg();
    quadMeshComp.material = materialComposed;
    const properties = builder.getNodeProperties(this);
    properties.textureNode = textureNode;
    return this._textureNode;
  }
};
var afterImage = (node, damp) => nodeObject(new AfterImageNode(nodeObject(node), damp));
addNodeElement("afterImage", afterImage);
var AfterImageNode_default = AfterImageNode;

// node_modules/three/examples/jsm/nodes/display/AnamorphicNode.js
var quadMesh = new QuadMesh_default();
var AnamorphicNode = class extends TempNode_default {
  constructor(textureNode, tresholdNode, scaleNode, samples) {
    super("vec4");
    this.textureNode = textureNode;
    this.tresholdNode = tresholdNode;
    this.scaleNode = scaleNode;
    this.colorNode = vec3(0.1, 0, 1);
    this.samples = samples;
    this.resolution = new Vector2(1, 1);
    this._renderTarget = new RenderTarget();
    this._renderTarget.texture.name = "anamorphic";
    this._invSize = uniform(new Vector2());
    this._textureNode = texturePass(this, this._renderTarget.texture);
    this.updateBeforeType = NodeUpdateType.RENDER;
  }
  getTextureNode() {
    return this._textureNode;
  }
  setSize(width, height) {
    this._invSize.value.set(1 / width, 1 / height);
    width = Math.max(Math.round(width * this.resolution.x), 1);
    height = Math.max(Math.round(height * this.resolution.y), 1);
    this._renderTarget.setSize(width, height);
  }
  updateBefore(frame) {
    const { renderer } = frame;
    const textureNode = this.textureNode;
    const map = textureNode.value;
    this._renderTarget.texture.type = map.type;
    const currentRenderTarget = renderer.getRenderTarget();
    const currentTexture = textureNode.value;
    quadMesh.material = this._material;
    this.setSize(map.image.width, map.image.height);
    renderer.setRenderTarget(this._renderTarget);
    quadMesh.render(renderer);
    renderer.setRenderTarget(currentRenderTarget);
    textureNode.value = currentTexture;
  }
  setup(builder) {
    const textureNode = this.textureNode;
    if (textureNode.isTextureNode !== true) {
      console.error("AnamorphNode requires a TextureNode.");
      return vec4();
    }
    const uvNode = textureNode.uvNode || uv();
    const sampleTexture = (uv2) => textureNode.cache().context({ getUV: () => uv2, forceUVContext: true });
    const anamorph = tslFn(() => {
      const samples = this.samples;
      const halfSamples = Math.floor(samples / 2);
      const total = vec3(0).toVar();
      loop({ start: -halfSamples, end: halfSamples }, ({ i }) => {
        const softness = float(i).abs().div(halfSamples).oneMinus();
        const uv2 = vec2(uvNode.x.add(this._invSize.x.mul(i).mul(this.scaleNode)), uvNode.y);
        const color2 = sampleTexture(uv2);
        const pass2 = threshold(color2, this.tresholdNode).mul(softness);
        total.addAssign(pass2);
      });
      return total.mul(this.colorNode);
    });
    const material = this._material || (this._material = builder.createNodeMaterial());
    material.fragmentNode = anamorph();
    const properties = builder.getNodeProperties(this);
    properties.textureNode = textureNode;
    return this._textureNode;
  }
};
var anamorphic = (node, threshold2 = 0.9, scale = 3, samples = 32) => nodeObject(new AnamorphicNode(nodeObject(node), nodeObject(threshold2), nodeObject(scale), samples));
addNodeElement("anamorphic", anamorphic);
var AnamorphicNode_default = AnamorphicNode;

// node_modules/three/examples/jsm/nodes/code/FunctionCallNode.js
var FunctionCallNode = class extends TempNode_default {
  constructor(functionNode = null, parameters = {}) {
    super();
    this.functionNode = functionNode;
    this.parameters = parameters;
  }
  setParameters(parameters) {
    this.parameters = parameters;
    return this;
  }
  getParameters() {
    return this.parameters;
  }
  getNodeType(builder) {
    return this.functionNode.getNodeType(builder);
  }
  generate(builder) {
    const params = [];
    const functionNode = this.functionNode;
    const inputs = functionNode.getInputs(builder);
    const parameters = this.parameters;
    if (Array.isArray(parameters)) {
      for (let i = 0; i < parameters.length; i++) {
        const inputNode = inputs[i];
        const node = parameters[i];
        params.push(node.build(builder, inputNode.type));
      }
    } else {
      for (const inputNode of inputs) {
        const node = parameters[inputNode.name];
        if (node !== void 0) {
          params.push(node.build(builder, inputNode.type));
        } else {
          throw new Error(`FunctionCallNode: Input '${inputNode.name}' not found in FunctionNode.`);
        }
      }
    }
    const functionName = functionNode.build(builder, "property");
    return `${functionName}( ${params.join(", ")} )`;
  }
};
var FunctionCallNode_default = FunctionCallNode;
var call = (func, ...params) => {
  params = params.length > 1 || params[0] && params[0].isNode === true ? nodeArray(params) : nodeObjects(params[0]);
  return nodeObject(new FunctionCallNode(nodeObject(func), params));
};
addNodeElement("call", call);
addNodeClass("FunctionCallNode", FunctionCallNode);

// node_modules/three/examples/jsm/nodes/code/ScriptableValueNode.js
var ScriptableValueNode = class extends Node_default {
  constructor(value = null) {
    super();
    this._value = value;
    this._cache = null;
    this.inputType = null;
    this.outpuType = null;
    this.events = new EventDispatcher();
    this.isScriptableValueNode = true;
  }
  get isScriptableOutputNode() {
    return this.outputType !== null;
  }
  set value(val) {
    if (this._value === val)
      return;
    if (this._cache && this.inputType === "URL" && this.value.value instanceof ArrayBuffer) {
      URL.revokeObjectURL(this._cache);
      this._cache = null;
    }
    this._value = val;
    this.events.dispatchEvent({ type: "change" });
    this.refresh();
  }
  get value() {
    return this._value;
  }
  refresh() {
    this.events.dispatchEvent({ type: "refresh" });
  }
  getValue() {
    const value = this.value;
    if (value && this._cache === null && this.inputType === "URL" && value.value instanceof ArrayBuffer) {
      this._cache = URL.createObjectURL(new Blob([value.value]));
    } else if (value && value.value !== null && value.value !== void 0 && ((this.inputType === "URL" || this.inputType === "String") && typeof value.value === "string" || this.inputType === "Number" && typeof value.value === "number" || this.inputType === "Vector2" && value.value.isVector2 || this.inputType === "Vector3" && value.value.isVector3 || this.inputType === "Vector4" && value.value.isVector4 || this.inputType === "Color" && value.value.isColor || this.inputType === "Matrix3" && value.value.isMatrix3 || this.inputType === "Matrix4" && value.value.isMatrix4)) {
      return value.value;
    }
    return this._cache || value;
  }
  getNodeType(builder) {
    return this.value && this.value.isNode ? this.value.getNodeType(builder) : "float";
  }
  setup() {
    return this.value && this.value.isNode ? this.value : float();
  }
  serialize(data) {
    super.serialize(data);
    if (this.value !== null) {
      if (this.inputType === "ArrayBuffer") {
        data.value = arrayBufferToBase64(this.value);
      } else {
        data.value = this.value ? this.value.toJSON(data.meta).uuid : null;
      }
    } else {
      data.value = null;
    }
    data.inputType = this.inputType;
    data.outputType = this.outputType;
  }
  deserialize(data) {
    super.deserialize(data);
    let value = null;
    if (data.value !== null) {
      if (data.inputType === "ArrayBuffer") {
        value = base64ToArrayBuffer(data.value);
      } else if (data.inputType === "Texture") {
        value = data.meta.textures[data.value];
      } else {
        value = data.meta.nodes[data.value] || null;
      }
    }
    this.value = value;
    this.inputType = data.inputType;
    this.outputType = data.outputType;
  }
};
var ScriptableValueNode_default = ScriptableValueNode;
var scriptableValue = nodeProxy(ScriptableValueNode);
addNodeElement("scriptableValue", scriptableValue);
addNodeClass("ScriptableValueNode", ScriptableValueNode);

// node_modules/three/examples/jsm/nodes/code/ScriptableNode.js
var Resources = class extends Map {
  get(key, callback = null, ...params) {
    if (this.has(key))
      return super.get(key);
    if (callback !== null) {
      const value = callback(...params);
      this.set(key, value);
      return value;
    }
  }
};
var Parameters = class {
  constructor(scriptableNode) {
    this.scriptableNode = scriptableNode;
  }
  get parameters() {
    return this.scriptableNode.parameters;
  }
  get layout() {
    return this.scriptableNode.getLayout();
  }
  getInputLayout(id2) {
    return this.scriptableNode.getInputLayout(id2);
  }
  get(name) {
    const param = this.parameters[name];
    const value = param ? param.getValue() : null;
    return value;
  }
};
var global = new Resources();
var ScriptableNode = class extends Node_default {
  constructor(codeNode = null, parameters = {}) {
    super();
    this.codeNode = codeNode;
    this.parameters = parameters;
    this._local = new Resources();
    this._output = scriptableValue();
    this._outputs = {};
    this._source = this.source;
    this._method = null;
    this._object = null;
    this._value = null;
    this._needsOutputUpdate = true;
    this.onRefresh = this.onRefresh.bind(this);
    this.isScriptableNode = true;
  }
  get source() {
    return this.codeNode ? this.codeNode.code : "";
  }
  setLocal(name, value) {
    return this._local.set(name, value);
  }
  getLocal(name) {
    return this._local.get(name);
  }
  onRefresh() {
    this._refresh();
  }
  getInputLayout(id2) {
    for (const element2 of this.getLayout()) {
      if (element2.inputType && (element2.id === id2 || element2.name === id2)) {
        return element2;
      }
    }
  }
  getOutputLayout(id2) {
    for (const element2 of this.getLayout()) {
      if (element2.outputType && (element2.id === id2 || element2.name === id2)) {
        return element2;
      }
    }
  }
  setOutput(name, value) {
    const outputs = this._outputs;
    if (outputs[name] === void 0) {
      outputs[name] = scriptableValue(value);
    } else {
      outputs[name].value = value;
    }
    return this;
  }
  getOutput(name) {
    return this._outputs[name];
  }
  getParameter(name) {
    return this.parameters[name];
  }
  setParameter(name, value) {
    const parameters = this.parameters;
    if (value && value.isScriptableNode) {
      this.deleteParameter(name);
      parameters[name] = value;
      parameters[name].getDefaultOutput().events.addEventListener("refresh", this.onRefresh);
    } else if (value && value.isScriptableValueNode) {
      this.deleteParameter(name);
      parameters[name] = value;
      parameters[name].events.addEventListener("refresh", this.onRefresh);
    } else if (parameters[name] === void 0) {
      parameters[name] = scriptableValue(value);
      parameters[name].events.addEventListener("refresh", this.onRefresh);
    } else {
      parameters[name].value = value;
    }
    return this;
  }
  getValue() {
    return this.getDefaultOutput().getValue();
  }
  deleteParameter(name) {
    let valueNode = this.parameters[name];
    if (valueNode) {
      if (valueNode.isScriptableNode)
        valueNode = valueNode.getDefaultOutput();
      valueNode.events.removeEventListener("refresh", this.onRefresh);
    }
    return this;
  }
  clearParameters() {
    for (const name of Object.keys(this.parameters)) {
      this.deleteParameter(name);
    }
    this.needsUpdate = true;
    return this;
  }
  call(name, ...params) {
    const object = this.getObject();
    const method = object[name];
    if (typeof method === "function") {
      return method(...params);
    }
  }
  async callAsync(name, ...params) {
    const object = this.getObject();
    const method = object[name];
    if (typeof method === "function") {
      return method.constructor.name === "AsyncFunction" ? await method(...params) : method(...params);
    }
  }
  getNodeType(builder) {
    return this.getDefaultOutputNode().getNodeType(builder);
  }
  refresh(output2 = null) {
    if (output2 !== null) {
      this.getOutput(output2).refresh();
    } else {
      this._refresh();
    }
  }
  getObject() {
    if (this.needsUpdate)
      this.dispose();
    if (this._object !== null)
      return this._object;
    const refresh = () => this.refresh();
    const setOutput = (id2, value) => this.setOutput(id2, value);
    const parameters = new Parameters(this);
    const THREE = global.get("THREE");
    const TSL = global.get("TSL");
    const method = this.getMethod(this.codeNode);
    const params = [parameters, this._local, global, refresh, setOutput, THREE, TSL];
    this._object = method(...params);
    const layout = this._object.layout;
    if (layout) {
      if (layout.cache === false) {
        this._local.clear();
      }
      this._output.outputType = layout.outputType || null;
      if (Array.isArray(layout.elements)) {
        for (const element2 of layout.elements) {
          const id2 = element2.id || element2.name;
          if (element2.inputType) {
            if (this.getParameter(id2) === void 0)
              this.setParameter(id2, null);
            this.getParameter(id2).inputType = element2.inputType;
          }
          if (element2.outputType) {
            if (this.getOutput(id2) === void 0)
              this.setOutput(id2, null);
            this.getOutput(id2).outputType = element2.outputType;
          }
        }
      }
    }
    return this._object;
  }
  deserialize(data) {
    super.deserialize(data);
    for (const name in this.parameters) {
      let valueNode = this.parameters[name];
      if (valueNode.isScriptableNode)
        valueNode = valueNode.getDefaultOutput();
      valueNode.events.addEventListener("refresh", this.onRefresh);
    }
  }
  getLayout() {
    return this.getObject().layout;
  }
  getDefaultOutputNode() {
    const output2 = this.getDefaultOutput().value;
    if (output2 && output2.isNode) {
      return output2;
    }
    return float();
  }
  getDefaultOutput() {
    return this._exec()._output;
  }
  getMethod() {
    if (this.needsUpdate)
      this.dispose();
    if (this._method !== null)
      return this._method;
    const parametersProps = ["parameters", "local", "global", "refresh", "setOutput", "THREE", "TSL"];
    const interfaceProps = ["layout", "init", "main", "dispose"];
    const properties = interfaceProps.join(", ");
    const declarations = "var " + properties + "; var output = {};\n";
    const returns = "\nreturn { ...output, " + properties + " };";
    const code2 = declarations + this.codeNode.code + returns;
    this._method = new Function(...parametersProps, code2);
    return this._method;
  }
  dispose() {
    if (this._method === null)
      return;
    if (this._object && typeof this._object.dispose === "function") {
      this._object.dispose();
    }
    this._method = null;
    this._object = null;
    this._source = null;
    this._value = null;
    this._needsOutputUpdate = true;
    this._output.value = null;
    this._outputs = {};
  }
  setup() {
    return this.getDefaultOutputNode();
  }
  set needsUpdate(value) {
    if (value === true)
      this.dispose();
  }
  get needsUpdate() {
    return this.source !== this._source;
  }
  _exec() {
    if (this.codeNode === null)
      return this;
    if (this._needsOutputUpdate === true) {
      this._value = this.call("main");
      this._needsOutputUpdate = false;
    }
    this._output.value = this._value;
    return this;
  }
  _refresh() {
    this.needsUpdate = true;
    this._exec();
    this._output.refresh();
  }
};
var ScriptableNode_default = ScriptableNode;
var scriptable = nodeProxy(ScriptableNode);
addNodeElement("scriptable", scriptable);
addNodeClass("ScriptableNode", ScriptableNode);

// node_modules/three/examples/jsm/nodes/fog/FogNode.js
var FogNode = class extends Node_default {
  constructor(colorNode, factorNode) {
    super("float");
    this.isFogNode = true;
    this.colorNode = colorNode;
    this.factorNode = factorNode;
  }
  getViewZNode(builder) {
    let viewZ;
    const getViewZ = builder.context.getViewZ;
    if (getViewZ !== void 0) {
      viewZ = getViewZ(this);
    }
    return (viewZ || positionView.z).negate();
  }
  setup() {
    return this.factorNode;
  }
};
var FogNode_default = FogNode;
var fog = nodeProxy(FogNode);
addNodeElement("fog", fog);
addNodeClass("FogNode", FogNode);

// node_modules/three/examples/jsm/nodes/fog/FogRangeNode.js
var FogRangeNode = class extends FogNode_default {
  constructor(colorNode, nearNode, farNode) {
    super(colorNode);
    this.isFogRangeNode = true;
    this.nearNode = nearNode;
    this.farNode = farNode;
  }
  setup(builder) {
    const viewZ = this.getViewZNode(builder);
    return smoothstep(this.nearNode, this.farNode, viewZ);
  }
};
var FogRangeNode_default = FogRangeNode;
var rangeFog = nodeProxy(FogRangeNode);
addNodeElement("rangeFog", rangeFog);
addNodeClass("FogRangeNode", FogRangeNode);

// node_modules/three/examples/jsm/nodes/fog/FogExp2Node.js
var FogExp2Node = class extends FogNode_default {
  constructor(colorNode, densityNode) {
    super(colorNode);
    this.isFogExp2Node = true;
    this.densityNode = densityNode;
  }
  setup(builder) {
    const viewZ = this.getViewZNode(builder);
    const density = this.densityNode;
    return density.mul(density, viewZ, viewZ).negate().exp().oneMinus();
  }
};
var FogExp2Node_default = FogExp2Node;
var densityFog = nodeProxy(FogExp2Node);
addNodeElement("densityFog", densityFog);
addNodeClass("FogExp2Node", FogExp2Node);

// node_modules/three/examples/jsm/nodes/geometry/RangeNode.js
var min2 = null;
var max2 = null;
var RangeNode = class extends Node_default {
  constructor(minNode = float(), maxNode = float()) {
    super();
    this.minNode = minNode;
    this.maxNode = maxNode;
  }
  getVectorLength(builder) {
    const minLength = builder.getTypeLength(getValueType(this.minNode.value));
    const maxLength = builder.getTypeLength(getValueType(this.maxNode.value));
    return minLength > maxLength ? minLength : maxLength;
  }
  getNodeType(builder) {
    return builder.object.isInstancedMesh === true ? builder.getTypeFromLength(this.getVectorLength(builder)) : "float";
  }
  setup(builder) {
    const object = builder.object;
    let output2 = null;
    if (object.isInstancedMesh === true) {
      const minValue = this.minNode.value;
      const maxValue = this.maxNode.value;
      const minLength = builder.getTypeLength(getValueType(minValue));
      const maxLength = builder.getTypeLength(getValueType(maxValue));
      min2 = min2 || new Vector4();
      max2 = max2 || new Vector4();
      min2.setScalar(0);
      max2.setScalar(0);
      if (minLength === 1)
        min2.setScalar(minValue);
      else if (minValue.isColor)
        min2.set(minValue.r, minValue.g, minValue.b);
      else
        min2.set(minValue.x, minValue.y, minValue.z || 0, minValue.w || 0);
      if (maxLength === 1)
        max2.setScalar(maxValue);
      else if (maxValue.isColor)
        max2.set(maxValue.r, maxValue.g, maxValue.b);
      else
        max2.set(maxValue.x, maxValue.y, maxValue.z || 0, maxValue.w || 0);
      const stride = 4;
      const length2 = stride * object.count;
      const array = new Float32Array(length2);
      for (let i = 0; i < length2; i++) {
        const index = i % stride;
        const minElementValue = min2.getComponent(index);
        const maxElementValue = max2.getComponent(index);
        array[i] = MathUtils.lerp(minElementValue, maxElementValue, Math.random());
      }
      const nodeType = this.getNodeType(builder);
      output2 = buffer(array, "vec4", object.count).element(instanceIndex).convert(nodeType);
    } else {
      output2 = float(0);
    }
    return output2;
  }
};
var RangeNode_default = RangeNode;
var range = nodeProxy(RangeNode);
addNodeClass("RangeNode", RangeNode);

// node_modules/three/examples/jsm/nodes/gpgpu/ComputeNode.js
var ComputeNode = class extends Node_default {
  constructor(computeNode, count, workgroupSize = [64]) {
    super("void");
    this.isComputeNode = true;
    this.computeNode = computeNode;
    this.count = count;
    this.workgroupSize = workgroupSize;
    this.dispatchCount = 0;
    this.version = 1;
    this.updateBeforeType = NodeUpdateType.OBJECT;
    this.updateDispatchCount();
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
  updateDispatchCount() {
    const { count, workgroupSize } = this;
    let size = workgroupSize[0];
    for (let i = 1; i < workgroupSize.length; i++)
      size *= workgroupSize[i];
    this.dispatchCount = Math.ceil(count / size);
  }
  onInit() {
  }
  updateBefore({ renderer }) {
    renderer.compute(this);
  }
  generate(builder) {
    const { shaderStage } = builder;
    if (shaderStage === "compute") {
      const snippet = this.computeNode.build(builder, "void");
      if (snippet !== "") {
        builder.addLineFlowCode(snippet);
      }
    }
  }
};
var ComputeNode_default = ComputeNode;
var compute = (node, count, workgroupSize) => nodeObject(new ComputeNode(nodeObject(node), count, workgroupSize));
addNodeElement("compute", compute);
addNodeClass("ComputeNode", ComputeNode);

// node_modules/three/examples/jsm/nodes/lighting/LightNode.js
var LightNode = class _LightNode extends Node_default {
  constructor(scope = _LightNode.TARGET_DIRECTION, light = null) {
    super();
    this.scope = scope;
    this.light = light;
  }
  setup() {
    const { scope, light } = this;
    let output2 = null;
    if (scope === _LightNode.TARGET_DIRECTION) {
      output2 = cameraViewMatrix.transformDirection(objectPosition(light).sub(objectPosition(light.target)));
    }
    return output2;
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
LightNode.TARGET_DIRECTION = "targetDirection";
var LightNode_default = LightNode;
var lightTargetDirection = nodeProxy(LightNode, LightNode.TARGET_DIRECTION);
addNodeClass("LightNode", LightNode);

// node_modules/three/examples/jsm/nodes/lighting/LightUtils.js
var getDistanceAttenuation = tslFn((inputs) => {
  const { lightDistance, cutoffDistance, decayExponent } = inputs;
  const distanceFalloff = lightDistance.pow(decayExponent).max(0.01).reciprocal();
  return cutoffDistance.greaterThan(0).cond(
    distanceFalloff.mul(lightDistance.div(cutoffDistance).pow4().oneMinus().clamp().pow2()),
    distanceFalloff
  );
});

// node_modules/three/examples/jsm/nodes/lighting/PointLightNode.js
var PointLightNode = class extends AnalyticLightNode_default {
  constructor(light = null) {
    super(light);
    this.cutoffDistanceNode = uniform(0);
    this.decayExponentNode = uniform(0);
  }
  update(frame) {
    const { light } = this;
    super.update(frame);
    this.cutoffDistanceNode.value = light.distance;
    this.decayExponentNode.value = light.decay;
  }
  setup(builder) {
    const { colorNode, cutoffDistanceNode, decayExponentNode, light } = this;
    const lightingModel = builder.context.lightingModel;
    const lVector = objectViewPosition(light).sub(positionView);
    const lightDirection = lVector.normalize();
    const lightDistance = lVector.length();
    const lightAttenuation = getDistanceAttenuation({
      lightDistance,
      cutoffDistance: cutoffDistanceNode,
      decayExponent: decayExponentNode
    });
    const lightColor = colorNode.mul(lightAttenuation);
    const reflectedLight = builder.context.reflectedLight;
    lightingModel.direct({
      lightDirection,
      lightColor,
      reflectedLight,
      shadowMask: this.shadowMaskNode
    }, builder.stack, builder);
  }
};
var PointLightNode_default = PointLightNode;
addNodeClass("PointLightNode", PointLightNode);
addLightNode(PointLight, PointLightNode);

// node_modules/three/examples/jsm/nodes/lighting/DirectionalLightNode.js
var DirectionalLightNode = class extends AnalyticLightNode_default {
  constructor(light = null) {
    super(light);
  }
  setup(builder) {
    super.setup(builder);
    const lightingModel = builder.context.lightingModel;
    const lightColor = this.colorNode;
    const lightDirection = lightTargetDirection(this.light);
    const reflectedLight = builder.context.reflectedLight;
    lightingModel.direct({
      lightDirection,
      lightColor,
      reflectedLight,
      shadowMask: this.shadowMaskNode
    }, builder.stack, builder);
  }
};
var DirectionalLightNode_default = DirectionalLightNode;
addNodeClass("DirectionalLightNode", DirectionalLightNode);
addLightNode(DirectionalLight, DirectionalLightNode);

// node_modules/three/examples/jsm/nodes/lighting/SpotLightNode.js
var SpotLightNode = class extends AnalyticLightNode_default {
  constructor(light = null) {
    super(light);
    this.coneCosNode = uniform(0);
    this.penumbraCosNode = uniform(0);
    this.cutoffDistanceNode = uniform(0);
    this.decayExponentNode = uniform(0);
  }
  update(frame) {
    super.update(frame);
    const { light } = this;
    this.coneCosNode.value = Math.cos(light.angle);
    this.penumbraCosNode.value = Math.cos(light.angle * (1 - light.penumbra));
    this.cutoffDistanceNode.value = light.distance;
    this.decayExponentNode.value = light.decay;
  }
  getSpotAttenuation(angleCosine) {
    const { coneCosNode, penumbraCosNode } = this;
    return smoothstep(coneCosNode, penumbraCosNode, angleCosine);
  }
  setup(builder) {
    super.setup(builder);
    const lightingModel = builder.context.lightingModel;
    const { colorNode, cutoffDistanceNode, decayExponentNode, light } = this;
    const lVector = objectViewPosition(light).sub(positionView);
    const lightDirection = lVector.normalize();
    const angleCos = lightDirection.dot(lightTargetDirection(light));
    const spotAttenuation = this.getSpotAttenuation(angleCos);
    const lightDistance = lVector.length();
    const lightAttenuation = getDistanceAttenuation({
      lightDistance,
      cutoffDistance: cutoffDistanceNode,
      decayExponent: decayExponentNode
    });
    const lightColor = colorNode.mul(spotAttenuation).mul(lightAttenuation);
    const reflectedLight = builder.context.reflectedLight;
    lightingModel.direct({
      lightDirection,
      lightColor,
      reflectedLight,
      shadowMask: this.shadowMaskNode
    }, builder.stack, builder);
  }
};
var SpotLightNode_default = SpotLightNode;
addNodeClass("SpotLightNode", SpotLightNode);
addLightNode(SpotLight, SpotLightNode);

// node_modules/three/examples/jsm/nodes/lighting/IESSpotLightNode.js
var IESSpotLightNode = class extends SpotLightNode_default {
  getSpotAttenuation(angleCosine) {
    const iesMap = this.light.iesMap;
    let spotAttenuation = null;
    if (iesMap && iesMap.isTexture === true) {
      const angle = angleCosine.acos().mul(1 / Math.PI);
      spotAttenuation = texture(iesMap, vec2(angle, 0), 0).r;
    } else {
      spotAttenuation = super.getSpotAttenuation(angleCosine);
    }
    return spotAttenuation;
  }
};
var IESSpotLightNode_default = IESSpotLightNode;
addNodeClass("IESSpotLightNode", IESSpotLightNode);
addLightNode(IESSpotLight_default, IESSpotLightNode);

// node_modules/three/examples/jsm/nodes/lighting/AmbientLightNode.js
var AmbientLightNode = class extends AnalyticLightNode_default {
  constructor(light = null) {
    super(light);
  }
  setup({ context: context2 }) {
    context2.irradiance.addAssign(this.colorNode);
  }
};
var AmbientLightNode_default = AmbientLightNode;
addNodeClass("AmbientLightNode", AmbientLightNode);
addLightNode(AmbientLight, AmbientLightNode);

// node_modules/three/examples/jsm/nodes/lighting/HemisphereLightNode.js
var HemisphereLightNode = class extends AnalyticLightNode_default {
  constructor(light = null) {
    super(light);
    this.lightPositionNode = objectPosition(light);
    this.lightDirectionNode = this.lightPositionNode.normalize();
    this.groundColorNode = uniform(new Color());
  }
  update(frame) {
    const { light } = this;
    super.update(frame);
    this.lightPositionNode.object3d = light;
    this.groundColorNode.value.copy(light.groundColor).multiplyScalar(light.intensity);
  }
  setup(builder) {
    const { colorNode, groundColorNode, lightDirectionNode } = this;
    const dotNL = normalView.dot(lightDirectionNode);
    const hemiDiffuseWeight = dotNL.mul(0.5).add(0.5);
    const irradiance = mix(groundColorNode, colorNode, hemiDiffuseWeight);
    builder.context.irradiance.addAssign(irradiance);
  }
};
var HemisphereLightNode_default = HemisphereLightNode;
addNodeClass("HemisphereLightNode", HemisphereLightNode);
addLightNode(HemisphereLight, HemisphereLightNode);

// node_modules/three/examples/jsm/nodes/procedural/CheckerNode.js
var checkerShaderNode = tslFn((inputs) => {
  const uv2 = inputs.uv.mul(2);
  const cx = uv2.x.floor();
  const cy = uv2.y.floor();
  const result = cx.add(cy).mod(2);
  return result.sign();
});
var CheckerNode = class extends TempNode_default {
  constructor(uvNode = uv()) {
    super("float");
    this.uvNode = uvNode;
  }
  setup() {
    return checkerShaderNode({ uv: this.uvNode });
  }
};
var CheckerNode_default = CheckerNode;
var checker = nodeProxy(CheckerNode);
addNodeElement("checker", checker);
addNodeClass("CheckerNode", CheckerNode);

// node_modules/three/examples/jsm/nodes/loaders/NodeLoader.js
var NodeLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.textures = {};
  }
  load(url, onLoad, onProgress, onError) {
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, (text) => {
      try {
        onLoad(this.parse(JSON.parse(text)));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        this.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parseNodes(json) {
    const nodes = {};
    if (json !== void 0) {
      for (const nodeJSON of json) {
        const { uuid, type } = nodeJSON;
        nodes[uuid] = nodeObject(createNodeFromType(type));
        nodes[uuid].uuid = uuid;
      }
      const meta = { nodes, textures: this.textures };
      for (const nodeJSON of json) {
        nodeJSON.meta = meta;
        const node = nodes[nodeJSON.uuid];
        node.deserialize(nodeJSON);
        delete nodeJSON.meta;
      }
    }
    return nodes;
  }
  parse(json) {
    const node = nodeObject(createNodeFromType(json.type));
    node.uuid = json.uuid;
    const nodes = this.parseNodes(json.nodes);
    const meta = { nodes, textures: this.textures };
    json.meta = meta;
    node.deserialize(json);
    delete json.meta;
    return node;
  }
  setTextures(value) {
    this.textures = value;
    return this;
  }
};
var NodeLoader_default = NodeLoader;

// node_modules/three/examples/jsm/nodes/materials/InstancedPointsNodeMaterial.js
var defaultValues = new PointsMaterial();
var InstancedPointsNodeMaterial = class extends NodeMaterial_default {
  constructor(params = {}) {
    super();
    this.normals = false;
    this.lights = false;
    this.useAlphaToCoverage = true;
    this.useColor = params.vertexColors;
    this.pointWidth = 1;
    this.pointColorNode = null;
    this.setDefaultValues(defaultValues);
    this.setupShaders();
    this.setValues(params);
  }
  setupShaders() {
    const useAlphaToCoverage = this.alphaToCoverage;
    const useColor = this.useColor;
    this.vertexNode = tslFn(() => {
      varying(vec2(), "vUv").assign(uv());
      const instancePosition = attribute("instancePosition");
      const mvPos = property("vec4", "mvPos");
      mvPos.assign(modelViewMatrix.mul(vec4(instancePosition, 1)));
      const aspect = viewport.z.div(viewport.w);
      const clipPos = cameraProjectionMatrix.mul(mvPos);
      const offset = property("vec2", "offset");
      offset.assign(positionGeometry.xy);
      offset.assign(offset.mul(materialPointWidth));
      offset.assign(offset.div(viewport.z));
      offset.y.assign(offset.y.mul(aspect));
      offset.assign(offset.mul(clipPos.w));
      clipPos.assign(clipPos.add(vec4(offset, 0, 0)));
      return clipPos;
    })();
    this.fragmentNode = tslFn(() => {
      const vUv = varying(vec2(), "vUv");
      const alpha = property("float", "alpha");
      alpha.assign(1);
      const a = vUv.x;
      const b = vUv.y;
      const len2 = a.mul(a).add(b.mul(b));
      if (useAlphaToCoverage) {
        const dlen = property("float", "dlen");
        dlen.assign(len2.fwidth());
        alpha.assign(smoothstep(dlen.oneMinus(), dlen.add(1), len2).oneMinus());
      } else {
        len2.greaterThan(1).discard();
      }
      let pointColorNode;
      if (this.pointColorNode) {
        pointColorNode = this.pointColorNode;
      } else {
        if (useColor) {
          const instanceColor = attribute("instanceColor");
          pointColorNode = instanceColor.mul(materialColor);
        } else {
          pointColorNode = materialColor;
        }
      }
      return vec4(pointColorNode, alpha);
    })();
    this.needsUpdate = true;
  }
  get alphaToCoverage() {
    return this.useAlphaToCoverage;
  }
  set alphaToCoverage(value) {
    if (this.useAlphaToCoverage !== value) {
      this.useAlphaToCoverage = value;
      this.setupShaders();
    }
  }
};
var InstancedPointsNodeMaterial_default = InstancedPointsNodeMaterial;
addNodeMaterial("InstancedPointsNodeMaterial", InstancedPointsNodeMaterial);

// node_modules/three/examples/jsm/nodes/materials/LineBasicNodeMaterial.js
var defaultValues2 = new LineBasicMaterial();
var LineBasicNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isLineBasicNodeMaterial = true;
    this.lights = false;
    this.normals = false;
    this.setDefaultValues(defaultValues2);
    this.setValues(parameters);
  }
};
var LineBasicNodeMaterial_default = LineBasicNodeMaterial;
addNodeMaterial("LineBasicNodeMaterial", LineBasicNodeMaterial);

// node_modules/three/examples/jsm/nodes/materials/LineDashedNodeMaterial.js
var defaultValues3 = new LineDashedMaterial();
var LineDashedNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isLineDashedNodeMaterial = true;
    this.lights = false;
    this.normals = false;
    this.setDefaultValues(defaultValues3);
    this.offsetNode = null;
    this.dashScaleNode = null;
    this.dashSizeNode = null;
    this.gapSizeNode = null;
    this.setValues(parameters);
  }
  setupVariants() {
    const offsetNode = this.offsetNode;
    const dashScaleNode = this.dashScaleNode ? float(this.dashScaleNode) : materialLineScale;
    const dashSizeNode = this.dashSizeNode ? float(this.dashSizeNode) : materialLineDashSize;
    const gapSizeNode = this.dashSizeNode ? float(this.dashGapNode) : materialLineGapSize;
    dashSize.assign(dashSizeNode);
    gapSize.assign(gapSizeNode);
    const vLineDistance = varying(attribute("lineDistance").mul(dashScaleNode));
    const vLineDistanceOffset = offsetNode ? vLineDistance.add(offsetNode) : vLineDistance;
    vLineDistanceOffset.mod(dashSize.add(gapSize)).greaterThan(dashSize).discard();
  }
};
var LineDashedNodeMaterial_default = LineDashedNodeMaterial;
addNodeMaterial("LineDashedNodeMaterial", LineDashedNodeMaterial);

// node_modules/three/examples/jsm/nodes/materials/Line2NodeMaterial.js
var defaultValues4 = new LineDashedMaterial();
var Line2NodeMaterial = class extends NodeMaterial_default {
  constructor(params = {}) {
    super();
    this.normals = false;
    this.lights = false;
    this.setDefaultValues(defaultValues4);
    this.useAlphaToCoverage = true;
    this.useColor = params.vertexColors;
    this.useDash = params.dashed;
    this.useWorldUnits = false;
    this.dashOffset = 0;
    this.lineWidth = 1;
    this.lineColorNode = null;
    this.offsetNode = null;
    this.dashScaleNode = null;
    this.dashSizeNode = null;
    this.gapSizeNode = null;
    this.setValues(params);
  }
  setup(builder) {
    this.setupShaders();
    super.setup(builder);
  }
  setupShaders() {
    const useAlphaToCoverage = this.alphaToCoverage;
    const useColor = this.useColor;
    const useDash = this.dashed;
    const useWorldUnits = this.worldUnits;
    const trimSegment = tslFn(({ start, end }) => {
      const a = cameraProjectionMatrix.element(2).element(2);
      const b = cameraProjectionMatrix.element(3).element(2);
      const nearEstimate = b.mul(-0.5).div(a);
      const alpha = nearEstimate.sub(start.z).div(end.z.sub(start.z));
      return vec4(mix(start.xyz, end.xyz, alpha), end.w);
    });
    this.vertexNode = tslFn(() => {
      varyingProperty("vec2", "vUv").assign(uv());
      const instanceStart = attribute("instanceStart");
      const instanceEnd = attribute("instanceEnd");
      const start = property("vec4", "start");
      const end = property("vec4", "end");
      start.assign(modelViewMatrix.mul(vec4(instanceStart, 1)));
      end.assign(modelViewMatrix.mul(vec4(instanceEnd, 1)));
      if (useWorldUnits) {
        varyingProperty("vec3", "worldStart").assign(start.xyz);
        varyingProperty("vec3", "worldEnd").assign(end.xyz);
      }
      const aspect = viewport.z.div(viewport.w);
      const perspective = cameraProjectionMatrix.element(2).element(3).equal(-1);
      If(perspective, () => {
        If(start.z.lessThan(0).and(end.z.greaterThan(0)), () => {
          end.assign(trimSegment({ start, end }));
        }).elseif(end.z.lessThan(0).and(start.z.greaterThanEqual(0)), () => {
          start.assign(trimSegment({ start: end, end: start }));
        });
      });
      const clipStart = cameraProjectionMatrix.mul(start);
      const clipEnd = cameraProjectionMatrix.mul(end);
      const ndcStart = clipStart.xyz.div(clipStart.w);
      const ndcEnd = clipEnd.xyz.div(clipEnd.w);
      const dir = ndcEnd.xy.sub(ndcStart.xy).temp();
      dir.x.assign(dir.x.mul(aspect));
      dir.assign(dir.normalize());
      const clip = temp(vec4());
      if (useWorldUnits) {
        const worldDir = end.xyz.sub(start.xyz).normalize();
        const tmpFwd = mix(start.xyz, end.xyz, 0.5).normalize();
        const worldUp = worldDir.cross(tmpFwd).normalize();
        const worldFwd = worldDir.cross(worldUp);
        const worldPos = varyingProperty("vec4", "worldPos");
        worldPos.assign(positionGeometry.y.lessThan(0.5).cond(start, end));
        const hw = materialLineWidth.mul(0.5);
        worldPos.addAssign(vec4(positionGeometry.x.lessThan(0).cond(worldUp.mul(hw), worldUp.mul(hw).negate()), 0));
        if (!useDash) {
          worldPos.addAssign(vec4(positionGeometry.y.lessThan(0.5).cond(worldDir.mul(hw).negate(), worldDir.mul(hw)), 0));
          worldPos.addAssign(vec4(worldFwd.mul(hw), 0));
          If(positionGeometry.y.greaterThan(1).or(positionGeometry.y.lessThan(0)), () => {
            worldPos.subAssign(vec4(worldFwd.mul(2).mul(hw), 0));
          });
        }
        clip.assign(cameraProjectionMatrix.mul(worldPos));
        const clipPose = temp(vec3());
        clipPose.assign(positionGeometry.y.lessThan(0.5).cond(ndcStart, ndcEnd));
        clip.z.assign(clipPose.z.mul(clip.w));
      } else {
        const offset = property("vec2", "offset");
        offset.assign(vec2(dir.y, dir.x.negate()));
        dir.x.assign(dir.x.div(aspect));
        offset.x.assign(offset.x.div(aspect));
        offset.assign(positionGeometry.x.lessThan(0).cond(offset.negate(), offset));
        If(positionGeometry.y.lessThan(0), () => {
          offset.assign(offset.sub(dir));
        }).elseif(positionGeometry.y.greaterThan(1), () => {
          offset.assign(offset.add(dir));
        });
        offset.assign(offset.mul(materialLineWidth));
        offset.assign(offset.div(viewport.w));
        clip.assign(positionGeometry.y.lessThan(0.5).cond(clipStart, clipEnd));
        offset.assign(offset.mul(clip.w));
        clip.assign(clip.add(vec4(offset, 0, 0)));
      }
      return clip;
    })();
    const closestLineToLine = tslFn(({ p1, p2, p3, p4 }) => {
      const p13 = p1.sub(p3);
      const p43 = p4.sub(p3);
      const p21 = p2.sub(p1);
      const d1343 = p13.dot(p43);
      const d4321 = p43.dot(p21);
      const d1321 = p13.dot(p21);
      const d4343 = p43.dot(p43);
      const d2121 = p21.dot(p21);
      const denom = d2121.mul(d4343).sub(d4321.mul(d4321));
      const numer = d1343.mul(d4321).sub(d1321.mul(d4343));
      const mua = numer.div(denom).clamp();
      const mub = d1343.add(d4321.mul(mua)).div(d4343).clamp();
      return vec2(mua, mub);
    });
    this.fragmentNode = tslFn(() => {
      const vUv = varyingProperty("vec2", "vUv");
      if (useDash) {
        const offsetNode = this.offsetNode ? float(this.offsetNodeNode) : materialLineDashOffset;
        const dashScaleNode = this.dashScaleNode ? float(this.dashScaleNode) : materialLineScale;
        const dashSizeNode = this.dashSizeNode ? float(this.dashSizeNode) : materialLineDashSize;
        const gapSizeNode = this.dashSizeNode ? float(this.dashGapNode) : materialLineGapSize;
        dashSize.assign(dashSizeNode);
        gapSize.assign(gapSizeNode);
        const instanceDistanceStart = attribute("instanceDistanceStart");
        const instanceDistanceEnd = attribute("instanceDistanceEnd");
        const lineDistance = positionGeometry.y.lessThan(0.5).cond(dashScaleNode.mul(instanceDistanceStart), materialLineScale.mul(instanceDistanceEnd));
        const vLineDistance = varying(lineDistance.add(materialLineDashOffset));
        const vLineDistanceOffset = offsetNode ? vLineDistance.add(offsetNode) : vLineDistance;
        vUv.y.lessThan(-1).or(vUv.y.greaterThan(1)).discard();
        vLineDistanceOffset.mod(dashSize.add(gapSize)).greaterThan(dashSize).discard();
      }
      const alpha = property("float", "alpha");
      alpha.assign(1);
      if (useWorldUnits) {
        const worldStart = varyingProperty("vec3", "worldStart");
        const worldEnd = varyingProperty("vec3", "worldEnd");
        const rayEnd = varyingProperty("vec4", "worldPos").xyz.normalize().mul(1e5);
        const lineDir = worldEnd.sub(worldStart);
        const params = closestLineToLine({ p1: worldStart, p2: worldEnd, p3: vec3(0, 0, 0), p4: rayEnd });
        const p1 = worldStart.add(lineDir.mul(params.x));
        const p2 = rayEnd.mul(params.y);
        const delta = p1.sub(p2);
        const len = delta.length();
        const norm = len.div(materialLineWidth);
        if (!useDash) {
          if (useAlphaToCoverage) {
            const dnorm = norm.fwidth();
            alpha.assign(smoothstep(dnorm.negate().add(0.5), dnorm.add(0.5), norm).oneMinus());
          } else {
            norm.greaterThan(0.5).discard();
          }
        }
      } else {
        if (useAlphaToCoverage) {
          const a = vUv.x;
          const b = vUv.y.greaterThan(0).cond(vUv.y.sub(1), vUv.y.add(1));
          const len2 = a.mul(a).add(b.mul(b));
          const dlen = property("float", "dlen");
          dlen.assign(len2.fwidth());
          If(vUv.y.abs().greaterThan(1), () => {
            alpha.assign(smoothstep(dlen.oneMinus(), dlen.add(1), len2).oneMinus());
          });
        } else {
          If(vUv.y.abs().greaterThan(1), () => {
            const a = vUv.x;
            const b = vUv.y.greaterThan(0).cond(vUv.y.sub(1), vUv.y.add(1));
            const len2 = a.mul(a).add(b.mul(b));
            len2.greaterThan(1).discard();
          });
        }
      }
      let lineColorNode;
      if (this.lineColorNode) {
        lineColorNode = this.lineColorNode;
      } else {
        if (useColor) {
          const instanceColorStart = attribute("instanceColorStart");
          const instanceColorEnd = attribute("instanceColorEnd");
          const instanceColor = positionGeometry.y.lessThan(0.5).cond(instanceColorStart, instanceColorEnd);
          lineColorNode = instanceColor.mul(materialColor);
        } else {
          lineColorNode = materialColor;
        }
      }
      return vec4(lineColorNode, alpha);
    })();
  }
  get worldUnits() {
    return this.useWorldUnits;
  }
  set worldUnits(value) {
    if (this.useWorldUnits !== value) {
      this.useWorldUnits = value;
      this.needsUpdate = true;
    }
  }
  get dashed() {
    return this.useDash;
  }
  set dashed(value) {
    if (this.useDash !== value) {
      this.useDash = value;
      this.needsUpdate = true;
    }
  }
  get alphaToCoverage() {
    return this.useAlphaToCoverage;
  }
  set alphaToCoverage(value) {
    if (this.useAlphaToCoverage !== value) {
      this.useAlphaToCoverage = value;
      this.needsUpdate = true;
    }
  }
};
var Line2NodeMaterial_default = Line2NodeMaterial;
addNodeMaterial("Line2NodeMaterial", Line2NodeMaterial);

// node_modules/three/examples/jsm/nodes/materials/MeshNormalNodeMaterial.js
var defaultValues5 = new MeshNormalMaterial();
var MeshNormalNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isMeshNormalNodeMaterial = true;
    this.setDefaultValues(defaultValues5);
    this.setValues(parameters);
  }
  setupDiffuseColor() {
    const opacityNode = this.opacityNode ? float(this.opacityNode) : materialOpacity;
    diffuseColor.assign(vec4(directionToColor(transformedNormalView), opacityNode));
  }
};
var MeshNormalNodeMaterial_default = MeshNormalNodeMaterial;
addNodeMaterial("MeshNormalNodeMaterial", MeshNormalNodeMaterial);

// node_modules/three/examples/jsm/nodes/materials/MeshBasicNodeMaterial.js
var defaultValues6 = new MeshBasicMaterial();
var MeshBasicNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isMeshBasicNodeMaterial = true;
    this.lights = false;
    this.setDefaultValues(defaultValues6);
    this.setValues(parameters);
  }
};
var MeshBasicNodeMaterial_default = MeshBasicNodeMaterial;
addNodeMaterial("MeshBasicNodeMaterial", MeshBasicNodeMaterial);

// node_modules/three/examples/jsm/nodes/functions/BSDF/F_Schlick.js
var F_Schlick = tslFn(({ f0, f90, dotVH }) => {
  const fresnel = dotVH.mul(-5.55473).sub(6.98316).mul(dotVH).exp2();
  return f0.mul(fresnel.oneMinus()).add(f90.mul(fresnel));
});
var F_Schlick_default = F_Schlick;

// node_modules/three/examples/jsm/nodes/functions/BSDF/BRDF_Lambert.js
var BRDF_Lambert = tslFn((inputs) => {
  return inputs.diffuseColor.mul(1 / Math.PI);
});
var BRDF_Lambert_default = BRDF_Lambert;

// node_modules/three/examples/jsm/nodes/functions/PhongLightingModel.js
var G_BlinnPhong_Implicit = () => float(0.25);
var D_BlinnPhong = tslFn(({ dotNH }) => {
  return shininess.mul(float(0.5)).add(1).mul(float(1 / Math.PI)).mul(dotNH.pow(shininess));
});
var BRDF_BlinnPhong = tslFn(({ lightDirection }) => {
  const halfDir = lightDirection.add(positionViewDirection).normalize();
  const dotNH = transformedNormalView.dot(halfDir).clamp();
  const dotVH = positionViewDirection.dot(halfDir).clamp();
  const F = F_Schlick_default({ f0: specularColor, f90: 1, dotVH });
  const G = G_BlinnPhong_Implicit();
  const D = D_BlinnPhong({ dotNH });
  return F.mul(G).mul(D);
});
var PhongLightingModel = class extends LightingModel_default {
  constructor(specular = true) {
    super();
    this.specular = specular;
  }
  direct({ lightDirection, lightColor, reflectedLight }) {
    const dotNL = transformedNormalView.dot(lightDirection).clamp();
    const irradiance = dotNL.mul(lightColor);
    reflectedLight.directDiffuse.addAssign(irradiance.mul(BRDF_Lambert_default({ diffuseColor: diffuseColor.rgb })));
    if (this.specular === true) {
      reflectedLight.directSpecular.addAssign(irradiance.mul(BRDF_BlinnPhong({ lightDirection })).mul(materialSpecularStrength));
    }
  }
  indirectDiffuse({ irradiance, reflectedLight }) {
    reflectedLight.indirectDiffuse.addAssign(irradiance.mul(BRDF_Lambert_default({ diffuseColor })));
  }
};
var PhongLightingModel_default = PhongLightingModel;

// node_modules/three/examples/jsm/nodes/materials/MeshLambertNodeMaterial.js
var defaultValues7 = new MeshLambertMaterial();
var MeshLambertNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isMeshLambertNodeMaterial = true;
    this.lights = true;
    this.setDefaultValues(defaultValues7);
    this.setValues(parameters);
  }
  setupLightingModel() {
    return new PhongLightingModel_default(false);
  }
};
var MeshLambertNodeMaterial_default = MeshLambertNodeMaterial;
addNodeMaterial("MeshLambertNodeMaterial", MeshLambertNodeMaterial);

// node_modules/three/examples/jsm/nodes/materials/MeshPhongNodeMaterial.js
var defaultValues8 = new MeshPhongMaterial();
var MeshPhongNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isMeshPhongNodeMaterial = true;
    this.lights = true;
    this.shininessNode = null;
    this.specularNode = null;
    this.setDefaultValues(defaultValues8);
    this.setValues(parameters);
  }
  setupLightingModel() {
    return new PhongLightingModel_default();
  }
  setupVariants() {
    const shininessNode = (this.shininessNode ? float(this.shininessNode) : materialShininess).max(1e-4);
    shininess.assign(shininessNode);
    const specularNode = this.specularNode || materialSpecular;
    specularColor.assign(specularNode);
  }
  copy(source) {
    this.shininessNode = source.shininessNode;
    this.specularNode = source.specularNode;
    return super.copy(source);
  }
};
var MeshPhongNodeMaterial_default = MeshPhongNodeMaterial;
addNodeMaterial("MeshPhongNodeMaterial", MeshPhongNodeMaterial);

// node_modules/three/examples/jsm/nodes/functions/material/getGeometryRoughness.js
var getGeometryRoughness = tslFn(() => {
  const dxy = normalGeometry.dFdx().abs().max(normalGeometry.dFdy().abs());
  const geometryRoughness = dxy.x.max(dxy.y).max(dxy.z);
  return geometryRoughness;
});
var getGeometryRoughness_default = getGeometryRoughness;

// node_modules/three/examples/jsm/nodes/functions/material/getRoughness.js
var getRoughness = tslFn((inputs) => {
  const { roughness: roughness2 } = inputs;
  const geometryRoughness = getGeometryRoughness_default();
  let roughnessFactor = roughness2.max(0.0525);
  roughnessFactor = roughnessFactor.add(geometryRoughness);
  roughnessFactor = roughnessFactor.min(1);
  return roughnessFactor;
});
var getRoughness_default = getRoughness;

// node_modules/three/examples/jsm/nodes/functions/BSDF/V_GGX_SmithCorrelated.js
var V_GGX_SmithCorrelated = tslFn(({ alpha, dotNL, dotNV }) => {
  const a2 = alpha.pow2();
  const gv = dotNL.mul(a2.add(a2.oneMinus().mul(dotNV.pow2())).sqrt());
  const gl = dotNV.mul(a2.add(a2.oneMinus().mul(dotNL.pow2())).sqrt());
  return div(0.5, gv.add(gl).max(EPSILON));
}).setLayout({
  name: "V_GGX_SmithCorrelated",
  type: "float",
  inputs: [
    { name: "alpha", type: "float" },
    { name: "dotNL", type: "float" },
    { name: "dotNV", type: "float" }
  ]
});
var V_GGX_SmithCorrelated_default = V_GGX_SmithCorrelated;

// node_modules/three/examples/jsm/nodes/functions/BSDF/V_GGX_SmithCorrelated_Anisotropic.js
var V_GGX_SmithCorrelated_Anisotropic = tslFn(({ alphaT: alphaT2, alphaB, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL }) => {
  const gv = dotNL.mul(vec3(alphaT2.mul(dotTV), alphaB.mul(dotBV), dotNV).length());
  const gl = dotNV.mul(vec3(alphaT2.mul(dotTL), alphaB.mul(dotBL), dotNL).length());
  const v = div(0.5, gv.add(gl));
  return v.saturate();
}).setLayout({
  name: "V_GGX_SmithCorrelated_Anisotropic",
  type: "float",
  inputs: [
    { name: "alphaT", type: "float", qualifier: "in" },
    { name: "alphaB", type: "float", qualifier: "in" },
    { name: "dotTV", type: "float", qualifier: "in" },
    { name: "dotBV", type: "float", qualifier: "in" },
    { name: "dotTL", type: "float", qualifier: "in" },
    { name: "dotBL", type: "float", qualifier: "in" },
    { name: "dotNV", type: "float", qualifier: "in" },
    { name: "dotNL", type: "float", qualifier: "in" }
  ]
});
var V_GGX_SmithCorrelated_Anisotropic_default = V_GGX_SmithCorrelated_Anisotropic;

// node_modules/three/examples/jsm/nodes/functions/BSDF/D_GGX.js
var D_GGX = tslFn(({ alpha, dotNH }) => {
  const a2 = alpha.pow2();
  const denom = dotNH.pow2().mul(a2.oneMinus()).oneMinus();
  return a2.div(denom.pow2()).mul(1 / Math.PI);
}).setLayout({
  name: "D_GGX",
  type: "float",
  inputs: [
    { name: "alpha", type: "float" },
    { name: "dotNH", type: "float" }
  ]
});
var D_GGX_default = D_GGX;

// node_modules/three/examples/jsm/nodes/functions/BSDF/D_GGX_Anisotropic.js
var RECIPROCAL_PI = float(1 / Math.PI);
var D_GGX_Anisotropic = tslFn(({ alphaT: alphaT2, alphaB, dotNH, dotTH, dotBH }) => {
  const a2 = alphaT2.mul(alphaB);
  const v = vec3(alphaB.mul(dotTH), alphaT2.mul(dotBH), a2.mul(dotNH));
  const v2 = v.dot(v);
  const w22 = a2.div(v2);
  return RECIPROCAL_PI.mul(a2.mul(w22.pow2()));
}).setLayout({
  name: "D_GGX_Anisotropic",
  type: "float",
  inputs: [
    { name: "alphaT", type: "float", qualifier: "in" },
    { name: "alphaB", type: "float", qualifier: "in" },
    { name: "dotNH", type: "float", qualifier: "in" },
    { name: "dotTH", type: "float", qualifier: "in" },
    { name: "dotBH", type: "float", qualifier: "in" }
  ]
});
var D_GGX_Anisotropic_default = D_GGX_Anisotropic;

// node_modules/three/examples/jsm/nodes/functions/BSDF/BRDF_GGX.js
var BRDF_GGX = tslFn((inputs) => {
  const { lightDirection, f0, f90, roughness: roughness2, f, USE_IRIDESCENCE, USE_ANISOTROPY } = inputs;
  const normalView2 = inputs.normalView || transformedNormalView;
  const alpha = roughness2.pow2();
  const halfDir = lightDirection.add(positionViewDirection).normalize();
  const dotNL = normalView2.dot(lightDirection).clamp();
  const dotNV = normalView2.dot(positionViewDirection).clamp();
  const dotNH = normalView2.dot(halfDir).clamp();
  const dotVH = positionViewDirection.dot(halfDir).clamp();
  let F = F_Schlick_default({ f0, f90, dotVH });
  let V, D;
  if (defined(USE_IRIDESCENCE)) {
    F = iridescence.mix(F, f);
  }
  if (defined(USE_ANISOTROPY)) {
    const dotTL = anisotropyT.dot(lightDirection);
    const dotTV = anisotropyT.dot(positionViewDirection);
    const dotTH = anisotropyT.dot(halfDir);
    const dotBL = anisotropyB.dot(lightDirection);
    const dotBV = anisotropyB.dot(positionViewDirection);
    const dotBH = anisotropyB.dot(halfDir);
    V = V_GGX_SmithCorrelated_Anisotropic_default({ alphaT, alphaB: alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL });
    D = D_GGX_Anisotropic_default({ alphaT, alphaB: alpha, dotNH, dotTH, dotBH });
  } else {
    V = V_GGX_SmithCorrelated_default({ alpha, dotNL, dotNV });
    D = D_GGX_default({ alpha, dotNH });
  }
  return F.mul(V).mul(D);
});
var BRDF_GGX_default = BRDF_GGX;

// node_modules/three/examples/jsm/nodes/functions/BSDF/DFGApprox.js
var DFGApprox = tslFn(({ roughness: roughness2, dotNV }) => {
  const c0 = vec4(-1, -0.0275, -0.572, 0.022);
  const c1 = vec4(1, 0.0425, 1.04, -0.04);
  const r = roughness2.mul(c0).add(c1);
  const a004 = r.x.mul(r.x).min(dotNV.mul(-9.28).exp2()).mul(r.x).add(r.y);
  const fab = vec2(-1.04, 1.04).mul(a004).add(r.zw);
  return fab;
}).setLayout({
  name: "DFGApprox",
  type: "vec2",
  inputs: [
    { name: "roughness", type: "float" },
    { name: "dotNV", type: "vec3" }
  ]
});
var DFGApprox_default = DFGApprox;

// node_modules/three/examples/jsm/nodes/functions/BSDF/EnvironmentBRDF.js
var EnvironmentBRDF = tslFn((inputs) => {
  const { dotNV, specularColor: specularColor2, specularF90: specularF902, roughness: roughness2 } = inputs;
  const fab = DFGApprox_default({ dotNV, roughness: roughness2 });
  return specularColor2.mul(fab.x).add(specularF902.mul(fab.y));
});
var EnvironmentBRDF_default = EnvironmentBRDF;

// node_modules/three/examples/jsm/nodes/functions/BSDF/Schlick_to_F0.js
var Schlick_to_F0 = tslFn(({ f, f90, dotVH }) => {
  const x = dotVH.oneMinus().saturate();
  const x2 = x.mul(x);
  const x5 = x.mul(x2, x2).clamp(0, 0.9999);
  return f.sub(vec3(f90).mul(x5)).div(x5.oneMinus());
}).setLayout({
  name: "Schlick_to_F0",
  type: "vec3",
  inputs: [
    { name: "f", type: "vec3" },
    { name: "f90", type: "float" },
    { name: "dotVH", type: "float" }
  ]
});
var Schlick_to_F0_default = Schlick_to_F0;

// node_modules/three/examples/jsm/nodes/functions/BSDF/BRDF_Sheen.js
var D_Charlie = tslFn(({ roughness: roughness2, dotNH }) => {
  const alpha = roughness2.pow2();
  const invAlpha = float(1).div(alpha);
  const cos2h = dotNH.pow2();
  const sin2h = cos2h.oneMinus().max(78125e-7);
  return float(2).add(invAlpha).mul(sin2h.pow(invAlpha.mul(0.5))).div(2 * Math.PI);
}).setLayout({
  name: "D_Charlie",
  type: "float",
  inputs: [
    { name: "roughness", type: "float" },
    { name: "dotNH", type: "float" }
  ]
});
var V_Neubelt = tslFn(({ dotNV, dotNL }) => {
  return float(1).div(float(4).mul(dotNL.add(dotNV).sub(dotNL.mul(dotNV))));
}).setLayout({
  name: "V_Neubelt",
  type: "float",
  inputs: [
    { name: "dotNV", type: "float" },
    { name: "dotNL", type: "float" }
  ]
});
var BRDF_Sheen = tslFn(({ lightDirection }) => {
  const halfDir = lightDirection.add(positionViewDirection).normalize();
  const dotNL = transformedNormalView.dot(lightDirection).clamp();
  const dotNV = transformedNormalView.dot(positionViewDirection).clamp();
  const dotNH = transformedNormalView.dot(halfDir).clamp();
  const D = D_Charlie({ roughness: sheenRoughness, dotNH });
  const V = V_Neubelt({ dotNV, dotNL });
  return sheen.mul(D).mul(V);
});
var BRDF_Sheen_default = BRDF_Sheen;

// node_modules/three/examples/jsm/nodes/functions/PhysicalLightingModel.js
var getVolumeTransmissionRay = tslFn(([n, v, thickness2, ior2, modelMatrix]) => {
  const refractionVector = vec3(refract(v.negate(), normalize(n), div(1, ior2)));
  const modelScale2 = vec3(
    length(modelMatrix[0].xyz),
    length(modelMatrix[1].xyz),
    length(modelMatrix[2].xyz)
  );
  return normalize(refractionVector).mul(thickness2.mul(modelScale2));
}).setLayout({
  name: "getVolumeTransmissionRay",
  type: "vec3",
  inputs: [
    { name: "n", type: "vec3" },
    { name: "v", type: "vec3" },
    { name: "thickness", type: "float" },
    { name: "ior", type: "float" },
    { name: "modelMatrix", type: "mat4" }
  ]
});
var applyIorToRoughness = tslFn(([roughness2, ior2]) => {
  return roughness2.mul(clamp(ior2.mul(2).sub(2), 0, 1));
}).setLayout({
  name: "applyIorToRoughness",
  type: "float",
  inputs: [
    { name: "roughness", type: "float" },
    { name: "ior", type: "float" }
  ]
});
var singleViewportMipTexture = viewportMipTexture();
var getTransmissionSample = tslFn(([fragCoord, roughness2, ior2]) => {
  const transmissionSample = singleViewportMipTexture.uv(fragCoord);
  const lod = log2(float(viewportResolution.x)).mul(applyIorToRoughness(roughness2, ior2));
  return transmissionSample.bicubic(lod);
});
var volumeAttenuation = tslFn(([transmissionDistance, attenuationColor2, attenuationDistance2]) => {
  If(attenuationDistance2.notEqual(0), () => {
    const attenuationCoefficient = log(attenuationColor2).negate().div(attenuationDistance2);
    const transmittance = exp(attenuationCoefficient.negate().mul(transmissionDistance));
    return transmittance;
  });
  return vec3(1);
}).setLayout({
  name: "volumeAttenuation",
  type: "vec3",
  inputs: [
    { name: "transmissionDistance", type: "float" },
    { name: "attenuationColor", type: "vec3" },
    { name: "attenuationDistance", type: "float" }
  ]
});
var getIBLVolumeRefraction = tslFn(([n, v, roughness2, diffuseColor2, specularColor2, specularF902, position, modelMatrix, viewMatrix, projMatrix, ior2, thickness2, attenuationColor2, attenuationDistance2, dispersion2]) => {
  let transmittedLight, transmittance;
  if (dispersion2) {
    transmittedLight = vec4().toVar();
    transmittance = vec3().toVar();
    const halfSpread = ior2.sub(1).mul(dispersion2.mul(0.025));
    const iors = vec3(ior2.sub(halfSpread), ior2, ior2.add(halfSpread));
    loop({ start: 0, end: 3 }, ({ i }) => {
      const ior3 = iors.element(i);
      const transmissionRay = getVolumeTransmissionRay(n, v, thickness2, ior3, modelMatrix);
      const refractedRayExit = position.add(transmissionRay);
      const ndcPos = projMatrix.mul(viewMatrix.mul(vec4(refractedRayExit, 1)));
      const refractionCoords = vec2(ndcPos.xy.div(ndcPos.w)).toVar();
      refractionCoords.addAssign(1);
      refractionCoords.divAssign(2);
      refractionCoords.assign(vec2(refractionCoords.x, refractionCoords.y.oneMinus()));
      const transmissionSample = getTransmissionSample(refractionCoords, roughness2, ior3);
      transmittedLight.element(i).assign(transmissionSample.element(i));
      transmittedLight.a.addAssign(transmissionSample.a);
      transmittance.element(i).assign(diffuseColor2.element(i).mul(volumeAttenuation(length(transmissionRay), attenuationColor2, attenuationDistance2).element(i)));
    });
    transmittedLight.a.divAssign(3);
  } else {
    const transmissionRay = getVolumeTransmissionRay(n, v, thickness2, ior2, modelMatrix);
    const refractedRayExit = position.add(transmissionRay);
    const ndcPos = projMatrix.mul(viewMatrix.mul(vec4(refractedRayExit, 1)));
    const refractionCoords = vec2(ndcPos.xy.div(ndcPos.w)).toVar();
    refractionCoords.addAssign(1);
    refractionCoords.divAssign(2);
    refractionCoords.assign(vec2(refractionCoords.x, refractionCoords.y.oneMinus()));
    transmittedLight = getTransmissionSample(refractionCoords, roughness2, ior2);
    transmittance = diffuseColor2.mul(volumeAttenuation(length(transmissionRay), attenuationColor2, attenuationDistance2));
  }
  const attenuatedColor = transmittance.rgb.mul(transmittedLight.rgb);
  const dotNV = n.dot(v).clamp();
  const F = vec3(EnvironmentBRDF_default({
    // n, v, specularColor, specularF90, roughness
    dotNV,
    specularColor: specularColor2,
    specularF90: specularF902,
    roughness: roughness2
  }));
  const transmittanceFactor = transmittance.r.add(transmittance.g, transmittance.b).div(3);
  return vec4(F.oneMinus().mul(attenuatedColor), transmittedLight.a.oneMinus().mul(transmittanceFactor).oneMinus());
});
var XYZ_TO_REC709 = mat3(
  3.2404542,
  -0.969266,
  0.0556434,
  -1.5371385,
  1.8760108,
  -0.2040259,
  -0.4985314,
  0.041556,
  1.0572252
);
var Fresnel0ToIor = (fresnel0) => {
  const sqrtF0 = fresnel0.sqrt();
  return vec3(1).add(sqrtF0).div(vec3(1).sub(sqrtF0));
};
var IorToFresnel0 = (transmittedIor, incidentIor) => {
  return transmittedIor.sub(incidentIor).div(transmittedIor.add(incidentIor)).pow2();
};
var evalSensitivity = (OPD, shift) => {
  const phase = OPD.mul(2 * Math.PI * 1e-9);
  const val = vec3(54856e-17, 44201e-17, 52481e-17);
  const pos = vec3(1681e3, 1795300, 2208400);
  const VAR = vec3(43278e5, 93046e5, 66121e5);
  const x = float(9747e-17 * Math.sqrt(2 * Math.PI * 45282e5)).mul(phase.mul(2239900).add(shift.x).cos()).mul(phase.pow2().mul(-45282e5).exp());
  let xyz = val.mul(VAR.mul(2 * Math.PI).sqrt()).mul(pos.mul(phase).add(shift).cos()).mul(phase.pow2().negate().mul(VAR).exp());
  xyz = vec3(xyz.x.add(x), xyz.y, xyz.z).div(10685e-11);
  const rgb = XYZ_TO_REC709.mul(xyz);
  return rgb;
};
var evalIridescence = tslFn(({ outsideIOR, eta2, cosTheta1, thinFilmThickness, baseF0 }) => {
  const iridescenceIOR2 = mix(outsideIOR, eta2, smoothstep(0, 0.03, thinFilmThickness));
  const sinTheta2Sq = outsideIOR.div(iridescenceIOR2).pow2().mul(float(1).sub(cosTheta1.pow2()));
  const cosTheta2Sq = float(1).sub(sinTheta2Sq);
  const cosTheta2 = cosTheta2Sq.sqrt();
  const R0 = IorToFresnel0(iridescenceIOR2, outsideIOR);
  const R12 = F_Schlick_default({ f0: R0, f90: 1, dotVH: cosTheta1 });
  const T121 = R12.oneMinus();
  const phi12 = iridescenceIOR2.lessThan(outsideIOR).cond(Math.PI, 0);
  const phi21 = float(Math.PI).sub(phi12);
  const baseIOR = Fresnel0ToIor(baseF0.clamp(0, 0.9999));
  const R1 = IorToFresnel0(baseIOR, iridescenceIOR2.toVec3());
  const R23 = F_Schlick_default({ f0: R1, f90: 1, dotVH: cosTheta2 });
  const phi23 = vec3(
    baseIOR.x.lessThan(iridescenceIOR2).cond(Math.PI, 0),
    baseIOR.y.lessThan(iridescenceIOR2).cond(Math.PI, 0),
    baseIOR.z.lessThan(iridescenceIOR2).cond(Math.PI, 0)
  );
  const OPD = iridescenceIOR2.mul(thinFilmThickness, cosTheta2, 2);
  const phi = vec3(phi21).add(phi23);
  const R123 = R12.mul(R23).clamp(1e-5, 0.9999);
  const r123 = R123.sqrt();
  const Rs = T121.pow2().mul(R23).div(vec3(1).sub(R123));
  const C0 = R12.add(Rs);
  let I = C0;
  let Cm = Rs.sub(T121);
  for (let m = 1; m <= 2; ++m) {
    Cm = Cm.mul(r123);
    const Sm = evalSensitivity(float(m).mul(OPD), float(m).mul(phi)).mul(2);
    I = I.add(Cm.mul(Sm));
  }
  return I.max(vec3(0));
}).setLayout({
  name: "evalIridescence",
  type: "vec3",
  inputs: [
    { name: "outsideIOR", type: "float" },
    { name: "eta2", type: "float" },
    { name: "cosTheta1", type: "float" },
    { name: "thinFilmThickness", type: "float" },
    { name: "baseF0", type: "vec3" }
  ]
});
var IBLSheenBRDF = tslFn(({ normal: normal2, viewDir, roughness: roughness2 }) => {
  const dotNV = normal2.dot(viewDir).saturate();
  const r2 = roughness2.pow2();
  const a = cond(
    roughness2.lessThan(0.25),
    float(-339.2).mul(r2).add(float(161.4).mul(roughness2)).sub(25.9),
    float(-8.48).mul(r2).add(float(14.3).mul(roughness2)).sub(9.95)
  );
  const b = cond(
    roughness2.lessThan(0.25),
    float(44).mul(r2).sub(float(23.7).mul(roughness2)).add(3.26),
    float(1.97).mul(r2).sub(float(3.27).mul(roughness2)).add(0.72)
  );
  const DG = cond(roughness2.lessThan(0.25), 0, float(0.1).mul(roughness2).sub(0.025)).add(a.mul(dotNV).add(b).exp());
  return DG.mul(1 / Math.PI).saturate();
});
var clearcoatF0 = vec3(0.04);
var clearcoatF90 = float(1);
var PhysicalLightingModel = class extends LightingModel_default {
  constructor(clearcoat2 = false, sheen2 = false, iridescence2 = false, anisotropy2 = false, transmission2 = false, dispersion2 = false) {
    super();
    this.clearcoat = clearcoat2;
    this.sheen = sheen2;
    this.iridescence = iridescence2;
    this.anisotropy = anisotropy2;
    this.transmission = transmission2;
    this.dispersion = dispersion2;
    this.clearcoatRadiance = null;
    this.clearcoatSpecularDirect = null;
    this.clearcoatSpecularIndirect = null;
    this.sheenSpecularDirect = null;
    this.sheenSpecularIndirect = null;
    this.iridescenceFresnel = null;
    this.iridescenceF0 = null;
  }
  start(context2) {
    if (this.clearcoat === true) {
      this.clearcoatRadiance = vec3().temp("clearcoatRadiance");
      this.clearcoatSpecularDirect = vec3().temp("clearcoatSpecularDirect");
      this.clearcoatSpecularIndirect = vec3().temp("clearcoatSpecularIndirect");
    }
    if (this.sheen === true) {
      this.sheenSpecularDirect = vec3().temp("sheenSpecularDirect");
      this.sheenSpecularIndirect = vec3().temp("sheenSpecularIndirect");
    }
    if (this.iridescence === true) {
      const dotNVi = transformedNormalView.dot(positionViewDirection).clamp();
      this.iridescenceFresnel = evalIridescence({
        outsideIOR: float(1),
        eta2: iridescenceIOR,
        cosTheta1: dotNVi,
        thinFilmThickness: iridescenceThickness,
        baseF0: specularColor
      });
      this.iridescenceF0 = Schlick_to_F0_default({ f: this.iridescenceFresnel, f90: 1, dotVH: dotNVi });
    }
    if (this.transmission === true) {
      const position = positionWorld;
      const v = cameraPosition.sub(positionWorld).normalize();
      const n = transformedNormalWorld;
      context2.backdrop = getIBLVolumeRefraction(
        n,
        v,
        roughness,
        diffuseColor,
        specularColor,
        specularF90,
        // specularF90
        position,
        // positionWorld
        modelWorldMatrix,
        // modelMatrix
        cameraViewMatrix,
        // viewMatrix
        cameraProjectionMatrix,
        // projMatrix
        ior,
        thickness,
        attenuationColor,
        attenuationDistance,
        this.dispersion ? dispersion : null
      );
      context2.backdropAlpha = transmission;
      diffuseColor.a.mulAssign(mix(1, context2.backdrop.a, transmission));
    }
  }
  // Fdez-Agera's "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"
  // Approximates multiscattering in order to preserve energy.
  // http://www.jcgt.org/published/0008/01/03/
  computeMultiscattering(singleScatter, multiScatter, specularF902) {
    const dotNV = transformedNormalView.dot(positionViewDirection).clamp();
    const fab = DFGApprox_default({ roughness, dotNV });
    const Fr = this.iridescenceF0 ? iridescence.mix(specularColor, this.iridescenceF0) : specularColor;
    const FssEss = Fr.mul(fab.x).add(specularF902.mul(fab.y));
    const Ess = fab.x.add(fab.y);
    const Ems = Ess.oneMinus();
    const Favg = specularColor.add(specularColor.oneMinus().mul(0.047619));
    const Fms = FssEss.mul(Favg).div(Ems.mul(Favg).oneMinus());
    singleScatter.addAssign(FssEss);
    multiScatter.addAssign(Fms.mul(Ems));
  }
  direct({ lightDirection, lightColor, reflectedLight }) {
    const dotNL = transformedNormalView.dot(lightDirection).clamp();
    const irradiance = dotNL.mul(lightColor);
    if (this.sheen === true) {
      this.sheenSpecularDirect.addAssign(irradiance.mul(BRDF_Sheen_default({ lightDirection })));
    }
    if (this.clearcoat === true) {
      const dotNLcc = transformedClearcoatNormalView.dot(lightDirection).clamp();
      const ccIrradiance = dotNLcc.mul(lightColor);
      this.clearcoatSpecularDirect.addAssign(ccIrradiance.mul(BRDF_GGX_default({ lightDirection, f0: clearcoatF0, f90: clearcoatF90, roughness: clearcoatRoughness, normalView: transformedClearcoatNormalView })));
    }
    reflectedLight.directDiffuse.addAssign(irradiance.mul(BRDF_Lambert_default({ diffuseColor: diffuseColor.rgb })));
    reflectedLight.directSpecular.addAssign(irradiance.mul(BRDF_GGX_default({ lightDirection, f0: specularColor, f90: 1, roughness, iridescence: this.iridescence, f: this.iridescenceFresnel, USE_IRIDESCENCE: this.iridescence, USE_ANISOTROPY: this.anisotropy })));
  }
  indirectDiffuse({ irradiance, reflectedLight }) {
    reflectedLight.indirectDiffuse.addAssign(irradiance.mul(BRDF_Lambert_default({ diffuseColor })));
  }
  indirectSpecular({ radiance, iblIrradiance, reflectedLight }) {
    if (this.sheen === true) {
      this.sheenSpecularIndirect.addAssign(iblIrradiance.mul(
        sheen,
        IBLSheenBRDF({
          normal: transformedNormalView,
          viewDir: positionViewDirection,
          roughness: sheenRoughness
        })
      ));
    }
    if (this.clearcoat === true) {
      const dotNVcc = transformedClearcoatNormalView.dot(positionViewDirection).clamp();
      const clearcoatEnv = EnvironmentBRDF_default({
        dotNV: dotNVcc,
        specularColor: clearcoatF0,
        specularF90: clearcoatF90,
        roughness: clearcoatRoughness
      });
      this.clearcoatSpecularIndirect.addAssign(this.clearcoatRadiance.mul(clearcoatEnv));
    }
    const singleScattering = vec3().temp("singleScattering");
    const multiScattering = vec3().temp("multiScattering");
    const cosineWeightedIrradiance = iblIrradiance.mul(1 / Math.PI);
    this.computeMultiscattering(singleScattering, multiScattering, specularF90);
    const totalScattering = singleScattering.add(multiScattering);
    const diffuse = diffuseColor.mul(totalScattering.r.max(totalScattering.g).max(totalScattering.b).oneMinus());
    reflectedLight.indirectSpecular.addAssign(radiance.mul(singleScattering));
    reflectedLight.indirectSpecular.addAssign(multiScattering.mul(cosineWeightedIrradiance));
    reflectedLight.indirectDiffuse.addAssign(diffuse.mul(cosineWeightedIrradiance));
  }
  ambientOcclusion({ ambientOcclusion, reflectedLight }) {
    const dotNV = transformedNormalView.dot(positionViewDirection).clamp();
    const aoNV = dotNV.add(ambientOcclusion);
    const aoExp = roughness.mul(-16).oneMinus().negate().exp2();
    const aoNode = ambientOcclusion.sub(aoNV.pow(aoExp).oneMinus()).clamp();
    if (this.clearcoat === true) {
      this.clearcoatSpecularIndirect.mulAssign(ambientOcclusion);
    }
    if (this.sheen === true) {
      this.sheenSpecularIndirect.mulAssign(ambientOcclusion);
    }
    reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion);
    reflectedLight.indirectSpecular.mulAssign(aoNode);
  }
  finish(context2) {
    const { outgoingLight } = context2;
    if (this.clearcoat === true) {
      const dotNVcc = transformedClearcoatNormalView.dot(positionViewDirection).clamp();
      const Fcc = F_Schlick_default({
        dotVH: dotNVcc,
        f0: clearcoatF0,
        f90: clearcoatF90
      });
      const clearcoatLight = outgoingLight.mul(clearcoat.mul(Fcc).oneMinus()).add(this.clearcoatSpecularDirect.add(this.clearcoatSpecularIndirect).mul(clearcoat));
      outgoingLight.assign(clearcoatLight);
    }
    if (this.sheen === true) {
      const sheenEnergyComp = sheen.r.max(sheen.g).max(sheen.b).mul(0.157).oneMinus();
      const sheenLight = outgoingLight.mul(sheenEnergyComp).add(this.sheenSpecularDirect, this.sheenSpecularIndirect);
      outgoingLight.assign(sheenLight);
    }
  }
};
var PhysicalLightingModel_default = PhysicalLightingModel;

// node_modules/three/examples/jsm/nodes/materials/MeshStandardNodeMaterial.js
var defaultValues9 = new MeshStandardMaterial();
var MeshStandardNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isMeshStandardNodeMaterial = true;
    this.emissiveNode = null;
    this.metalnessNode = null;
    this.roughnessNode = null;
    this.setDefaultValues(defaultValues9);
    this.setValues(parameters);
  }
  setupLightingModel() {
    return new PhysicalLightingModel_default();
  }
  setupSpecular() {
    const specularColorNode = mix(vec3(0.04), diffuseColor.rgb, metalness);
    specularColor.assign(specularColorNode);
    specularF90.assign(1);
  }
  setupVariants() {
    const metalnessNode = this.metalnessNode ? float(this.metalnessNode) : materialMetalness;
    metalness.assign(metalnessNode);
    let roughnessNode = this.roughnessNode ? float(this.roughnessNode) : materialRoughness;
    roughnessNode = getRoughness_default({ roughness: roughnessNode });
    roughness.assign(roughnessNode);
    this.setupSpecular();
    diffuseColor.assign(vec4(diffuseColor.rgb.mul(metalnessNode.oneMinus()), diffuseColor.a));
  }
  copy(source) {
    this.emissiveNode = source.emissiveNode;
    this.metalnessNode = source.metalnessNode;
    this.roughnessNode = source.roughnessNode;
    return super.copy(source);
  }
};
var MeshStandardNodeMaterial_default = MeshStandardNodeMaterial;
addNodeMaterial("MeshStandardNodeMaterial", MeshStandardNodeMaterial);

// node_modules/three/examples/jsm/nodes/materials/MeshPhysicalNodeMaterial.js
var defaultValues10 = new MeshPhysicalMaterial();
var MeshPhysicalNodeMaterial = class extends MeshStandardNodeMaterial_default {
  constructor(parameters) {
    super();
    this.isMeshPhysicalNodeMaterial = true;
    this.clearcoatNode = null;
    this.clearcoatRoughnessNode = null;
    this.clearcoatNormalNode = null;
    this.sheenNode = null;
    this.sheenRoughnessNode = null;
    this.iridescenceNode = null;
    this.iridescenceIORNode = null;
    this.iridescenceThicknessNode = null;
    this.specularIntensityNode = null;
    this.specularColorNode = null;
    this.iorNode = null;
    this.transmissionNode = null;
    this.thicknessNode = null;
    this.attenuationDistanceNode = null;
    this.attenuationColorNode = null;
    this.dispersionNode = null;
    this.anisotropyNode = null;
    this.setDefaultValues(defaultValues10);
    this.setValues(parameters);
  }
  get useClearcoat() {
    return this.clearcoat > 0 || this.clearcoatNode !== null;
  }
  get useIridescence() {
    return this.iridescence > 0 || this.iridescenceNode !== null;
  }
  get useSheen() {
    return this.sheen > 0 || this.sheenNode !== null;
  }
  get useAnisotropy() {
    return this.anisotropy > 0 || this.anisotropyNode !== null;
  }
  get useTransmission() {
    return this.transmission > 0 || this.transmissionNode !== null;
  }
  get useDispersion() {
    return this.dispersion > 0 || this.dispersionNode !== null;
  }
  setupSpecular() {
    const iorNode = this.iorNode ? float(this.iorNode) : materialIOR;
    ior.assign(iorNode);
    specularColor.assign(mix(min(pow2(ior.sub(1).div(ior.add(1))).mul(materialSpecularColor), vec3(1)).mul(materialSpecularIntensity), diffuseColor.rgb, metalness));
    specularF90.assign(mix(materialSpecularIntensity, 1, metalness));
  }
  setupLightingModel() {
    return new PhysicalLightingModel_default(this.useClearcoat, this.useSheen, this.useIridescence, this.useAnisotropy, this.useTransmission, this.useDispersion);
  }
  setupVariants(builder) {
    super.setupVariants(builder);
    if (this.useClearcoat) {
      const clearcoatNode = this.clearcoatNode ? float(this.clearcoatNode) : materialClearcoat;
      const clearcoatRoughnessNode = this.clearcoatRoughnessNode ? float(this.clearcoatRoughnessNode) : materialClearcoatRoughness;
      clearcoat.assign(clearcoatNode);
      clearcoatRoughness.assign(getRoughness_default({ roughness: clearcoatRoughnessNode }));
    }
    if (this.useSheen) {
      const sheenNode = this.sheenNode ? vec3(this.sheenNode) : materialSheen;
      const sheenRoughnessNode = this.sheenRoughnessNode ? float(this.sheenRoughnessNode) : materialSheenRoughness;
      sheen.assign(sheenNode);
      sheenRoughness.assign(sheenRoughnessNode);
    }
    if (this.useIridescence) {
      const iridescenceNode = this.iridescenceNode ? float(this.iridescenceNode) : materialIridescence;
      const iridescenceIORNode = this.iridescenceIORNode ? float(this.iridescenceIORNode) : materialIridescenceIOR;
      const iridescenceThicknessNode = this.iridescenceThicknessNode ? float(this.iridescenceThicknessNode) : materialIridescenceThickness;
      iridescence.assign(iridescenceNode);
      iridescenceIOR.assign(iridescenceIORNode);
      iridescenceThickness.assign(iridescenceThicknessNode);
    }
    if (this.useAnisotropy) {
      const anisotropyV = (this.anisotropyNode ? vec2(this.anisotropyNode) : materialAnisotropy).toVar();
      anisotropy.assign(anisotropyV.length());
      If(anisotropy.equal(0), () => {
        anisotropyV.assign(vec2(1, 0));
      }).else(() => {
        anisotropyV.divAssign(anisotropy);
        anisotropy.assign(anisotropy.saturate());
      });
      alphaT.assign(anisotropy.pow2().mix(roughness.pow2(), 1));
      anisotropyT.assign(TBNViewMatrix[0].mul(anisotropyV.x).add(TBNViewMatrix[1].mul(anisotropyV.y)));
      anisotropyB.assign(TBNViewMatrix[1].mul(anisotropyV.x).sub(TBNViewMatrix[0].mul(anisotropyV.y)));
    }
    if (this.useTransmission) {
      const transmissionNode = this.transmissionNode ? float(this.transmissionNode) : materialTransmission;
      const thicknessNode = this.thicknessNode ? float(this.thicknessNode) : materialThickness;
      const attenuationDistanceNode = this.attenuationDistanceNode ? float(this.attenuationDistanceNode) : materialAttenuationDistance;
      const attenuationColorNode = this.attenuationColorNode ? vec3(this.attenuationColorNode) : materialAttenuationColor;
      transmission.assign(transmissionNode);
      thickness.assign(thicknessNode);
      attenuationDistance.assign(attenuationDistanceNode);
      attenuationColor.assign(attenuationColorNode);
      if (this.useDispersion) {
        const dispersionNode = this.dispersionNode ? float(this.dispersionNode) : materialDispersion;
        dispersion.assign(dispersionNode);
      }
    }
  }
  setupNormal(builder) {
    super.setupNormal(builder);
    const clearcoatNormalNode = this.clearcoatNormalNode ? vec3(this.clearcoatNormalNode) : materialClearcoatNormal;
    transformedClearcoatNormalView.assign(clearcoatNormalNode);
  }
  copy(source) {
    this.clearcoatNode = source.clearcoatNode;
    this.clearcoatRoughnessNode = source.clearcoatRoughnessNode;
    this.clearcoatNormalNode = source.clearcoatNormalNode;
    this.sheenNode = source.sheenNode;
    this.sheenRoughnessNode = source.sheenRoughnessNode;
    this.iridescenceNode = source.iridescenceNode;
    this.iridescenceIORNode = source.iridescenceIORNode;
    this.iridescenceThicknessNode = source.iridescenceThicknessNode;
    this.specularIntensityNode = source.specularIntensityNode;
    this.specularColorNode = source.specularColorNode;
    this.transmissionNode = source.transmissionNode;
    this.thicknessNode = source.thicknessNode;
    this.attenuationDistanceNode = source.attenuationDistanceNode;
    this.attenuationColorNode = source.attenuationColorNode;
    this.dispersionNode = source.dispersionNode;
    this.anisotropyNode = source.anisotropyNode;
    return super.copy(source);
  }
};
var MeshPhysicalNodeMaterial_default = MeshPhysicalNodeMaterial;
addNodeMaterial("MeshPhysicalNodeMaterial", MeshPhysicalNodeMaterial);

// node_modules/three/examples/jsm/nodes/materials/MeshSSSNodeMaterial.js
var SSSLightingModel = class extends PhysicalLightingModel_default {
  constructor(useClearcoat, useSheen, useIridescence, useSSS) {
    super(useClearcoat, useSheen, useIridescence);
    this.useSSS = useSSS;
  }
  direct({ lightDirection, lightColor, reflectedLight }, stack2, builder) {
    if (this.useSSS === true) {
      const material = builder.material;
      const { thicknessColorNode, thicknessDistortionNode, thicknessAmbientNode, thicknessAttenuationNode, thicknessPowerNode, thicknessScaleNode } = material;
      const scatteringHalf = lightDirection.add(transformedNormalView.mul(thicknessDistortionNode)).normalize();
      const scatteringDot = float(positionViewDirection.dot(scatteringHalf.negate()).saturate().pow(thicknessPowerNode).mul(thicknessScaleNode));
      const scatteringIllu = vec3(scatteringDot.add(thicknessAmbientNode).mul(thicknessColorNode));
      reflectedLight.directDiffuse.addAssign(scatteringIllu.mul(thicknessAttenuationNode.mul(lightColor)));
    }
    super.direct({ lightDirection, lightColor, reflectedLight }, stack2, builder);
  }
};
var MeshSSSNodeMaterial = class extends MeshPhysicalNodeMaterial_default {
  constructor(parameters) {
    super(parameters);
    this.thicknessColorNode = null;
    this.thicknessDistortionNode = float(0.1);
    this.thicknessAmbientNode = float(0);
    this.thicknessAttenuationNode = float(0.1);
    this.thicknessPowerNode = float(2);
    this.thicknessScaleNode = float(10);
  }
  get useSSS() {
    return this.thicknessColorNode !== null;
  }
  setupLightingModel() {
    return new SSSLightingModel(this.useClearcoat, this.useSheen, this.useIridescence, this.useSSS);
  }
  copy(source) {
    this.thicknessColorNode = source.thicknessColorNode;
    this.thicknessDistortionNode = source.thicknessDistortionNode;
    this.thicknessAmbientNode = source.thicknessAmbientNode;
    this.thicknessAttenuationNode = source.thicknessAttenuationNode;
    this.thicknessPowerNode = source.thicknessPowerNode;
    this.thicknessScaleNode = source.thicknessScaleNode;
    return super.copy(source);
  }
};
var MeshSSSNodeMaterial_default = MeshSSSNodeMaterial;
addNodeMaterial("MeshSSSNodeMaterial", MeshSSSNodeMaterial);

// node_modules/three/examples/jsm/nodes/functions/ToonLightingModel.js
var getGradientIrradiance = tslFn(({ normal: normal2, lightDirection, builder }) => {
  const dotNL = normal2.dot(lightDirection);
  const coord = vec2(dotNL.mul(0.5).add(0.5), 0);
  if (builder.material.gradientMap) {
    const gradientMap = materialReference("gradientMap", "texture").context({ getUV: () => coord });
    return vec3(gradientMap.r);
  } else {
    const fw = coord.fwidth().mul(0.5);
    return mix(vec3(0.7), vec3(1), smoothstep(float(0.7).sub(fw.x), float(0.7).add(fw.x), coord.x));
  }
});
var ToonLightingModel = class extends LightingModel_default {
  direct({ lightDirection, lightColor, reflectedLight }, stack2, builder) {
    const irradiance = getGradientIrradiance({ normal: normalGeometry, lightDirection, builder }).mul(lightColor);
    reflectedLight.directDiffuse.addAssign(irradiance.mul(BRDF_Lambert_default({ diffuseColor: diffuseColor.rgb })));
  }
  indirectDiffuse({ irradiance, reflectedLight }) {
    reflectedLight.indirectDiffuse.addAssign(irradiance.mul(BRDF_Lambert_default({ diffuseColor })));
  }
};
var ToonLightingModel_default = ToonLightingModel;

// node_modules/three/examples/jsm/nodes/materials/MeshToonNodeMaterial.js
var defaultValues11 = new MeshToonMaterial();
var MeshToonNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isMeshToonNodeMaterial = true;
    this.lights = true;
    this.setDefaultValues(defaultValues11);
    this.setValues(parameters);
  }
  setupLightingModel() {
    return new ToonLightingModel_default();
  }
};
var MeshToonNodeMaterial_default = MeshToonNodeMaterial;
addNodeMaterial("MeshToonNodeMaterial", MeshToonNodeMaterial);

// node_modules/three/examples/jsm/nodes/materials/MeshMatcapNodeMaterial.js
var defaultValues12 = new MeshMatcapMaterial();
var MeshMatcapNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isMeshMatcapNodeMaterial = true;
    this.lights = false;
    this.setDefaultValues(defaultValues12);
    this.setValues(parameters);
  }
  setupVariants(builder) {
    const uv2 = matcapUV;
    let matcapColor;
    if (builder.material.matcap) {
      matcapColor = materialReference("matcap", "texture").context({ getUV: () => uv2 });
    } else {
      matcapColor = vec3(mix(0.2, 0.8, uv2.y));
    }
    diffuseColor.rgb.mulAssign(matcapColor.rgb);
  }
};
var MeshMatcapNodeMaterial_default = MeshMatcapNodeMaterial;
addNodeMaterial("MeshMatcapNodeMaterial", MeshMatcapNodeMaterial);

// node_modules/three/examples/jsm/nodes/materials/PointsNodeMaterial.js
var defaultValues13 = new PointsMaterial();
var PointsNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isPointsNodeMaterial = true;
    this.lights = false;
    this.normals = false;
    this.transparent = true;
    this.sizeNode = null;
    this.setDefaultValues(defaultValues13);
    this.setValues(parameters);
  }
  copy(source) {
    this.sizeNode = source.sizeNode;
    return super.copy(source);
  }
};
var PointsNodeMaterial_default = PointsNodeMaterial;
addNodeMaterial("PointsNodeMaterial", PointsNodeMaterial);

// node_modules/three/examples/jsm/nodes/materials/SpriteNodeMaterial.js
var defaultValues14 = new SpriteMaterial();
var SpriteNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isSpriteNodeMaterial = true;
    this.lights = false;
    this.normals = false;
    this.positionNode = null;
    this.rotationNode = null;
    this.scaleNode = null;
    this.setDefaultValues(defaultValues14);
    this.setValues(parameters);
  }
  setupPosition({ object, context: context2 }) {
    const { positionNode, rotationNode, scaleNode } = this;
    const vertex = positionLocal;
    let mvPosition = modelViewMatrix.mul(vec3(positionNode || 0));
    let scale = vec2(modelWorldMatrix[0].xyz.length(), modelWorldMatrix[1].xyz.length());
    if (scaleNode !== null) {
      scale = scale.mul(scaleNode);
    }
    let alignedPosition = vertex.xy;
    if (object.center && object.center.isVector2 === true) {
      alignedPosition = alignedPosition.sub(uniform(object.center).sub(0.5));
    }
    alignedPosition = alignedPosition.mul(scale);
    const rotation = float(rotationNode || materialRotation);
    const rotatedPosition = alignedPosition.rotate(rotation);
    mvPosition = vec4(mvPosition.xy.add(rotatedPosition), mvPosition.zw);
    const modelViewProjection2 = cameraProjectionMatrix.mul(mvPosition);
    context2.vertex = vertex;
    return modelViewProjection2;
  }
  copy(source) {
    this.positionNode = source.positionNode;
    this.rotationNode = source.rotationNode;
    this.scaleNode = source.scaleNode;
    return super.copy(source);
  }
};
var SpriteNodeMaterial_default = SpriteNodeMaterial;
addNodeMaterial("SpriteNodeMaterial", SpriteNodeMaterial);

// node_modules/three/examples/jsm/nodes/functions/ShadowMaskModel.js
var ShadowMaskModel = class extends LightingModel_default {
  constructor() {
    super();
    this.shadowNode = float(1).toVar("shadowMask");
  }
  direct({ shadowMask }) {
    this.shadowNode.mulAssign(shadowMask);
  }
  finish(context2) {
    diffuseColor.a.mulAssign(this.shadowNode.oneMinus());
    context2.outgoingLight.rgb.assign(diffuseColor.rgb);
  }
};
var ShadowMaskModel_default = ShadowMaskModel;

// node_modules/three/examples/jsm/nodes/materials/ShadowNodeMaterial.js
var defaultValues15 = new ShadowMaterial();
var ShadowNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isShadowNodeMaterial = true;
    this.lights = true;
    this.setDefaultValues(defaultValues15);
    this.setValues(parameters);
  }
  setupLightingModel() {
    return new ShadowMaskModel_default();
  }
};
var ShadowNodeMaterial_default = ShadowNodeMaterial;
addNodeMaterial("ShadowNodeMaterial", ShadowNodeMaterial);

// node_modules/three/examples/jsm/nodes/materials/VolumeNodeMaterial.js
var VolumeNodeMaterial = class extends NodeMaterial_default {
  constructor(params = {}) {
    super();
    this.normals = false;
    this.lights = false;
    this.isVolumeNodeMaterial = true;
    this.testNode = null;
    this.setValues(params);
  }
  setup(builder) {
    const map = texture3D(this.map, null, 0);
    const hitBox = tslFn(({ orig, dir }) => {
      const box_min = vec3(-0.5);
      const box_max = vec3(0.5);
      const inv_dir = dir.reciprocal();
      const tmin_tmp = box_min.sub(orig).mul(inv_dir);
      const tmax_tmp = box_max.sub(orig).mul(inv_dir);
      const tmin = min(tmin_tmp, tmax_tmp);
      const tmax = max(tmin_tmp, tmax_tmp);
      const t0 = max(tmin.x, max(tmin.y, tmin.z));
      const t1 = min(tmax.x, min(tmax.y, tmax.z));
      return vec2(t0, t1);
    });
    this.fragmentNode = tslFn(() => {
      const vOrigin = varying(vec3(modelWorldMatrixInverse.mul(vec4(cameraPosition, 1))));
      const vDirection = varying(positionGeometry.sub(vOrigin));
      const rayDir = vDirection.normalize();
      const bounds = property("vec2", "bounds").assign(hitBox({ orig: vOrigin, dir: rayDir }));
      bounds.x.greaterThan(bounds.y).discard();
      bounds.assign(vec2(max(bounds.x, 0), bounds.y));
      const p = property("vec3", "p").assign(vOrigin.add(bounds.x.mul(rayDir)));
      const inc = property("vec3", "inc").assign(vec3(rayDir.abs().reciprocal()));
      const delta = property("float", "delta").assign(min(inc.x, min(inc.y, inc.z)));
      delta.divAssign(materialReference("steps", "float"));
      const ac = property("vec4", "ac").assign(vec4(materialReference("base", "color"), 0));
      loop({ type: "float", start: bounds.x, end: bounds.y, update: "+= delta" }, () => {
        const d = property("float", "d").assign(map.uv(p.add(0.5)).r);
        if (this.testNode !== null) {
          this.testNode({ map, mapValue: d, probe: p, finalColor: ac }).append();
        } else {
          ac.a.assign(1);
          Break();
        }
        p.addAssign(rayDir.mul(delta));
      });
      ac.a.equal(0).discard();
      return vec4(ac);
    })();
    super.setup(builder);
  }
};
var VolumeNodeMaterial_default = VolumeNodeMaterial;
addNodeMaterial("VolumeNodeMaterial", VolumeNodeMaterial);

// node_modules/three/examples/jsm/nodes/loaders/NodeMaterialLoader.js
var superFromTypeFunction = MaterialLoader.createMaterialFromType;
MaterialLoader.createMaterialFromType = function(type) {
  const material = createNodeMaterialFromType(type);
  if (material !== void 0) {
    return material;
  }
  return superFromTypeFunction.call(this, type);
};
var NodeMaterialLoader = class extends MaterialLoader {
  constructor(manager) {
    super(manager);
    this.nodes = {};
  }
  parse(json) {
    const material = super.parse(json);
    const nodes = this.nodes;
    const inputNodes = json.inputNodes;
    for (const property2 in inputNodes) {
      const uuid = inputNodes[property2];
      material[property2] = nodes[uuid];
    }
    return material;
  }
  setNodes(value) {
    this.nodes = value;
    return this;
  }
};
var NodeMaterialLoader_default = NodeMaterialLoader;

// node_modules/three/examples/jsm/nodes/loaders/NodeObjectLoader.js
var NodeObjectLoader = class extends ObjectLoader {
  constructor(manager) {
    super(manager);
    this._nodesJSON = null;
  }
  parse(json, onLoad) {
    this._nodesJSON = json.nodes;
    const data = super.parse(json, onLoad);
    this._nodesJSON = null;
    return data;
  }
  parseNodes(json, textures) {
    if (json !== void 0) {
      const loader = new NodeLoader_default();
      loader.setTextures(textures);
      return loader.parseNodes(json);
    }
    return {};
  }
  parseMaterials(json, textures) {
    const materials = {};
    if (json !== void 0) {
      const nodes = this.parseNodes(this._nodesJSON, textures);
      const loader = new NodeMaterialLoader_default();
      loader.setTextures(textures);
      loader.setNodes(nodes);
      for (let i = 0, l = json.length; i < l; i++) {
        const data = json[i];
        materials[data.uuid] = loader.parse(data);
      }
    }
    return materials;
  }
};
var NodeObjectLoader_default = NodeObjectLoader;

// node_modules/three/examples/jsm/nodes/core/NodeParser.js
var NodeParser = class {
  parseFunction() {
    console.warn("Abstract function.");
  }
};
var NodeParser_default = NodeParser;

// node_modules/three/examples/jsm/nodes/core/NodeFunction.js
var NodeFunction = class {
  constructor(type, inputs, name = "", presicion = "") {
    this.type = type;
    this.inputs = inputs;
    this.name = name;
    this.presicion = presicion;
  }
  getCode() {
    console.warn("Abstract function.");
  }
};
NodeFunction.isNodeFunction = true;
var NodeFunction_default = NodeFunction;

// node_modules/three/examples/jsm/nodes/parsers/GLSLNodeFunction.js
var declarationRegexp = /^\s*(highp|mediump|lowp)?\s*([a-z_0-9]+)\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)/i;
var propertiesRegexp = /[a-z_0-9]+/ig;
var pragmaMain = "#pragma main";
var parse = (source) => {
  source = source.trim();
  const pragmaMainIndex = source.indexOf(pragmaMain);
  const mainCode = pragmaMainIndex !== -1 ? source.slice(pragmaMainIndex + pragmaMain.length) : source;
  const declaration = mainCode.match(declarationRegexp);
  if (declaration !== null && declaration.length === 5) {
    const inputsCode = declaration[4];
    const propsMatches = [];
    let nameMatch = null;
    while ((nameMatch = propertiesRegexp.exec(inputsCode)) !== null) {
      propsMatches.push(nameMatch);
    }
    const inputs = [];
    let i = 0;
    while (i < propsMatches.length) {
      const isConst = propsMatches[i][0] === "const";
      if (isConst === true) {
        i++;
      }
      let qualifier = propsMatches[i][0];
      if (qualifier === "in" || qualifier === "out" || qualifier === "inout") {
        i++;
      } else {
        qualifier = "";
      }
      const type2 = propsMatches[i++][0];
      let count = Number.parseInt(propsMatches[i][0]);
      if (Number.isNaN(count) === false)
        i++;
      else
        count = null;
      const name2 = propsMatches[i++][0];
      inputs.push(new NodeFunctionInput_default(type2, name2, count, qualifier, isConst));
    }
    const blockCode = mainCode.substring(declaration[0].length);
    const name = declaration[3] !== void 0 ? declaration[3] : "";
    const type = declaration[2];
    const presicion = declaration[1] !== void 0 ? declaration[1] : "";
    const headerCode = pragmaMainIndex !== -1 ? source.slice(0, pragmaMainIndex) : "";
    return {
      type,
      inputs,
      name,
      presicion,
      inputsCode,
      blockCode,
      headerCode
    };
  } else {
    throw new Error("FunctionNode: Function is not a GLSL code.");
  }
};
var GLSLNodeFunction = class extends NodeFunction_default {
  constructor(source) {
    const { type, inputs, name, presicion, inputsCode, blockCode, headerCode } = parse(source);
    super(type, inputs, name, presicion);
    this.inputsCode = inputsCode;
    this.blockCode = blockCode;
    this.headerCode = headerCode;
  }
  getCode(name = this.name) {
    let code2;
    const blockCode = this.blockCode;
    if (blockCode !== "") {
      const { type, inputsCode, headerCode, presicion } = this;
      let declarationCode = `${type} ${name} ( ${inputsCode.trim()} )`;
      if (presicion !== "") {
        declarationCode = `${presicion} ${declarationCode}`;
      }
      code2 = headerCode + declarationCode + blockCode;
    } else {
      code2 = "";
    }
    return code2;
  }
};
var GLSLNodeFunction_default = GLSLNodeFunction;

// node_modules/three/examples/jsm/nodes/parsers/GLSLNodeParser.js
var GLSLNodeParser = class extends NodeParser_default {
  parseFunction(source) {
    return new GLSLNodeFunction_default(source);
  }
};
var GLSLNodeParser_default = GLSLNodeParser;

// node_modules/three/examples/jsm/nodes/materialx/lib/mx_noise.js
var mx_select = tslFn(([b_immutable, t_immutable, f_immutable]) => {
  const f = float(f_immutable).toVar();
  const t = float(t_immutable).toVar();
  const b = bool(b_immutable).toVar();
  return cond(b, t, f);
});
var mx_negate_if = tslFn(([val_immutable, b_immutable]) => {
  const b = bool(b_immutable).toVar();
  const val = float(val_immutable).toVar();
  return cond(b, val.negate(), val);
});
var mx_floor = tslFn(([x_immutable]) => {
  const x = float(x_immutable).toVar();
  return int(floor(x));
});
var mx_floorfrac = tslFn(([x_immutable, i]) => {
  const x = float(x_immutable).toVar();
  i.assign(mx_floor(x));
  return x.sub(float(i));
});
var mx_bilerp_0 = tslFn(([v0_immutable, v1_immutable, v2_immutable, v3_immutable, s_immutable, t_immutable]) => {
  const t = float(t_immutable).toVar();
  const s = float(s_immutable).toVar();
  const v3 = float(v3_immutable).toVar();
  const v2 = float(v2_immutable).toVar();
  const v1 = float(v1_immutable).toVar();
  const v0 = float(v0_immutable).toVar();
  const s1 = float(sub(1, s)).toVar();
  return sub(1, t).mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))));
});
var mx_bilerp_1 = tslFn(([v0_immutable, v1_immutable, v2_immutable, v3_immutable, s_immutable, t_immutable]) => {
  const t = float(t_immutable).toVar();
  const s = float(s_immutable).toVar();
  const v3 = vec3(v3_immutable).toVar();
  const v2 = vec3(v2_immutable).toVar();
  const v1 = vec3(v1_immutable).toVar();
  const v0 = vec3(v0_immutable).toVar();
  const s1 = float(sub(1, s)).toVar();
  return sub(1, t).mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))));
});
var mx_bilerp = overloadingFn([mx_bilerp_0, mx_bilerp_1]);
var mx_trilerp_0 = tslFn(([v0_immutable, v1_immutable, v2_immutable, v3_immutable, v4_immutable, v5_immutable, v6_immutable, v7_immutable, s_immutable, t_immutable, r_immutable]) => {
  const r = float(r_immutable).toVar();
  const t = float(t_immutable).toVar();
  const s = float(s_immutable).toVar();
  const v7 = float(v7_immutable).toVar();
  const v6 = float(v6_immutable).toVar();
  const v5 = float(v5_immutable).toVar();
  const v4 = float(v4_immutable).toVar();
  const v3 = float(v3_immutable).toVar();
  const v2 = float(v2_immutable).toVar();
  const v1 = float(v1_immutable).toVar();
  const v0 = float(v0_immutable).toVar();
  const s1 = float(sub(1, s)).toVar();
  const t1 = float(sub(1, t)).toVar();
  const r1 = float(sub(1, r)).toVar();
  return r1.mul(t1.mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))))).add(r.mul(t1.mul(v4.mul(s1).add(v5.mul(s))).add(t.mul(v6.mul(s1).add(v7.mul(s))))));
});
var mx_trilerp_1 = tslFn(([v0_immutable, v1_immutable, v2_immutable, v3_immutable, v4_immutable, v5_immutable, v6_immutable, v7_immutable, s_immutable, t_immutable, r_immutable]) => {
  const r = float(r_immutable).toVar();
  const t = float(t_immutable).toVar();
  const s = float(s_immutable).toVar();
  const v7 = vec3(v7_immutable).toVar();
  const v6 = vec3(v6_immutable).toVar();
  const v5 = vec3(v5_immutable).toVar();
  const v4 = vec3(v4_immutable).toVar();
  const v3 = vec3(v3_immutable).toVar();
  const v2 = vec3(v2_immutable).toVar();
  const v1 = vec3(v1_immutable).toVar();
  const v0 = vec3(v0_immutable).toVar();
  const s1 = float(sub(1, s)).toVar();
  const t1 = float(sub(1, t)).toVar();
  const r1 = float(sub(1, r)).toVar();
  return r1.mul(t1.mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))))).add(r.mul(t1.mul(v4.mul(s1).add(v5.mul(s))).add(t.mul(v6.mul(s1).add(v7.mul(s))))));
});
var mx_trilerp = overloadingFn([mx_trilerp_0, mx_trilerp_1]);
var mx_gradient_float_0 = tslFn(([hash_immutable, x_immutable, y_immutable]) => {
  const y = float(y_immutable).toVar();
  const x = float(x_immutable).toVar();
  const hash2 = uint(hash_immutable).toVar();
  const h = uint(hash2.bitAnd(uint(7))).toVar();
  const u = float(mx_select(h.lessThan(uint(4)), x, y)).toVar();
  const v = float(mul(2, mx_select(h.lessThan(uint(4)), y, x))).toVar();
  return mx_negate_if(u, bool(h.bitAnd(uint(1)))).add(mx_negate_if(v, bool(h.bitAnd(uint(2)))));
});
var mx_gradient_float_1 = tslFn(([hash_immutable, x_immutable, y_immutable, z_immutable]) => {
  const z = float(z_immutable).toVar();
  const y = float(y_immutable).toVar();
  const x = float(x_immutable).toVar();
  const hash2 = uint(hash_immutable).toVar();
  const h = uint(hash2.bitAnd(uint(15))).toVar();
  const u = float(mx_select(h.lessThan(uint(8)), x, y)).toVar();
  const v = float(mx_select(h.lessThan(uint(4)), y, mx_select(h.equal(uint(12)).or(h.equal(uint(14))), x, z))).toVar();
  return mx_negate_if(u, bool(h.bitAnd(uint(1)))).add(mx_negate_if(v, bool(h.bitAnd(uint(2)))));
});
var mx_gradient_float = overloadingFn([mx_gradient_float_0, mx_gradient_float_1]);
var mx_gradient_vec3_0 = tslFn(([hash_immutable, x_immutable, y_immutable]) => {
  const y = float(y_immutable).toVar();
  const x = float(x_immutable).toVar();
  const hash2 = uvec3(hash_immutable).toVar();
  return vec3(mx_gradient_float(hash2.x, x, y), mx_gradient_float(hash2.y, x, y), mx_gradient_float(hash2.z, x, y));
});
var mx_gradient_vec3_1 = tslFn(([hash_immutable, x_immutable, y_immutable, z_immutable]) => {
  const z = float(z_immutable).toVar();
  const y = float(y_immutable).toVar();
  const x = float(x_immutable).toVar();
  const hash2 = uvec3(hash_immutable).toVar();
  return vec3(mx_gradient_float(hash2.x, x, y, z), mx_gradient_float(hash2.y, x, y, z), mx_gradient_float(hash2.z, x, y, z));
});
var mx_gradient_vec3 = overloadingFn([mx_gradient_vec3_0, mx_gradient_vec3_1]);
var mx_gradient_scale2d_0 = tslFn(([v_immutable]) => {
  const v = float(v_immutable).toVar();
  return mul(0.6616, v);
});
var mx_gradient_scale3d_0 = tslFn(([v_immutable]) => {
  const v = float(v_immutable).toVar();
  return mul(0.982, v);
});
var mx_gradient_scale2d_1 = tslFn(([v_immutable]) => {
  const v = vec3(v_immutable).toVar();
  return mul(0.6616, v);
});
var mx_gradient_scale2d = overloadingFn([mx_gradient_scale2d_0, mx_gradient_scale2d_1]);
var mx_gradient_scale3d_1 = tslFn(([v_immutable]) => {
  const v = vec3(v_immutable).toVar();
  return mul(0.982, v);
});
var mx_gradient_scale3d = overloadingFn([mx_gradient_scale3d_0, mx_gradient_scale3d_1]);
var mx_rotl32 = tslFn(([x_immutable, k_immutable]) => {
  const k = int(k_immutable).toVar();
  const x = uint(x_immutable).toVar();
  return x.shiftLeft(k).bitOr(x.shiftRight(int(32).sub(k)));
});
var mx_bjmix = tslFn(([a, b, c]) => {
  a.subAssign(c);
  a.bitXorAssign(mx_rotl32(c, int(4)));
  c.addAssign(b);
  b.subAssign(a);
  b.bitXorAssign(mx_rotl32(a, int(6)));
  a.addAssign(c);
  c.subAssign(b);
  c.bitXorAssign(mx_rotl32(b, int(8)));
  b.addAssign(a);
  a.subAssign(c);
  a.bitXorAssign(mx_rotl32(c, int(16)));
  c.addAssign(b);
  b.subAssign(a);
  b.bitXorAssign(mx_rotl32(a, int(19)));
  a.addAssign(c);
  c.subAssign(b);
  c.bitXorAssign(mx_rotl32(b, int(4)));
  b.addAssign(a);
});
var mx_bjfinal = tslFn(([a_immutable, b_immutable, c_immutable]) => {
  const c = uint(c_immutable).toVar();
  const b = uint(b_immutable).toVar();
  const a = uint(a_immutable).toVar();
  c.bitXorAssign(b);
  c.subAssign(mx_rotl32(b, int(14)));
  a.bitXorAssign(c);
  a.subAssign(mx_rotl32(c, int(11)));
  b.bitXorAssign(a);
  b.subAssign(mx_rotl32(a, int(25)));
  c.bitXorAssign(b);
  c.subAssign(mx_rotl32(b, int(16)));
  a.bitXorAssign(c);
  a.subAssign(mx_rotl32(c, int(4)));
  b.bitXorAssign(a);
  b.subAssign(mx_rotl32(a, int(14)));
  c.bitXorAssign(b);
  c.subAssign(mx_rotl32(b, int(24)));
  return c;
});
var mx_bits_to_01 = tslFn(([bits_immutable]) => {
  const bits = uint(bits_immutable).toVar();
  return float(bits).div(float(uint(int(4294967295))));
});
var mx_fade = tslFn(([t_immutable]) => {
  const t = float(t_immutable).toVar();
  return t.mul(t.mul(t.mul(t.mul(t.mul(6).sub(15)).add(10))));
});
var mx_hash_int_0 = tslFn(([x_immutable]) => {
  const x = int(x_immutable).toVar();
  const len = uint(uint(1)).toVar();
  const seed = uint(uint(int(3735928559)).add(len.shiftLeft(uint(2)).add(uint(13)))).toVar();
  return mx_bjfinal(seed.add(uint(x)), seed, seed);
});
var mx_hash_int_1 = tslFn(([x_immutable, y_immutable]) => {
  const y = int(y_immutable).toVar();
  const x = int(x_immutable).toVar();
  const len = uint(uint(2)).toVar();
  const a = uint().toVar(), b = uint().toVar(), c = uint().toVar();
  a.assign(b.assign(c.assign(uint(int(3735928559)).add(len.shiftLeft(uint(2)).add(uint(13))))));
  a.addAssign(uint(x));
  b.addAssign(uint(y));
  return mx_bjfinal(a, b, c);
});
var mx_hash_int_2 = tslFn(([x_immutable, y_immutable, z_immutable]) => {
  const z = int(z_immutable).toVar();
  const y = int(y_immutable).toVar();
  const x = int(x_immutable).toVar();
  const len = uint(uint(3)).toVar();
  const a = uint().toVar(), b = uint().toVar(), c = uint().toVar();
  a.assign(b.assign(c.assign(uint(int(3735928559)).add(len.shiftLeft(uint(2)).add(uint(13))))));
  a.addAssign(uint(x));
  b.addAssign(uint(y));
  c.addAssign(uint(z));
  return mx_bjfinal(a, b, c);
});
var mx_hash_int_3 = tslFn(([x_immutable, y_immutable, z_immutable, xx_immutable]) => {
  const xx = int(xx_immutable).toVar();
  const z = int(z_immutable).toVar();
  const y = int(y_immutable).toVar();
  const x = int(x_immutable).toVar();
  const len = uint(uint(4)).toVar();
  const a = uint().toVar(), b = uint().toVar(), c = uint().toVar();
  a.assign(b.assign(c.assign(uint(int(3735928559)).add(len.shiftLeft(uint(2)).add(uint(13))))));
  a.addAssign(uint(x));
  b.addAssign(uint(y));
  c.addAssign(uint(z));
  mx_bjmix(a, b, c);
  a.addAssign(uint(xx));
  return mx_bjfinal(a, b, c);
});
var mx_hash_int_4 = tslFn(([x_immutable, y_immutable, z_immutable, xx_immutable, yy_immutable]) => {
  const yy = int(yy_immutable).toVar();
  const xx = int(xx_immutable).toVar();
  const z = int(z_immutable).toVar();
  const y = int(y_immutable).toVar();
  const x = int(x_immutable).toVar();
  const len = uint(uint(5)).toVar();
  const a = uint().toVar(), b = uint().toVar(), c = uint().toVar();
  a.assign(b.assign(c.assign(uint(int(3735928559)).add(len.shiftLeft(uint(2)).add(uint(13))))));
  a.addAssign(uint(x));
  b.addAssign(uint(y));
  c.addAssign(uint(z));
  mx_bjmix(a, b, c);
  a.addAssign(uint(xx));
  b.addAssign(uint(yy));
  return mx_bjfinal(a, b, c);
});
var mx_hash_int = overloadingFn([mx_hash_int_0, mx_hash_int_1, mx_hash_int_2, mx_hash_int_3, mx_hash_int_4]);
var mx_hash_vec3_0 = tslFn(([x_immutable, y_immutable]) => {
  const y = int(y_immutable).toVar();
  const x = int(x_immutable).toVar();
  const h = uint(mx_hash_int(x, y)).toVar();
  const result = uvec3().toVar();
  result.x.assign(h.bitAnd(int(255)));
  result.y.assign(h.shiftRight(int(8)).bitAnd(int(255)));
  result.z.assign(h.shiftRight(int(16)).bitAnd(int(255)));
  return result;
});
var mx_hash_vec3_1 = tslFn(([x_immutable, y_immutable, z_immutable]) => {
  const z = int(z_immutable).toVar();
  const y = int(y_immutable).toVar();
  const x = int(x_immutable).toVar();
  const h = uint(mx_hash_int(x, y, z)).toVar();
  const result = uvec3().toVar();
  result.x.assign(h.bitAnd(int(255)));
  result.y.assign(h.shiftRight(int(8)).bitAnd(int(255)));
  result.z.assign(h.shiftRight(int(16)).bitAnd(int(255)));
  return result;
});
var mx_hash_vec3 = overloadingFn([mx_hash_vec3_0, mx_hash_vec3_1]);
var mx_perlin_noise_float_0 = tslFn(([p_immutable]) => {
  const p = vec2(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar();
  const fx = float(mx_floorfrac(p.x, X)).toVar();
  const fy = float(mx_floorfrac(p.y, Y)).toVar();
  const u = float(mx_fade(fx)).toVar();
  const v = float(mx_fade(fy)).toVar();
  const result = float(mx_bilerp(mx_gradient_float(mx_hash_int(X, Y), fx, fy), mx_gradient_float(mx_hash_int(X.add(int(1)), Y), fx.sub(1), fy), mx_gradient_float(mx_hash_int(X, Y.add(int(1))), fx, fy.sub(1)), mx_gradient_float(mx_hash_int(X.add(int(1)), Y.add(int(1))), fx.sub(1), fy.sub(1)), u, v)).toVar();
  return mx_gradient_scale2d(result);
});
var mx_perlin_noise_float_1 = tslFn(([p_immutable]) => {
  const p = vec3(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
  const fx = float(mx_floorfrac(p.x, X)).toVar();
  const fy = float(mx_floorfrac(p.y, Y)).toVar();
  const fz = float(mx_floorfrac(p.z, Z)).toVar();
  const u = float(mx_fade(fx)).toVar();
  const v = float(mx_fade(fy)).toVar();
  const w = float(mx_fade(fz)).toVar();
  const result = float(mx_trilerp(mx_gradient_float(mx_hash_int(X, Y, Z), fx, fy, fz), mx_gradient_float(mx_hash_int(X.add(int(1)), Y, Z), fx.sub(1), fy, fz), mx_gradient_float(mx_hash_int(X, Y.add(int(1)), Z), fx, fy.sub(1), fz), mx_gradient_float(mx_hash_int(X.add(int(1)), Y.add(int(1)), Z), fx.sub(1), fy.sub(1), fz), mx_gradient_float(mx_hash_int(X, Y, Z.add(int(1))), fx, fy, fz.sub(1)), mx_gradient_float(mx_hash_int(X.add(int(1)), Y, Z.add(int(1))), fx.sub(1), fy, fz.sub(1)), mx_gradient_float(mx_hash_int(X, Y.add(int(1)), Z.add(int(1))), fx, fy.sub(1), fz.sub(1)), mx_gradient_float(mx_hash_int(X.add(int(1)), Y.add(int(1)), Z.add(int(1))), fx.sub(1), fy.sub(1), fz.sub(1)), u, v, w)).toVar();
  return mx_gradient_scale3d(result);
});
var mx_perlin_noise_float = overloadingFn([mx_perlin_noise_float_0, mx_perlin_noise_float_1]);
var mx_perlin_noise_vec3_0 = tslFn(([p_immutable]) => {
  const p = vec2(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar();
  const fx = float(mx_floorfrac(p.x, X)).toVar();
  const fy = float(mx_floorfrac(p.y, Y)).toVar();
  const u = float(mx_fade(fx)).toVar();
  const v = float(mx_fade(fy)).toVar();
  const result = vec3(mx_bilerp(mx_gradient_vec3(mx_hash_vec3(X, Y), fx, fy), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y), fx.sub(1), fy), mx_gradient_vec3(mx_hash_vec3(X, Y.add(int(1))), fx, fy.sub(1)), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y.add(int(1))), fx.sub(1), fy.sub(1)), u, v)).toVar();
  return mx_gradient_scale2d(result);
});
var mx_perlin_noise_vec3_1 = tslFn(([p_immutable]) => {
  const p = vec3(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
  const fx = float(mx_floorfrac(p.x, X)).toVar();
  const fy = float(mx_floorfrac(p.y, Y)).toVar();
  const fz = float(mx_floorfrac(p.z, Z)).toVar();
  const u = float(mx_fade(fx)).toVar();
  const v = float(mx_fade(fy)).toVar();
  const w = float(mx_fade(fz)).toVar();
  const result = vec3(mx_trilerp(mx_gradient_vec3(mx_hash_vec3(X, Y, Z), fx, fy, fz), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y, Z), fx.sub(1), fy, fz), mx_gradient_vec3(mx_hash_vec3(X, Y.add(int(1)), Z), fx, fy.sub(1), fz), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y.add(int(1)), Z), fx.sub(1), fy.sub(1), fz), mx_gradient_vec3(mx_hash_vec3(X, Y, Z.add(int(1))), fx, fy, fz.sub(1)), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y, Z.add(int(1))), fx.sub(1), fy, fz.sub(1)), mx_gradient_vec3(mx_hash_vec3(X, Y.add(int(1)), Z.add(int(1))), fx, fy.sub(1), fz.sub(1)), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y.add(int(1)), Z.add(int(1))), fx.sub(1), fy.sub(1), fz.sub(1)), u, v, w)).toVar();
  return mx_gradient_scale3d(result);
});
var mx_perlin_noise_vec3 = overloadingFn([mx_perlin_noise_vec3_0, mx_perlin_noise_vec3_1]);
var mx_cell_noise_float_0 = tslFn(([p_immutable]) => {
  const p = float(p_immutable).toVar();
  const ix = int(mx_floor(p)).toVar();
  return mx_bits_to_01(mx_hash_int(ix));
});
var mx_cell_noise_float_1 = tslFn(([p_immutable]) => {
  const p = vec2(p_immutable).toVar();
  const ix = int(mx_floor(p.x)).toVar();
  const iy = int(mx_floor(p.y)).toVar();
  return mx_bits_to_01(mx_hash_int(ix, iy));
});
var mx_cell_noise_float_2 = tslFn(([p_immutable]) => {
  const p = vec3(p_immutable).toVar();
  const ix = int(mx_floor(p.x)).toVar();
  const iy = int(mx_floor(p.y)).toVar();
  const iz = int(mx_floor(p.z)).toVar();
  return mx_bits_to_01(mx_hash_int(ix, iy, iz));
});
var mx_cell_noise_float_3 = tslFn(([p_immutable]) => {
  const p = vec4(p_immutable).toVar();
  const ix = int(mx_floor(p.x)).toVar();
  const iy = int(mx_floor(p.y)).toVar();
  const iz = int(mx_floor(p.z)).toVar();
  const iw = int(mx_floor(p.w)).toVar();
  return mx_bits_to_01(mx_hash_int(ix, iy, iz, iw));
});
var mx_cell_noise_float = overloadingFn([mx_cell_noise_float_0, mx_cell_noise_float_1, mx_cell_noise_float_2, mx_cell_noise_float_3]);
var mx_cell_noise_vec3_0 = tslFn(([p_immutable]) => {
  const p = float(p_immutable).toVar();
  const ix = int(mx_floor(p)).toVar();
  return vec3(mx_bits_to_01(mx_hash_int(ix, int(0))), mx_bits_to_01(mx_hash_int(ix, int(1))), mx_bits_to_01(mx_hash_int(ix, int(2))));
});
var mx_cell_noise_vec3_1 = tslFn(([p_immutable]) => {
  const p = vec2(p_immutable).toVar();
  const ix = int(mx_floor(p.x)).toVar();
  const iy = int(mx_floor(p.y)).toVar();
  return vec3(mx_bits_to_01(mx_hash_int(ix, iy, int(0))), mx_bits_to_01(mx_hash_int(ix, iy, int(1))), mx_bits_to_01(mx_hash_int(ix, iy, int(2))));
});
var mx_cell_noise_vec3_2 = tslFn(([p_immutable]) => {
  const p = vec3(p_immutable).toVar();
  const ix = int(mx_floor(p.x)).toVar();
  const iy = int(mx_floor(p.y)).toVar();
  const iz = int(mx_floor(p.z)).toVar();
  return vec3(mx_bits_to_01(mx_hash_int(ix, iy, iz, int(0))), mx_bits_to_01(mx_hash_int(ix, iy, iz, int(1))), mx_bits_to_01(mx_hash_int(ix, iy, iz, int(2))));
});
var mx_cell_noise_vec3_3 = tslFn(([p_immutable]) => {
  const p = vec4(p_immutable).toVar();
  const ix = int(mx_floor(p.x)).toVar();
  const iy = int(mx_floor(p.y)).toVar();
  const iz = int(mx_floor(p.z)).toVar();
  const iw = int(mx_floor(p.w)).toVar();
  return vec3(mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, int(0))), mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, int(1))), mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, int(2))));
});
var mx_cell_noise_vec3 = overloadingFn([mx_cell_noise_vec3_0, mx_cell_noise_vec3_1, mx_cell_noise_vec3_2, mx_cell_noise_vec3_3]);
var mx_fractal_noise_float = tslFn(([p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable]) => {
  const diminish = float(diminish_immutable).toVar();
  const lacunarity = float(lacunarity_immutable).toVar();
  const octaves = int(octaves_immutable).toVar();
  const p = vec3(p_immutable).toVar();
  const result = float(0).toVar();
  const amplitude = float(1).toVar();
  loop({ start: int(0), end: octaves }, ({ i }) => {
    result.addAssign(amplitude.mul(mx_perlin_noise_float(p)));
    amplitude.mulAssign(diminish);
    p.mulAssign(lacunarity);
  });
  return result;
});
var mx_fractal_noise_vec3 = tslFn(([p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable]) => {
  const diminish = float(diminish_immutable).toVar();
  const lacunarity = float(lacunarity_immutable).toVar();
  const octaves = int(octaves_immutable).toVar();
  const p = vec3(p_immutable).toVar();
  const result = vec3(0).toVar();
  const amplitude = float(1).toVar();
  loop({ start: int(0), end: octaves }, ({ i }) => {
    result.addAssign(amplitude.mul(mx_perlin_noise_vec3(p)));
    amplitude.mulAssign(diminish);
    p.mulAssign(lacunarity);
  });
  return result;
});
var mx_fractal_noise_vec2 = tslFn(([p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable]) => {
  const diminish = float(diminish_immutable).toVar();
  const lacunarity = float(lacunarity_immutable).toVar();
  const octaves = int(octaves_immutable).toVar();
  const p = vec3(p_immutable).toVar();
  return vec2(mx_fractal_noise_float(p, octaves, lacunarity, diminish), mx_fractal_noise_float(p.add(vec3(int(19), int(193), int(17))), octaves, lacunarity, diminish));
});
var mx_fractal_noise_vec4 = tslFn(([p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable]) => {
  const diminish = float(diminish_immutable).toVar();
  const lacunarity = float(lacunarity_immutable).toVar();
  const octaves = int(octaves_immutable).toVar();
  const p = vec3(p_immutable).toVar();
  const c = vec3(mx_fractal_noise_vec3(p, octaves, lacunarity, diminish)).toVar();
  const f = float(mx_fractal_noise_float(p.add(vec3(int(19), int(193), int(17))), octaves, lacunarity, diminish)).toVar();
  return vec4(c, f);
});
var mx_worley_distance_0 = tslFn(([p_immutable, x_immutable, y_immutable, xoff_immutable, yoff_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter = float(jitter_immutable).toVar();
  const yoff = int(yoff_immutable).toVar();
  const xoff = int(xoff_immutable).toVar();
  const y = int(y_immutable).toVar();
  const x = int(x_immutable).toVar();
  const p = vec2(p_immutable).toVar();
  const tmp = vec3(mx_cell_noise_vec3(vec2(x.add(xoff), y.add(yoff)))).toVar();
  const off = vec2(tmp.x, tmp.y).toVar();
  off.subAssign(0.5);
  off.mulAssign(jitter);
  off.addAssign(0.5);
  const cellpos = vec2(vec2(float(x), float(y)).add(off)).toVar();
  const diff = vec2(cellpos.sub(p)).toVar();
  If(metric.equal(int(2)), () => {
    return abs(diff.x).add(abs(diff.y));
  });
  If(metric.equal(int(3)), () => {
    return max(abs(diff.x), abs(diff.y));
  });
  return dot(diff, diff);
});
var mx_worley_distance_1 = tslFn(([p_immutable, x_immutable, y_immutable, z_immutable, xoff_immutable, yoff_immutable, zoff_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter = float(jitter_immutable).toVar();
  const zoff = int(zoff_immutable).toVar();
  const yoff = int(yoff_immutable).toVar();
  const xoff = int(xoff_immutable).toVar();
  const z = int(z_immutable).toVar();
  const y = int(y_immutable).toVar();
  const x = int(x_immutable).toVar();
  const p = vec3(p_immutable).toVar();
  const off = vec3(mx_cell_noise_vec3(vec3(x.add(xoff), y.add(yoff), z.add(zoff)))).toVar();
  off.subAssign(0.5);
  off.mulAssign(jitter);
  off.addAssign(0.5);
  const cellpos = vec3(vec3(float(x), float(y), float(z)).add(off)).toVar();
  const diff = vec3(cellpos.sub(p)).toVar();
  If(metric.equal(int(2)), () => {
    return abs(diff.x).add(abs(diff.y).add(abs(diff.z)));
  });
  If(metric.equal(int(3)), () => {
    return max(max(abs(diff.x), abs(diff.y)), abs(diff.z));
  });
  return dot(diff, diff);
});
var mx_worley_distance = overloadingFn([mx_worley_distance_0, mx_worley_distance_1]);
var mx_worley_noise_float_0 = tslFn(([p_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter = float(jitter_immutable).toVar();
  const p = vec2(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar();
  const localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y)).toVar();
  const sqdist = float(1e6).toVar();
  loop({ start: -1, end: int(1), name: "x", condition: "<=" }, ({ x }) => {
    loop({ start: -1, end: int(1), name: "y", condition: "<=" }, ({ y }) => {
      const dist = float(mx_worley_distance(localpos, x, y, X, Y, jitter, metric)).toVar();
      sqdist.assign(min(sqdist, dist));
    });
  });
  If(metric.equal(int(0)), () => {
    sqdist.assign(sqrt(sqdist));
  });
  return sqdist;
});
var mx_worley_noise_vec2_0 = tslFn(([p_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter = float(jitter_immutable).toVar();
  const p = vec2(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar();
  const localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y)).toVar();
  const sqdist = vec2(1e6, 1e6).toVar();
  loop({ start: -1, end: int(1), name: "x", condition: "<=" }, ({ x }) => {
    loop({ start: -1, end: int(1), name: "y", condition: "<=" }, ({ y }) => {
      const dist = float(mx_worley_distance(localpos, x, y, X, Y, jitter, metric)).toVar();
      If(dist.lessThan(sqdist.x), () => {
        sqdist.y.assign(sqdist.x);
        sqdist.x.assign(dist);
      }).elseif(dist.lessThan(sqdist.y), () => {
        sqdist.y.assign(dist);
      });
    });
  });
  If(metric.equal(int(0)), () => {
    sqdist.assign(sqrt(sqdist));
  });
  return sqdist;
});
var mx_worley_noise_vec3_0 = tslFn(([p_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter = float(jitter_immutable).toVar();
  const p = vec2(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar();
  const localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y)).toVar();
  const sqdist = vec3(1e6, 1e6, 1e6).toVar();
  loop({ start: -1, end: int(1), name: "x", condition: "<=" }, ({ x }) => {
    loop({ start: -1, end: int(1), name: "y", condition: "<=" }, ({ y }) => {
      const dist = float(mx_worley_distance(localpos, x, y, X, Y, jitter, metric)).toVar();
      If(dist.lessThan(sqdist.x), () => {
        sqdist.z.assign(sqdist.y);
        sqdist.y.assign(sqdist.x);
        sqdist.x.assign(dist);
      }).elseif(dist.lessThan(sqdist.y), () => {
        sqdist.z.assign(sqdist.y);
        sqdist.y.assign(dist);
      }).elseif(dist.lessThan(sqdist.z), () => {
        sqdist.z.assign(dist);
      });
    });
  });
  If(metric.equal(int(0)), () => {
    sqdist.assign(sqrt(sqdist));
  });
  return sqdist;
});
var mx_worley_noise_float_1 = tslFn(([p_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter = float(jitter_immutable).toVar();
  const p = vec3(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
  const localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z)).toVar();
  const sqdist = float(1e6).toVar();
  loop({ start: -1, end: int(1), name: "x", condition: "<=" }, ({ x }) => {
    loop({ start: -1, end: int(1), name: "y", condition: "<=" }, ({ y }) => {
      loop({ start: -1, end: int(1), name: "z", condition: "<=" }, ({ z }) => {
        const dist = float(mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric)).toVar();
        sqdist.assign(min(sqdist, dist));
      });
    });
  });
  If(metric.equal(int(0)), () => {
    sqdist.assign(sqrt(sqdist));
  });
  return sqdist;
});
var mx_worley_noise_float = overloadingFn([mx_worley_noise_float_0, mx_worley_noise_float_1]);
var mx_worley_noise_vec2_1 = tslFn(([p_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter = float(jitter_immutable).toVar();
  const p = vec3(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
  const localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z)).toVar();
  const sqdist = vec2(1e6, 1e6).toVar();
  loop({ start: -1, end: int(1), name: "x", condition: "<=" }, ({ x }) => {
    loop({ start: -1, end: int(1), name: "y", condition: "<=" }, ({ y }) => {
      loop({ start: -1, end: int(1), name: "z", condition: "<=" }, ({ z }) => {
        const dist = float(mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric)).toVar();
        If(dist.lessThan(sqdist.x), () => {
          sqdist.y.assign(sqdist.x);
          sqdist.x.assign(dist);
        }).elseif(dist.lessThan(sqdist.y), () => {
          sqdist.y.assign(dist);
        });
      });
    });
  });
  If(metric.equal(int(0)), () => {
    sqdist.assign(sqrt(sqdist));
  });
  return sqdist;
});
var mx_worley_noise_vec2 = overloadingFn([mx_worley_noise_vec2_0, mx_worley_noise_vec2_1]);
var mx_worley_noise_vec3_1 = tslFn(([p_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter = float(jitter_immutable).toVar();
  const p = vec3(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
  const localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z)).toVar();
  const sqdist = vec3(1e6, 1e6, 1e6).toVar();
  loop({ start: -1, end: int(1), name: "x", condition: "<=" }, ({ x }) => {
    loop({ start: -1, end: int(1), name: "y", condition: "<=" }, ({ y }) => {
      loop({ start: -1, end: int(1), name: "z", condition: "<=" }, ({ z }) => {
        const dist = float(mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric)).toVar();
        If(dist.lessThan(sqdist.x), () => {
          sqdist.z.assign(sqdist.y);
          sqdist.y.assign(sqdist.x);
          sqdist.x.assign(dist);
        }).elseif(dist.lessThan(sqdist.y), () => {
          sqdist.z.assign(sqdist.y);
          sqdist.y.assign(dist);
        }).elseif(dist.lessThan(sqdist.z), () => {
          sqdist.z.assign(dist);
        });
      });
    });
  });
  If(metric.equal(int(0)), () => {
    sqdist.assign(sqrt(sqdist));
  });
  return sqdist;
});
var mx_worley_noise_vec3 = overloadingFn([mx_worley_noise_vec3_0, mx_worley_noise_vec3_1]);
mx_select.setLayout({
  name: "mx_select",
  type: "float",
  inputs: [
    { name: "b", type: "bool" },
    { name: "t", type: "float" },
    { name: "f", type: "float" }
  ]
});
mx_negate_if.setLayout({
  name: "mx_negate_if",
  type: "float",
  inputs: [
    { name: "val", type: "float" },
    { name: "b", type: "bool" }
  ]
});
mx_floor.setLayout({
  name: "mx_floor",
  type: "int",
  inputs: [
    { name: "x", type: "float" }
  ]
});
mx_bilerp_0.setLayout({
  name: "mx_bilerp_0",
  type: "float",
  inputs: [
    { name: "v0", type: "float" },
    { name: "v1", type: "float" },
    { name: "v2", type: "float" },
    { name: "v3", type: "float" },
    { name: "s", type: "float" },
    { name: "t", type: "float" }
  ]
});
mx_bilerp_1.setLayout({
  name: "mx_bilerp_1",
  type: "vec3",
  inputs: [
    { name: "v0", type: "vec3" },
    { name: "v1", type: "vec3" },
    { name: "v2", type: "vec3" },
    { name: "v3", type: "vec3" },
    { name: "s", type: "float" },
    { name: "t", type: "float" }
  ]
});
mx_trilerp_0.setLayout({
  name: "mx_trilerp_0",
  type: "float",
  inputs: [
    { name: "v0", type: "float" },
    { name: "v1", type: "float" },
    { name: "v2", type: "float" },
    { name: "v3", type: "float" },
    { name: "v4", type: "float" },
    { name: "v5", type: "float" },
    { name: "v6", type: "float" },
    { name: "v7", type: "float" },
    { name: "s", type: "float" },
    { name: "t", type: "float" },
    { name: "r", type: "float" }
  ]
});
mx_trilerp_1.setLayout({
  name: "mx_trilerp_1",
  type: "vec3",
  inputs: [
    { name: "v0", type: "vec3" },
    { name: "v1", type: "vec3" },
    { name: "v2", type: "vec3" },
    { name: "v3", type: "vec3" },
    { name: "v4", type: "vec3" },
    { name: "v5", type: "vec3" },
    { name: "v6", type: "vec3" },
    { name: "v7", type: "vec3" },
    { name: "s", type: "float" },
    { name: "t", type: "float" },
    { name: "r", type: "float" }
  ]
});
mx_gradient_float_0.setLayout({
  name: "mx_gradient_float_0",
  type: "float",
  inputs: [
    { name: "hash", type: "uint" },
    { name: "x", type: "float" },
    { name: "y", type: "float" }
  ]
});
mx_gradient_float_1.setLayout({
  name: "mx_gradient_float_1",
  type: "float",
  inputs: [
    { name: "hash", type: "uint" },
    { name: "x", type: "float" },
    { name: "y", type: "float" },
    { name: "z", type: "float" }
  ]
});
mx_gradient_vec3_0.setLayout({
  name: "mx_gradient_vec3_0",
  type: "vec3",
  inputs: [
    { name: "hash", type: "uvec3" },
    { name: "x", type: "float" },
    { name: "y", type: "float" }
  ]
});
mx_gradient_vec3_1.setLayout({
  name: "mx_gradient_vec3_1",
  type: "vec3",
  inputs: [
    { name: "hash", type: "uvec3" },
    { name: "x", type: "float" },
    { name: "y", type: "float" },
    { name: "z", type: "float" }
  ]
});
mx_gradient_scale2d_0.setLayout({
  name: "mx_gradient_scale2d_0",
  type: "float",
  inputs: [
    { name: "v", type: "float" }
  ]
});
mx_gradient_scale3d_0.setLayout({
  name: "mx_gradient_scale3d_0",
  type: "float",
  inputs: [
    { name: "v", type: "float" }
  ]
});
mx_gradient_scale2d_1.setLayout({
  name: "mx_gradient_scale2d_1",
  type: "vec3",
  inputs: [
    { name: "v", type: "vec3" }
  ]
});
mx_gradient_scale3d_1.setLayout({
  name: "mx_gradient_scale3d_1",
  type: "vec3",
  inputs: [
    { name: "v", type: "vec3" }
  ]
});
mx_rotl32.setLayout({
  name: "mx_rotl32",
  type: "uint",
  inputs: [
    { name: "x", type: "uint" },
    { name: "k", type: "int" }
  ]
});
mx_bjfinal.setLayout({
  name: "mx_bjfinal",
  type: "uint",
  inputs: [
    { name: "a", type: "uint" },
    { name: "b", type: "uint" },
    { name: "c", type: "uint" }
  ]
});
mx_bits_to_01.setLayout({
  name: "mx_bits_to_01",
  type: "float",
  inputs: [
    { name: "bits", type: "uint" }
  ]
});
mx_fade.setLayout({
  name: "mx_fade",
  type: "float",
  inputs: [
    { name: "t", type: "float" }
  ]
});
mx_hash_int_0.setLayout({
  name: "mx_hash_int_0",
  type: "uint",
  inputs: [
    { name: "x", type: "int" }
  ]
});
mx_hash_int_1.setLayout({
  name: "mx_hash_int_1",
  type: "uint",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" }
  ]
});
mx_hash_int_2.setLayout({
  name: "mx_hash_int_2",
  type: "uint",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" }
  ]
});
mx_hash_int_3.setLayout({
  name: "mx_hash_int_3",
  type: "uint",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" },
    { name: "xx", type: "int" }
  ]
});
mx_hash_int_4.setLayout({
  name: "mx_hash_int_4",
  type: "uint",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" },
    { name: "xx", type: "int" },
    { name: "yy", type: "int" }
  ]
});
mx_hash_vec3_0.setLayout({
  name: "mx_hash_vec3_0",
  type: "uvec3",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" }
  ]
});
mx_hash_vec3_1.setLayout({
  name: "mx_hash_vec3_1",
  type: "uvec3",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" }
  ]
});
mx_perlin_noise_float_0.setLayout({
  name: "mx_perlin_noise_float_0",
  type: "float",
  inputs: [
    { name: "p", type: "vec2" }
  ]
});
mx_perlin_noise_float_1.setLayout({
  name: "mx_perlin_noise_float_1",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" }
  ]
});
mx_perlin_noise_vec3_0.setLayout({
  name: "mx_perlin_noise_vec3_0",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec2" }
  ]
});
mx_perlin_noise_vec3_1.setLayout({
  name: "mx_perlin_noise_vec3_1",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec3" }
  ]
});
mx_cell_noise_float_0.setLayout({
  name: "mx_cell_noise_float_0",
  type: "float",
  inputs: [
    { name: "p", type: "float" }
  ]
});
mx_cell_noise_float_1.setLayout({
  name: "mx_cell_noise_float_1",
  type: "float",
  inputs: [
    { name: "p", type: "vec2" }
  ]
});
mx_cell_noise_float_2.setLayout({
  name: "mx_cell_noise_float_2",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" }
  ]
});
mx_cell_noise_float_3.setLayout({
  name: "mx_cell_noise_float_3",
  type: "float",
  inputs: [
    { name: "p", type: "vec4" }
  ]
});
mx_cell_noise_vec3_0.setLayout({
  name: "mx_cell_noise_vec3_0",
  type: "vec3",
  inputs: [
    { name: "p", type: "float" }
  ]
});
mx_cell_noise_vec3_1.setLayout({
  name: "mx_cell_noise_vec3_1",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec2" }
  ]
});
mx_cell_noise_vec3_2.setLayout({
  name: "mx_cell_noise_vec3_2",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec3" }
  ]
});
mx_cell_noise_vec3_3.setLayout({
  name: "mx_cell_noise_vec3_3",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec4" }
  ]
});
mx_fractal_noise_float.setLayout({
  name: "mx_fractal_noise_float",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" }
  ]
});
mx_fractal_noise_vec3.setLayout({
  name: "mx_fractal_noise_vec3",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" }
  ]
});
mx_fractal_noise_vec2.setLayout({
  name: "mx_fractal_noise_vec2",
  type: "vec2",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" }
  ]
});
mx_fractal_noise_vec4.setLayout({
  name: "mx_fractal_noise_vec4",
  type: "vec4",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" }
  ]
});
mx_worley_distance_0.setLayout({
  name: "mx_worley_distance_0",
  type: "float",
  inputs: [
    { name: "p", type: "vec2" },
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "xoff", type: "int" },
    { name: "yoff", type: "int" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
mx_worley_distance_1.setLayout({
  name: "mx_worley_distance_1",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" },
    { name: "xoff", type: "int" },
    { name: "yoff", type: "int" },
    { name: "zoff", type: "int" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
mx_worley_noise_float_0.setLayout({
  name: "mx_worley_noise_float_0",
  type: "float",
  inputs: [
    { name: "p", type: "vec2" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
mx_worley_noise_vec2_0.setLayout({
  name: "mx_worley_noise_vec2_0",
  type: "vec2",
  inputs: [
    { name: "p", type: "vec2" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
mx_worley_noise_vec3_0.setLayout({
  name: "mx_worley_noise_vec3_0",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec2" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
mx_worley_noise_float_1.setLayout({
  name: "mx_worley_noise_float_1",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
mx_worley_noise_vec2_1.setLayout({
  name: "mx_worley_noise_vec2_1",
  type: "vec2",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
mx_worley_noise_vec3_1.setLayout({
  name: "mx_worley_noise_vec3_1",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});

// node_modules/three/examples/jsm/nodes/materialx/lib/mx_hsv.js
var mx_hsvtorgb = tslFn(([hsv_immutable]) => {
  const hsv = vec3(hsv_immutable).toVar();
  const h = float(hsv.x).toVar();
  const s = float(hsv.y).toVar();
  const v = float(hsv.z).toVar();
  If(s.lessThan(1e-4), () => {
    return vec3(v, v, v);
  }).else(() => {
    h.assign(mul(6, h.sub(floor(h))));
    const hi = int(trunc(h)).toVar();
    const f = float(h.sub(float(hi))).toVar();
    const p = float(v.mul(sub(1, s))).toVar();
    const q = float(v.mul(sub(1, s.mul(f)))).toVar();
    const t = float(v.mul(sub(1, s.mul(sub(1, f))))).toVar();
    If(hi.equal(int(0)), () => {
      return vec3(v, t, p);
    }).elseif(hi.equal(int(1)), () => {
      return vec3(q, v, p);
    }).elseif(hi.equal(int(2)), () => {
      return vec3(p, v, t);
    }).elseif(hi.equal(int(3)), () => {
      return vec3(p, q, v);
    }).elseif(hi.equal(int(4)), () => {
      return vec3(t, p, v);
    });
    return vec3(v, p, q);
  });
});
var mx_rgbtohsv = tslFn(([c_immutable]) => {
  const c = vec3(c_immutable).toVar();
  const r = float(c.x).toVar();
  const g = float(c.y).toVar();
  const b = float(c.z).toVar();
  const mincomp = float(min(r, min(g, b))).toVar();
  const maxcomp = float(max(r, max(g, b))).toVar();
  const delta = float(maxcomp.sub(mincomp)).toVar();
  const h = float().toVar(), s = float().toVar(), v = float().toVar();
  v.assign(maxcomp);
  If(maxcomp.greaterThan(0), () => {
    s.assign(delta.div(maxcomp));
  }).else(() => {
    s.assign(0);
  });
  If(s.lessThanEqual(0), () => {
    h.assign(0);
  }).else(() => {
    If(r.greaterThanEqual(maxcomp), () => {
      h.assign(g.sub(b).div(delta));
    }).elseif(g.greaterThanEqual(maxcomp), () => {
      h.assign(add(2, b.sub(r).div(delta)));
    }).else(() => {
      h.assign(add(4, r.sub(g).div(delta)));
    });
    h.mulAssign(1 / 6);
    If(h.lessThan(0), () => {
      h.addAssign(1);
    });
  });
  return vec3(h, s, v);
});
mx_hsvtorgb.setLayout({
  name: "mx_hsvtorgb",
  type: "vec3",
  inputs: [
    { name: "hsv", type: "vec3" }
  ]
});
mx_rgbtohsv.setLayout({
  name: "mx_rgbtohsv",
  type: "vec3",
  inputs: [
    { name: "c", type: "vec3" }
  ]
});

// node_modules/three/examples/jsm/nodes/materialx/lib/mx_transform_color.js
var mx_srgb_texture_to_lin_rec709 = tslFn(([color_immutable]) => {
  const color2 = vec3(color_immutable).toVar();
  const isAbove = bvec3(greaterThan(color2, vec3(0.04045))).toVar();
  const linSeg = vec3(color2.div(12.92)).toVar();
  const powSeg = vec3(pow(max(color2.add(vec3(0.055)), vec3(0)).div(1.055), vec3(2.4))).toVar();
  return mix(linSeg, powSeg, isAbove);
});
mx_srgb_texture_to_lin_rec709.setLayout({
  name: "mx_srgb_texture_to_lin_rec709",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" }
  ]
});

// node_modules/three/examples/jsm/nodes/materialx/MaterialXNodes.js
var mx_aastep = (threshold2, value) => {
  threshold2 = float(threshold2);
  value = float(value);
  const afwidth = vec2(value.dFdx(), value.dFdy()).length().mul(0.7071067811865476);
  return smoothstep(threshold2.sub(afwidth), threshold2.add(afwidth), value);
};
var _ramp = (a, b, uv2, p) => mix(a, b, uv2[p].clamp());
var mx_ramplr = (valuel, valuer, texcoord = uv()) => _ramp(valuel, valuer, texcoord, "x");
var mx_ramptb = (valuet, valueb, texcoord = uv()) => _ramp(valuet, valueb, texcoord, "y");
var _split = (a, b, center, uv2, p) => mix(a, b, mx_aastep(center, uv2[p]));
var mx_splitlr = (valuel, valuer, center, texcoord = uv()) => _split(valuel, valuer, center, texcoord, "x");
var mx_splittb = (valuet, valueb, center, texcoord = uv()) => _split(valuet, valueb, center, texcoord, "y");
var mx_transform_uv = (uv_scale = 1, uv_offset = 0, uv_geo = uv()) => uv_geo.mul(uv_scale).add(uv_offset);
var mx_safepower = (in1, in2 = 1) => {
  in1 = float(in1);
  return in1.abs().pow(in2).mul(in1.sign());
};
var mx_contrast = (input, amount = 1, pivot = 0.5) => float(input).sub(pivot).mul(amount).add(pivot);
var mx_noise_float = (texcoord = uv(), amplitude = 1, pivot = 0) => mx_perlin_noise_float(texcoord.convert("vec2|vec3")).mul(amplitude).add(pivot);
var mx_noise_vec3 = (texcoord = uv(), amplitude = 1, pivot = 0) => mx_perlin_noise_vec3(texcoord.convert("vec2|vec3")).mul(amplitude).add(pivot);
var mx_noise_vec4 = (texcoord = uv(), amplitude = 1, pivot = 0) => {
  texcoord = texcoord.convert("vec2|vec3");
  const noise_vec4 = vec4(mx_perlin_noise_vec3(texcoord), mx_perlin_noise_float(texcoord.add(vec2(19, 73))));
  return noise_vec4.mul(amplitude).add(pivot);
};
var mx_worley_noise_float2 = (texcoord = uv(), jitter = 1) => mx_worley_noise_float(texcoord.convert("vec2|vec3"), jitter, int(1));
var mx_worley_noise_vec22 = (texcoord = uv(), jitter = 1) => mx_worley_noise_vec2(texcoord.convert("vec2|vec3"), jitter, int(1));
var mx_worley_noise_vec32 = (texcoord = uv(), jitter = 1) => mx_worley_noise_vec3(texcoord.convert("vec2|vec3"), jitter, int(1));
var mx_cell_noise_float2 = (texcoord = uv()) => mx_cell_noise_float(texcoord.convert("vec2|vec3"));
var mx_fractal_noise_float2 = (position = uv(), octaves = 3, lacunarity = 2, diminish = 0.5, amplitude = 1) => mx_fractal_noise_float(position, int(octaves), lacunarity, diminish).mul(amplitude);
var mx_fractal_noise_vec22 = (position = uv(), octaves = 3, lacunarity = 2, diminish = 0.5, amplitude = 1) => mx_fractal_noise_vec2(position, int(octaves), lacunarity, diminish).mul(amplitude);
var mx_fractal_noise_vec32 = (position = uv(), octaves = 3, lacunarity = 2, diminish = 0.5, amplitude = 1) => mx_fractal_noise_vec3(position, int(octaves), lacunarity, diminish).mul(amplitude);
var mx_fractal_noise_vec42 = (position = uv(), octaves = 3, lacunarity = 2, diminish = 0.5, amplitude = 1) => mx_fractal_noise_vec4(position, int(octaves), lacunarity, diminish).mul(amplitude);
export {
  AONode_default as AONode,
  AfterImageNode_default as AfterImageNode,
  AmbientLightNode_default as AmbientLightNode,
  AnalyticLightNode_default as AnalyticLightNode,
  AnamorphicNode_default as AnamorphicNode,
  ArrayElementNode_default as ArrayElementNode,
  AssignNode_default as AssignNode,
  AttributeNode_default as AttributeNode,
  BRDF_GGX_default as BRDF_GGX,
  BRDF_Lambert_default as BRDF_Lambert,
  BatchNode_default as BatchNode,
  BlendModeNode_default as BlendModeNode,
  Break,
  BufferAttributeNode_default as BufferAttributeNode,
  BufferNode_default as BufferNode,
  BumpMapNode_default as BumpMapNode,
  BypassNode_default as BypassNode,
  CacheNode_default as CacheNode,
  CheckerNode_default as CheckerNode,
  CodeNode_default as CodeNode,
  ColorAdjustmentNode_default as ColorAdjustmentNode,
  ColorSpaceNode_default as ColorSpaceNode,
  ComputeNode_default as ComputeNode,
  CondNode_default as CondNode,
  ConstNode_default as ConstNode,
  ContextNode_default as ContextNode,
  Continue,
  ConvertNode_default as ConvertNode,
  CubeTextureNode_default as CubeTextureNode,
  DFGApprox_default as DFGApprox,
  D_GGX_default as D_GGX,
  DirectionalLightNode_default as DirectionalLightNode,
  DiscardNode_default as DiscardNode,
  EPSILON,
  EnvironmentNode_default as EnvironmentNode,
  EquirectUVNode_default as EquirectUVNode,
  ExpressionNode_default as ExpressionNode,
  F_Schlick_default as F_Schlick,
  FogExp2Node_default as FogExp2Node,
  FogNode_default as FogNode,
  FogRangeNode_default as FogRangeNode,
  FrontFacingNode_default as FrontFacingNode,
  FunctionCallNode_default as FunctionCallNode,
  FunctionNode_default as FunctionNode,
  FunctionOverloadingNode_default as FunctionOverloadingNode,
  GLSLNodeParser_default as GLSLNodeParser,
  GaussianBlurNode_default as GaussianBlurNode,
  HashNode_default as HashNode,
  HemisphereLightNode_default as HemisphereLightNode,
  IESSpotLightNode_default as IESSpotLightNode,
  INFINITY,
  If,
  IndexNode_default as IndexNode,
  InstanceNode_default as InstanceNode,
  InstancedPointsNodeMaterial_default as InstancedPointsNodeMaterial,
  IrradianceNode_default as IrradianceNode,
  JoinNode_default as JoinNode,
  LightNode_default as LightNode,
  LightingContextNode_default as LightingContextNode,
  LightingModel_default as LightingModel,
  LightingNode_default as LightingNode,
  LightsNode_default as LightsNode,
  Line2NodeMaterial_default as Line2NodeMaterial,
  LineBasicNodeMaterial_default as LineBasicNodeMaterial,
  LineDashedNodeMaterial_default as LineDashedNodeMaterial,
  LoopNode_default as LoopNode,
  MatcapUVNode_default as MatcapUVNode,
  MaterialNode_default as MaterialNode,
  MaterialReferenceNode_default as MaterialReferenceNode,
  MathNode_default as MathNode,
  MaxMipLevelNode_default as MaxMipLevelNode,
  MeshBasicNodeMaterial_default as MeshBasicNodeMaterial,
  MeshLambertNodeMaterial_default as MeshLambertNodeMaterial,
  MeshMatcapNodeMaterial_default as MeshMatcapNodeMaterial,
  MeshNormalNodeMaterial_default as MeshNormalNodeMaterial,
  MeshPhongNodeMaterial_default as MeshPhongNodeMaterial,
  MeshPhysicalNodeMaterial_default as MeshPhysicalNodeMaterial,
  MeshSSSNodeMaterial_default as MeshSSSNodeMaterial,
  MeshStandardNodeMaterial_default as MeshStandardNodeMaterial,
  MeshToonNodeMaterial_default as MeshToonNodeMaterial,
  ModelNode_default as ModelNode,
  ModelViewProjectionNode_default as ModelViewProjectionNode,
  MorphNode_default as MorphNode,
  Node_default as Node,
  NodeAttribute_default as NodeAttribute,
  NodeBuilder_default as NodeBuilder,
  NodeCache_default as NodeCache,
  NodeCode_default as NodeCode,
  NodeFrame_default as NodeFrame,
  NodeFunctionInput_default as NodeFunctionInput,
  NodeKeywords_default as NodeKeywords,
  NodeLoader_default as NodeLoader,
  NodeMaterial_default as NodeMaterial,
  NodeMaterialLoader_default as NodeMaterialLoader,
  NodeObjectLoader_default as NodeObjectLoader,
  NodeShaderStage,
  NodeType,
  NodeUniform_default as NodeUniform,
  NodeUpdateType,
  NodeUtils_exports as NodeUtils,
  NodeVar_default as NodeVar,
  NodeVarying_default as NodeVarying,
  NormalMapNode_default as NormalMapNode,
  Object3DNode_default as Object3DNode,
  OperatorNode_default as OperatorNode,
  OscNode_default as OscNode,
  OutputStructNode_default as OutputStructNode,
  PI,
  PI2,
  PMREMNode_default as PMREMNode,
  PMREMUtils_exports as PMREMUtils,
  PackingNode_default as PackingNode,
  ParameterNode_default as ParameterNode,
  PassNode_default as PassNode,
  PhongLightingModel_default as PhongLightingModel,
  PhysicalLightingModel_default as PhysicalLightingModel,
  PointLightNode_default as PointLightNode,
  PointUVNode_default as PointUVNode,
  PointsNodeMaterial_default as PointsNodeMaterial,
  PosterizeNode_default as PosterizeNode,
  PropertyNode_default as PropertyNode,
  RangeNode_default as RangeNode,
  ReferenceNode_default as ReferenceNode,
  ReflectorNode_default as ReflectorNode,
  RemapNode_default as RemapNode,
  RendererReferenceNode_default as RendererReferenceNode,
  RotateNode_default as RotateNode,
  RotateUVNode_default as RotateUVNode,
  SceneNode_default as SceneNode,
  Schlick_to_F0_default as Schlick_to_F0,
  ScriptableNode_default as ScriptableNode,
  ScriptableValueNode_default as ScriptableValueNode,
  SetNode_default as SetNode,
  ShaderNode,
  ShadowNodeMaterial_default as ShadowNodeMaterial,
  SkinningNode_default as SkinningNode,
  SplitNode_default as SplitNode,
  SpotLightNode_default as SpotLightNode,
  SpriteNodeMaterial_default as SpriteNodeMaterial,
  SpriteSheetUVNode_default as SpriteSheetUVNode,
  StackNode_default as StackNode,
  StorageArrayElementNode_default as StorageArrayElementNode,
  StorageBufferNode_default as StorageBufferNode,
  StorageTextureNode_default as StorageTextureNode,
  TBNViewMatrix,
  TempNode_default as TempNode,
  Texture3DNode_default as Texture3DNode,
  TextureBicubicNode_default as TextureBicubicNode,
  TextureNode_default as TextureNode,
  TimerNode_default as TimerNode,
  ToneMappingNode_default as ToneMappingNode,
  TriplanarTexturesNode_default as TriplanarTexturesNode,
  UniformGroupNode_default as UniformGroupNode,
  UniformNode_default as UniformNode,
  UniformsNode_default as UniformsNode,
  UserDataNode_default as UserDataNode,
  V_GGX_SmithCorrelated_default as V_GGX_SmithCorrelated,
  VarNode_default as VarNode,
  VaryingNode_default as VaryingNode,
  VertexColorNode_default as VertexColorNode,
  ViewportDepthNode_default as ViewportDepthNode,
  ViewportDepthTextureNode_default as ViewportDepthTextureNode,
  ViewportNode_default as ViewportNode,
  ViewportSharedTextureNode_default as ViewportSharedTextureNode,
  ViewportTextureNode_default as ViewportTextureNode,
  VolumeNodeMaterial_default as VolumeNodeMaterial,
  abs,
  acos,
  add,
  addLightNode,
  addNodeClass,
  addNodeElement,
  addNodeMaterial,
  afterImage,
  all,
  alphaT,
  anamorphic,
  and,
  anisotropy,
  anisotropyB,
  anisotropyT,
  any,
  append,
  arrayBuffer,
  asin,
  assign,
  atan,
  atan2,
  attribute,
  backgroundBlurriness,
  backgroundIntensity,
  batch,
  bitAnd,
  bitNot,
  bitOr,
  bitXor,
  bitangentGeometry,
  bitangentLocal,
  bitangentView,
  bitangentWorld,
  bitcast,
  bmat2,
  bmat3,
  bmat4,
  bool,
  buffer,
  bufferAttribute,
  bumpMap,
  burn,
  bvec2,
  bvec3,
  bvec4,
  bypass,
  cache,
  call,
  cameraFar,
  cameraLogDepth,
  cameraNear,
  cameraNormalMatrix,
  cameraPosition,
  cameraProjectionMatrix,
  cameraProjectionMatrixInverse,
  cameraViewMatrix,
  cameraWorldMatrix,
  cbrt,
  ceil,
  checker,
  clamp,
  clearcoat,
  clearcoatRoughness,
  code,
  color,
  colorSpaceToLinear,
  colorToDirection,
  compute,
  cond,
  context,
  convert,
  cos,
  createNodeFromType,
  createNodeMaterialFromType,
  cross,
  cubeTexture,
  dFdx,
  dFdy,
  dashSize,
  defaultBuildStages,
  defaultShaderStages,
  defined,
  degrees,
  densityFog,
  depth,
  depthPass,
  depthPixel,
  depthTexture,
  difference,
  diffuseColor,
  directionToColor,
  discard,
  distance,
  div,
  dodge,
  dot,
  dynamicBufferAttribute,
  element,
  equal,
  equals,
  equirectUV,
  exp,
  exp2,
  expression,
  faceDirection,
  faceForward,
  float,
  floor,
  fog,
  fract,
  frameGroup,
  frameId,
  frontFacing,
  fwidth,
  gain,
  gapSize,
  gaussianBlur,
  getConstNodeType,
  getCurrentStack,
  getDistanceAttenuation,
  getGeometryRoughness_default as getGeometryRoughness,
  getRoughness_default as getRoughness,
  global,
  glsl,
  glslFn,
  greaterThan,
  greaterThanEqual,
  hash,
  hue,
  imat2,
  imat3,
  imat4,
  instance,
  instanceIndex,
  instancedBufferAttribute,
  instancedDynamicBufferAttribute,
  int,
  inverseSqrt,
  iridescence,
  iridescenceIOR,
  iridescenceThickness,
  ivec2,
  ivec3,
  ivec4,
  js,
  label,
  length,
  lengthSq,
  lessThan,
  lessThanEqual,
  lightTargetDirection,
  lightingContext,
  lights,
  lightsNode,
  linearToColorSpace,
  linearTosRGB,
  log,
  log2,
  loop,
  lumaCoeffs,
  luminance,
  mat2,
  mat3,
  mat4,
  matcapUV,
  materialAlphaTest,
  materialAnisotropy,
  materialAnisotropyVector,
  materialClearcoat,
  materialClearcoatNormal,
  materialClearcoatRoughness,
  materialColor,
  materialDispersion,
  materialEmissive,
  materialIridescence,
  materialIridescenceIOR,
  materialIridescenceThickness,
  materialLineDashOffset,
  materialLineDashSize,
  materialLineGapSize,
  materialLineScale,
  materialLineWidth,
  materialMetalness,
  materialNormal,
  materialOpacity,
  materialPointWidth,
  materialReference,
  materialReflectivity,
  materialRotation,
  materialRoughness,
  materialSheen,
  materialSheenRoughness,
  materialShininess,
  materialSpecular,
  materialSpecularStrength,
  max,
  maxMipLevel,
  metalness,
  min,
  mix,
  mod,
  modelDirection,
  modelNormalMatrix,
  modelPosition,
  modelScale,
  modelViewMatrix,
  modelViewPosition,
  modelViewProjection,
  modelWorldMatrix,
  modelWorldMatrixInverse,
  morphReference,
  mul,
  mx_aastep,
  mx_cell_noise_float2 as mx_cell_noise_float,
  mx_contrast,
  mx_fractal_noise_float2 as mx_fractal_noise_float,
  mx_fractal_noise_vec22 as mx_fractal_noise_vec2,
  mx_fractal_noise_vec32 as mx_fractal_noise_vec3,
  mx_fractal_noise_vec42 as mx_fractal_noise_vec4,
  mx_hsvtorgb,
  mx_noise_float,
  mx_noise_vec3,
  mx_noise_vec4,
  mx_ramplr,
  mx_ramptb,
  mx_rgbtohsv,
  mx_safepower,
  mx_splitlr,
  mx_splittb,
  mx_srgb_texture_to_lin_rec709,
  mx_transform_uv,
  mx_worley_noise_float2 as mx_worley_noise_float,
  mx_worley_noise_vec22 as mx_worley_noise_vec2,
  mx_worley_noise_vec32 as mx_worley_noise_vec3,
  negate,
  nodeArray,
  nodeImmutable,
  nodeObject,
  nodeObjects,
  nodeProxy,
  normalGeometry,
  normalLocal,
  normalMap,
  normalView,
  normalWorld,
  normalize,
  not,
  objectDirection,
  objectGroup,
  objectNormalMatrix,
  objectPosition,
  objectScale,
  objectViewMatrix,
  objectViewPosition,
  objectWorldMatrix,
  oneMinus,
  or,
  orthographicDepthToViewZ,
  oscSawtooth,
  oscSine,
  oscSquare,
  oscTriangle,
  output,
  outputStruct,
  overlay,
  overloadingFn,
  parabola,
  parallaxDirection,
  parallaxUV,
  parameter,
  pass,
  pcurve,
  perspectiveDepthToViewZ,
  pmremTexture,
  pointUV,
  pointWidth,
  positionGeometry,
  positionLocal,
  positionView,
  positionViewDirection,
  positionWorld,
  positionWorldDirection,
  posterize,
  pow,
  pow2,
  pow3,
  pow4,
  property,
  radians,
  range,
  rangeFog,
  reciprocal,
  reference,
  referenceBuffer,
  reflect,
  reflectVector,
  reflectView,
  reflector,
  refract,
  remainder,
  remap,
  remapClamp,
  renderGroup,
  rendererReference,
  rotate,
  rotateUV,
  roughness,
  round,
  sRGBToLinear,
  sampler,
  saturate,
  saturation,
  screen,
  scriptable,
  scriptableValue,
  setCurrentStack,
  shaderStages,
  sheen,
  sheenRoughness,
  shiftLeft,
  shiftRight,
  shininess,
  sign,
  sin,
  sinc,
  skinning,
  smoothstep,
  specularColor,
  split,
  spritesheetUV,
  sqrt,
  stack,
  step,
  storage,
  storageObject,
  storageTexture,
  storageTextureReadOnly,
  storageTextureReadWrite,
  string,
  sub,
  tan,
  tangentGeometry,
  tangentLocal,
  tangentView,
  tangentWorld,
  temp,
  texture,
  texture3D,
  textureBicubic,
  textureLoad,
  texturePass,
  textureStore,
  threshold,
  timerDelta,
  timerGlobal,
  timerLocal,
  toneMapping,
  transformDirection,
  transformedBentNormalView,
  transformedBitangentView,
  transformedBitangentWorld,
  transformedClearcoatNormalView,
  transformedNormalView,
  transformedNormalWorld,
  transformedTangentView,
  transformedTangentWorld,
  triNoise3D,
  triplanarTexture,
  triplanarTextures,
  trunc,
  tslFn,
  uint,
  umat2,
  umat3,
  umat4,
  uniform,
  uniformGroup,
  uniforms,
  userData,
  uv,
  uvec2,
  uvec3,
  uvec4,
  varying,
  varyingProperty,
  vec2,
  vec3,
  vec4,
  vectorComponents,
  vertexColor,
  vertexIndex,
  vibrance,
  viewZToOrthographicDepth,
  viewZToPerspectiveDepth,
  viewport,
  viewportBottomLeft,
  viewportBottomRight,
  viewportCoordinate,
  viewportDepthTexture,
  viewportMipTexture,
  viewportResolution,
  viewportSharedTexture,
  viewportTexture,
  viewportTopLeft,
  viewportTopRight,
  wgsl,
  wgslFn,
  xor
};
//# sourceMappingURL=three_examples_jsm_nodes_Nodes__js.js.map
