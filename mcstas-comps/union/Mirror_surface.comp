/*******************************************************************************
*
*  McStas, neutron ray-tracing package
*  Copyright(C) 2007 Risoe National Laboratory.
*
* %I
* Written by: Mads Bertelsen
* Date: 20.08.15
* Version: $Revision: 0.1 $
* Origin: University of Copenhagen
*
* A Mirror surface process
*
* %D
*
* This is a Union surface process that describes a supermirror or other surface
*  that only have specular reflection. The reflectivity can be given as a file
*  or using the standard reflectivity inputs. To use this in a simulation an
*  instance of this component should be defined in the instrument file, then
*  attatched to one or more geometries in their surface stacks pertaining to
*  each face of the geometry.
*  
* Part of the Union components, a set of components that work together and thus
*  sperates geometry and physics within McStas.
* The use of this component requires other components to be used.
*
* 1) One specifies a number of processes using process components like this one
* 2) These are gathered into material definitions using Union_make_material
* 3) Geometries are placed using Union_box / Union_cylinder, assigned a material
* 4) A Union_master component placed after all of the above
*
* Only in step 4 will any simulation happen, and per default all geometries
*  defined before the master, but after the previous will be simulated here.
*
* There is a dedicated manual available for the Union_components
*
*
* Algorithm:
* Described elsewhere
*
* %P
* INPUT PARAMETERS:
* R0:                 [1]      Low-angle reflectivity
* Qc:                 [AA-1]   Critical scattering vector
* alpha:              [AA]     Slope of reflectivity
* m:                  [1]      m-value of material. Zero means completely absorbing.
* W:                  [AA-1]   Width of supermirror cut-off
* reflect:            [str]    Name of reflectivity file. Format q(Angs-1) R(0-1)
* init:               [string] Name of Union_init component (typically "init", default)
*
* %L
*
* %E
******************************************************************************/

DEFINE COMPONENT Mirror_surface // Remember to change the name of process here

SETTING PARAMETERS(string reflect=0, R0=0.99, Qc=0.0219, alpha=6.07, m=2, W=0.003, string init="init")


SHARE
%{
#ifndef Union
#error "The Union_init component must be included before this Mirror_surface component"
#endif
	
	
%include "read_table-lib"
%include "ref-lib"

// Very important to add a pointer to this struct in the union-lib.c file
struct Mirror_surface_storage_struct{
    // Variables that needs to be transfered between any of the following places:
    // The initialize in this component
    // The function for calculating my
    // The function for calculating scattering
    
    // Avoid duplicates of setting parameters in naming
	double par[5];
	t_Table pTable;
	int table_present;	
};

// Function for handling surface physics
// The input for this function and its order may not be changed, but the names may be updated.
int Mirror_surface_function(union surface_data_transfer_union data_transfer, // data in struct defined above, can have data stored in initialize and other calls to this function
                              double *weight, double *wavevector, int *continues, // given weight and wavevector, to be updated, and pointer to continues which should be provided by function
							  double *normal_vector, enum in_or_out inward_or_outward, // normal_vector of surface and information on whether the neutron is going into or out of this surface
							  _class_particle *_particle) {

    // wavevector and normal_vector are a pointers to a simple array with 3 doubles, wavevector[0], wavevector[1], wavevector[2] which describes the vector

	// Retrieve data storage struct
	struct Mirror_surface_storage_struct *storage;
	storage = data_transfer.pointer_to_a_Mirror_surface_storage_struct;

	double k_n_dot = wavevector[0]*normal_vector[0] + wavevector[1]*normal_vector[1] + wavevector[2]*normal_vector[2];

	// Calculate q normal
	double q_normal = 2.0*fabs(k_n_dot);

	// Calculate or read reflectivity
	double reflectivity;
	if (storage->table_present == 1) {
	    TableReflecFunc(q_normal, &storage->pTable, &reflectivity);
	} else {
	    StdReflecFunc(q_normal, storage->par, &reflectivity);
	}

	// Take monte carlo choice on whether to be reflected by the mirror or not
	if (rand01() > reflectivity) {
		*continues = 1; // Tells algorithm the ray goes through this surface
	} else {
		// mirror ray
		wavevector[0] = wavevector[0] - 2.0 * k_n_dot * normal_vector[0];
		wavevector[1] = wavevector[1] - 2.0 * k_n_dot * normal_vector[1];
		wavevector[2] = wavevector[2] - 2.0 * k_n_dot * normal_vector[2];				
		
		*continues = 0; // Tells algorithm the ray does not go through this surface
	}

    return 1;
	
    // There is access to the data_transfer from within this function:
    // int table_present = data_transfer.pointer_to_a_Mirror_physics_storage_struct->table_present;
	// Its even possible to write to this data structure and use results for a later ray if relevant
};

// These lines help with future error correction, and tell other Union components
//  that at least one surface have been defined.
#ifndef SURFACE_DETECTOR
    #define SURFACE_DETECTOR dummy
#endif
#ifndef SURFACE_PROCESS_MIRROR_DETECTOR
    #define SURFACE_PROCESS_MIRROR_DETECTOR dummy
#endif
%}

DECLARE
%{
// Declare for this component, to do calculations on the input / store in the transported data
struct Mirror_surface_storage_struct Mirror_storage; // Replace Mirror with your own name here

// Needed for transport to the main component, will be the same for all surface processes
struct global_surface_element_struct global_surface_element;
struct surface_process_struct This_surface;
%}

INITIALIZE
%{
  // Initialize done in the component
  if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
	    if (Table_Read(&Mirror_storage.pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
	      exit(fprintf(stderr,"Mirror_surface: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
	    Mirror_storage.table_present=1;
  } else {
	    Mirror_storage.table_present=0;
	    if (W < 0 || R0 < 0 || Qc < 0 || m < 0) { 
			fprintf(stderr,"Mirror_surface: %s: W R0 Qc must be >0.\n", NAME_CURRENT_COMP);
	        exit(-1); 
	    }
  }
  
  // Insert input parameter to par array as required for the standard reflectivity function
  Mirror_storage.par[0] = R0;
  Mirror_storage.par[1] = Qc;
  Mirror_storage.par[2] = alpha;
  Mirror_storage.par[3] = m;
  Mirror_storage.par[4] = W;  

  // Will need to do similar system for surfaces
  // Need to specify if this process is isotropic
  //This_process.non_isotropic_rot_index = -1; // Yes (powder)
  //This_process.non_isotropic_rot_index =  1;  // No (single crystal)
  //rot_copy(This_surface.rotation_matrix, ROT_A_CURRENT_COMP);

  // The type of the process must be saved in the global enum process located in union-lib.c
  This_surface.eSurface = Mirror;

  // Packing the data into a structure that is transported to the main component
  This_surface.data_transfer.pointer_to_a_Mirror_surface_storage_struct = &Mirror_storage;

  // This will be the same for all process's, and can thus be moved to an include.
  sprintf(This_surface.name,"%s",NAME_CURRENT_COMP);
  sprintf(global_surface_element.name,"%s",NAME_CURRENT_COMP);
  global_surface_element.component_index = INDEX_CURRENT_COMP;
  global_surface_element.p_surface_process = &This_surface;

  if (_getcomp_index(init) < 0) {
    fprintf(stderr,"Mirror_surface:%s: Error identifying Union_init component, %s is not a known component name.\n",
    NAME_CURRENT_COMP, init);
    exit(-1);
  }

   struct pointer_to_global_surface_list *global_surface_list = COMP_GETPAR3(Union_init, init, global_surface_list);
  add_element_to_surface_list(global_surface_list, global_surface_element);
 %}

TRACE
%{
    // Trace should be empty, the simulation is perfomed in Union_master
%}

END

