/*****************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright 1997-2006, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Component: Set_pol
*
* %I
* Written by: Peter Christiansen
* Date: August 2006
* Origin: Risoe
*
* (Unphysical) way of setting the polarization.
*
* %D
*
* This component has no physical size (like Arm - also drawn that
* way), but is used to set the polarisation in one of two ways:
* 1) (randomOn=0) Hardcode the polarisation to the vector (px, py, pz)
* 2) (randomOn!=0) Set the polarisation to a random vector on the unit sphere
*
* Example: Set_pol(px=0, py=-1, pz=0)
*
* %P
* INPUT PARAMETERS:
*
* px: [1]        X-component of polarisation vector (can be negative) 
* py: [1]        Y-component of polarisation vector (can be negative) 
* pz: [1]        Z-component of polarisation vector (can be negative) 
* randomOn: [1]  Generate random values if randomOn!=0. 
*
* OUTPUT PARAMETERS:
*
* %E
*******************************************************************************/

DEFINE COMPONENT Set_pol
DEFINITION PARAMETERS ()
SETTING PARAMETERS (px=0, py=0, pz=0, randomOn=0)
/* Neutron parameters: (x,y,z,vx,vy,vz,t,sx,sy,sz,p) */

DECLARE
%{

%}

INITIALIZE
%{
if (px==1 && py==1 && pz==1)
  {
    printf("Set_pol: %s: NULL vector defined!\n"
	   "ERROR      (px, py, pz). Exiting",
           NAME_CURRENT_COMP);
    exit(1);
  }

  if ((px*px + py*py + pz*pz) > 1)
  {
    printf("Set_pol: %s: Polarisation vector (px, py, pz) is unphysical!\n"
	   "ERROR  px*px + py*py + pz*pz > 1. Exiting....",
           NAME_CURRENT_COMP);
    exit(1);
  }

  if(randomOn!=0)
    printf("Set_pol: %s: Setting polarisation randomly.\n",
           NAME_CURRENT_COMP);
  else
    printf("Set_pol: %s: Setting polarisation to (%f, %f, %f)\n",
           NAME_CURRENT_COMP, px, py, pz);
%}

TRACE
%{
  double theta, phi;

  if(randomOn!=0)
  {
    theta = 2*PI*rand01(); // 0-2*PI
    phi   = acos(2*rand01()-1); // 0-PI

    sx = sin(phi)*cos(theta);
    sy = sin(phi)*sin(theta);
    sz = cos(phi);
  }
  else
  {
    sx = px;
    sy = py;
    sz = pz;
  }

  SCATTER;
%}

MCDISPLAY
%{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
%}

END
