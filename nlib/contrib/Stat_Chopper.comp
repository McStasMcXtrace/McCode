/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright (C) 1997-2009, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Component: Stat_Chopper
*
* %Identification
*
* Written by: C. Monzat/E. Farhi/S. Rozenkranz
* Date: 2009
* Version: $Revision 1.0$
* Origin: ILL
* Release: McStas 2.0
*
* Statistical (correlation) Chopper
*
* %Description
* This component is a statistical chopper based on a pseudo random sequence that the user
* can specify. Inspired on DiskChopper, it must be used with Chopper_Monitor component.
* 
*
* %Parameters
* INPUT PARAMETERS:
* sequence :           string containing 0 and 1
* omega    : (rad/s)   Angular speed of the chopper 
* phase    : (degrees) Phase of the chopper 
* abs_out  : (0/1)     Absorb neutrons hitting outside of chopper radius
* R        : (m)       Radius of the disc
* t_0      : (s)       Time 'delay'.
* phi_0    : (deg)     Angular 'delay' (suppresses t_0)
* h        : (m)       Slit height (if = 0, equal to R). Auto centering of beam at h/2.
* OUTPUT PARAMETERS:
* VarsC    :           Structure containing variables describing the chopper 
* delta_y  : (m)       Used to change coordinate
* height   : (m)       Slit height
* Tg       : (s)       Time from opening of slit to next opening of slit
* (sequence,number of slits, number of possible slits,angular speed and phase)
* %End
*******************************************************************************/

DEFINE COMPONENT Stat_Chopper
DEFINITION PARAMETERS ()
SETTING PARAMETERS (string sequence="100000010101001101110010010011110111111001011000011101001010111100101011111011010011011111000100011011100010000010001101101010100001110111001011111011001110001100011011011110101010000000110000011110011010100101011100000001001101000111100010110110001100100",
omega,abs_out=1,R,h=0,t_0=0,phi_0=0)
OUTPUT PARAMETERS (VarsC,delta_y,height,Tg)
STATE PARAMETERS (x,y,z,vx,vy,vz,t,sx,sy,sz,p)
DECLARE
%{

struct ChopVars
    {
	int Nseq;      /*Number of possible slits on the chopper*/
	int m;         /*Number of slits on the chopper */
	int * ChopSeq; /*Array containing 0 and 1,0 means closed, 1 opened*/
	double ww;      /*Angular speed of the chopper*/
	double phi;    /*Initial phase of the chopper*/
	
    }VarsC;
double transmission,Tg,delta_y,height;
%}



INITIALIZE
%{
int i;

VarsC.Nseq=strlen(sequence);
VarsC.m=0;
//printf("Nseq : %i\n",Vars.Nseq);
VarsC.ChopSeq = malloc(VarsC.Nseq * sizeof(int));

if (VarsC.ChopSeq==NULL){
	fprintf(stderr,"Memory not allocated : VarsC.Chopseq", NAME_CURRENT_COMP);
	exit(-1);
}

for (i=0;i<VarsC.Nseq;i++){
	VarsC.ChopSeq[i]=(int)sequence[i]-48;
	//printf("ChopSeq[%i] : %i\n",i,ChopSeq[i]);
	if (VarsC.ChopSeq[i]) {
		VarsC.m++;
	}
}

VarsC.ww=omega;

/*angle of the chopper between his original position and his actual position, in radians*/


/* If slit height 'unset', assume full opening */
if (h == 0) {
	height=R;
} else {
	height=h;
}

delta_y = R-height/2;

if (VarsC.Nseq<=0 || R <0){
	fprintf(stderr,"Stat_Chopper: %s: n and R must be > 0\n", NAME_CURRENT_COMP);
	exit(-1);
}

if (h && h>R && R!=0){
	fprintf(stderr,"Stat_Chopper: %s: h must be < R\n", NAME_CURRENT_COMP);
	exit(-1);
}

if (!omega){
	fprintf(stderr,"Stat_Chopper: %s WARNING: chopper frequency is 0!\n", NAME_CURRENT_COMP);
	omega = 1e-15; /* We should actually use machine epsilon here... */
}

if (!(abs_out==1)) {
	fprintf(stderr,"Stat_Chopper: %s WARNING: chopper will NOT absorb neutrons outside radius R\n", NAME_CURRENT_COMP);
	abs_out=0;
}

/* Calulate t_0 from phi_0 and vice versa, 'direction' moderated by sign of omega */
t_0 *=omega/fabs(omega);
if (phi_0) {
	if (t_0) {
		fprintf(stderr,"Stat_Chopper: %s WARNING: t_0 AND phi_0 specified. Using phi_0 setting\n", NAME_CURRENT_COMP);  
	}
	phi_0*=DEG2RAD;
	/* 'Delay' should always be a delay, taking rotation direction into account: */
	t_0=omega*phi_0/(omega*omega);
	VarsC.phi=phi_0;
} else {
	phi_0=t_0*omega;
	VarsC.phi=phi_0;
}
// printf("t_0 : %e \n",t_0);
// printf("phi rad : %e \n",VarsC.phi);
// printf("phi deg : %e \n",RAD2DEG*VarsC.phi);

/* Time from opening of slit to next opening of slit */
Tg=2*PI/fabs(omega)/VarsC.Nseq;


%}



TRACE
%{

double toff,angle,yprime;
int i,seq;

angle = VarsC.ww*t+VarsC.phi;
seq=(int) floor(angle*VarsC.Nseq/(2*PI)) % VarsC.Nseq;
if ( seq < 0 ) seq += VarsC.Nseq;

yprime = y+delta_y;

/*Case of a finite radius*/
if (R!=0){

/* Is neutron outside the vertical slit range and should we absorb? */
if ((x*x+yprime*yprime)>R*R && abs_out==1) {
	ABSORB;
}
/* Does neutron hit inner solid part of chopper in case of h!=R? */
if ((x*x+yprime*yprime)<(R-height)*(R-height)) {
	ABSORB;
}


toff=fabs(t-atan2(x,yprime)/VarsC.ww - t_0);


}


if (VarsC.ChopSeq[seq]){
	SCATTER;
}
else
{
	ABSORB;
}


%}



FINALLY
%{
free(VarsC.ChopSeq);
transmission = (double) VarsC.m/ (double)VarsC.Nseq;
printf("Statistical Chopper ## Transmission : %f\n",transmission);
%}


MCDISPLAY
%{
magnify("xy");
if (R==0){
	circle("xy", 0.0, -0.05, 0.0, 0.05);
}else{
	circle("xy", 0.0, (double)-R, 0.0, (double)R);
}

%}

END
