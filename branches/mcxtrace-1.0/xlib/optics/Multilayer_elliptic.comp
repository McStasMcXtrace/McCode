/*******************************************************************************
*
* McXtrace, X-ray tracing package
*         Copyright, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*         University of Copenhagen, Copenhagen, Denmark
*
* Component: Multilayer_elliptic
*
* %I
*
* Written by: Jana Baltser, Peter Willendrup, Anette Vickery, Andrea Prodi, Erik Knudsen
* Date: February 2011
* Version: 1.0
* Release: McXtrace 0.1
* Origin: NBI
*
* Elliptic multilayer mirror
* 
* %D
* Reads reflectivity values from a data input file (Ref.dat) for a Si/W multilayer.
* The multilayer code reflects ray in an ideal geometry, does not include surface imperfections
*
* The mirror is positioned such that the long axis of the mirror elliptical surface coincides with
* z-axis
* 
* The algorithm:
*  Incoming photon's coordinates and direction (k-vector) are transformed into an elliptical reference frame 
* (elliptical parameters are calculated according to the mirror's position and its focusing distances and the  * incident angle), the intersection point is then defined. A new, reflected photon is then starting at the  
* point of intersection.
* 
*
* %P
* Input parameters:
* theta [degrees] - incident angle
* s1 [m] - distance from the source to the multilayer
* s2 [m] - focusing distance of the multilayer
* length [m] - length of the mirrors
* width [m] - width of the mirror along x-axis
* R - reflectivity
*
* (none)
*
* %E
*******************************************************************************/

DEFINE COMPONENT Multilayer_elliptic
DEFINITION PARAMETERS (string reflectivity_datafile="reflectivity.txt")
SETTING PARAMETERS (theta=1.2,s1,s2,length=0.5,width=0.2,R0=1)
OUTPUT PARAMETERS (prms_m, a,b,c,M,Z0,Y0,xi,cost0)
/* X-ray parameters: (x,y,z,kx,ky,kz,phi,t,Ex,Ey,Ez,p) */ 

SHARE 
%{
   %include "read_table-lib"
   struct prms_multilayer_elliptic{
     double *Q;
     double **R; //reflectivity
     double Emin,Emax,Estep;
   };
  
  /*something that would be relevant for ALL elliptical mirrors*/
  /* coordinate transformation McXtrace-Ellipse (ME) and Ellipse-McXtrace(EM) functions */
  void CoordTransME(double *x_el, double *y_el, double *z_el, 
		    double x0, double y0, double z0, double Zmir, double Ymir, double xi_mir)
  {
   *x_el=x0;
   *y_el=cos(xi_mir)*y0+sin(xi_mir)*z0+Ymir;
   *z_el=-sin(xi_mir)*y0+cos(xi_mir)*z0+Zmir;
  }
  
  void CoordTransEM(double *x_gen, double *y_gen,double *z_gen,
		    double x0, double y0, double z0, double Zmir, double Ymir,double xi_mir)
  {
   *x_gen=x0;
   *y_gen=cos(xi_mir)*(y0-Ymir)-sin(xi_mir)*(z0-Zmir);
   *z_gen=sin(xi_mir)*(y0-Ymir)+cos(xi_mir)*(z0-Zmir);
  }
  
%}

DECLARE
%{
  double a,b,c,M,Z0,Y0,xi,cost0;
  struct prms_multilayer_elliptic *prms_m;
    
%}

INITIALIZE
%{
  /* calculation of the elliptical parameters according to the input mirror parameters:
  ellipse major axis a/2, minor axis b/2, M-magnification factor, Z0&Y0 - position of the mirror centre in the elliptical coordinate system.*/
  double Theta=DEG2RAD*theta;
  
  M=s2/s1;
  cost0 = (1-M)/sqrt(1-2*M + M*M + 4*M*(cos(Theta)*cos(Theta)));
  a = (s1*sqrt(1-cost0*cost0+cos(Theta)*cos(Theta)*cost0*cost0))/(cost0*cos(Theta)+sqrt(1-cost0*cost0+ (cos(Theta)*cos(Theta))*cost0*cost0));
  c = a*cos(Theta)/sqrt(1-cost0*cost0+(cos(Theta)*cos(Theta))*cost0*cost0);
  b = sqrt(a*a-c*c);
  Z0 = a*cost0;
  Y0 = b*sin(acos(cost0)); 
  xi = -atan((Z0*b*b)/(Y0*a*a)); 
 
 // reflectivity datafile parsing
  int status=0;
  t_Table T;
  if ( (status=Table_Read(&T,reflectivity_datafile,0))==-1){
    fprintf(stderr,"Error: Could not parse file \"%s\" in COMP %s\n",reflectivity_datafile,NAME_CURRENT_COMP);
    exit(-1);
  }
  prms_m=malloc(sizeof(struct prms_multilayer_elliptic));
  (prms_m->R)=malloc(sizeof(double *)*(T.rows));
  (prms_m->Q)=malloc(sizeof(double)*(T.rows));
    int i,j;
  for (i=0;i<T.rows;i++){
    prms_m->R[i]=malloc(sizeof(double)*(T.columns-1));
  }
  for(i=0;i<T.rows;i++){
    prms_m->Q[i]=T.data[i*T.columns];
    for(j=0;j<T.columns-1;j++){
      prms_m->R[i][j]=T.data[i*T.columns+j+1];
    }
  }
  /*now parse the header to find boundaries*/
  char **header_parsed;
  header_parsed=Table_ParseHeader(T.header,"E","Lambda",NULL);
  if (header_parsed[0] || header_parsed[1]){
    char *p;
    if (header_parsed[0]) p=strchr(header_parsed[0],'[');
    else if (header_parsed[1]) p=strchr(header_parsed[1],'[');
  
    prms_m->Emin=strtod(p+1,NULL);
    p=strchr(p,':');
    prms_m->Estep=strtod(p+1,NULL);
    p=strchr(p+1,':');
    prms_m->Emax=strtod(p+1,NULL);
    
    if (header_parsed[1]){
      /*reflectivity is a fucntion of wavelength*/
      prms_m->Emin=K2E*2*M_PI/prms_m->Emin;
      prms_m->Estep=K2E*2*M_PI/prms_m->Estep;
      prms_m->Emax=K2E*2*M_PI/prms_m->Emax;
    }
    /*check values*/
    if (prms_m->Estep>fabs(prms_m->Emax-prms_m->Emin) || prms_m->Estep<0){
      fprintf(stderr,"Error: Multilayer_elliptic(%s): Nonsensical energy interval read from file %s\n",NAME_CURRENT_COMP,reflectivity_datafile);
      exit(-1);
    }
    if (prms_m->Emin>prms_m->Emax){
      double tmp=prms_m->Emin;
      prms_m->Emin=prms_m->Emax;prms_m->Emax=tmp;
    }
  }
  
  Table_Free(&T);
%}

TRACE
%{
  double K,vink; 
  double x_el,y_el,z_el;	// beginning coordinates transformed into the ellipse system
  double kx_el,ky_el,kz_el;	// kvector transformed into the ellipse system, hence 
  
  double A,B,C,D,t0,t1,t;
  double x_int,y_int,z_int,dist;	// intersection with the elliptical surface
  double nx,ny,nz;
  double kxn,kyn,kzn;		// reflected ray's kvector
  
  
  /* get the photon's coordinates and kvector in the ellipse frame */
  K=sqrt(kx*kx+ky*ky+kz*kz);
  
  
  CoordTransME(&x_el,&y_el,&z_el,x,y,z,Z0,Y0,xi);
  CoordTransME(&kx_el,&ky_el,&kz_el,kx,ky,kz,0,0,xi);
    
  NORM(kx_el,ky_el,kz_el);
  
  /*intersection calculation*/
  A=b*b*kz_el*kz_el+a*a*ky_el*ky_el;
  B=2.0*(z_el*kz_el*b*b+y_el*ky_el*a*a);
  C=b*b*z_el*z_el+a*a*y_el*y_el-a*a*b*b;
  D=B*B-4*A*C;
  if (D>=0){
    t0=(-B+sqrt(D))/(2*A);
    t1=(-B-sqrt(D))/(2*A);
    if (t0>=0) { 
	t=t0;
    } else if (t1>=0){
	t=t1;
    }
    /* check whether our intersection lies within the boundaries of the mirror*/
    x_int=x_el+kx_el*t;
    y_int=y_el+ky_el*t;
    z_int=z_el+kz_el*t;
    
    if (y_int>=0 && fabs(x_int)<=width/2){
	dist=sqrt((x_el-x_int)*(x_el-x_int)+(y_el-y_int)*(y_el-y_int)+(z_el-z_int)*(z_el-z_int));
	PROP_DL(dist); 
	
	if (fabs(z)<=length/2) { /*finally in business on the mirror! YAY! */
	  nx=0;
	  if (fabs(z_int)==0){
	      ny=1;
	      nz=0;
	  } else {
            ny=(a*a*y_int)/(b*b*z_int);
            nz=1.0;
	  }
	  NORM(nx,ny,nz);
	  vink=scalar_prod(nx,ny,nz,kx_el,ky_el,kz_el); 
	  kxn=kx_el-2.0*vink*nx;
	  kyn=ky_el-2.0*vink*ny;
	  kzn=kz_el-2.0*vink*nz;
	  NORM(kxn,kyn,kzn); 
	  
	  double kxo,kyo,kzo;
	  kxo=kx;kyo=ky,kzo=kz;
	  CoordTransEM(&kx,&ky,&kz,kxn,kyn,kzn,0,0,xi);
	 	  
	  kx=K*kx;
	  ky=K*ky;
	  kz=K*kz;
	  	  
	  double Q;
	  Q=sqrt((kx-kxo)*(kx-kxo)+(ky-kyo)*(ky-kyo)+(kz-kzo)*(kz-kzo)); 
	  double E;
	  E=K*K2E; 
	  //interpolate in table
	  int c=0;
	  while (E>(prms_m->Emin+c*prms_m->Estep)) c++;
           
          int r=0;
          while (r<=6000){
            if(Q<(prms_m->Q[r])) break;
            r++;
          } 
          
          double Ref;
          /*check for table index overrruns*/
          if (c<1)c=1;
          else if (c>60) c=60;
          if (r<1)r=1;
          else if (r>6000) r=6000;
          //for now just take the mean, should really interpolate
          
          Ref=(prms_m->R[r-1][c-1] + prms_m->R[r-1][c] + prms_m->R[r][c-1] + prms_m->R[r][c])/4; 
	  
	  // apply reflectivity
	  p*=Ref; 
	  SCATTER;
	  
	} else {
	  RESTORE_XRAY(INDEX_CURRENT_COMP, x, y, z, kx, ky, kz, phi, t, Ex, Ey, Ez, p);
	} 
    }
  }
  
%}

MCDISPLAY
%{
  /*magnify("");
  rectangle("xz",0,0,0,width,length); */
  int i,j,N=10;
  double x0,y0,z0;
  double x1,y1,z1,z_el,y_el;
  
  x0=-width/2.0;
    
  for (i=0;i<=N;i++){
    z0=-length/2.0; 
    z_el=cos(xi)*z0+Z0; //transformation to EL reference frame
    y_el=b*sqrt(1.0-((z_el*z_el)/(a*a)));
    y0=cos(xi)*(y_el-Y0)-sin(xi)*(z_el-Z0);
    line(-width/2,y0,z0,width/2,y0,z0);
    for (j=0;j<=N;j++){
      z1=z0+length/N;
      z_el=cos(xi)*z0+Z0;
      y_el=b*sqrt(1.0-((z_el*z_el)/(a*a))); 
      y1=cos(xi)*(y_el-Y0)-sin(xi)*(z_el-Z0); 
      line(x0,y0,z0,x0,y1,z1);
      y0=y1;
      z0=z1;
      line(-width/2,y1,z1,width/2,y1,z1);
    }
    x0=x0+width/N;
  }   
 
%}

END
