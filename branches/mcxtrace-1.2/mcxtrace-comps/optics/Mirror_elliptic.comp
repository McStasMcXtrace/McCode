/*******************************************************************************
*
* McXtrace, xray-tracing package
*         Copyright, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Component: Mirror_elliptic
*
* %I
* Written by: Erik Knudsen
* Date: Feb 11, 2010
* Version: $Revision$
* Origin: Risoe
* Release: McXtrace 1.0
*
* Idealized elliptic mirror.
* 
* %D 
* Takes a reflectivity (default=1) as input and reflects rays in a ideal geometry
* elliptic mirror.
* The mirror is positioned such that the long axis of the mirror ellipsoid is on the
* z-axis
*
* %P
* INPUT PARAMETERS
*
* R: [1] reflectivity of mirror.
* a: [m] long half axis (along z).
* b: [m] 1st short half axis (along x)
* c: [m] 2nd short half axis (along y)
* 
* %E
*******************************************************************************/


  DEFINE COMPONENT Mirror_elliptic
DEFINITION PARAMETERS ()
  SETTING PARAMETERS (R=1, a=0, b=0, c=1, xwidth=1,yheight=1,zdepth=1)
OUTPUT PARAMETERS ()
/* X-ray parameters: (x,y,z,kx,ky,kz,phi,t,Ex,Ey,Ez,p) */ 

DECLARE
%{
  double a2,b2,c2;
  double Ox,Oy,Oz;
%}

INITIALIZE
%{
  /*check for 0 a or b*/
  Ox=0;Oy=0;Oz=0;
  if(!c){

  }
  if(a && !b){
    b=a;
  }else if(!a && b){
    a=b;
  }
  a2=a*a;
  b2=b*b;
  c2=c*c;
%}

TRACE
%{
  double A,B,C,k;
  double t0,t1,l0,l1;
  k=sqrt(kx*kx+ky*ky+kz*kz);
  C=x*x/a2 + y*y/b2 + z*z/c2 -1;
  B=2*(kx*x/a2 + ky*y/b2 + kz*z/c2);
  A=kx*kx/a2 + ky*ky/b2 + kz*kz/c2;
  if(solve_2nd_order(&t0,&t1,A,B,C)){
     l0=t0*k;
     l1=t1*k;
     if (l1>0) {
       fprintf(stderr,"warning: x-ray hits mirror %s on back surface\n",NAME_CURRENT_COMP);
     }
     PROP_DL(l0);
     if (x>-xwidth/2.0 && x<xwidth/2.0 && z>-zdepth/2.0 && z<zdepth/2.0){
       /*reflect through normal vector*/
       double nx,ny,nz,kfx,kfy,kfz,kdotn;
       nx=Ox-x;
       ny=Oy-y;
       nz=Oz-z;
       NORM(nx,ny,nz);
       kdotn=-scalar_prod(kx,ky,kz,nx,ny,nz);
       kfx=kx+2*kdotn*nx;
       kfy=ky+2*kdotn*ny;
       kfz=kz+2*kdotn*nz;

       kx=kfx;ky=kfy;kz=kfz;
       /*adjust weight of ray*/
       p*=R;
     }
  }

%}

MCDISPLAY
%{
  int i,j,N=12;
  double t,xx,yy,zz,xx0,yy0,zz0;

  if (xwidth && zdepth){
    for (i=0;i<N;i++){
      xx0=-xwidth/2.0;
      zz=i*zdepth/(N-1)-zdepth/2.0;
      yy0=sqrt(b2*(1-xx0*xx0/a2-zz*zz/c2));
      for (j=1;j<N;j++){
        xx=j*xwidth/(N-1)-xwidth/2.0;
        yy=sqrt(b2*(1-xx*xx/a2-zz*zz/c2));
        line(xx0,yy0,zz,xx,yy,zz);
        xx0=xx;
        yy0=yy; 
      }
    }
    for (i=0;i<N;i++){
      zz0=-zdepth/2.0;
      xx=i*xwidth/(N-1)-xwidth/2.0;
      yy0=sqrt(b2*(1-xx*xx/a2-zz0*zz0/c2));
      for (j=1;j<N;j++){
        zz=j*zdepth/(N-1)-zdepth/2.0;
        yy=sqrt(b2*(1-xx*xx/a2-zz*zz/c2));
        line(xx,yy0,zz0,xx,yy,zz);
        zz0=zz;
        yy0=yy; 
      }
    }
  }
  for (i=0;i<1;i++){
    yy=i*b/(N-1);
    xx0=0;
    zz0=c;
    for (j=1;j<=180;j++){
      t=j*M_PI/180;
      xx=a*sin(t*2);
      zz=c*cos(t*2);
      line(xx0,yy,zz0,xx,yy,zz);
      xx0=xx;zz0=zz;
    }
  }

%}

END
