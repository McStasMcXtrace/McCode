/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright 1997-2008, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Component: MirrorPara
*
* %I
* Written by: <a href="mailto:desert@drecam.cea.fr">Sylvain Desert</a>
* Date: 2007
* Version: $Revision: 1.1 $
* Origin: <a href="http://www-llb.cea.fr/">LLB</a>
* Release: McStas 1.12
*
* Elliptical mirror.
*
* %D
* Models an elliptical mirror. The reflectivity profile is given by a 2-column reflectivity free 
* text file with format [q(Angs-1) R(0-1)].
*
* Example:  MirrorElli(reflect="supermirror_m3.rfl",focus=6.6e-4, interfocus = 8.2, yheight = 0.0002,
*				  zmin=-3.24, zmax=-1.49)
*
*
* %P
* INPUT PARAMETERS:
* yheight: height of the mirror (m)
* focus: focal length (m)
* reflect: (str)  Reflectivity file name. Format [q(Angs-1) R(0-1)]
* interfocus: (m) Distance between the two elliptical focal points
* zmin: (m) 
* zmax: (m) 
* %D
* Example values: reflect="supermirror_m3.rfl" deltafaisceau=0.05 yheight=2e-4 focus=6.6e-4 ecartx=0.05
*
* Example instrumentfile FocalisationMirrors.instr is available in the examples/ folder.
*
* %E
*******************************************************************************/

DEFINE COMPONENT MirrorElli
DEFINITION PARAMETERS (string reflect=0)
SETTING PARAMETERS (focus,interfocus, yheight, zmin=0, zmax=0)
OUTPUT PARAMETERS (beta1, alpha1,beta2, alpha2, err)
STATE PARAMETERS (x,y,z,vx,vy,vz,t,s1,s2,p)

SHARE
%{
%include "read_table-lib"
int Signe(double bla){
    int i;
    if (bla<0)i=-1;
    else i=1;
    return i;
}
%}

DECLARE
%{
  double  beta1, alpha1;                 /* ellipse parameters */
  double  beta2, alpha2;                 /* ellipse squared parameters */
  double a, b;                         
  double delta;
  double angle;
  t_Table pTable;
  double old_x,old_y,old_z;
  int err;                            
%}  

INITIALIZE
%{

  if (reflect && strlen(reflect)) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"MirrorPara: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  }
  else{
    exit(fprintf(stderr,"MirrorElli: %s: no file\n", NAME_CURRENT_COMP));
  }
  /* Calculation of ellipse parameters */
  alpha1 = interfocus/2 +focus;
  alpha2 = alpha1*alpha1;
  beta2 = alpha2 - (interfocus*interfocus)/4;
  beta1 = sqrt(beta2);
  err = 0;
  yheight/=2;
  if(zmin==0&&zmax==0){
      zmin = -alpha1;
      zmax = alpha1;
  }
  else{
      if(zmin>=zmax) exit(fprintf(stderr,"MirrorElli: %s: error definition zmin and zmax\n", NAME_CURRENT_COMP));
  }
  printf("\n\nalpha : %f / alpha^2 : %f\nbeta : %f / beta^2 : %f\n\n",alpha1,alpha2,beta1,beta2);  
%}

TRACE
%{
  double q, B;
  double div,z1,x1,z2,x2;
  double v;
  double vx_2,vz_2;
  int i=-1;
  double oa,ob,ab,xa,za;
  
  /* First check if neutron has the right direction. */
  if((vz != 0.0 && -z/vz >= 0) && x+beta1> 0)
  {

      i++;
      old_z=z;
      old_x=x;
      old_y=y;
      a=vx/vz;
      b=x-a*z;
      /*      printf("\nx  : %e / z  : %f / y : %e\nvx : %e / vz : %e / vy : %e\na  : %e / b  : %f",x,z,y,vx,vz,a,b); */

      /* Calculation of intersection with ellipse */
      delta = sqrt(4*(a*a*b*b-(a*a+beta2/alpha2)*(b*b-beta2)));
      /*      printf("\nDELTA : %e",delta); */
      z1 = (-2*a*b - delta)/(2*(a*a+beta2/alpha2));
      z2 = (-2*a*b + delta)/(2*(a*a+beta2/alpha2));
      x1 = a*z1+b;
      x2 = a*z2+b;
      /*      printf("\nx1 : %f / z1 : %f\nx2 : %f / z2 : %f\n",x1,z1,x2,z2); */

      /* Choose the right result */
      if((z1>z2)&&(fabs(z1)<alpha1)){
          x=Signe(x1)*beta1*sqrt(1-z1*z1/alpha2);
          z=z1;
      }
      else{          
          if(fabs(z2)<alpha1){
               x=Signe(x2)*beta1*sqrt(1-z2*z2/alpha2);
               z=z2;
          }
          else{
               printf("WARNING : Error in the coordinates calculation \n");
               ABSORB;
          }
      }
      if(fabs(x-a*z-b)>0.001){
            err++;
            printf("x  : %e / z  : %f \nX : %f",x,z,a*z+b);
            ABSORB;
      }
        
        
      /* y calculation */
      y+=vy*(z-old_z)/vz;

      /*reflection*/
      if(x<0 && fabs(y)<=yheight && z>=zmin && z<=zmax){
           /*reflection angle in the plane xz*/
           div = -atan(vx/vz);
           angle = -atan((beta2*z)/(alpha2*x));
           
           /*vx and vz calculation after reflection*/
           v=sqrt(vx*vx+vz*vz);
           vz = v*cos(2*angle+div);
           vx = v*sin(2*angle+div);
/*           
           printf("reflection2D :\nv: %e / angle (tangeante) : %f / div : %f / incidence : %f\n",v,angle,div,2*angle+div);
           printf("vx : %f /vz : %f\n",vx,vz);
*/           
           /*incidence angle in 3D*/
           ob = sqrt((old_x-x)*(old_x-x)+(old_z-z)*(old_z-z));
           xa = x-ob*cos(div+angle)*sin(angle);
           za = z-ob*cos(div+angle)*cos(angle);
           oa = sqrt((old_x-xa)*(old_x-xa)+(old_z-za)*(old_z-za));
           ob = sqrt((old_x-x)*(old_x-x)+(old_y-y)*(old_y-y)+(old_z-z)*(old_z-z));
           ab = sqrt((xa-x)*(xa-x)+(old_y-y)*(old_y-y)+(za-z)*(za-z));
           angle = acos((-ab*ab-ob*ob+oa*oa)/(2*ab*ob));
	   /*           printf("3D :\nxa : %f / za : %f\noa : %f / ob : %f / ab : %f\nangle : %f / v : %e\n",xa,za,oa,ob,ab,angle,v); */
           
           v=sqrt(vx*vx+vy*vy+vz*vz);
           q = fabs(2*sin(angle)*v*V2Q);
           /* Reflectivity (see component Guide). */
           B=Table_Value(pTable, q, 1);
           if (B <= 0) ABSORB;
           else if (B > 1) B=1;
           /* now handle either probability weight */
           p *= B;
           
      }
      else ABSORB;     
      SCATTER;
  }
  else{
    ABSORB;
  }
%}

FINALLY
%{
   if(err!=0){
      fprintf(stderr,"WARNING : %d neutrons absorbed for inadapted divergeance !\n",err);
   }
%}

MCDISPLAY
%{
  double xi,zi,xf,zf,delta_z;
  
  delta_z = (zmax-zmin)/99;
  xi=-beta1*sqrt(1-zmin*zmin/alpha2);
  line(xi,-yheight,zmin,xi,yheight,zmin);
  zi=zmin;
  printf("delta_z : %f / xi : %f / zi : %f\n",delta_z,xi,zi);
  do{
         zf = zi + delta_z;
         xf=-beta1*sqrt(1-zf*zf/alpha2);
         line(xi,yheight,zi,xf,yheight,zf);
         line(xf,yheight,zf,xf,-yheight,zf);
         line(xf,-yheight,zf,xi,-yheight,zi);
         xi=xf;
         zi=zf;
  }while(zf<=zmax);

%}
END
