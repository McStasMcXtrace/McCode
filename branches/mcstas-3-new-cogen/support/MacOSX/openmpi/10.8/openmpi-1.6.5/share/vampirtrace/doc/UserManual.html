<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2008 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>VampirTrace - User Manual</TITLE>
<META NAME="description" CONTENT="VampirTrace - User Manual">
<META NAME="keywords" CONTENT="UserManual">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2008">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<STYLE>
/* Century Schoolbook font is very similar to Computer Modern Math: cmmi */
.MATH    { font-family: "Century Schoolbook", serif; }
.MATH I  { font-family: "Century Schoolbook", serif; font-style: italic }
.BOLDMATH { font-family: "Century Schoolbook", serif; font-weight: bold }

/* implement both fixed-size and relative sizes */
SMALL.XTINY		{ font-size : xx-small }
SMALL.TINY		{ font-size : x-small  }
SMALL.SCRIPTSIZE	{ font-size : smaller  }
SMALL.FOOTNOTESIZE	{ font-size : small    }
SMALL.SMALL		{  }
BIG.LARGE		{  }
BIG.XLARGE		{ font-size : large    }
BIG.XXLARGE		{ font-size : x-large  }
BIG.HUGE		{ font-size : larger   }
BIG.XHUGE		{ font-size : xx-large }

/* heading styles */
H1		{  }
H2		{  }
H3		{  }
H4		{  }
H5		{  }

/* mathematics styles */
DIV.displaymath		{ }	/* math displays */
TD.eqno			{ }	/* equation-number cells */


/* document-specific styles come next */
DIV.scriptsize		{   }
PRE.preform		{   }
DIV.footnotesize		{   }
DIV.small		{   }
DIV.center		{   }
DIV.navigation		{   }
SPAN.textbf		{ font-weight: bold  }
SPAN.arabic		{   }
SPAN.textit		{ font-style: italic  }

BODY			{ font-family: sans-serif; }
</STYLE>

</HEAD>

<BODY >

<P>

<P>
<B><BIG CLASS="XHUGE">VampirTrace 5.14.4&nbsp;User Manual</BIG></B>
<BR>
<BR>
<BR>
TU Dresden
<BR>
Center for Information Services and 
<BR>
High Performance Computing (ZIH)
<BR>
01062 Dresden
<BR>
Germany
<BR>
<BR>
http://www.tu-dresden.de/zih
<BR>
http://www.tu-dresden.de/zih/vampirtrace
<BR>
<BR>
<P>
Contact: vampirsupport@zih.tu-dresden.de
<P>
<BR>

<H2><A NAME="SECTION00100000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->

<UL CLASS="TofC">
<LI><A NAME="tex2html128"
  HREF="#SECTION00200000000000000000">Introduction</A>
<LI><A NAME="tex2html129"
  HREF="#SECTION00300000000000000000">Instrumentation</A>
<UL>
<LI><A NAME="tex2html130"
  HREF="#SECTION00310000000000000000">Compiler Wrappers</A>
<LI><A NAME="tex2html131"
  HREF="#SECTION00320000000000000000">Instrumentation Types</A>
<LI><A NAME="tex2html132"
  HREF="#SECTION00330000000000000000">Automatic Instrumentation</A>
<UL>
<LI><A NAME="tex2html133"
  HREF="#SECTION00331000000000000000">Supported Compilers</A>
<LI><A NAME="tex2html134"
  HREF="#SECTION00332000000000000000">Notes for Using the GNU, Intel, PathScale, or Open64 Compiler</A>
<LI><A NAME="tex2html135"
  HREF="#SECTION00333000000000000000">Notes on Instrumentation of Inline Functions</A>
<LI><A NAME="tex2html136"
  HREF="#SECTION00334000000000000000">Instrumentation of Loops with OpenUH Compiler</A>
</UL>
<LI><A NAME="tex2html137"
  HREF="#SECTION00340000000000000000">Manual Instrumentation</A>
<UL>
<LI><A NAME="tex2html138"
  HREF="#SECTION00341000000000000000">Using the VampirTrace API</A>
<LI><A NAME="tex2html139"
  HREF="#SECTION00342000000000000000">Measurement Controls</A>
</UL>
<LI><A NAME="tex2html140"
  HREF="#SECTION00350000000000000000">Source Instrumentation Using PDT/TAU</A>
<LI><A NAME="tex2html141"
  HREF="#SECTION00360000000000000000">Binary Instrumentation Using Dyninst</A>
<UL>
<LI><A NAME="tex2html142"
  HREF="#SECTION00361000000000000000">Static Binary Instrumentation</A>
</UL>
<LI><A NAME="tex2html143"
  HREF="#SECTION00370000000000000000">Runtime Instrumentation Using VTRun</A>
<LI><A NAME="tex2html144"
  HREF="#SECTION00380000000000000000">Tracing Java Applications Using JVMTI</A>
<LI><A NAME="tex2html145"
  HREF="#SECTION00390000000000000000">Tracing Calls to 3rd-Party Libraries</A>
</UL>
<BR>
<LI><A NAME="tex2html146"
  HREF="#SECTION00400000000000000000">Runtime Measurement</A>
<UL>
<LI><A NAME="tex2html147"
  HREF="#SECTION00410000000000000000">Trace File Name and Location</A>
<LI><A NAME="tex2html148"
  HREF="#SECTION00420000000000000000">Environment Variables</A>
<LI><A NAME="tex2html149"
  HREF="#SECTION00430000000000000000">Influencing Trace Buffer Size</A>
<LI><A NAME="tex2html150"
  HREF="#SECTION00440000000000000000">Profiling an Application</A>
<LI><A NAME="tex2html151"
  HREF="#SECTION00450000000000000000">Unification of Local Traces</A>
<LI><A NAME="tex2html152"
  HREF="#SECTION00460000000000000000">Synchronized Buffer Flush</A>
<LI><A NAME="tex2html153"
  HREF="#SECTION00470000000000000000">Enhanced Timer Synchronization</A>
<LI><A NAME="tex2html154"
  HREF="#SECTION00480000000000000000">Environment Configuration Using VTSetup</A>
</UL>
<BR>
<LI><A NAME="tex2html155"
  HREF="#SECTION00500000000000000000">Recording Additional Events and Counters</A>
<UL>
<LI><A NAME="tex2html156"
  HREF="#SECTION00510000000000000000">Hardware Performance Counters</A>
<LI><A NAME="tex2html157"
  HREF="#SECTION00520000000000000000">Resource Usage Counters</A>
<LI><A NAME="tex2html158"
  HREF="#SECTION00530000000000000000">Memory Allocation Counter</A>
<LI><A NAME="tex2html159"
  HREF="#SECTION00540000000000000000">CPU ID Counter</A>
<LI><A NAME="tex2html160"
  HREF="#SECTION00550000000000000000">NVIDIA CUDA</A>
<LI><A NAME="tex2html161"
  HREF="#SECTION00560000000000000000">Pthread API Calls</A>
<LI><A NAME="tex2html162"
  HREF="#SECTION00570000000000000000">Plugin Counter Metrics</A>
<LI><A NAME="tex2html163"
  HREF="#SECTION00580000000000000000">I/O Calls</A>
<LI><A NAME="tex2html164"
  HREF="#SECTION00590000000000000000">Child Process Execution Calls</A>
<LI><A NAME="tex2html165"
  HREF="#SECTION005100000000000000000">MPI Correctness Checking Using UniMCI</A>
<LI><A NAME="tex2html166"
  HREF="#SECTION005110000000000000000">User-defined Counters</A>
<LI><A NAME="tex2html167"
  HREF="#SECTION005120000000000000000">User-defined Markers</A>
<LI><A NAME="tex2html168"
  HREF="#SECTION005130000000000000000">User-defined Communcation</A>
</UL>
<BR>
<LI><A NAME="tex2html169"
  HREF="#SECTION00600000000000000000">Filtering &amp; Grouping</A>
<UL>
<LI><A NAME="tex2html170"
  HREF="#SECTION00610000000000000000">Function Filtering</A>
<LI><A NAME="tex2html171"
  HREF="#SECTION00620000000000000000">Java Specific Filtering</A>
<LI><A NAME="tex2html172"
  HREF="#SECTION00630000000000000000">Function Grouping</A>
</UL>
<BR>
<LI><A NAME="tex2html173"
  HREF="#SECTION00700000000000000000">VampirTrace Installation</A>
<UL>
<LI><A NAME="tex2html174"
  HREF="#SECTION00710000000000000000">Basics</A>
<LI><A NAME="tex2html175"
  HREF="#SECTION00720000000000000000">Configure Options</A>
<LI><A NAME="tex2html176"
  HREF="#SECTION00730000000000000000">Cross Compilation</A>
<LI><A NAME="tex2html177"
  HREF="#SECTION00740000000000000000">Environment Set-Up</A>
<LI><A NAME="tex2html178"
  HREF="#SECTION00750000000000000000">Notes for Developers</A>
</UL>
<BR>
<LI><A NAME="tex2html179"
  HREF="#SECTION00800000000000000000">Command Reference</A>
<UL>
<LI><A NAME="tex2html180"
  HREF="#SECTION00810000000000000000">Compiler Wrappers (vtcc,vtcxx,vtfort)</A>
<LI><A NAME="tex2html181"
  HREF="#SECTION00820000000000000000">Local Trace Unifier (vtunify)</A>
<LI><A NAME="tex2html182"
  HREF="#SECTION00830000000000000000">Binary Instrumentor (vtdyn)</A>
<LI><A NAME="tex2html183"
  HREF="#SECTION00840000000000000000">Trace Filter Tool (vtfilter)</A>
<LI><A NAME="tex2html184"
  HREF="#SECTION00850000000000000000">Library Wrapper Generator (vtlibwrapgen)</A>
<LI><A NAME="tex2html185"
  HREF="#SECTION00860000000000000000">Application Execution Wrapper (vtrun)</A>
<LI><A NAME="tex2html186"
  HREF="#SECTION00870000000000000000">IOFSL server startup script (vtiofsl-start)</A>
<LI><A NAME="tex2html187"
  HREF="#SECTION00880000000000000000">IOFSL server shutdown script (vtiofsl-stop)</A>
</UL>
<BR>
<LI><A NAME="tex2html188"
  HREF="#SECTION00900000000000000000">Counter Specifications</A>
<UL>
<LI><A NAME="tex2html189"
  HREF="#SECTION00910000000000000000">PAPI</A>
<LI><A NAME="tex2html190"
  HREF="#SECTION00920000000000000000">CPC</A>
<LI><A NAME="tex2html191"
  HREF="#SECTION00930000000000000000">NEC SX Hardware Performance Counter</A>
<LI><A NAME="tex2html192"
  HREF="#SECTION00940000000000000000">Resource Usage</A>
</UL>
<BR>
<LI><A NAME="tex2html193"
  HREF="#SECTION001000000000000000000">Using VampirTrace with IOFSL</A>
<UL>
<LI><A NAME="tex2html194"
  HREF="#SECTION001010000000000000000">Introduction</A>
<LI><A NAME="tex2html195"
  HREF="#SECTION001020000000000000000">Overview</A>
<UL>
<LI><A NAME="tex2html196"
  HREF="#SECTION001021000000000000000">File handling in OTF</A>
<LI><A NAME="tex2html197"
  HREF="#SECTION001022000000000000000">I/O Forwarding Scalability Layer</A>
<LI><A NAME="tex2html198"
  HREF="#SECTION001023000000000000000">Architecture</A>
</UL>
<LI><A NAME="tex2html199"
  HREF="#SECTION001030000000000000000">Installation</A>
<UL>
<LI><A NAME="tex2html200"
  HREF="#SECTION001031000000000000000">Support Libraries</A>
<LI><A NAME="tex2html201"
  HREF="#SECTION001032000000000000000">Building IOFSL</A>
<LI><A NAME="tex2html202"
  HREF="#SECTION001033000000000000000">Building VampirTrace &amp; OTF</A>
</UL>
<LI><A NAME="tex2html203"
  HREF="#SECTION001040000000000000000">Usage Examples</A>
<UL>
<LI><A NAME="tex2html204"
  HREF="#SECTION001041000000000000000">Using VampirTrace with IOFSL on Cray XK6 / with PBS</A>
<LI><A NAME="tex2html205"
  HREF="#SECTION001042000000000000000">Manual Usage</A>
</UL>
</UL>
<BR>
<LI><A NAME="tex2html206"
  HREF="#SECTION001100000000000000000">FAQ</A>
<UL>
<LI><A NAME="tex2html207"
  HREF="#SECTION001110000000000000000">Can I use different compilers for VampirTrace and my application?</A>
<LI><A NAME="tex2html208"
  HREF="#SECTION001120000000000000000">Why does my application need such a long time for starting?</A>
<LI><A NAME="tex2html209"
  HREF="#SECTION001130000000000000000">How can I limit compiler instrumentation?</A>
<LI><A NAME="tex2html210"
  HREF="#SECTION001140000000000000000">Why do I see multiple
I/O operations for a single (un)formatted file read/write from my Fortran
application?</A>
<LI><A NAME="tex2html211"
  HREF="#SECTION001150000000000000000">The application has run to completion, but there is no *.otf file. What can I do?</A>
<LI><A NAME="tex2html212"
  HREF="#SECTION001160000000000000000">What limitations are associated with "on/off" and buffer rewind?</A>
<LI><A NAME="tex2html213"
  HREF="#SECTION001170000000000000000">VampirTrace warns that it ``cannot lock file a.lock'', what's wrong?</A>
<LI><A NAME="tex2html214"
  HREF="#SECTION001180000000000000000">Can I relocate my VampirTrace installation without rebuilding from source?</A>
<LI><A NAME="tex2html215"
  HREF="#SECTION001190000000000000000">What are the byte counts in collective communication records?</A>
<LI><A NAME="tex2html216"
  HREF="#SECTION0011100000000000000000">I get ``error: unknown asm constraint letter''</A>
<LI><A NAME="tex2html217"
  HREF="#SECTION0011110000000000000000">I have a question that is not answered in this document!</A>
<LI><A NAME="tex2html218"
  HREF="#SECTION0011120000000000000000">I need support for additional features so I can trace application xyz.</A>
</UL></UL>
<!--End of Table of Contents-->
<P>
This documentation describes how to apply VampirTrace to an application 
in order to generate trace files at execution time.
This step is called <SPAN  CLASS="textit">instrumentation</SPAN>.
It furthermore explains how to control the runtime measurement system 
during execution (<SPAN  CLASS="textit">tracing</SPAN>). 
This also includes performance counter sampling
as well as selective filtering and grouping of functions.

<P>

<P>

<H1><A NAME="SECTION00200000000000000000">
Introduction</A>
</H1>

<P>
VampirTrace consists of a tool set and a runtime library for instrumentation 
and tracing of software applications. It is particularly tailored to
parallel and distributed High Performance Computing (HPC) applications.

<P>
The instrumentation part modifies a given application in order to inject
additional measurement calls during runtime. The tracing part provides 
the actual measurement functionality used by the instrumentation calls.
By this means, a variety of detailed performance properties can be collected 
and recorded during runtime. 
This includes function enter and leave events, MPI communication,
OpenMP events, and performance counters.

<P>
After a successful tracing run, VampirTrace writes all collected data to a  
trace file in the Open Trace Format (OTF)<A NAME="tex2html1"
  HREF="#foot1614"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A>.
As a result, the information is available for post-mortem analysis and 
visualization by various tools. 
Most notably, VampirTrace provides the input data for the Vampir analysis  
and visualization tool<A NAME="tex2html2"
  HREF="#foot1615"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A>. 

<P>
VampirTrace is included in OpenMPI&nbsp;1.3 and later versions.
If not disabled explicitly, VampirTrace is built automatically when installing
OpenMPI<A NAME="tex2html3"
  HREF="#foot1616"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A>.

<P>
Trace files can quickly become very large, especially with automatic instrumentation.
Tracing applications for only a few seconds can result in 
trace files of several hundred megabytes. To protect users from 
creating trace files of several gigabytes, the default behavior of 
VampirTrace limits the internal buffer to 32 MB per process. Thus, even for larger
scale runs the total trace file size will be moderate.
Please read Section&nbsp;<A HREF="#sec:trace_file_size">3.3</A> on how to remove or change this limit. 

<P>
VampirTrace supports various Unix and Linux platforms that are common in  
HPC nowadays. It is available as open source software under a BSD License.  

<P>
The following list shows a summary of all instrumentation and tracing features
that VampirTrace offers.
Note that not all features are supported on all platforms.

<P>
<BR>
<BR>

<P>

<P>
 <SPAN  CLASS="textbf">Tracing of user functions</SPAN>  &#8658; Chapter&nbsp;<A HREF="#chap:instrumentation">2</A> <BR>

<UL>
<LI>Record function enter and leave events
</LI>
<LI>Record name and source code location (file name, line)
</LI>
<LI>Various kinds of instrumentation &#8658; Section&nbsp;<A HREF="#sec:instrumentation_types">2.2</A>

<UL>
<LI>Automatic with many compilers &#8658; Section&nbsp;<A HREF="#sec:compinst">2.3</A> 
</LI>
<LI>Manual using VampirTrace API &#8658; Section&nbsp;<A HREF="#sec:maninst">2.4</A> 
</LI>
<LI>Automatic with tau_instrumentor &#8658; Section&nbsp;<A HREF="#sec:tauinst">2.5</A> 
</LI>
<LI>Automatic with Dyninst &#8658; Section&nbsp;<A HREF="#sec:dyninst">2.6</A> 
</LI>
</UL>
</LI>
</UL>

<P>
 <SPAN  CLASS="textbf">MPI Tracing</SPAN>  &#8658; Chapter&nbsp;<A HREF="#chap:instrumentation">2</A>  <BR>

<UL>
<LI>Record MPI functions
</LI>
<LI>Record MPI communication: participating processes, transferred bytes, tag, communicator
</LI>
</UL>

<P>
 <SPAN  CLASS="textbf">OpenMP Tracing</SPAN>  &#8658; Chapter&nbsp;<A HREF="#chap:instrumentation">2</A>  <BR>

<UL>
<LI>OpenMP directives, synchronization, thread idle time
</LI>
<LI>Also hybrid (MPI and OpenMP) applications are supported
</LI>
</UL>

<P>
 <SPAN  CLASS="textbf">Pthread Tracing</SPAN>

<UL>
<LI>Trace POSIX thread API calls &#8658; Section&nbsp;<A HREF="#sec:pthread_calls">4.6</A>
</LI>
<LI>Also hybrid (MPI and POSIX threads) applications are supported
</LI>
</UL>

<P>
 <SPAN  CLASS="textbf">Java Tracing</SPAN>  &#8658; Section&nbsp;<A HREF="#sec:jvmti">2.8</A>  <BR>

<UL>
<LI>Record method calls
</LI>
<LI>Using JVMTI as interface between VampirTrace and Java Applications
</LI>
</UL>

<P>
 <SPAN  CLASS="textbf">3rd-Party Library tracing</SPAN> &#8658; Section&nbsp;<A HREF="#sec:3rd-party">2.9</A>  <BR>

<UL>
<LI>Trace calls to arbitrary third party libraries
</LI>
<LI>Generate wrapper for library functions based on library's header file(s)
</LI>
<LI>No recompilation of application or library is required
</LI>
</UL>

<P>
 <SPAN  CLASS="textbf">MPI Correctness Checking</SPAN> &#8658; Section&nbsp;<A HREF="#sec:unimci">4.10</A> <BR>

<UL>
<LI>Record MPI usage errors
</LI>
<LI>Using UniMCI as interface between VampirTrace and a MPI correctness checking tool (e.g. Marmot)
</LI>
</UL>

<P>
 <SPAN  CLASS="textbf">User API</SPAN> <BR>

<UL>
<LI>Manual instrumentation of source code regions &#8658; Section&nbsp;<A HREF="#sec:maninst">2.4</A>
</LI>
<LI>Measurement controls &#8658; Section&nbsp;<A HREF="#subsec:measurement_controls">2.4.2</A>
</LI>
<LI>User-defined counters &#8658; Section&nbsp;<A HREF="#sec:userdefinedcounters">4.11</A>
</LI>
<LI>User-defined marker &#8658; Section&nbsp;<A HREF="#sec:userdefinedmarkers">4.12</A>
</LI>
<LI>User-defined communication &#8658; Section&nbsp;<A HREF="#sec:userdefinedcomm">4.13</A>
</LI>
</UL>

<P>
 <SPAN  CLASS="textbf">Performance Counters</SPAN>  &#8658; Sections&nbsp;<A HREF="#sec:hw_perf_counters">4.1</A> and&nbsp;<A HREF="#sec:rusage_counters">4.2</A>  <BR>

<UL>
<LI>Hardware performance counters using PAPI, CPC, or NEC SX performance counter
</LI>
<LI>Resource usage counters using getrusage
</LI>
</UL> 

<P>
 <SPAN  CLASS="textbf">CPU ID Tracing</SPAN>  &#8658; Section&nbsp;<A HREF="#sec:cpu_id_counter">4.4</A>  <BR>

<UL>
<LI>Trace core ID of a CPU on which the calling thread is running
</LI>
<LI>Record core ID as counter
</LI>
</UL>

<P>
 <SPAN  CLASS="textbf">Child Process Execution Tracing</SPAN>  &#8658; Section&nbsp;<A HREF="#sec:exec_calls">4.9</A> <BR>

<UL>
<LI>Trace LIBC function calls for creating and controling child processes
</LI>
<LI>Add forked processes to the trace
</LI>
</UL>

<P>
 <SPAN  CLASS="textbf">I/O Tracing</SPAN>  &#8658; Section&nbsp;<A HREF="#sec:io_calls">4.8</A>  <BR>

<UL>
<LI>Trace LIBC I/O calls
</LI>
<LI>Record I/O events: file name, transferred bytes
</LI>
</UL>

<P>
 <SPAN  CLASS="textbf">Memory Allocation Tracing</SPAN>  &#8658; Section&nbsp;<A HREF="#sec:mem_alloc_counter">4.3</A>  <BR>

<UL>
<LI>Trace LIBC memory allocation and free functions
</LI>
<LI>Record size of currently allocated memory as counter
</LI>
</UL>

<P>
 <SPAN  CLASS="textbf">Filtering &amp; Grouping</SPAN>  &#8658; Chapter&nbsp;<A HREF="#filtering_and_grouping">5</A> <BR>

<UL>
<LI>Runtime and post-mortem filter (i.e.&nbsp;exclude functions from being recorded in the trace)
</LI>
<LI>Runtime grouping (i.e.&nbsp;assign functions to groups for improved analysis)
</LI>
</UL>

<P>
 <SPAN  CLASS="textbf">OTF Output</SPAN>  &#8658; Chapter&nbsp;<A HREF="#chap:runtime_measurement">3</A> <BR>

<UL>
<LI>Writes compressed OTF files
</LI>
<LI>Output as trace file, statistical summary (profile), or both
</LI>
</UL>

<P>

<H1><A NAME="SECTION00300000000000000000"></A>
<A NAME="chap:instrumentation"></A>
<BR>
Instrumentation
</H1>

<P>
To perform measurements with VampirTrace, the user's application program needs to
be instrumented, i.e., at specific points of interest (called ``events'') VampirTrace
measurement calls have to be activated.
As an example, common events are, amongst others, entering and leaving 
of functions as well as sending and receiving of MPI messages.

<P>
VampirTrace handles this automatically by default. In order to enable the
instrumentation of function calls, the user only needs to replace the compiler 
and linker commands with VampirTrace's wrappers, 
see Section&nbsp;<A HREF="#sec:compiler_wrappers">2.1</A> below. 
VampirTrace supports different ways of instrumentation as described in 
Section&nbsp;<A HREF="#sec:instrumentation_types">2.2</A>.

<P>

<H1><A NAME="SECTION00310000000000000000"></A>
<A NAME="sec:compiler_wrappers"></A>
<BR>
Compiler Wrappers
</H1>

<P>
All the necessary instrumentation of user functions, MPI, and
OpenMP events is handled by VampirTrace's compiler wrappers (vtcc, vtcxx, and vtfort).
In the script used to build the application (e.g.&nbsp;a makefile), all compile
and link commands should be replaced by the VampirTrace compiler wrapper.
The wrappers perform the necessary instrumentation of the program and link
the suitable VampirTrace library.
Note that the VampirTrace version included in OpenMPI&nbsp;1.3
has additional wrappers (mpicc-vt, mpicxx-vt, mpif77-vt, and mpif90-vt) which
are like the ordinary MPI compiler wrappers (mpicc, mpicxx, mpif77, and mpif90)
with the extension of automatic instrumentation.

<P>
The following list shows some examples specific to the parallelization
type of the program:

<P>

<UL>
<LI><SPAN  CLASS="textbf">Serial programs</SPAN>:
Compiling serial codes is the default behavior of the wrappers.
Simply replace the compiler by VampirTrace's wrapper:

<P>
<BR>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">original:</TD>
<TD ALIGN="LEFT"><TT>gfortran hello.f90 -o hello  </TT></TD>
</TR>
<TR><TD ALIGN="LEFT">with instrumentation:</TD>
<TD ALIGN="LEFT"><TT><SPAN  CLASS="textbf">vtfort</SPAN> hello.f90 -o hello  </TT></TD>
</TR>
</TABLE>
<BR>

<P>
This will instrument user functions (if supported by the compiler) and
link the VampirTrace library.

<P>
</LI>
<LI><SPAN  CLASS="textbf">MPI parallel programs</SPAN>:
MPI instrumentation is always handled by means of the PMPI interface, 
which is part of the MPI standard.
This requires the compiler wrapper to link with an MPI-aware version of
the VampirTrace library.
If your MPI implementation uses special MPI compilers (e.g.&nbsp;mpicc, mpxlf90),
you will need to tell VampirTrace's wrapper to use this compiler
instead of the serial one:

<P>
<BR>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">original:</TD>
<TD ALIGN="LEFT"><TT>mpicc hello.c -o hello  </TT></TD>
</TR>
<TR><TD ALIGN="LEFT">with instrumentation:</TD>
<TD ALIGN="LEFT"><TT><SPAN  CLASS="textbf">vtcc -vt:cc mpicc</SPAN> hello.c -o hello  </TT></TD>
</TR>
</TABLE>
<BR>

<P>
MPI implementations without own compilers require the user to link
the MPI library manually. In this case, simply replace the compiler
by VampirTrace's compiler wrapper:

<P>
<BR>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">original:</TD>
<TD ALIGN="LEFT"><TT>icc hello.c -o hello -lmpi </TT></TD>
</TR>
<TR><TD ALIGN="LEFT">with instrumentation:</TD>
<TD ALIGN="LEFT"><TT><SPAN  CLASS="textbf">vtcc</SPAN> hello.c -o hello -lmpi  </TT></TD>
</TR>
</TABLE>
<BR>

<P>
If you want to instrument MPI events only (this creates smaller trace files and less overhead)
use the option <TT>-vt:inst manual</TT> to disable automatic instrumentation
of user functions (see also Section&nbsp;<A HREF="#sec:maninst">2.4</A>).

<P>
</LI>
<LI><SPAN  CLASS="textbf">Threaded parallel programs</SPAN>:
When VampirTrace detects OpenMP or 
<BR>
Pthread flags on the command line, special instrumentation 
calls are invoked. For OpenMP events OPARI is invoked for automatic source code instrumentation.

<P>
<BR>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">original:</TD>
<TD ALIGN="LEFT"><TT>ifort &lt;-openmp|-pthread&gt; hello.f90 </TT></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><TT>-o hello </TT></TD>
</TR>
<TR><TD ALIGN="LEFT">with instrumentation:</TD>
<TD ALIGN="LEFT"><TT><SPAN  CLASS="textbf">vtfort</SPAN> &lt;-openmp|-pthread&gt; hello.f90 </TT></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><TT>-o hello </TT></TD>
</TR>
</TABLE>
<BR>

<P>
For more information about OPARI read the documentation available in VampirTrace's installation
directory at:
<TT>share/vampirtrace/doc/opari/Readme.html</TT> 

<P>
</LI>
<LI><SPAN  CLASS="textbf">Hybrid MPI/Threaded parallel programs</SPAN>:
With a combination of the  above mentioned approaches, hybrid applications can be instrumented:

<P>
<BR>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT">original:</TD>
<TD ALIGN="LEFT"><TT>mpif90 &lt;-openmp|-pthread&gt; hello.F90 </TT></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><TT>-o hello </TT></TD>
</TR>
<TR><TD ALIGN="LEFT">with instrumentation:</TD>
<TD ALIGN="LEFT"><TT><SPAN  CLASS="textbf">vtfort -vt:fc mpif90</SPAN> </TT></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><TT>&lt;-openmp|-pthread&gt; hello.F90</TT></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT"><TT>-o hello </TT></TD>
</TR>
</TABLE>
<BR>

<P>
</LI>
</UL>

<P>
The VampirTrace compiler wrappers automatically try to detect which parallelization
method is used by means of the compiler flags (e.g.&nbsp;<TT>-lmpi</TT>,&nbsp;<TT>-openmp</TT> 
or <TT>-pthread</TT>) and the compiler command (e.g.&nbsp;<TT>mpif90</TT>).
If the compiler wrapper failed to detect this correctly,
the instrumentation could be incomplete and an unsuitable
VampirTrace library would be linked to the binary.
In this case, you should tell the compiler wrapper which parallelization method
your program uses by using the switches
<TT>-vt:mpi</TT>, <TT>-vt:mt</TT>, and <TT>-vt:hyb</TT> for MPI, multithreaded, and
hybrid programs, respectively.
Note that these switches do not change the underlying compiler or compiler flags.
Use the option <TT>-vt:verbose</TT> to see the command line that the compiler wrapper 
executes.
The default settings of the compiler wrappers can be modified in the files
<TT>share/vampirtrace/vtcc-wrapper-data.txt</TT> (and similar for the other languages)
in the installation directory of VampirTrace.
The settings include compilers, compiler flags, libraries, and instrumentation types.
You could for instance modify the default C compiler 
from <TT>gcc</TT>
to <TT>mpicc</TT> by changing the line <TT>compiler=gcc</TT> to <TT>compiler=mpicc</TT>.
This may be convenient if you instrument MPI parallel programs only.

<P>

<H1><A NAME="SECTION00320000000000000000"></A>
<A NAME="sec:instrumentation_types"></A>
<BR>
Instrumentation Types
</H1>

<P>
The wrapper option <TT>-vt:inst &lt;insttype&gt;</TT> specifies the 
instrumentation type to be used. The following values for 
<TT>&lt;insttype&gt;</TT> are possible:

<P>

<UL>
<LI><TT>compinst</TT> 
<BR>
Fully-automatic instrumentation by the compiler (&#8658; Section&nbsp;<A HREF="#sec:compinst">2.3</A>)

<P>
</LI>
<LI><TT>manual</TT> 
<BR>
Manual instrumentation by using VampirTrace's API (&#8658; Section&nbsp;<A HREF="#sec:maninst">2.4</A>) 
<BR>(needs source-code modifications)

<P>
</LI>
<LI><TT>tauinst</TT> 
<BR>
Fully-automatic instrumentation by the tau_instrumentator (&#8658; Section&nbsp;<A HREF="#sec:tauinst">2.5</A>)

<P>
</LI>
<LI><TT>dyninst</TT> 
<BR>
Binary-instrumentation with Dyninst (&#8658; Section&nbsp;<A HREF="#sec:dyninst">2.6</A>)

<P>
</LI>
</UL>

<P>
To determine which instrumentation type will be used by default and which instrumentation
types are available on your system have a look at the entry <TT>inst_avail</TT> in the
wrapper's configuration file (e.g.&nbsp;<TT>share/vampirtrace/vtcc-wrapper-data.txt</TT> in the
installation directory of VampirTrace for the C compiler wrapper).

<P>
Type <TT>vtcc -vt:help</TT> for otheroptions that can be passed to VampirTrace's compiler wrapper.

<P>

<H1><A NAME="SECTION00330000000000000000"></A>
<A NAME="sec:compinst"></A>
<BR>
Automatic Instrumentation
</H1>

<P>
Automatic instrumentation is the most convenient method to instrument your program.
If available, simply use the compiler wrappers without any parameters, e.g.:

<P>
<BR>
<BR>
<code>   % vtfort hello.f90 -o hello</code>
<BR>

<P>

<H2><A NAME="SECTION00331000000000000000">
Supported Compilers</A>
</H2>
VampirTrace supports following compilers for automatic instrumentation:

<P>

<UL>
<LI>GNU (i.e.&nbsp;gcc, g++, gfortran, g95)
</LI>
<LI>Intel version &#8805;10.0 (i.e.&nbsp;icc, icpc, ifort)
</LI>
<LI>PathScale version &#8805;3.1 (i.e.&nbsp;pathcc, pathCC, pathf90)
</LI>
<LI>Portland Group (PGI) (i.e.&nbsp;pgcc, pgCC, pgf90, pgf77)
</LI>
<LI>Cray CCE (i.e.&nbsp;craycc, crayCC, crayftn)
</LI>
<LI>SUN Fortran 90 (i.e.&nbsp;cc, CC, f90)
</LI>
<LI>IBM (i.e.&nbsp;xlcc, xlCC, xlf90)
</LI>
<LI>NEC SX (i.e.&nbsp;sxcc, sxc++, sxf90)
</LI>
<LI>Open64 version &#8805;4.2 (i.e.&nbsp;opencc, openCC, openf90)
</LI>
<LI>OpenUH version &#8805;4.0 (i.e.&nbsp;uhcc, uhCC, uhf90)
</LI>
</UL>

<P>

<H2><A NAME="SECTION00332000000000000000"></A>
<A NAME="subsec:nmnotes"></A>
<BR>
Notes for Using the GNU, Intel, PathScale, or Open64 Compiler
</H2>
For these compilers the command <TT>nm</TT> is required to get symbol information
of the running application executable. For example on Linux systems, this program is a
part of the <SPAN  CLASS="textit">GNU Binutils</SPAN>, which is downloadable from
http://www.gnu.org/software/binutils.
To get the application executable for <TT>nm</TT> during runtime, VampirTrace uses the
<TT>/proc</TT> file system. As <TT>/proc</TT> is not present on all operating systems,
automatic symbol information might not be available. In this case, it is necessary to set
the environment variable <TT>VT_APPPATH</TT> to the pathname of the application executable
to get symbols resolved via <TT>nm</TT>.

<P>
Should any problems emerge to get symbol information automatically, then the environment
variable <TT>VT_GNU_NMFILE</TT> can be set to a symbol list file, which is created with the
command <TT>nm</TT>, like:

<P>
<BR>
<BR>
<code>   % nm hello &gt; hello.nm</code>
<BR>
<BR>
<BR>
To get the source code line for the application functions use <TT>nm -l</TT> on Linux systems.
VampirTrace will include this information into the trace.
Note that the output format of <TT>nm</TT> must be written in BSD-style. See the manual page
of <TT>nm</TT> to obtain help for dealing with the output format setting.

<P>

<H2><A NAME="SECTION00333000000000000000"></A>
<A NAME="subsec:inlinenotes"></A>
<BR>
Notes on Instrumentation of Inline Functions
</H2>
Compilers behave differently when they automatically instrument inlined functions.
The GNU and Intel &#8805;10.0 compilers instrument all functions by default when they
are used with VampirTrace. They therefore switch off inlining completely, disregarding
the optimization level chosen.
One can prevent these particular functions from being instrumented by appending the
following attribute to function declarations, hence
making them able to be inlined (this works only for C/C++):

<P>
<BR>
<BR>
<code>      __attribute__ ((__no_instrument_function__))</code>
<BR>
<BR>

<P>
The PGI and IBM compilers prefer inlining over instrumentation when compiling
with enabled inlining. Thus, one needs to disable inlining to enable the instrumentation
of inline functions and vice versa.

<P>
The bottom line is that a function cannot be inlined and instrumented at the same time.
For more information on how to inline functions read your compiler's manual.

<P>

<H2><A NAME="SECTION00334000000000000000"></A>
<A NAME="subsec:openuh_loop"></A>
<BR>
Instrumentation of Loops with OpenUH Compiler
</H2>
The OpenUH compiler provides the possibility of instrumenting loops in addition to functions.
To use this functionality add the compiler flag <TT>-OPT:instr_loop</TT>. In this
case loops induce additional events including the type of loop (e.g. for, while, or do)
and the source code location.

<P>

<H1><A NAME="SECTION00340000000000000000"></A>
<A NAME="sec:maninst"></A>
<BR>
Manual Instrumentation
</H1>

<H2><A NAME="SECTION00341000000000000000">
Using the VampirTrace API</A>
</H2>

<P>
The <TT>VT_USER_START</TT>, <TT>VT_USER_END</TT> calls 
can be used to instrument any user-defined sequence of statements. 

<P>
<PRE>
Fortran: 
           #include "vt_user.inc"
           VT_USER_START('name')
           ...
           VT_USER_END('name')
</PRE> 

<P>
<PRE>
C:
           #include "vt_user.h"
           VT_USER_START("name");
           ...
           VT_USER_END("name");
</PRE>
If a block has several exit points (as it is often the case for
functions), all exit points have to be instrumented with 
<TT>VT_USER_END</TT>, too.

<P>
For C++ it is simpler as is demonstrated in the following example. Only entry points into a 
scope need to be marked. The exit points are detected automatically when C++ 
deletes scope-local variables.

<P>
<PRE>
C++:
           #include "vt_user.h"
           {
             VT_TRACER("name");
             ...
           }
</PRE> 

<P>
The instrumented sources have to be compiled with <TT>-DVTRACE</TT> for
  all three languages, otherwise the <TT>VT_*</TT> calls are ignored. 
  Note that Fortran source files instrumented this way have to be 
  preprocessed, too.

<P>
In addition, you can combine this particular instrumentation type with all other types.
  In such a way, all user functions can be instrumented by a compiler while
  special source code regions (e.g.&nbsp;loops) can be instrumented by VT's API.

<P>
Use VT's compiler wrapper (described above) for compiling and linking the
  instrumented source code, such as:

<UL>
<LI>combined with automatic compiler instrumentation:
<BR>
<BR><TT>% vtcc <SPAN  CLASS="textbf">-DVTRACE</SPAN> hello.c -o hello</TT>
<BR>
<BR>
</LI>
<LI>without compiler instrumentation:
<BR>
<BR><TT>% vtcc -vt:inst manual <SPAN  CLASS="textbf">-DVTRACE</SPAN> hello.c -o hello</TT>
<BR>
<BR>
</LI>
</UL>

<P>
Note that you can also use the option <TT>-vt:inst manual</TT>
  with non-instrumented sources.
  Binaries created in this manner only contain MPI and OpenMP instrumentation,
  which might be desirable in some cases.

<P>

<H2><A NAME="SECTION00342000000000000000"></A>
<A NAME="subsec:measurement_controls"></A>
<BR>
Measurement Controls
</H2>

<P>

<H4><A NAME="SECTION00342010000000000000"></A>
<A NAME="subsec:onoff"></A>
<BR>
Switching tracing on/off:
</H4>
  In addition to instrumenting arbitrary blocks of code, one can use the
  <TT>VT_ON</TT>/ <TT>VT_OFF</TT> instrumentation calls to start and stop
  the recording of events. These constructs can be used to stop recording
  of events for a part of the application and later resume recording. For
  example, as is demonstrated in the following C/C++ code snippet, one could
  not collect trace events during the initialization phase of an application
  and turn on tracing for the computation part.
<PRE>
           int main() {
             ...
             VT_OFF();
             initialize();
             VT_ON();
             compute();
             ...
           }
</PRE>
  Furthermore the "on/off" functionality can be used to control the 
  tracing behavior of VampirTrace and allows to trace only parts of interests.
  Therefore the amount of trace data can be reduced essentially.
  To check whether if tracing is enabled or not use the call <TT>VT_IS_ON</TT>.

<P>

<H4><A NAME="SECTION00342020000000000000">
Trace buffer rewind:</A>
</H4>
  An alternative to the "on/off" functionality is the buffer rewind
  approach. It is useful when the program should decide dynamically <SPAN  CLASS="textit">after</SPAN> a
  specific code section (i.e. a time step or iteration) if this section
  <SPAN  CLASS="textit">has been</SPAN> interesting (i.e. anomalous/slow behavior) and should be
  recorded to the trace file.
  The key difference to "on/off" is that you do not need to know a priori if a section
  should be recorded.

<P>
Use the instrumentation call <TT>VT_SET_REWIND_MARK</TT> at the beginning of
  a (possibly not interesting) code section.
  Later, you can decide to rewind the trace buffer to the mark with the call  
  <TT>VT_REWIND</TT>.
  All recorded trace data between the mark and the rewind call will be dropped.
  Note, that only one mark can be set at a time. The last call to
  <TT>VT_SET_REWIND_MARK</TT> will be considered when rewinding the trace buffer.
  This simplified Fortran code example sketches how the rewind approach can be used:
<PRE>
           do step=1,number_of_time_steps
             VT_SET_REWIND_MARK()
             call compute_time_step(step)
             if(finished_as_expected) VT_REWIND()
           end do
</PRE>
<H4><A NAME="SECTION00342030000000000000">
Intermediate buffer flush:</A>
</H4>
  In addition to an automated buffer flush when the buffer is filled, it is
  possible to flush the buffer at any point of the application. This way you can
  guarantee that after a manual buffer flush there will be a sequence of the program
  with no automatic buffer flush interrupting. To flush the buffer you can use the
  call <TT>VT_BUFFER_FLUSH</TT>.

<P>

<H4><A NAME="SECTION00342040000000000000">
Intermediate time synchronisation:</A>
</H4>
  VampirTrace provides several mechanisms for timer synchronization (&#8658;   Section&nbsp;<A HREF="#sec:timer_synchronization">3.7</A>). In addition it is also possible to
  initiate a timer synchronization at any point of the application by calling
  <TT>VT_TIMESYNC</TT>. Please note that the user has to ensure that all
  processes are actual at a synchronized point in the program (e.g. at a barrier).
  To use this call make sure that the enhanced timer synchronization is activated
  (set the environment variable <TT>VT_ETIMESYNC</TT> &#8658; Section&nbsp;<A HREF="#sec:env_variables">3.2</A>). 

<P>

<H4><A NAME="SECTION00342050000000000000">
Intermediate counter update:</A>
</H4> 
  VampirTrace provides the functionality to collect the values of arbitrary
  hardware counters. Chosen counter values are automatically recorded whenever
  an event occurs. Sometimes (e.g. within a long-lasting function) it is desirable
  to get the counter values at an arbitrary point within the program. To record
  the counter values at any given point you can call <TT>VT_UPDATE_COUNTER</TT>.

<P>

<H4><A NAME="SECTION00342060000000000000">
Note:</A>
</H4>
  For all three languages the instrumented sources have to be compiled 
  with <TT>-DVTRACE</TT>. Otherwise the <TT>VT_*</TT> calls are ignored.
<BR>
In addition, if the sources contains further VampirTrace API calls and only the
  calls for measurement controls shall be disabled, then the sources have to be
  compiled with <TT>-DVTRACE_NO_CONTROL</TT>, too.

<P>

<H1><A NAME="SECTION00350000000000000000"></A>
<A NAME="sec:tauinst"></A>
<BR>
Source Instrumentation Using PDT/TAU
</H1>
  TAU instrumentation combines the advantages of compiler and manual instrumentation and has further advantages.
  Like compiler instrumentation it works automatically, like on manual instrumentation you have a filtered set of events,
  this is especially recommended for C++, because STL-constructor calls are suppressed.
  Unlike with compiler instrumentation you get an optimized binary - this solves the issue described in Section <A HREF="#subsec:inlinenotes">2.3.3</A>.
  In the simpliest case you just run the compiler wrappers with <TT>-vt:inst tauinst</TT> option:

<P>
<BR>
<BR>
<code>   % vtcc -vt:inst tauinst hello.c -o hello</code>
<BR>
<BR>

<P>

<H4><A NAME="SECTION00350010000000000000">
Requirements for TAU instrumentation:</A>
</H4>
  To work with TAU instrumenation you need the Program Database Toolkit.
  You have to make sure, to have <TT>cparse</TT> and <TT>tau_instrumentor</TT> in your <TT>$PATH</TT>. 
  The PDToolkit can be downloaded from http://www.cs.uoregon.edu/research/pdt/home.php.

<H4><A NAME="SECTION00350020000000000000">
Include/Exclude Lists:</A>
</H4>
  <TT>tau_instrumentor</TT> provides a mechanism to include and exclude files or functions
  from instrumenation. The lists are deposed
<BR>
in a single file, that 
  is announced to <TT>tau_instrumentor</TT> via the option
<BR><TT>-f &lt;filename&gt;</TT>.
  This file contains up to four lists which begin with
<BR><TT>BEGIN[_FILE]_&lt;INCLUDE|EXCLUDE&gt;_LIST</TT>.
  The names in between may contain wildcards as ``?'', ``*', and ``#'', each entry gets a new line.
  The lists end with <TT>END[_FILE]_&lt;INCLUDE|EXCLUDE&gt;_LIST</TT>. For further information on selective 
  profiling have a look at the TAU documentation<A NAME="tex2html4"
  HREF="#foot1640"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A>.
  To announce the file through the compiler wrapper use the option <TT>-vt:tau</TT>:
<PRE>
   % vtcc -vt:inst tauinst hello.c -o hello \
     -vt:tau '-f &lt;filename&gt;'
</PRE>
<H1><A NAME="SECTION00360000000000000000"></A>
<A NAME="sec:dyninst"></A>
<BR>
Binary Instrumentation Using Dyninst
</H1>

<P>
The option <TT>-vt:inst dyninst</TT> is used with the compiler wrapper to 
instrument the application during runtime (binary instrumentation), by using 
Dyninst<A NAME="tex2html5"
  HREF="#foot1641"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A>.
Recompiling is not necessary for this kind of instrumentation,
but relinking:

<P>
<BR>
<BR>
<code>   % vtfort -vt:inst dyninst hello.o -o hello</code>
<BR>
<BR>
<BR>
The compiler wrapper dynamically links the library <TT>libvt-dynatt.so</TT>
  to the  application. This library attaches the <SPAN  CLASS="textit">mutator</SPAN>-program
  <TT>vtdyn</TT> during runtime which invokes the instrumentation by using Dyninst.

<P>
To prevent certain functions from being instrumented you can use the runtime function
  filtering as explained in Section&nbsp;<A HREF="#sec:function_filter">5.1</A>. All additional overhead,
  due to instrumentation of these functions, will be removed.

<P>
VampirTrace also allows binary instrumentation of functions located in shared libraries.
  For this to work a colon-separated list of shared library names has to be given in
  the environment variable <TT>VT_DYN_SHLIBS</TT>:

<P>
<BR>
<BR>
  <code>   VT_DYN_SHLIBS=libsupport.so:libmath.so</code>
  <BR>
<BR>

<P>

<H2><A NAME="SECTION00361000000000000000"></A>
<A NAME="sec:static_dyninst"></A>
<BR>
Static Binary Instrumentation
</H2>
In order to avoid the overhead introduced by Dyninst during runtime, the tool 
<TT>vtdyn</TT> can be used for binary instrumentation before application launch.
To accomplish this, the <TT>-o</TT> or <TT>-output</TT> switch can be used to 
specify the output binary. Note that the application must be linked to the corresponding
VampirTrace library.

<P>

<H4><A NAME="SECTION00361010000000000000">
Example</A>
</H4> 
To apply binary instrumentation to the executable <TT>a.out</TT> the following 
command is nescessary:

<P>
<BR>
<BR>
<code>	% vtdyn -o dyninst_a.out ./a.out</code>
<BR>
<BR>

<P>

<H1><A NAME="SECTION00370000000000000000"></A>
<A NAME="sec:runtime_instrumentation"></A>
<BR>
Runtime Instrumentation Using VTRun
</H1>
Besides the already described instrumentation at compile-time, VampirTrace also 
supports runtime instrumention using the <TT>vtrun</TT> command. Prepending the actual
call to the application will transparently add instrumentation support and launch the 
application. This includes support function instrumentation by Dyninst (Section&nbsp;<A HREF="#sec:dyninst">2.6</A>)
as well as MPI communication tracing. In order to enable instrumentation for user
functions the user has to specify the <TT>-dyninst</TT> command line switch.

<P>

<H4><A NAME="SECTION00370010000000000000">
Example</A>
</H4>
In order to add tracing support to an already existing executable, only a small change to 
the startup command has to be made. Assuming the usual way of calling the 
application looks like:

<P>
<BR>
<BR>
<code>	% mpirun -np 4 ./a.out </code>
<BR>
<BR>

<P>
By putting the call to <TT>vtrun</TT> directly before the actual application call, instrumention 
support will be enabled at runtime:

<P>
<BR>
<BR>
<code>	% mpirun -np 4 vtrun ./a.out</code>
<BR>
<BR>

<P>
For more information about the tool <TT>vtrun</TT> see Section&nbsp;<A HREF="#sec:VTRUN">B.6</A>.

<P>

<H1><A NAME="SECTION00380000000000000000"></A>
<A NAME="sec:jvmti"></A>
<BR>
Tracing Java Applications Using JVMTI
</H1>
  In addition to C, C++, and Fortran, VampirTrace is capable of tracing Java
  applications. This is accomplished by means of the Java Virtual Machine Tool
  Interface (JVMTI) which is part of JDK versions 5 and later.
  If VampirTrace was built with Java tracing support, the library <TT>libvt-java.so</TT>
  can be used as follows to trace any Java program: 

<P>
<BR>
<BR>
  <code>   % java -agentlib:vt-java ...</code>
  <BR>
<BR>

<P>
Or more easier, by replacing the usal Java application launcher <TT>java</TT> by the command <TT>vtjava</TT>:

<P>
<BR>
<BR>
  <code>  % vtjava ...                 </code>
  <BR>
<BR>

<P>
When tracing Java applications, you probably want to filter out dispensable
  function calls. Please have a look at Sections&nbsp;<A HREF="#sec:function_filter">5.1</A>
  and&nbsp;<A HREF="#sec:java_filter">5.2</A> to learn about different ways for excluding parts of the
  application from tracing.

<P>

<H1><A NAME="SECTION00390000000000000000"></A>
<A NAME="sec:3rd-party"></A>
<BR>
Tracing Calls to 3rd-Party Libraries
</H1>
  VampirTrace is also capable to trace calls to third party libraries, which come with
  at least one C header file even without the library's source code. If VampirTrace was
  built with support for library tracing (the CTool library<A NAME="tex2html6"
  HREF="#foot1642"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A>  is required), the tool <TT>vtlibwrapgen</TT> can be used to
  generate a wrapper library to intercept each call to the actual library functions.
  This wrapper library can be linked to the application or used in combination with the
  <TT>LD_PRELOAD</TT> mechanism provided by Linux.
  The generation of a wrapper library is done using the <TT>vtlibwrapgen</TT> 
  command and consists of two steps. The first step generates a C source file, 
  providing the wrapped functions of the library header file:

<P>
<BR>
<BR>
  <code>  % vtlibwrapgen -g SDL -o SDLwrap.c /usr/include/SDL/*.h</code>
  <BR>
<BR>

<P>
This generates the source file <TT>SDLwrap.c</TT> that contains wrapper-functions for
  all library functions found in the header-files located in /usr/include/SDL/ and
  instructs VampirTrace to assign these functions to the new group <TT>SDL</TT>.

<P>
The generated wrapper source file can be edited in order to add manual instrumentation
  or alter attributes of the library wrapper. A detailed description can be found in the 
  generated source file or in the header file <TT>vt_libwrap.h</TT> which can be found in the 
  include directory of VampirTrace.

<P>
To adapt the library instrumentation it is possible to pass a filter file to
  the generation process. The rules are like these for normal VampirTrace instrumentation
  (see Section&nbsp;<A HREF="#sec:function_filter">5.1</A>), where only 0 (exclude functions) and -1 (generally include
  functions) are allowed.
<BR>
<P>
The second step is to compile the generated source file:

<P>
<BR>
<BR>
  <code>  % vtlibwrapgen --build --shared -o libSDLwrap SDLwrap.c</code>
  <BR>
<BR>

<P>
This builds the shared library <TT>libSDLwrap.so</TT> which can be linked to the application
  or preloaded by using the environment variable <TT>LD_PRELOAD</TT>:

<P>
<BR>
<BR>
  <code>  % LD_PRELOAD=$PWD/libSDLwrap.so &lt;executable&gt;</code>
  <BR>
<BR>

<P>

<H1><A NAME="SECTION00400000000000000000"></A>
<A NAME="chap:runtime_measurement"></A>
<BR>
Runtime Measurement
</H1>

<P>
Running a VampirTrace instrumented application should normally result in an
OTF trace file in the current working directory where the application was
executed. If a problem occurs, set the environment variable
<TT>VT_VERBOSE</TT> to <TT>2</TT> before executing the instrumented application
in order to see control messages of the VampirTrace runtime system which might
help tracking down the problem.

<P>
The internal buffer of VampirTrace is limited to 32 MB per process. Use the environment
variables <TT>VT_BUFFER_SIZE</TT> and <TT>VT_MAX_FLUSHES</TT> to increase
this limit. Section&nbsp;<A HREF="#sec:trace_file_size">3.3</A> contains further information on
how to influence trace file size.

<P>

<H1><A NAME="SECTION00410000000000000000"></A>
<A NAME="sec:tracefilename"></A>
<BR>
Trace File Name and Location
</H1>

<P>
The default name of the trace file depends on the operating system where the
application is run. On Linux, MacOS and Sun Solaris the trace file will
be named like the application, e.g.&nbsp;<TT>hello.otf</TT> for the executable <TT>hello</TT>.
For other systems, the default name is <TT>a.otf</TT>.
Optionally, the trace file name can be defined manually by setting the environment
variable <TT>VT_FILE_PREFIX</TT> to the desired name. The suffix <TT>.otf</TT>
will be added automatically.

<P>
To prevent overwriting of trace files by repetitive program runs,
one can enable unique trace file naming by setting <TT>VT_FILE_UNIQUE</TT> to <TT>yes</TT>.
In this case, VampirTrace adds a unique number to the file names as soon as a second
trace file with the same name is created.
A <TT>*.lock</TT> file is used to count up the number of trace files in a directory.
Be aware that VampirTrace potentially overwrites an existing trace file
if you delete this lock file.
The default value of <TT>VT_FILE_UNIQUE</TT> is <TT>no</TT>.
You can also set this variable to a number greater than zero,
which will be added to the trace file name. This way you can manually control
the unique file naming.

<P>
The default location of the final trace file is the working directory at application
start time. If the trace file shall be stored in another place, use
<TT>VT_PFORM_GDIR</TT> as described in Section&nbsp;<A HREF="#sec:env_variables">3.2</A>
to change the location of the trace file.

<P>

<H1><A NAME="SECTION00420000000000000000"></A>
<A NAME="sec:env_variables"></A>
<BR>
Environment Variables
</H1>
The following environment variables can be used to control the measurement
of a VampirTrace instrumented executable:

<P>

<P>
<TABLE CELLPADDING=3>
<TR><TH ALIGN="LEFT"><SPAN  CLASS="textbf">Variable</SPAN></TH>
<TH ALIGN="LEFT"><SPAN  CLASS="textbf">Purpose</SPAN></TH>
<TH ALIGN="LEFT"><SPAN  CLASS="textbf">Default</SPAN></TH>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_GLOBAL_SETTINGS"></A> </TD>
<TD ALIGN="LEFT">
<BR>
	<SPAN  CLASS="textbf">Global Settings</SPAN> 
	<BR></TD>
<TD></TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_APPPATH"></A><TT>VT_APPPATH</TT></TD>
<TD ALIGN="LEFT">Path to the application executable.
	<BR>
	&#8658; Section&nbsp;<A HREF="#subsec:nmnotes">2.3.2</A></TD>
<TD ALIGN="LEFT">-</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_BUFFER_SIZE"></A><TT>VT_BUFFER_SIZE</TT></TD>
<TD ALIGN="LEFT">Size of internal event trace buffer per process. This is the place where
	event records are stored, before being written to OTF.
	<BR>
	&#8658; Section&nbsp;<A HREF="#sec:trace_file_size">3.3</A></TD>
<TD ALIGN="LEFT">32M</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_CLEAN"></A><TT>VT_CLEAN</TT></TD>
<TD ALIGN="LEFT">Remove temporary trace files?</TD>
<TD ALIGN="LEFT">yes</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_COMPRESSION"></A><TT>VT_COMPRESSION</TT></TD>
<TD ALIGN="LEFT">Write compressed trace files?</TD>
<TD ALIGN="LEFT">yes</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_COMPRESSION_BSIZE"></A><TT>VT_COMPRESSION_BSIZE</TT></TD>
<TD ALIGN="LEFT">Size of the compression buffer in OTF.</TD>
<TD ALIGN="LEFT">OTF default</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_FILE_PREFIX"></A><TT>VT_FILE_PREFIX</TT></TD>
<TD ALIGN="LEFT">Prefix used for trace filenames.</TD>
<TD ALIGN="LEFT">&#8658;Sect.<A HREF="#sec:tracefilename">3.1</A></TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_FILE_UNIQUE"></A><TT>VT_FILE_UNIQUE</TT></TD>
<TD ALIGN="LEFT">Enable unique trace file naming?
        Set to yes, no, or a numerical ID.
<BR>
	&#8658; Section&nbsp;<A HREF="#sec:tracefilename">3.1</A></TD>
<TD ALIGN="LEFT">no</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_MAX_FLUSHES"></A><TT>VT_MAX_FLUSHES</TT></TD>
<TD ALIGN="LEFT">Maximum number of buffer flushes.
	<BR>
	&#8658; Section&nbsp;<A HREF="#sec:trace_file_size">3.3</A></TD>
<TD ALIGN="LEFT">1</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_MAX_SNAPSHOTS"></A><TT>VT_MAX_SNAPSHOTS</TT></TD>
<TD ALIGN="LEFT">Maximum number of snapshots to generate.</TD>
<TD ALIGN="LEFT">1024</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_MAX_THREADS"></A><TT>VT_MAX_THREADS</TT></TD>
<TD ALIGN="LEFT">Maximum number of threads per process that VampirTrace reserves resources for.</TD>
<TD ALIGN="LEFT">65536</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_OTF_BUFFER_SIZE"></A><TT>VT_OTF_BUFFER_SIZE</TT></TD>
<TD ALIGN="LEFT">Size of internal OTF buffer. This buffer contains OTF-encoded
	trace data that is written to file at once.</TD>
<TD ALIGN="LEFT">OTF default</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_PFORM_GDIR"></A><TT>VT_PFORM_GDIR</TT></TD>
<TD ALIGN="LEFT">Name of global directory to store final trace file in.</TD>
<TD ALIGN="LEFT"><TT>./</TT></TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_PFORM_LDIR"></A><TT>VT_PFORM_LDIR</TT></TD>
<TD ALIGN="LEFT">Name of node-local directory which can be used to store temporary trace files.</TD>
<TD ALIGN="LEFT"><TT>/tmp/</TT></TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_SNAPSHOTS"></A><TT>VT_SNAPSHOTS</TT></TD>
<TD ALIGN="LEFT">Enable snapshot generation? Allows Vampir to load subsets of the resulting trace.</TD>
<TD ALIGN="LEFT">yes</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_THREAD_BUFFER_SIZE"></A><TT>VT_THREAD_BUFFER_SIZE</TT></TD>
<TD ALIGN="LEFT">Size of internal event trace buffer per thread. If not defined, the 
	size is set to 10% of <TT>VT_BUFFER_SIZE</TT>.
	<BR>
	&#8658; Section&nbsp;<A HREF="#sec:trace_file_size">3.3</A></TD>
<TD ALIGN="LEFT">0</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_UNIFY"></A><TT>VT_UNIFY</TT></TD>
<TD ALIGN="LEFT">Unify local trace files afterwards?</TD>
<TD ALIGN="LEFT">yes</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_VERBOSE"></A><TT>VT_VERBOSE</TT></TD>
<TD ALIGN="LEFT">Level of VampirTrace related information messages:
        Quiet (0), Critical (1), Information (2)</TD>
<TD ALIGN="LEFT">1</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_IOFSL"></A></TD>
<TD ALIGN="LEFT">
<BR>
	<SPAN  CLASS="textbf">I/O Forwarding (IOFSL)</SPAN>
	<BR></TD>
<TD></TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_IOFSL_ASYNC_IO"></A><TT>VT_IOFSL_ASYNC_IO</TT></TD>
<TD ALIGN="LEFT">Enable buffered IOFSL writes?
	<BR>
	&#8658; Section&nbsp;<A HREF="#sec:iofsl-manual">D.4.2</A></TD>
<TD ALIGN="LEFT">no</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_IOFSL_SERVERS"></A><TT>VT_IOFSL_SERVERS</TT></TD>
<TD ALIGN="LEFT">Comma-separated list of IOFSL server addresses.
	<BR>
	&#8658; Section&nbsp;<A HREF="#sec:iofsl-manual">D.4.2</A></TD>
<TD ALIGN="LEFT">-</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_IOFSL_MODE"></A><TT>VT_IOFSL_MODE</TT></TD>
<TD ALIGN="LEFT">Mode of the IOFSL communication:
	<BR>
	(MULTIFILE_SPLIT or MULTIFILE)
	<BR>
	&#8658; Section&nbsp;<A HREF="#sec:iofsl-manual">D.4.2</A></TD>
<TD ALIGN="LEFT">MULTIFILE_SPLIT</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_OPTIONAL_FEATURES"></A></TD>
<TD ALIGN="LEFT">
<BR>
	<SPAN  CLASS="textbf">Optional Features</SPAN> 
	<BR></TD>
<TD></TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_CPUIDTRACE"></A><TT>VT_CPUIDTRACE</TT></TD>
<TD ALIGN="LEFT">Enable tracing of core ID of a CPU?
	<BR>
	&#8658; Section <A HREF="#sec:cpu_id_counter">4.4</A></TD>
<TD ALIGN="LEFT">no</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_ETIMESYNC"></A><TT>VT_ETIMESYNC</TT></TD>
<TD ALIGN="LEFT">Enable enhanced timer synchronization?
	<BR>
	&#8658; Section <A HREF="#sec:timer_synchronization">3.7</A></TD>
<TD ALIGN="LEFT">no</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_ETIMESYNC_INTV"></A><TT>VT_ETIMESYNC_INTV</TT></TD>
<TD ALIGN="LEFT">Interval between two successive synchronization phases in s.</TD>
<TD ALIGN="LEFT">120</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_GPUTRACE"></A><TT>VT_GPUTRACE</TT></TD>
<TD ALIGN="LEFT">Comma-separated list of GPU tracing options. <BR>
	&#8658; Section&nbsp;<A HREF="#sec:cuda">4.5</A></TD>
<TD ALIGN="LEFT">no</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_IOLIB_PATHNAME"></A><TT>VT_IOLIB_PATHNAME</TT></TD>
<TD ALIGN="LEFT">Provides an alternative library to use for LIBC I/O calls.
	&#8658; Section&nbsp;<A HREF="#sec:io_calls">4.8</A></TD>
<TD ALIGN="LEFT">-</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_IOTRACE"></A><TT>VT_IOTRACE</TT></TD>
<TD ALIGN="LEFT">Enable tracing of application I/O calls?
	<BR>
	&#8658; Section&nbsp;<A HREF="#sec:io_calls">4.8</A></TD>
<TD ALIGN="LEFT">no</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_IOTRACE_EXTENDED"></A><TT>VT_IOTRACE_EXTENDED</TT></TD>
<TD ALIGN="LEFT">Enable tracing of additional function argument for application I/O calls?
	<BR>
	&#8658; Section&nbsp;<A HREF="#sec:io_calls">4.8</A></TD>
<TD ALIGN="LEFT">no</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_EXECTRACE"></A><TT>VT_EXECTRACE</TT></TD>
<TD ALIGN="LEFT">Enable tracing of function calls for creating and controling child processes?
	<BR>
	&#8658; Section&nbsp;<A HREF="#sec:exec_calls">4.9</A></TD>
<TD ALIGN="LEFT">yes</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_MEMTRACE"></A><TT>VT_MEMTRACE</TT></TD>
<TD ALIGN="LEFT">Enable memory allocation counter?
	<BR>
	&#8658; Section&nbsp;<A HREF="#sec:mem_alloc_counter">4.3</A></TD>
<TD ALIGN="LEFT">no</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_MODE"></A><TT>VT_MODE</TT></TD>
<TD ALIGN="LEFT">Colon-separated list of VampirTrace modes: Tracing (TRACE), Profiling (STAT).
	<BR>
	&#8658; Section&nbsp;<A HREF="#sec:profiling">3.4</A></TD>
<TD ALIGN="LEFT">TRACE</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_MPICHECK"></A><TT>VT_MPICHECK</TT></TD>
<TD ALIGN="LEFT">Enable MPI correctness checking via UniMCI?</TD>
<TD ALIGN="LEFT">no</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_MPICHECK_ERREXIT"></A><TT>VT_MPICHECK_ERREXIT</TT></TD>
<TD ALIGN="LEFT">Force trace write and application exit if an MPI usage error is detected?</TD>
<TD ALIGN="LEFT">no</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_MPITRACE"></A><TT>VT_MPITRACE</TT></TD>
<TD ALIGN="LEFT">Enable tracing of MPI events?</TD>
<TD ALIGN="LEFT">yes</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_MPI_IGNORE_FILTER"></A><TT>VT_MPI_IGNORE_FILTER</TT></TD>
<TD ALIGN="LEFT">Enable tracing of MPI communication events although its corresponding functions are filtered?</TD>
<TD ALIGN="LEFT">no</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_OMPTRACE"></A><TT>VT_OMPTRACE</TT></TD>
<TD ALIGN="LEFT">Enable tracing of OpenMP events instrumented by OPARI?</TD>
<TD ALIGN="LEFT">yes</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_PTHREAD_REUSE"></A><TT>VT_PTHREAD_REUSE</TT></TD>
<TD ALIGN="LEFT">Reuse IDs of terminated Pthreads?</TD>
<TD ALIGN="LEFT">yes</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_STAT_INTV"></A><TT>VT_STAT_INTV</TT></TD>
<TD ALIGN="LEFT">Length of interval in ms for writing the next profiling record</TD>
<TD ALIGN="LEFT">0</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_STAT_PROPS"></A><TT>VT_STAT_PROPS</TT></TD>
<TD ALIGN="LEFT">Colon-separated list of event types that shall be recorded in profiling mode:
        Functions (FUNC), Messages (MSG), Collective Ops. (COLLOP) or all of them
	(ALL)
      	<BR>
	&#8658; Section&nbsp;<A HREF="#sec:profiling">3.4</A></TD>
<TD ALIGN="LEFT">ALL</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_SYNC_FLUSH"></A><TT>VT_SYNC_FLUSH</TT></TD>
<TD ALIGN="LEFT">Enable synchronized buffer flush?
	<BR>
	&#8658; Section <A HREF="#sec:buffer_flush">3.6</A></TD>
<TD ALIGN="LEFT">no</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_SYNC_FLUSH_LEVEL"></A><TT>VT_SYNC_FLUSH_LEVEL</TT></TD>
<TD ALIGN="LEFT">Minimum buffer fill level for synchronized buffer flush in percent.</TD>
<TD ALIGN="LEFT">80</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_COUNTERS"></A></TD>
<TD ALIGN="LEFT">
<BR>
	<SPAN  CLASS="textbf">Counters</SPAN> 
	<BR></TD>
<TD></TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_CUPTI_METRICS"></A><TT>VT_CUPTI_METRICS</TT></TD>
<TD ALIGN="LEFT">Specify CUDA hardware counter metrics (CUPTI events) to be recorded with trace events 
	as a colon/VT_METRICS_SEP-separated list of names.
	<BR>
	&#8658; Section&nbsp;<A HREF="#sec:cuda">4.5</A></TD>
<TD ALIGN="LEFT">-</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_CUPTI_EVENTS_SAMPLING"></A><TT>VT_CUPTI_EVENTS_SAMPLING</TT></TD>
<TD ALIGN="LEFT">Sample CUDA hardware counters during the execution of a kernel.
	<BR>
	&#8658; Section&nbsp;<A HREF="#sec:cuda">4.5</A></TD>
<TD ALIGN="LEFT">no</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_METRICS"></A><TT>VT_METRICS</TT></TD>
<TD ALIGN="LEFT">Specify counter metrics to be recorded with trace events as a
	colon/VT_METRICS_SEP-separated list of names.
	<BR>
	&#8658; Section&nbsp;<A HREF="#sec:hw_perf_counters">4.1</A></TD>
<TD ALIGN="LEFT">-</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_METRICS_SEP"></A><TT>VT_METRICS_SEP</TT></TD>
<TD ALIGN="LEFT">Separator string between counter specifications in VT_METRICS.</TD>
<TD ALIGN="LEFT">:</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_PLUGIN_CNTR_METRICS"></A><TT>VT_PLUGIN_CNTR_METRICS</TT></TD>
<TD ALIGN="LEFT">Colon-separated list of plugin counter metrics which shall be recorded.
	<BR>
	&#8658; Section&nbsp;<A HREF="#sec:plugin_counter_metrics">4.7</A></TD>
<TD ALIGN="LEFT">-</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_RUSAGE"></A><TT>VT_RUSAGE</TT></TD>
<TD ALIGN="LEFT">Colon-separated list of resource usage counters which shall be recorded.
	<BR>
	&#8658; Section&nbsp;<A HREF="#sec:rusage_counters">4.2</A></TD>
<TD ALIGN="LEFT">-</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_RUSAGE_INTV"></A><TT>VT_RUSAGE_INTV</TT></TD>
<TD ALIGN="LEFT">Sample interval for recording resource usage counters in ms.</TD>
<TD ALIGN="LEFT">100</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_DYNINST"></A></TD>
<TD ALIGN="LEFT">
<BR>
	<SPAN  CLASS="textbf">Binary Instrumentation (Dyninst)</SPAN>
	<BR></TD>
<TD></TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_DYN_DETACH"></A><TT>VT_DYN_DETACH</TT></TD>
<TD ALIGN="LEFT">Detach Dyninst mutator-program <TT>vtdyn</TT> from application process?</TD>
<TD ALIGN="LEFT">yes</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_DYN_IGNORE_NODBG"></A><TT>VT_DYN_IGNORE_NODBG</TT></TD>
<TD ALIGN="LEFT">Disable instrumentation of functions which have no debug information?</TD>
<TD ALIGN="LEFT">no</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_DYN_INNER_LOOPS"></A><TT>VT_DYN_INNER_LOOPS</TT></TD>
<TD ALIGN="LEFT">Instrument inner loops within outer loops?
	<BR>
	(implies <TT>VT_DYN_OUTER_LOOPS=yes</TT>)</TD>
<TD ALIGN="LEFT">no</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_DYN_LOOP_ITERS"></A><TT>VT_DYN_LOOP_ITERS</TT></TD>
<TD ALIGN="LEFT">Instrument loop iterations? 
	<BR>
	(implies <TT>VT_DYN_OUTER_LOOPS=yes</TT>)</TD>
<TD ALIGN="LEFT">no</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_DYN_OUTER_LOOPS"></A><TT>VT_DYN_OUTER_LOOPS</TT></TD>
<TD ALIGN="LEFT">Instrument outer loops within functions?</TD>
<TD ALIGN="LEFT">no</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_DYN_SHLIBS"></A><TT>VT_DYN_SHLIBS</TT></TD>
<TD ALIGN="LEFT">Colon-separated list of shared libraries for Dyninst instrumentation.
	<BR>
	&#8658; Section&nbsp;<A HREF="#sec:dyninst">2.6</A></TD>
<TD ALIGN="LEFT">-</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_FILTERING_GROUPING"></A></TD>
<TD ALIGN="LEFT">
<BR>
	<SPAN  CLASS="textbf">Filtering, Grouping</SPAN> 
	<BR></TD>
<TD></TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_FILTER_SPEC"></A><TT>VT_FILTER_SPEC</TT></TD>
<TD ALIGN="LEFT">Name of function/region filter file.
	<BR>
	&#8658; Section&nbsp;<A HREF="#sec:function_filter">5.1</A></TD>
<TD ALIGN="LEFT">-</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_GROUPS_SPEC"></A><TT>VT_GROUPS_SPEC</TT></TD>
<TD ALIGN="LEFT">Name of function grouping file.
	<BR>
	&#8658; Section&nbsp;<A HREF="#sec:function_groups">5.3</A></TD>
<TD ALIGN="LEFT">-</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_JAVA_FILTER_SPEC"></A><TT>VT_JAVA_FILTER_SPEC</TT></TD>
<TD ALIGN="LEFT">Name of Java specific filter file.
	<BR>
	&#8658; Section&nbsp;<A HREF="#sec:java_filter">5.2</A></TD>
<TD ALIGN="LEFT">-</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_JAVA_GROUP_CLASSES"></A><TT>VT_JAVA_GROUP_CLASSES</TT></TD>
<TD ALIGN="LEFT">Create a group for each Java class automatically?</TD>
<TD ALIGN="LEFT">yes</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_MAX_STACK_DEPTH"></A><TT>VT_MAX_STACK_DEPTH</TT></TD>
<TD ALIGN="LEFT">Maximum number of stack level to be traced.
	<BR>
	(0 = unlimited)</TD>
<TD ALIGN="LEFT">0</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_ONOFF_CHECK_STACK_BALANCE"></A><TT>VT_ONOFF_CHECK_STACK_BALANCE</TT></TD>
<TD ALIGN="LEFT">Check stack level balance when switching tracing on/off.
	<BR>
	&#8658; Section&nbsp;<A HREF="#subsec:onoff">2.4.2</A></TD>
<TD ALIGN="LEFT">yes</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_SYMBOL_LIST"></A></TD>
<TD ALIGN="LEFT">
<BR>
	<SPAN  CLASS="textbf">Symbol List</SPAN> 
	<BR></TD>
<TD></TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_GNU_NM"></A><TT>VT_GNU_NM</TT></TD>
<TD ALIGN="LEFT">Command to list symbols from object files.
        <BR>
	&#8658; Section&nbsp;<A HREF="#sec:compinst">2.3</A></TD>
<TD ALIGN="LEFT">nm</TD>
</TR>
<TR><TD ALIGN="LEFT"><A NAME="VT_SETUP_VT_GNU_NMFILE"></A><TT>VT_GNU_NMFILE</TT></TD>
<TD ALIGN="LEFT">Name of file with symbol list information.
	<BR>
	&#8658; Section&nbsp;<A HREF="#sec:compinst">2.3</A></TD>
<TD ALIGN="LEFT">-</TD>
</TR>
</TABLE>

<P>
The variables <TT>VT_PFORM_GDIR</TT>, <TT>VT_PFORM_LDIR</TT>, <TT>VT_FILE_PREFIX</TT>
may contain (sub)strings of the form <TT>$XYZ</TT> or <TT>${XYZ}</TT> where
<TT>XYZ</TT> is the name of another environment variable.
Evaluation of the environment variable is done at measurement runtime.

<P>
When you use these environment variables, make sure that they have the same
value for all processes of your application on <SPAN  CLASS="textbf">all</SPAN> nodes of your cluster.
Some cluster environments do not automatically transfer your environment
when executing parts of your job on remote nodes of the cluster, and you
may need to explicitly set and export them in batch job submission scripts.

<P>

<H1><A NAME="SECTION00430000000000000000"></A>
<A NAME="sec:trace_file_size"></A>
<BR>
Influencing Trace Buffer Size
</H1>

<P>
The default values of the environment variables <TT>VT_BUFFER_SIZE</TT> and 
<TT>VT_MAX_FLUSHES</TT> limit the internal buffer of VampirTrace to
32 MB per process and the number of times that the buffer is flushed to 1, 
respectively. Events that are to be recorded after the limit has been reached
are no longer written into the trace file. The environment variables apply 
to every process of a parallel application, meaning that applications with 
<SPAN  CLASS="textit">n</SPAN> processes will typically create trace files <SPAN  CLASS="textit">n</SPAN> times 
the size of a serial application.

<P>
To remove the limit and get a complete trace of an application, set 
<TT>VT_MAX_FLUSHES</TT> to <TT>0</TT>. This causes VampirTrace to always
write the buffer to disk when it is full. To change the size of the
buffer, use the environment variable <TT>VT_BUFFER_SIZE</TT>. The optimal value for
this variable depends on the application which is to be traced. Setting a
small value will increase the memory available to the application, but
will trigger frequent buffer flushes by VampirTrace. These buffer flushes can
significantly change the behavior of the application. On the other hand,
setting a large value, like <TT>2G</TT>, will minimize buffer flushes by
VampirTrace, but decrease the memory available to the application. If not
enough memory is available to hold the VampirTrace buffer and the application
data, parts of the application may be swapped to disk, leading
to a significant change in the behavior of the application.

<P>
<SPAN  CLASS="textbf">In multi-threaded applications</SPAN> a single buffer cannot be shared across a process 
and the associated threads for performance reasons. Thus independent 
buffers are created for every process and thread, at which the process buffer 
size is 70% and the thread buffer size is 10% of the value set in 
<TT>VT_BUFFER_SIZE</TT>. 
The buffer size of processes and threads can be explicitly specified setting 
the environment variable <TT>VT_THREAD_BUFFER_SIZE</TT>, which defines the 
buffer size of a thread, whereas the buffer size of a process is then defined 
by the value of <TT>VT_BUFFER_SIZE</TT>.
The total memory consumption of the application is calculated as follows  
(assuming that every process has the same number of threads):
<DL COMPACT>
<DT>a)</DT>
<DD>M = N * VT_BUFFER_SIZE * 0.7 + N * T * VT_BUFFER_SIZE * 0.1 
<BR>    <SMALL CLASS="SCRIPTSIZE">(VT_THREAD_BUFFER_SIZE is <TT>not</TT> specified) </SMALL>
  </DD>
<DT>b)</DT>
<DD>M = N * VT_BUFFER_SIZE + N * T * VT_THREAD_BUFFER_SIZE 
<BR>    <SMALL CLASS="SCRIPTSIZE">(VT_THREAD_BUFFER_SIZE is specified) </SMALL>
  </DD>
</DL>
<SMALL CLASS="FOOTNOTESIZE">M ... total allocated memory&nbsp;&nbsp;&nbsp;N ... number of processes&nbsp;&nbsp;&nbsp;T ... number of threads per process
</SMALL> 
<P>
<BR>

<P>
Note that you can decrease the size of trace files significantly by
using the runtime function filtering as explained in Section&nbsp;<A HREF="#sec:function_filter">5.1</A>.

<P>

<H1><A NAME="SECTION00440000000000000000"></A>
<A NAME="sec:profiling"></A>
<BR>
Profiling an Application
</H1>
Profiling an application collects aggregated information about certain events during 
a program run, whereas tracing records information about individual events.
Profiling can therefore be used to get a summary of the program activity and to detect events
that are called very often.
The profiling information can also be used to generate filter rules to reduce
the trace file size (&#8658; Section&nbsp;<A HREF="#sec:function_filter">5.1</A>).

<P>
To profile an application set the variable <TT>VT_MODE</TT> to <TT>STAT</TT>.
Setting <TT>VT_MODE</TT> to <TT>STAT:TRACE</TT> tells VampirTrace to perform tracing and profiling at the same time.
By setting the variable <TT>VT_STAT_PROPS</TT> the user can influence whether functions, messages, and/or collective operations
shall be profiled. See Section&nbsp;<A HREF="#sec:env_variables">3.2</A> for information about these environment variables. 

<P>

<H1><A NAME="SECTION00450000000000000000"></A>
<A NAME="sec:unification"></A>
<BR>
Unification of Local Traces
</H1>

<P>
After a run of an instrumented application the traces of the single
processes need to be <SPAN  CLASS="textit">unified</SPAN> in terms of timestamps and event IDs.
In most cases, this happens automatically.
If the environment variable <TT>VT_UNIFY</TT> is set to <TT>no</TT> or under
certain circumstances it is necessary to perform unification of local traces
manually. To do this, use the following command:

<P>
<BR>
<BR>
<code>   % vtunify &lt;prefix&gt;</code>
<BR>
<BR>
<BR>
<P>
If VampirTrace was built with support for OpenMP and/or MPI, it is possible to
speedup the unification of local traces significantly. To distribute the unification
on multible processes the MPI parallel version <TT>vtunify-mpi</TT> can be used as
follow:

<P>
<BR>
<BR>
<code>   % mpirun -np &lt;nranks&gt; vtunify-mpi &lt;prefix&gt;</code>
<BR>
<BR>
<BR>
<P>
Furthermore, both tools <TT>vtunify</TT> and <TT>vtunify-mpi</TT> are capable to
open additional OpenMP threads for unification. The number of threads can be specified
by the <TT>OMP_NUM_THREADS</TT> environment variable.

<P>

<H1><A NAME="SECTION00460000000000000000"></A>
<A NAME="sec:buffer_flush"></A>
<BR>
Synchronized Buffer Flush
</H1>
When tracing an application, VampirTrace temporarily stores the recorded events
in a trace buffer. Typically, if a buffer of a process or thread has reached its
maximum fill level, the buffer has to be flushed and other processes or threads maybe 
have to wait for this process or thread. This will result in an asynchronous
runtime behavior. <BR>
To avoid this problem, VampirTrace provides a buffer flush in a synchronized 
manner. That means, if one buffer has reached its minimum buffer fill level 
<TT>VT_SYNC_FLUSH_LEVEL</TT> (&#8658; Section&nbsp;<A HREF="#sec:env_variables">3.2</A>), all
buffers will be flushed.
This buffer flush is only available at appropriate points in the program flow. 
Currently, VampirTrace makes use of all MPI collective functions associated with 
 <TT>MPI_COMM_WORLD</TT>. Use the environment variable 
<TT>VT_SYNC_FLUSH</TT> to enable synchronized buffer flush.

<P>

<H1><A NAME="SECTION00470000000000000000"></A>
<A NAME="sec:timer_synchronization"></A>
<BR>
Enhanced Timer Synchronization
</H1>

<P>
Especially on cluster environments, where each process has its own local timer,
tracing relies on precisely synchronized timers. Therefore, VampirTrace provides
several mechanisms for timer synchronization. The default synchronization scheme is a
linear synchronization at the very begin and the very end of a trace run with a
master-slave communication pattern. <BR>
However, this way of synchronization can become to imprecise for long trace runs.
Therefore, we recommend the usage of the enhanced timer synchronization scheme of 
VampirTrace. This scheme inserts additional synchronization phases at appropriate
points in the program flow. Currently, VampirTrace makes use of all MPI collective
functions associated with <TT>MPI_COMM_WORLD</TT>.
<BR>
To enable this synchronization scheme, a LAPACK library with C wrapper support has to be 
provided for VampirTrace and the environment variable  
<TT>VT_ETIMESYNC</TT> (&#8658; Section&nbsp;<A HREF="#sec:env_variables">3.2</A>)
has to be set before the tracing.
<BR>
The length of the interval between two successive synchronization phases can be 
adjusted with <TT>VT_ETIMESYNC_INTV</TT>.
<BR>
The following LAPACK libraries provide a C-LAPACK API that can be used by VampirTrace
for the enhanced timer synchronization:

<UL>
<LI>CLAPACK <A NAME="tex2html7"
  HREF="#foot1652"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A>
</LI>
<LI>AMD ACML
</LI>
<LI>IBM ESSL
</LI>
<LI>Intel MKL
</LI>
<LI>SUN Performance Library
</LI>
</UL>

<P>

<H4><A NAME="SECTION00470010000000000000">
Note:</A>
</H4>
  Systems equipped with a global timer do not need timer synchronization.

<P>

<H4><A NAME="SECTION00470020000000000000">
Note:</A>
</H4>
  It is recommended to combine enhanced timer synchronization and synchronized buffer flush.

<P>

<H4><A NAME="SECTION00470030000000000000">
Note:</A>
</H4>
  Be aware that the asynchronous behavior of the application will be disturbed since VampirTrace
  makes use of asynchronous MPI collective functions for timer synchronization and synchronized
  buffer flush.
<BR>
Only make use of these approaches, if your application does not rely on an asynchronous behavior!
  Otherwise, keep this fact in mind during the process of performance analysis.

<P>

<H1><A NAME="SECTION00480000000000000000"></A>
<A NAME="sec:vtsetup"></A>
<BR>
Environment Configuration Using VTSetup
</H1>

<P>
In order to ease the process of configuring the runtime environment, the graphical 
tool <TT>vtsetup</TT> has been added to the VampirTrace toolset. With the help
of a graphical user interface, required environment variables can be configured. 
The following option categories can be managed:

<P>

<UL>
<LI><SPAN  CLASS="textbf">General Trace Settings</SPAN>: Configre the name of the executable 
			as well as the trace filename and set the trace buffer size.
</LI>
<LI><SPAN  CLASS="textbf">Optional Trace Features</SPAN>: Activate optional trace features, e.g. I/O 
			tracing and tracing of memory usage.
</LI>
<LI><SPAN  CLASS="textbf">Counters</SPAN>: Activate PAPI counter and resource usage counter.
</LI>
<LI><SPAN  CLASS="textbf">Filtering and Grouping</SPAN>: Guided setup of filters and
			function group definitions.
</LI>
</UL>

<P>
Furthermore, the user is granted more fine-grained control by activating the 
<SPAN  CLASS="textit">Advanced View</SPAN> button. The configuration can be saved to an XML file. 
After successfull configuration, the application can be launched directly or a 
script can be generated for manual execution.

<P>

<H1><A NAME="SECTION00500000000000000000">
Recording Additional Events and Counters</A>
</H1>

<P>

<H1><A NAME="SECTION00510000000000000000"></A>
<A NAME="sec:hw_perf_counters"></A>
<BR>
Hardware Performance Counters
</H1>

<P>
If VampirTrace has been built with hardware counter support , it is capable of recording hardware counter
  information as part of the event records. To request the measurement of
  certain counters, the user is required to set the environment variable <TT>VT_METRICS</TT>.
  The variable should contain a colon-separated list of counter names
  or a predefined platform-specific group.

<P>
The user can leave the environment variable unset to indicate that no
  counters are requested. If any of the requested counters are not recognized
  or the full list of counters cannot be recorded due to hardware resource
  limits, program execution will be aborted with an error message.

<P>

<H2><A NAME="SECTION00511000000000000000">
PAPI Hardware Performance Counters</A>
</H2>

<P>
If the PAPI library is used to access hardware performance counters,
  metric names can be any PAPI preset names or PAPI native counter names. 
  For example, set

<P>
<BR>
<BR>
  <code>   VT_METRICS=PAPI_FP_OPS:PAPI_L2_TCM:!CPU_TEMP1</code>
  <BR>
<BR>
<BR>
to record the number of floating point instructions and level 2 cache misses (PAPI preset counters), 
  cpu temperature from the lm_sensors component.
  The leading exclamation mark let CPU_TEMP1 be interpreted as absolute value counter.
  See Section&nbsp;<A HREF="#sec:papi">C.1</A> for a full list of PAPI preset counters.

<P>

<H2><A NAME="SECTION00512000000000000000">
CPC Hardware Performance Counters</A>
</H2>

<P>
On Sun Solaris operating systems VampirTrace can make use of the CPC
  performance counter library to query the processor's hardware performance counters.
  The counters which are actually available on your platform can be queried with
  the tool <TT>vtcpcavail</TT>. The listed names can then be used within
  <TT>VT_METRICS</TT> to tell VampirTrace which counters to record.

<P>

<H2><A NAME="SECTION00513000000000000000">
NEC SX Hardware Performance Counters</A>
</H2>

<P>
On NEC SX machines VampirTrace uses special register calls to query the processor's 
  hardware counters. Use <TT>VT_METRICS</TT> to specify the counters that have to be
  recorded. See Section&nbsp;<A HREF="#sec:necsx_pc">C.3</A> for a full list of NEC SX hardware performance 
  counters.

<P>

<H1><A NAME="SECTION00520000000000000000"></A>
<A NAME="sec:rusage_counters"></A>
<BR>
Resource Usage Counters
</H1>

<P>
The Unix system call <TT>getrusage</TT> provides information about consumed
  resources and operating system events of processes
  such as user/system time, received signals, and context switches.

<P>
If VampirTrace has been built with resource usage support, it is able
  to record this information as performance counters to the trace.
  You can enable tracing of specific resource counters by setting the environment
  variable <TT>VT_RUSAGE</TT> to a colon-separated list of counter names, as
  specified in Section&nbsp;<A HREF="#sec:rusage_list">C.4</A>. For example, set

<P>
<BR>
<BR>
  <code>   VT_RUSAGE=ru_stime:ru_majflt</code>
  <BR>
<BR>
<BR>
to record the system time consumed by each process and the number of page faults.
  Alternatively, one can set this variable to the value <TT>all</TT> to
  enable recording of all 16 resource usage counters.
  Note that not all counters are supported by all Unix operating systems.
  Linux 2.6 kernels, for example, support only resource information for six of them.
  See Section&nbsp;<A HREF="#sec:rusage_list">C.4</A> and the manual page of <TT>getrusage</TT> for details.

<P>
The resource usage counters are not recorded at every event.
  They are only read if 100ms have passed since the last sampling.
  The interval can be changed by setting <TT>VT_RUSAGE_INTV</TT>
  to the number of desired milliseconds.
  Setting <TT>VT_RUSAGE_INTV</TT> to zero leads to sampling resource
  usage counters at every event, which may introduce a large runtime overhead.
  Note that in most cases the operating system does not update the resource usage information 
  at the same high frequency as the hardware performance counters.
  Setting <TT>VT_RUSAGE_INTV</TT> to a value less than 10ms does usually not
  improve the granularity.

<P>
Be aware that, when using the resource usage counters for multi-threaded programs,
  the information displayed is valid for the whole process and not for each single thread.
  
<P>

<H1><A NAME="SECTION00530000000000000000"></A>
<A NAME="sec:mem_alloc_counter"></A>
<BR>
Memory Allocation Counter
</H1>

<P>
Calls to functions which reside in external libraries can be intercepted by
  implementing identical functions and linking them before the external library.
  Such ``wrapper functions'' can record the parameters and return values of the
  library functions.

<P>
If VampirTrace has been built with memory allocation tracing support , it uses this technique for recording calls to
  memory (de)allocation functions of the standard C library, which are executed by the application.
  The following functions are intercepted by VampirTrace:

<P>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>malloc</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>memalign</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>calloc</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>posix_memalign</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>realloc</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>valloc</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>free</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110>&nbsp;</TD>
</TR>
</TABLE>

<P>
The gathered information will be saved as counter which indicates the current memory allocated
  in bytes.  To request the measurement of the application's allocated memory, the user must set the
  environment variable <TT>VT_MEMTRACE</TT> to <TT>yes</TT>.

<P>

<H4><A NAME="SECTION00530010000000000000">
Note:</A>
</H4>
  VampirTrace currently does not support memory allocation tracing for threaded programs, e.g.,
  programs parallelized with OpenMP or Pthreads!

<P>

<H1><A NAME="SECTION00540000000000000000"></A>
<A NAME="sec:cpu_id_counter"></A>
<BR>
CPU ID Counter
</H1>

<P>
The GNU LIBC implementation provides a function to determine the core id of a CPU on which the calling
  thread is running. VampirTrace uses this functionality to record the current core identifier as
  counter. This feature can be activated by setting the environment variable
  <TT>VT_CPUIDTRACE</TT> to <TT>yes</TT>.

<P>

<H4><A NAME="SECTION00540010000000000000">
Note:</A>
</H4>
  To use this feature you need the GNU LIBC implementation at least in version
  2.6.

<P>

<H1><A NAME="SECTION00550000000000000000"></A>
<A NAME="sec:cuda"></A>
<BR>
NVIDIA CUDA
</H1>
  When tracing CUDA applications, only user events and functions are recorded,
  which are automatically or manually instrumented. CUDA API functions
  will not be traced by default.
  To enable tracing of CUDA runtime and driver API functions and CUDA device 
  activities (like kernel execution and memory copies) build VampirTrace with 
  CUDA support and set the following environment variable:

<P>
<DIV ALIGN="CENTER">
<TT>export VT_GPUTRACE=[yes|default|no]</TT>
<BR></DIV>
<P></P>
<DIV ALIGN="CENTER">
</DIV>  

<P>
To enable a particular composition of CUDA measurement features the variable 
  should contain a comma-separated list of available CUDA measurement options.

<P>
<DIV ALIGN="CENTER">
<TT>export VT_GPUTRACE=option1,option2,option2,...</TT>
<BR></DIV>
<P></P>
<DIV ALIGN="CENTER">
</DIV>

<P>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT"><TT>cuda</TT></TD>
<TD ALIGN="LEFT">enable CUDA (needed to use CUDA runtime API wrapper)</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">(OpenCL is available in VampirTrace GPU beta releases)</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>cupti</TT></TD>
<TD ALIGN="LEFT">use the CUPTI interface instead of the library wrapper</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>runtime</TT></TD>
<TD ALIGN="LEFT">CUDA runtime API</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>driver</TT></TD>
<TD ALIGN="LEFT">CUDA driver API</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>kernel</TT></TD>
<TD ALIGN="LEFT">CUDA kernels</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>concurrent</TT></TD>
<TD ALIGN="LEFT">force recording of concurrent kernels with CUPTI</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>idle</TT></TD>
<TD ALIGN="LEFT">GPU compute idle time</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>pure_idle</TT></TD>
<TD ALIGN="LEFT">GPU idle time - considering data transfers as not idle</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">(acts as <TT>idle</TT> for CUDA runtime API wrapper)</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>memcpy</TT></TD>
<TD ALIGN="LEFT">CUDA memory copies</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>sync</TT></TD>
<TD ALIGN="LEFT">enable recording of synchronization for tracing via CUPTI</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>stream_reuse</TT></TD>
<TD ALIGN="LEFT">force reusing of CUDA streams after cudaStreamDestroy()</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>memusage</TT></TD>
<TD ALIGN="LEFT">CUDA memory allocation</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>debug</TT></TD>
<TD ALIGN="LEFT">CUDA tracing debug mode</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>error</TT></TD>
<TD ALIGN="LEFT">CUDA errors will exit the program</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>yes|default</TT></TD>
<TD ALIGN="LEFT">same as ``cuda,runtime,kernel,memcpy''</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>no</TT></TD>
<TD ALIGN="LEFT">disable CUDA measurement</TD>
</TR>
</TABLE>
<BR><P></P>

<P>
Since CUDA Toolkit 4.1 the <SPAN  CLASS="textbf">CUDA</SPAN> <SPAN  CLASS="textbf">P</SPAN>rofiling and <SPAN  CLASS="textbf">T</SPAN>ool <SPAN  CLASS="textbf">I</SPAN>nterface 
  (CUPTI) allows capturing of CUDA device activities. VampirTrace trace has currently 
  two methods to trace the CUDA runtime API and corresponding GPU activities: 
  traditional library wrapping with CUDA events for GPU activity measurement and 
  tracing via the CUPTI interface. Several features are 
  just implemented in the library wrapping approach, whereas the CUPTI 
  measurement brings new possibilities and occasionally more accuracy. 
<P><P>
<BR>

<P>
The new environment variable <TT>VT_GPUTRACE</TT> replaces several 
  previously available environment variables. 
  However, there are still additional feature switches implemented as environment 
  variables to further refine CUDA tracing (the default is <TT><SPAN  CLASS="textbf">bold</SPAN></TT>):
  <DL>
<DT></DT>
<DD><TT>VT_GPUTRACE_KERNEL=[<SPAN  CLASS="textbf">yes</SPAN>|2]</TT>
<BR>
Tracing of CUDA kernels can be enabled with '<TT>yes</TT>'. This is the same 
      as adding the option <TT>kernel</TT> to <TT>VT_GPUTRACE</TT>. 
      With '<TT>2</TT>' additional kernel counters are captured. (CUPTI tracing only)

<P>
</DD>
<DT></DT>
<DD><TT>VT_GPUTRACE_SYNC=[0|1|2|<SPAN  CLASS="textbf">3</SPAN>]</TT>
<BR>
Controls how VampirTrace handles synchronizing CUDA API calls, especially 
      CUDA memory copies and CUDA device synchronization. 
      At level 0 only the CUDA calls will be executed, messages will be 
      displayed from the beginning to the end of the <SPAN  CLASS="textit">cudaMemcpy</SPAN>, regardless how 
      long the <SPAN  CLASS="textit">cudaMemcpy</SPAN> call has to wait for a kernel until the actual 
      data transfer starts. 
      At level 1 the <SPAN  CLASS="textit">cudaMemcpy</SPAN> will be split into an additional synchronization 
      and the actual data transfer in order to monitor the data transfer correctly. 
      The additional synchronization does not affect the program execution 
      significantly and will not be shown in the trace.
      At level 2 the additional synchronization will be exposed to the user. 
      This allows a better view on the application execution, showing how much 
      time is actually spent waiting for the GPU to complete. 
      Level 3 will further use the synchronization to flush the internal task 
      buffer and perform a timer synchronization between GPU and host. This 
      introduces a minimal overhead but increases timer precision and prevents 
      flushes elsewhere in the trace.

<P>
</DD>
<DT></DT>
<DD><TT>VT_CUPTI_METRICS</TT>
<BR>
Capture CUDA CUPTI counters. Metrics are separated by default with '':`` 
      or user specified by <TT>VT_METRICS_SEP</TT>.
<BR>
Example: <TT>VT_CUPTI_METRICS=local_store:local_load</TT>

<P>
</DD>
<DT></DT>
<DD><TT>VT_CUPTI_EVENTS_SAMPLING=[yes|<SPAN  CLASS="textbf">no</SPAN>]</TT>
<BR>
Poll for CUPTI counter values during kernel execution, if set to <TT>yes</TT>.

<P>
</DD>
<DT></DT>
<DD><TT>VT_GPUTRACE_MEMUSAGE=[<SPAN  CLASS="textbf">yes</SPAN>|2]</TT>
<BR>
Record GPU memory usage as counter ``gpu_mem_usage``, if set to <TT>yes</TT>, 
      which is the same as adding the option <TT>memusage</TT> to <TT>VT_GPUTRACE</TT>. 
      With '<TT>2</TT>' missing <SPAN  CLASS="textit">cudaFree()</SPAN> calls are printed to stderr.
 
</DD>
</DL>

<P>
Every CUDA stream, which is executed on a cuda-capable device and 
  used during program execution, creates an own thread. ``CUDA-Threads'' can 
  contain CUDA communication, kernel and counter records and have the following notation:

<P>
<DIV ALIGN="CENTER">
<TT>CUDA[device:stream] process:thread</TT>
  
</DIV>

<P>
Due to an issue with CUPTI, the device is not always properly 
  shown (<TT>device</TT> is displayed as <TT>?</TT>). The CUDA stream number is 
  increasing, beginning with the default stream <TT>1</TT>. The stream number 
  provided by CUPTI might not be evenly increasing. CUDA streams without records 
  will not be written. 
<P></P>

<P>
If CUDA libraries are used, which create CUDA streams themselves, 
  many CUDA threads (CUDA streams per device) can appear in a program trace. 
  In that case, it may be useful to force reusing of CUDA streams (add option 
  <TT>stream_reuse</TT> to <TT>VT_GPUTRACE</TT>). This enables VampirTrace to 
  reuse an existing thread buffer of a destroyed CUDA stream and therewith 
  reduces the number of separate CUDA threads (or streams) in the trace. The 
  CUDA stream number will then be missing in the CUDA thread notation. 
<P></P>

<P>
As kernels and asynchronous memory copies are executed asynchronously 
  on the CUDA device, information about these activities will be buffered until 
  a synchronizing CUDA API function call or the program exits. 
  Every used CUDA device and its corresponding host thread has an own buffer 
  (8192 bytes by default), when CUDA tracing is done via the CUDA runtime API wrapper. 
  If the buffer is full, it will be flushed immediately. 
  When using CUDA tracing via CUPTI every CUDA context creation initiates the 
  allocation of an own buffer (65536 bytes by default). If the buffer is full, 
  further records will be dropped and a warning will be shown in <SPAN  CLASS="textit">stderr</SPAN> output. 
  The buffer size can be specified in bytes with the environment variable 
  <TT>VT_CUDATRACE_BUFFER_SIZE</TT>.
<P></P>

<P>
Several new region groups have been introduced:
  <DIV ALIGN="CENTER">

    <TABLE CELLPADDING=3>
<TR><TH ALIGN="LEFT"><SPAN  CLASS="textbf">CUDART_API</SPAN></TH>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=269>CUDA runtime API calls</TD>
</TR>
<TR><TH ALIGN="LEFT"><SPAN  CLASS="textbf">CUDRV_API</SPAN></TH>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=269>CUDA driver API calls</TD>
</TR>
<TR><TH ALIGN="LEFT"><SPAN  CLASS="textbf">CUDA_SYNC</SPAN></TH>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=269>CUDA synchronization</TD>
</TR>
<TR><TH ALIGN="LEFT"><SPAN  CLASS="textbf">CUDA_KERNEL</SPAN></TH>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=269>CUDA kernels (device functions) can only appear on 
			      ``CUDA-Threads''</TD>
</TR>
<TR><TH ALIGN="LEFT"><SPAN  CLASS="textbf">GPU_IDLE</SPAN></TH>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=269>GPU compute idle time - the CUDA device does not run any 
			      kernel currently (shown in first used stream of 
                              the device)</TD>
</TR>
<TR><TH ALIGN="LEFT"><SPAN  CLASS="textbf">VT_CUDA</SPAN></TH>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=269>Measurement overhead (write CUDA events, 
			      check current device, etc.)</TD>
</TR>
</TABLE>
</DIV>

<P>

<H3><A NAME="SECTION00550100000000000000">
Tracing CUDA Runtime API via CUPTI</A>
</H3>
  If the VampirTrace CUDA runtime API wrapper and CUPTI are configured during 
  the VampirTrace build process, the option <TT>cupti</TT> has to be added to 
  <TT>VT_GPUTRACE</TT> to enable CUDA runtime API tracing via CUPTI. In that 
  case the CUDA runtime library should be preloaded to reduce tracing overhead 
  (the dynamic linker can use  <TT>LD_PRELOAD=libcudart.so</TT>). Otherwise 
  the library wrapper intercepts every CUDA runtime API call and makes a short 
  but unnecessary check, whether it is enabled. 
<P></P>

<P>
Synchronous CUDA peer-to-peer memory copies will only be recorded,
  if the <TT>sync</TT> option is set and the synchronization level is 3 (default).

<P>

<H3><A NAME="SECTION00550200000000000000">
CUDA Runtime API Wrapper Particularities</A>
</H3>
  CUDA tracing via this method will always record the CUDA runtime API
  calls. It is not possible to only record kernels, memory copies or memory 
  usage. CUDA driver API programs cannot be traced with the CUDA runtime API 
  wrapper. 
<P></P>

<P>
Until CUDA Toolkit 4.2 the usage of CUDA events between 
  asynchronous tasks serializes their on-device execution. 
  As VampirTrace uses CUDA events for time measurement and asynchronous tasks 
  may overlap (depends on the CUDA device capability), there might be a sensible 
  impact on the program flow. CUDA 5 removes this restriction.

<P>

<H3><A NAME="SECTION00550300000000000000">
Counter via CUDA API</A>
</H3>
  If <TT>VT_GPUTRACE_MEMUSAGE</TT> is enabled, CUDA memory allocations on the 
  GPU will be tracked to write the GPU memory usage counter 
  <TT>gpu_mem_usage</TT>. The counter values will be written directly to the 
  default CUDA stream '1'. This stream will be 
  created, if it does not exist and does not have to contain any other CUDA 
  device activities. If the environment variable is set to <TT>2</TT>, missing 
  <SPAN  CLASS="textit">cudaFree()</SPAN> calls will be printed to stderr.
<P></P>

<P>
With kernel tracing enabled there are three counters, which provide 
  information about the kernel's grid, block and thread composition: 
  <TT>blocks_per_grid</TT>, <TT>threads_per_block</TT>, <TT>threads_per_kernel</TT>.
  With CUPTI tracing additional kernel counters are available: static and 
  dynamic shared memory, total local memory and registers per thread 
  (<TT>VT_GPUTRACE_KERNEL=2</TT>).

<P>

<H3><A NAME="SECTION00550400000000000000">
CUDA Performance Counters via CUPTI Events</A>
</H3>
  To capture performance counters in CUDA applications, CUPTI events can be 
  specified with the environment variable <TT>VT_CUPTI_METRICS</TT>. Counters 
  are separated by default with '':`` or user specified by 
  <TT>VT_METRICS_SEP</TT>. The <SPAN  CLASS="textit">CUPTI User's Guide - Event Reference</SPAN> 
  provides information about the available counters. Alternatively set 
  <TT>VT_CUPTI_METRICS=help</TT> to show a list of available counters 
  (<TT>help_long</TT> to print the counter description as well). This will only 
  take effect, when a kernel is about to be executed. 

<P>

<H3><A NAME="SECTION00550500000000000000">
Compile and Link CUDA Applications</A>
</H3>
  Use the VampirTrace compiler wrapper <TT>vtnvcc</TT> instead of <TT>nvcc</TT> 
  to compile the CUDA application, which does automatic source code instrumentation.
<P></P>

<BR>
<P>
<SMALL CLASS="SMALL"><SPAN  CLASS="textbf">GCC4.3 and OpenMP:</SPAN></SMALL>
<BR>
Use the flags <TT>-vt:opari -nodecl -Xcompiler=-fopenmp</TT> with <TT>vtnvcc</TT> 
  to compile the OpenMP CUDA application.
<P></P>

<BR>
<P>
<SMALL CLASS="SMALL"><SPAN  CLASS="textbf">CUDA 3.1:</SPAN></SMALL>
<BR>
The CUDA runtime library 3.1 creates a conflict with <TT>zlib</TT>. 
  A workaround is to replace all 
  <TT>gcc/g++</TT> calls with the VampirTrace compiler wrappers 
  (<TT>vtcc/vtc++</TT>) and pass the following additional flags to 
  <TT>nvcc</TT> for compilation of the kernels:
  <PRE>
  -I$VT_INSTALL_PATH/include/vampirtrace
  -L$VT_INSTALL_PATH/lib 
  -Xcompiler=-g,-finstrument-functions,-pthread
  -lvt -lopen-trace-format -lcudart -lz -ldl -lm
</PRE>
  <SMALL CLASS="FOOTNOTESIZE"><TT>$VT_INSTALL_PATH</TT> is the path to the VampirTrace installation 
  directory. It is not necessary to specify the VampirTrace include and library 
  path, if it is installed in the default directory.
<BR>  </SMALL>

<P>
This uses automatic compiler instrumentation (<TT>-finstrument-functions</TT>) 
  and the standard VampirTrace library. Replace the <TT>-lvt</TT> with 
  <TT>-lvt-mt</TT> for multithreaded, <TT>-lvt-mpi</TT> for MPI and 
  <TT>-lvt-hyb</TT> for multithreaded MPI applications. In this case the CUDA 
  runtime library is linked before the <TT>zlib</TT>. 
<P></P>

<P>
If the application is linked with <TT>gcc/g++</TT>, the linking command has to ensure, 
  that the respective VampirTrace library is linked before the CUDA runtime 
  library <TT>libcudart.so</TT> (check e.g. with ``ldd <SPAN  CLASS="textit">executable</SPAN>''). 
  Using the VampirTrace compiler wrappers (<TT>vtcc/vtc++</TT>) for linking is 
  the easiest way to ensure correct linking of the VampirTrace library.
<P></P>

<P>
With the library tracing mechanism described in section <A HREF="#sec:3rd-party">2.9</A>, 
  it is possible to trace CUDA applications without recompiling or relinking. 
  There are only events written for Runtime API calls, kernels and communication 
  between host and device.

<P>

<H3><A NAME="SECTION00550600000000000000">
Tracing the NVIDIA CUDA Sample Applications</A>
</H3>
  <SMALL CLASS="SMALL"><SPAN  CLASS="textbf">CUDA 3.x and 4.x:</SPAN></SMALL>
<BR>
To get some example traces, replace the compiler commands in the common 
  Makefile include file (<TT>common/common.mk</TT>) with the corresponding 
  VampirTrace compiler wrappers (&#8658;<A HREF="#sec:compiler_wrappers">2.1</A>) for 
  automatic instrumentation:
  <PRE>
  # Compilers
  NVCC := vtnvcc
  CXX  := vtc++
  CC   := vtcc
  LINK := vtc++ #-vt:mt
</PRE>

<P>
<SMALL CLASS="SMALL"><SPAN  CLASS="textbf">CUDA 5.0:</SPAN></SMALL>
<BR>
Set the following environment variables for automatic instrumentation before 
  running <TT>make</TT>:
  <PRE>
  export GCC=vtc++ #-vt:mt
  export NVCC=vtnvcc #-vt:mt
</PRE>

<P>
Use the compiler switches for MPI, multi-threaded 
  and hybrid programs, if necessary (e.g. the CUDA SDK example 
  <TT>simpleMultiGPU</TT> is a multi-threaded program, which needs to be linked 
  with a multi-threaded VampirTrace library). 

<P>

<H3><A NAME="SECTION00550700000000000000">
Recording Concurrent Kernels (CUDA 5)</A>
</H3>
  Since CUDA 5 it is possible to record concurrently executed kernels on the GPU. 
  The VampirTrace CUDA runtime API wrapper uses CUDA events for GPU activity 
  time measurement and is therefore by default enabled for recording concurrent 
  kernels. The NVIDIA CUPTI library provides two possibilities for measuring 
  kernels. If a CUDA application creates the second CUDA stream, the activity 
  buffer will be flushed, the light-weight kernel recording disabled and 
  concurrent kernel recording enabled. To force concurrent kernel support at 
  VampirTrace CUDA initialization add the GPU tracing option <TT>concurrent</TT>.
  
<P><P>
<BR>

<BR>
<P>
<SPAN  CLASS="textbf">Notes:</SPAN>
<BR>
For 32-bit systems VampirTrace has to be configured with the 32-bit 
  version of the CUDA runtime library. If the link test fails, use the 
  following configure option :
  <PRE>
  --with-cuda-lib-dir=$CUDA_INSTALL_PATH/lib
</PRE>

<P>
To build CUPTI support on 32-bit systems (or for CUPTI 1.0), 
  VampirTrace has to be configured with the 32-bit version of the CUPTI library. 
  If the link test fails, use the 
  following configure option :
  <PRE>
  --with-cupti-lib-dir=$CUPTI_INSTALL_PATH/lib
</PRE>

<P>
VampirTrace CUDA support has been successfully tested with CUDA 
  toolkit version 3.x, 4.x and 5.0.

<P>

<H1><A NAME="SECTION00560000000000000000"></A>
<A NAME="sec:pthread_calls"></A>
<BR>
Pthread API Calls
</H1>
  When tracing applications with Pthreads, only user events and 
  functions are recorded which are automatically or manually instrumented. 
  Pthread API functions will not be traced by default.
<BR>
To enable tracing of all C-Pthread API functions include the header
  <TT>vt_user.h</TT> and compile the instrumented sources with 
  <TT>-DVTRACE_PTHREAD</TT>. 
<PRE>
C/C++:
           #include "vt_user.h"
</PRE>
<BR>
<BR>
<code>   % vtcc </code><TT><SPAN  CLASS="textbf">-DVTRACE_PTHREAD</SPAN></TT><code> hello.c -o hello</code>
<BR>
<BR>
<BR>
<P>

<H4><A NAME="SECTION00560010000000000000">
Note:</A>
</H4> Currently, Pthread instrumentation is only available for C/C++.

<P>

<H1><A NAME="SECTION00570000000000000000"></A>
<A NAME="sec:plugin_counter_metrics"></A>
<BR>
Plugin Counter Metrics
</H1>
  Plugin Counter add additional metrics to VampirTrace. They highly depend on
  the plugins, which are installed on your system. Every plugin should provide a
  README, which should be checked for available metrics.
  Once you have downloaded and compiled a plugin, copy the resulting library to
  a folder, which is part of your <TT>LD_LIBRARY_PATH</TT>.
  To enable the tracing of a specific metric, you should set the environment
  variable <TT>VT_PLUGIN_CNTR_METRICS</TT>. It is set in the following manner
<PRE>
export VT_PLUGIN_CNTR_METRICS=&lt;library_name&gt;_&lt;event_name&gt;
</PRE>
  If you have for example a library named <TT>libKswEvents.so</TT> with the
  event <TT>page_faults</TT>, the you can set it with
<PRE>
export VT_PLUGIN_CNTR_METRICS=KswEvents_page_faults
</PRE>
Visit http://www.tu-dresden.de/zih/vampirtrace/plugin_counter for 
documentation and examples.

<H4><A NAME="SECTION00570010000000000000">
Note:</A>
</H4> Multiple events can be concatenated by using colons.

<P>

<H1><A NAME="SECTION00580000000000000000"></A>
<A NAME="sec:io_calls"></A>
<BR>
I/O Calls
</H1>

<P>
If VampirTrace has been built with I/O tracing support , it uses the same technique as used to intercept
  memory (de)allocation functions (&#8658; Section&nbsp;<A HREF="#sec:mem_alloc_counter">4.3</A>) for recording calls
  to I/O functions of the standard C library, which are executed by the application. The following
  functions are intercepted by VampirTrace:

<P>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>close</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>creat</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>creat64</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>dup</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>dup2</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>fclose</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>fcntl</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>fdopen</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>fgetc</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>fgets</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>flockfile</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>fopen</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>fopen64</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>fprintf</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>fputc</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>fputs</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>fread</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>fscanf</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>fseek</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>fseeko</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>fseeko64</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>fsetpos</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>fsetpos64</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>ftrylockfile</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>funlockfile</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>fwrite</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>getc</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>gets</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>lockf</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>lseek</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>lseek64</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>open</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>open64</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>pread</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>pread64</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>putc</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>puts</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>pwrite</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>pwrite64</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>read</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>readv</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>rewind</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>unlink</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>write</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>writev</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110>&nbsp;</TD>
</TR>
</TABLE>

<P>
The gathered information will be saved as I/O event records in the trace file. This feature has
  to be activated for each tracing run by setting the environment variable <TT>VT_IOTRACE</TT> to
  <TT>yes</TT>.

<P>
If you'd like to experiment with some other I/O library, set the environment variable <TT>VT_IOLIB_PATHNAME</TT>
  to the alternative one. Beware that this library must provide all I/O functions mentioned above
  otherwise VampirTrace will abort. Setting the environment variable <TT>VT_IOTRACE_EXTENDED</TT> to <TT>yes</TT>
  enables the collection of additional function arguments for some of the I/O function mentioned above.
  For example, this option stores offsets for <TT>pwrite</TT> and <TT>pread</TT> additionally to the
  I/O event record. Enabling <TT>VT_IOTRACE_EXTENDED</TT> automatically enables <TT>VT_IOTRACE</TT>.

<P>

<H1><A NAME="SECTION00590000000000000000"></A>
<A NAME="sec:exec_calls"></A>
<BR>
Child Process Execution Calls
</H1>

<P>
In addition to the memory allocation tracing (&#8658; Section&nbsp;<A HREF="#sec:mem_alloc_counter">4.3</A>) and I/O tracing
  (&#8658; Section&nbsp;<A HREF="#sec:io_calls">4.8</A>), VampirTrace uses the library wrapping technique also to intercept
  functions of the standard C library for creating and controling child processes. These functions are:

<P>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>execl</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>execvp</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>fork</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>waitid</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>execlp</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>execve</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>system</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>wait3</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>execle</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>execvpe</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>wait</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>wait4</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>execv</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>fexecve</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>waitpid</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110>&nbsp;</TD>
</TR>
</TABLE>

<P>
When VampirTrace detects a call of an <TT>exec</TT> function, the current trace file is closed before
  executing the new program. If the executed program is also instrumented with VampirTrace, it will create
  a different trace file. Note that VampirTrace aborts if the <TT>exec</TT> function returns unsuccessfully.
  Calling <TT>fork</TT> in an instrumented program creates an additional process in the same trace file.
  Using this feature requires building VampirTrace with support for tracing LIBC functions for creating and , and setting
  the  environment variable <TT>VT_EXECTRACE</TT> to <TT>yes</TT>.

<P>

<H1><A NAME="SECTION005100000000000000000"></A>
<A NAME="sec:unimci"></A>
<BR>
MPI Correctness Checking Using UniMCI
</H1>

<P>
VampirTrace supports the recording of MPI correctness events, e.g., usage of invalid MPI requests. This is implemented by using the Universal MPI
  Correctness Interface (UniMCI), which provides an interface between tools like VampirTrace and existing runtime MPI correctness checking tools.
  Correctness events are stored as markers in the trace file and are visualized by Vampir.

<P>
If VampirTrace is built with UniMCI support, the user only has to enable MPI correctness checking. This is done by merely setting the environment
  variable <TT>VT_MPICHECK</TT> to <TT>yes</TT>. Further, if your application crashes due to an MPI error you should set
  <TT>VT_MPICHECK_ERREXIT</TT> to <TT>yes</TT>. This environmental variable forces VampirTrace to write its trace to disk and exit afterwards. As
  a result, the trace with the detected error is stored before the application might crash.

<P>
To install VampirTrace with correctness checking support it is necessary to have UniMCI installed on your system. UniMCI in turn requires you to
  have a supported MPI correctness checking tool installed, currently only the tool Marmot is known to have UniMCI support. So all in all you should
  use the following order to install with correctness checking support:
  
<OL>
<LI>Marmot
<BR>    (see http://www.hlrs.de/organization/av/amt/research/marmot)
</LI>
<LI>UniMCI
<BR>    (see http://www.tu-dresden.de/zih/unimci)
</LI>
<LI>VampirTrace
<BR>    (see http://www.tu-dresden.de/zih/vampirtrace)
  
</LI>
</OL>

<P>
Information on how to install Marmot and UniMCI is given in their respective manuals. VampirTrace will automatically detect an UniMCI installation
  if the <TT>unimci-config</TT> tool is in path.

<P>

<H1><A NAME="SECTION005110000000000000000"></A>
<A NAME="sec:userdefinedcounters"></A>
<BR>
User-defined Counters
</H1>

<P>
In addition to the manual instrumentation (&#8658; Section&nbsp;<A HREF="#sec:maninst">2.4</A>), the VampirTrace API
  provides instrumentation calls which allow recording of 
  program variable values (e.g. iteration counts, calculation results, ...) or any other 
  numerical quantity.
  A user-defined counter is identified by its name, the counter group it belongs to,
  the type of its value (integer or floating-point) and the unit that the value is 
  quoted (e.g.&nbsp;``GFlop/sec'').

<P>
The <TT>VT_COUNT_GROUP_DEF</TT> and <TT>VT_COUNT_DEF</TT> instrumentation
  calls can be used to define counter groups and counters:

<P>
<PRE>
Fortran:
           #include "vt_user.inc"
           integer :: id, gid
           VT_COUNT_GROUP_DEF('name', gid)
           VT_COUNT_DEF('name', 'unit', type, gid, id)
</PRE> 

<P>
<PRE>
C/C++:
           #include "vt_user.h"
           unsigned int id, gid;
           gid = VT_COUNT_GROUP_DEF("name");
           id = VT_COUNT_DEF("name", "unit", type, gid);
</PRE>

<P>
The definition of a counter group is optional. If no special counter group is desired,
  the default group ``User'' can be used.
  In this case, set the parameter <TT>gid</TT> of <TT>VT_COUNT_DEF()</TT> to
  <TT>VT_COUNT_DEFGROUP</TT>.

<P>
The third parameter <TT>type</TT> of <TT>VT_COUNT_DEF</TT> specifies the data
  type of the counter value. To record a value for any of the defined counters the 
  corresponding instrumentation call <TT>VT_COUNT_*_VAL</TT> must be invoked.

<P>

<P>
<TABLE CELLPADDING=3>
<TR><TH ALIGN="LEFT"><SPAN  CLASS="textbf">Fortran:</SPAN></TH>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TH ALIGN="LEFT"><SPAN  CLASS="textbf">Type</SPAN></TH>
<TD ALIGN="LEFT"><SPAN  CLASS="textbf">Count call</SPAN></TD>
<TD ALIGN="LEFT"><SPAN  CLASS="textbf">Data type</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>VT_COUNT_TYPE_INTEGER</TT></TD>
<TD ALIGN="LEFT"><TT>VT_COUNT_INTEGER_VAL</TT></TD>
<TD ALIGN="LEFT">integer (4 byte)</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>VT_COUNT_TYPE_INTEGER8</TT></TD>
<TD ALIGN="LEFT"><TT>VT_COUNT_INTEGER8_VAL</TT></TD>
<TD ALIGN="LEFT">integer (8 byte)</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>VT_COUNT_TYPE_REAL</TT></TD>
<TD ALIGN="LEFT"><TT>VT_COUNT_REAL_VAL</TT></TD>
<TD ALIGN="LEFT">real</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>VT_COUNT_TYPE_DOUBLE</TT></TD>
<TD ALIGN="LEFT"><TT>VT_COUNT_DOUBLE_VAL</TT></TD>
<TD ALIGN="LEFT">double precision</TD>
</TR>
</TABLE>

<P>
<TABLE CELLPADDING=3>
<TR><TH ALIGN="LEFT"><SPAN  CLASS="textbf">C/C++:</SPAN></TH>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TH ALIGN="LEFT"><SPAN  CLASS="textbf">Type</SPAN></TH>
<TD ALIGN="LEFT"><SPAN  CLASS="textbf">Count call</SPAN></TD>
<TD ALIGN="LEFT"><SPAN  CLASS="textbf">Data type</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>VT_COUNT_TYPE_SIGNED</TT></TD>
<TD ALIGN="LEFT"><TT>VT_COUNT_SIGNED_VAL</TT></TD>
<TD ALIGN="LEFT">signed int (max. 64-bit)</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>VT_COUNT_TYPE_UNSIGNED</TT></TD>
<TD ALIGN="LEFT"><TT>VT_COUNT_UNSIGNED_VAL</TT></TD>
<TD ALIGN="LEFT">unsigned int (max. 64-bit)</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>VT_COUNT_TYPE_FLOAT</TT></TD>
<TD ALIGN="LEFT"><TT>VT_COUNT_FLOAT_VAL</TT></TD>
<TD ALIGN="LEFT">float</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>VT_COUNT_TYPE_DOUBLE</TT></TD>
<TD ALIGN="LEFT"><TT>VT_COUNT_DOUBLE_VAL</TT></TD>
<TD ALIGN="LEFT">double</TD>
</TR>
</TABLE>

<P>
The following example records the loop index <TT>i</TT>:

<P>
<PRE>
Fortran:

  #include "vt_user.inc"

  program main
  integer :: i, cid, cgid

  VT_COUNT_GROUP_DEF('loopindex', cgid)
  VT_COUNT_DEF('i', '#', VT_COUNT_TYPE_INTEGER, cgid, cid)

  do i=1,100
    VT_COUNT_INTEGER_VAL(cid, i)
  end do

  end program main
</PRE> 

<P>
<PRE>
C/C++:

  #include "vt_user.h"

  int main() {
    unsigned int i, cid, cgid;

    cgid = VT_COUNT_GROUP_DEF('loopindex');
    cid = VT_COUNT_DEF("i", "#", VT_COUNT_TYPE_UNSIGNED,
                       cgid);

    for( i = 1; i &lt;= 100; i++ ) {
      VT_COUNT_UNSIGNED_VAL(cid, i);
    }

    return 0;
  }
</PRE>

<P>
For all three languages the instrumented sources have to be compiled 
  with <TT>-DVTRACE</TT>. Otherwise the <TT>VT_*</TT> calls are ignored.

<P>
Optionally, if the sources contain further VampirTrace API calls and only the
  calls for user-defined counters shall be disabled, then the sources have to be
  compiled with <TT>-DVTRACE_NO_COUNT</TT> in addition to <TT>-DVTRACE</TT>.

<P>

<H1><A NAME="SECTION005120000000000000000"></A>
<A NAME="sec:userdefinedmarkers"></A>
<BR>
User-defined Markers
</H1>

<P>
In addition to the manual instrumentation (&#8658; Section&nbsp;<A HREF="#sec:maninst">2.4</A>), the VampirTrace API
  provides instrumentation calls which allow recording of special user information, which 
  can be used to better identify parts of interest.
  A user-defined marker is identified by its name and type.

<P>
<PRE>
Fortran:
           #include "vt_user.inc"
           integer :: mid
           VT_MARKER_DEF('name', type, mid)
           VT_MARKER(mid, 'text')

C/C++:
           #include "vt_user.h"
           unsigned int mid;
           mid = VT_MARKER_DEF("name",type);
           VT_MARKER(mid, "text");

Types for Fortran/C/C++:
           VT_MARKER_TYPE_ERROR
           VT_MARKER_TYPE_WARNING
           VT_MARKER_TYPE_HINT
</PRE>

<P>
For all three languages the instrumented sources have to be compiled 
  with <TT>-DVTRACE</TT>. Otherwise the <TT>VT_*</TT> calls are ignored.

<P>
Optionally, if the sources contain further VampirTrace API calls and only the
  calls for user-defined markers shall be disabled, then the sources have to be
  compiled with <TT>-DVTRACE_NO_MARKER</TT> in addition to <TT>-DVTRACE</TT>.

<P>

<H1><A NAME="SECTION005130000000000000000"></A>
<A NAME="sec:userdefinedcomm"></A>
<BR>
User-defined Communcation
</H1>
In addition to the manual instrumentation (&#8658; Section&nbsp;<A HREF="#sec:maninst">2.4</A>), 
the VampirTrace API provides instrumentation calls which allow recording of 
special user information, which can be used to better identify parts of interest.
A user-defined communication operation is defined by a communicator and a tag.
The default communicator is <TT>VT_COMM_WORLD</TT>. 
Additionally, a user-defined communicator can be created using
<TT>VT_COMM_DEF</TT>:

<P>
<PRE>
Fortran:
         #include "vt_user.inc"
         integer :: cid
         VT_COMM_DEF('name', cid)
			
C/C++:
         #include "vt_user.h"
         unsigned cid;
         cid = VT_COMM_DEF("name", cid);
</PRE>

<P>
Using <TT>VT_SEND</TT> and <TT>VT_RECV</TT> the user
can insert send and receive events into the trace:

<P>
<PRE>
C/C++:
         int rank, size;
         MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);
         MPI_Comm_size(MPI_COMM_WORLD, &amp;size);

         if( rank == 0 )
         {
             for ( int i = 1; i &lt; size; i++ )
             {
                 VT_SEND(VT_COMM_WORLD,i,100);
             }  
         }else
         {
             VT_RECV(VT_COMM_WORLD,rank,100);
         }
</PRE>

<P>
The calls are similar for Fortran. 

<P>
As can be seen, the arguments to <TT>VT_SEND</TT> and <TT>VT_RECV</TT> 
are a communicator, a tag and the size of the message. The tag is required in order to
identify both ends of a user-defined communication. Therefore it has to be 
globally unique for a given communicator and cannot be reused within a single communicator.
Messages with duplicated tags will not be visible in the final trace.

<P>
For all three languages the instrumented sources have to be compiled 
with <TT>-DVTRACE</TT>. Otherwise the <TT>VT_*</TT> calls are ignored.
Optionally, if the sources contain further VampirTrace API calls and only the
calls for user-defined markers shall be disabled, then the sources have to be
compiled with <TT>-DVTRACE_NO_MSG</TT> in addition to <TT>-DVTRACE</TT>.

<P>

<H1><A NAME="SECTION00600000000000000000"></A>
<A NAME="filtering_and_grouping"></A>
<BR>
Filtering &amp; Grouping
</H1>

<P>

<H1><A NAME="SECTION00610000000000000000"></A>
<A NAME="sec:function_filter"></A>
<BR>
Function Filtering
</H1>

<P>
By default, all calls of instrumented functions will be traced, so that the
  resulting trace files can easily become very large. In order to decrease the
  size of a trace, VampirTrace allows the specification of filter directives
  before running an instrumented application.
  The user can decide on how often an instrumented function(group) shall be
  recorded to a trace file.
  To use a filter, the environment variable <TT>VT_FILTER_SPEC</TT> needs to be 
  defined. It should contain the path and name of a file with filter directives
  specified as follows:
<BR>
<P>
<TT>&lt;function&gt; - &lt;limit&gt; [S:&lt;[min-]max-stack-level&gt;] [R]</TT>
<BR>
or
<BR>  <TT>&lt;groups&gt; - &lt;limit&gt; [S:&lt;[min-]max-stack-level&gt;] [R] G</TT>
<BR>
or
<BR>  <TT>&lt;function-call-path&gt; - &lt;limit&gt; C</TT>
<BR>
<P>
<BR>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT"><TT>functions, groups</TT></TD>
<TD ALIGN="LEFT">Semicolon-separated list of</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">functions/groups.</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">(can contain wildcards)</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>function-call-path</TT></TD>
<TD ALIGN="LEFT">Semicolon-separated list of</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">functions in a call path.</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">(MUST NOT contain wildcards)</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>limit</TT></TD>
<TD ALIGN="LEFT">call limit</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">Stop recording of functions/groups when</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">the specified call limit is reached.</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">(0 = don't record functions/groups,</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">-1 record unlimited)</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
</TABLE>
<BR>

<P>
<BR>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT"><TT>S:&lt;[min-]max-stack-level&gt;</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">minimum/maximum call stack level</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">Don't record functions/groups called</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">beyond the specified stack level</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">boundaries.</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">(values must be &gt; 0, only valid if call</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">limit is != 0)</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>R</TT></TD>
<TD ALIGN="LEFT">Attribute for recursive filtering.</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">Don't record callees of filtered</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">function/group.</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>G</TT></TD>
<TD ALIGN="LEFT">Attribute for filtering function groups.</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>C</TT></TD>
<TD ALIGN="LEFT">Attribute for filtering function a call path.</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">(implies recursive filtering <TT>R</TT>)</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
</TABLE>
<BR>

<P>
Example:

<P>
<PRE>
  add;sub;mul;div -- 1000
  MATH            -- 500 G
  *               -- 3000000 S:5-10
</PRE>

<P>
These filter directives cause that the functions <TT>add</TT>, <TT>sub</TT>,
  <TT>mul</TT>, and <TT>div</TT> will be recorded at most 1000 times. All the functions
  of the group <TT>MATH</TT> at most 500 times. The remaining functions <TT>*</TT> will
  only be recorded when they are called between call stack level 5 and 10 but at most
  3000000 times.
<BR>
<P>
Besides creating filter files manually, you can also use the <TT>vtfilter</TT>
  tool to generate them automatically. This tool reads a provided trace
  and decides whether a function should be filtered or not, based on the evaluation of 
<H2><A NAME="SECTION00611000000000000000">
Call Path Specific Filtering</A>
</H2>

<P>
The 'C' attribute indicates that the listed functions specify a call path
  - a specific sequence of function calls. Recording of the last function in the
  list will be stopped if the specified call limit is reached.
  The call path must begin with the root function, typically main, and MUST NOT
  contain wildcards.
<BR>
<P>
Example:

<P>
<PRE>
  main;foo;bar -- 0 C
</PRE>

<P>
This filter directive causes that the function <TT>bar</TT> called from <TT>foo</TT> which
  prior was called from <TT>main</TT> will never be recorded. Since call path filtering
  impies recursiveness (see attribute <TT>R</TT>) all callee functions of this call
  path will be excluded from recording as well.

<P>

<H2><A NAME="SECTION00612000000000000000">
Rank Specific Filtering</A>
</H2>

<P>
An experimental extension allows rank specific filtering. Use <TT>@</TT> clauses to
  restrict all following filters to the given ranks. The rank selection must be given
  as a list of <TT>&lt;from&gt; - &lt;to&gt;</TT> pairs or single values. 
  Note that all rank specific rules are only effective after MPI_Init because the ranks
  are unknown before. 
  The optional argument <TT>- OFF</TT> disables the given ranks completely, regardless of
  following filter rules. 

<P>
<PRE>
  @ 35 - 42 -- OFF
  @ 4 - 10, 20 - 29, 34
  foo;bar -- 2000
  * -- 0
</PRE>

<P>
The example defines two limits for the ranks 4 - 10, 20 - 29, and 34. The first line
  disables the ranks 35 - 42 completely.

<P>

<H4><A NAME="SECTION00612010000000000000">
Attention:</A>
</H4>
  The rank specific rules are activated later than usual at MPI_Init, because
  the ranks are not available earlier. The special MPI routines MPI_Init, MPI_Init_thread,
  and MPI_Initialized cannot be filtered in this way.

<P>

<H1><A NAME="SECTION00620000000000000000"></A>
<A NAME="sec:java_filter"></A>
<BR>
Java Specific Filtering
</H1>

<P>
For Java tracing there are additional possibilities of filtering. Firstly,
  there is a default filter applied. The rules can be found in the filter file
  <TT>&lt;vt-install&gt;/etc/</TT> <TT>vt-java-default-filter.spec</TT>.
  Secondly, user-defined filters can be applied additionally by setting
  <TT>VT_JAVA_FILTER_SPEC</TT> to a file containing the rules.

<P>
The syntax of the filter rules is as follows:

<P>
<PRE>
 &lt;method|thread&gt; &lt;include|exclude&gt; &lt;filter string[;fs]...&gt;
</PRE>

<P>
Filtering can be done on thread names and method names, defined by the first
  parameter. The second parameter determines whether the matching item shall be
  included for tracing or excluded from it. Multiple filter strings on a line
  have to be separated by <TT>;</TT> and may contain occurences of <TT>*</TT>
  for wildcard matching.

<P>
The user-supplied filter rules will be applied before the default filter and
  the first match counts so it is possible to include items that would be
  excluded by the default filter otherwise.

<P>

<H1><A NAME="SECTION00630000000000000000"></A>
<A NAME="sec:function_groups"></A>
<BR>
Function Grouping
</H1>

<P>
VampirTrace allows assigning functions/regions to a group. 
  Groups can, for instance, be highlighted by different colors in Vampir displays.
  The following standard groups are created by VampirTrace:

<P>
<TABLE CELLPADDING=3>
<TR><TH ALIGN="LEFT"><SPAN  CLASS="textbf">Group name</SPAN></TH>
<TH ALIGN="LEFT"><SPAN  CLASS="textbf">Contained functions/regions</SPAN></TH>
</TR>
<TR><TD ALIGN="LEFT"><TT>MPI</TT></TD>
<TD ALIGN="LEFT">MPI functions</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>OMP</TT></TD>
<TD ALIGN="LEFT">OpenMP API function calls</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>OMP_SYNC</TT></TD>
<TD ALIGN="LEFT">OpenMP barriers</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>OMP_PREG</TT></TD>
<TD ALIGN="LEFT">OpenMP parallel regions</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>Pthreads</TT></TD>
<TD ALIGN="LEFT">Pthread API function calls</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>LIBC-EXEC</TT></TD>
<TD ALIGN="LEFT">LIBC function calls for creating and controling child processes (&#8658; Section&nbsp;<A HREF="#sec:exec_calls">4.9</A>)</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>LIBC-I/O</TT></TD>
<TD ALIGN="LEFT">LIBC functions (&#8658; Section&nbsp;<A HREF="#sec:io_calls">4.8</A>)</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>LIBC-MALLOC</TT></TD>
<TD ALIGN="LEFT">LIBC memory (de)allocation functions (&#8658; Section&nbsp;<A HREF="#sec:mem_alloc_counter">4.3</A>)</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>Application</TT></TD>
<TD ALIGN="LEFT">remaining instrumented functions and source code regions</TD>
</TR>
</TABLE>

<P>
Additionally, you can create your own groups, e.g.,&nbsp;to better distinguish
  different phases of an application.
  To use function/region grouping set the environment variable
  <TT>VT_GROUPS_SPEC</TT> to the path of a file which contains the group
  assignments specified as follows:

<P>
<PRE>
 &lt;group&gt;=&lt;functions&gt;
</PRE>

<P>
<BR>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT"><TT>group</TT></TD>
<TD ALIGN="LEFT">group name</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>functions</TT></TD>
<TD ALIGN="LEFT">semicolon-seperated list of functions</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">(can contain wildcards)</TD>
</TR>
</TABLE>
<BR>

<P>
Example:

<P>
<PRE>
  MATH=add;sub;mul;div
  USER=app_*
</PRE> 

<P>
These group assignments associate the functions <TT>add</TT>, <TT>sub</TT>, 
  <TT>mul</TT>, and <TT>div</TT> with group ``MATH'', and all functions 
  with the prefix <TT>app_</TT> are associated with group ``USER''.

<P>

<P>

<H1><A NAME="SECTION00700000000000000000"></A>
<A NAME="chap:install"></A>
<BR>
VampirTrace Installation
</H1>

<P>

<H1><A NAME="SECTION00710000000000000000">
Basics</A>
</H1>

<P>
Building VampirTrace is typically a combination of running <TT>configure</TT>
    and <TT>make</TT>.  Execute the following commands to install VampirTrace from
    the directory at the top of the tree:

<P>
<PRE>
% ./configure --prefix=/where/to/install
[...lots of output...]
% make all install
</PRE> 

<P>
If you need special access for installing, you can execute
    <TT>make all</TT> as a user with write permissions in the build tree and a
    separate <TT>make install</TT> as a user with write permissions to the
    install tree.

<P>
However, for more details, also read the following instructions. Sometimes
    it might be necessary to provide <TT>./configure</TT> with options, e.g.,&nbsp;
    specifications of paths or compilers.

<P>
VampirTrace comes with example programs written in C, C++, and Fortran.
    They can be used to test different instrumentation types of the
    VampirTrace installation.
    You can find them in the directory <TT>examples</TT> of the VampirTrace package.

<P>
Note that you should compile VampirTrace with the same compiler you use for the
    application to trace.

<P>

<H1><A NAME="SECTION00720000000000000000"></A>
<A NAME="sec:configure"></A>
<BR>
Configure Options
</H1>

<H2><A NAME="SECTION00721000000000000000">
Compilers and Options</A>
</H2>

<P>
Some systems require unusual options for compiling or linking which
      the <TT>configure</TT> script does not know.  Run <TT>./configure -help</TT>
      for details on some of the pertinent environment variables.

<P>
You can pass initial values for configuration parameters to <TT>configure</TT>
      by setting variables in the command line or in the environment.  Here
      is an example:

<P>
<PRE>
% ./configure CC=c89 CFLAGS=-O2 LIBS=-lposix
</PRE> 

<P>

<H2><A NAME="SECTION00722000000000000000">
Installation Names</A>
</H2>

<P>
By default, <TT>make install</TT> will install the package's files in
      <TT>/usr/local/bin</TT>, <TT>/usr/local/include</TT>, etc.  You can specify an
      installation prefix other than <TT>/usr/local</TT> by giving <TT>configure</TT> the
      option <TT>-prefix=PATH</TT>.

<P>

<H2><A NAME="SECTION00723000000000000000">
Optional Features</A>
</H2>

<P>
This a summary of the most important optional features. For a full list of all available 
      features run <TT>./configure -help</TT>.

<P>
<DL>
<DT><STRONG><TT>-enable-compinst=TYPE</TT></STRONG></DT>
<DD>&nbsp;
<BR>
enable support for compiler instrumentation,
                              e.g.&nbsp;<TT>gnu,pgi,pgi9,sun</TT>
<BR>
default: automatically by configure.
                              <SPAN  CLASS="textbf">Note:</SPAN> Use <TT>pgi9</TT> for PGI compiler version 9.0 or higher.

<P>
</DD>
<DT><STRONG><TT>-enable-dyninst</TT></STRONG></DT>
<DD>&nbsp;
<BR>
enable support for Dyninst instrumentation,
                              default: enable if found by configure.
                              <SPAN  CLASS="textbf">Note:</SPAN> Requires Dyninst<A NAME="tex2html8"
  HREF="#foot1680"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A> version 6.1 or higher!

<P>
</DD>
<DT><STRONG><TT>-enable-dyninst-attlib</TT></STRONG></DT>
<DD>&nbsp;
<BR>
build shared library which attaches Dyninst to 
                              the running application,
                              default: enable if Dyninst found
                              by configure and system supports shared libraries

<P>
</DD>
<DT><STRONG><TT>-enable-tauinst</TT></STRONG></DT>
<DD>&nbsp;
<BR>
enable support for automatic source code
                              instrumentation by using TAU, default: enable if
                              found by configure.
                              <SPAN  CLASS="textbf">Note:</SPAN> Requires PDToolkit<A NAME="tex2html9"
  HREF="#foot1681"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A> or TAU<A NAME="tex2html10"
  HREF="#foot1682"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A>!

<P>
</DD>
<DT><STRONG><TT>-enable-cpuidtrace</TT></STRONG></DT>
<DD>&nbsp;
<BR>
enable CPU ID tracing support, default: enable if
                              found by configure

<P>
</DD>
<DT><STRONG><TT>-enable-libtrace=LIST</TT></STRONG></DT>
<DD>&nbsp;
<BR>
enable library tracing support
                              (gen,exec,io,malloc,cudart), default: automatically
                              by configure

<P>
</DD>
<DT><STRONG><TT>-enable-exectrace</TT></STRONG></DT>
<DD>&nbsp;
<BR>
enable support for tracing LIBC functions for
                              creating and controling child processes (e.g.
                              execl,fork,system,wait) via library wrapping,
                              default: enable

<P>
</DD>
<DT><STRONG><TT>-enable-iotrace</TT></STRONG></DT>
<DD>&nbsp;
<BR>
enable support for tracing LIBC I/O functions (e.g.
                              fopen,fclose,fread,fwrite) via library wrapping,
                              default: enable

<P>
</DD>
<DT><STRONG><TT>-enable-memtrace</TT></STRONG></DT>
<DD>&nbsp;
<BR>
enable support for tracing LIBC functions for memory
                              de/allocation (e.g. malloc,realloc,free) via library
                              wrapping, default: enable

<P>
</DD>
<DT><STRONG><TT>-enable-cudartwrap</TT></STRONG></DT>
<DD>&nbsp;
<BR>
enable support for tracing the CUDA runtime API via
                              library wrapping, default: enable if no CUPTI
                              present

<P>
</DD>
<DT><STRONG><TT>-enable-rutrace</TT></STRONG></DT>
<DD>&nbsp;
<BR>
enable resource usage tracing support, default:
                              enable if found by configure

<P>
</DD>
<DT><STRONG><TT>-enable-metrics=TYPE</TT></STRONG></DT>
<DD>&nbsp;
<BR>
enable support for hardware performance counter
                              (<TT>papi,cpc,necsx</TT>), default: automatically
                              by configure

<P>
</DD>
<DT><STRONG><TT>-enable-zlib</TT></STRONG></DT>
<DD>&nbsp;
<BR>
enable ZLIB trace compression support, default:
                              enable if found by configure

<P>
</DD>
<DT><STRONG><TT>-enable-mpi</TT></STRONG></DT>
<DD>&nbsp;
<BR>
enable MPI support, default: enable if
                              MPI found by configure

<P>
</DD>
<DT><STRONG><TT>-enable-fmpi-lib</TT></STRONG></DT>
<DD>&nbsp;
<BR>
build the MPI Fortran support library, in case your 
                              system does not have a MPI Fortran library.
                              default: enable if no MPI Fortran library 
                              found by configure

<P>
</DD>
<DT><STRONG><TT>-enable-fmpi-handle-convert</TT></STRONG></DT>
<DD>&nbsp;
<BR>
do convert MPI handles, default: enable if MPI
                              conversion functions found by configure

<P>
</DD>
<DT><STRONG><TT>-enable-mpi2-thread</TT></STRONG></DT>
<DD>&nbsp;
<BR>
enable MPI-2 Thread support, default: enable if
                              found by configure

<P>
</DD>
<DT><STRONG><TT>-enable-mpi2-1sided</TT></STRONG></DT>
<DD>&nbsp;
<BR>
enable MPI-2 One-Sided Communication support,
                              default: enable if found by configure

<P>
</DD>
<DT><STRONG><TT>-enable-mpi2-extcoll</TT></STRONG></DT>
<DD>&nbsp;
<BR>
enable MPI-2 Extended Collective Operation support,
                              default: enable if found by configure

<P>
</DD>
<DT><STRONG><TT>-enable-mpi2-io</TT></STRONG></DT>
<DD>&nbsp;
<BR>
enable MPI-2 I/O support, default: enable if found
                              configure

<P>
</DD>
<DT><STRONG><TT>-enable-mpicheck</TT></STRONG></DT>
<DD>&nbsp;
<BR>
enable support for Universal MPI Correctness
                              Interface (UniMCI), default: enable if
                              unimci-config found by configure

<P>
</DD>
<DT><STRONG><TT>-enable-etimesync</TT></STRONG></DT>
<DD>&nbsp;
<BR>
enable enhanced timer synchronization support,
                              default: enable if  C-LAPACK found by configure

<P>
</DD>
<DT><STRONG><TT>-enable-threads=LIST</TT></STRONG></DT>
<DD>&nbsp;
<BR>
enable support for threads (pthread, omp), 
                              default: automatically by configure

<P>
</DD>
<DT><STRONG><TT>-enable-java</TT></STRONG></DT>
<DD>&nbsp;
<BR>
enable Java support, default: enable if JVMTI
                              found by configure

<P>
</DD>
<DT><STRONG><TT>-enable-cupti</TT></STRONG></DT>
<DD>&nbsp;
<BR>
enable support for tracing CUDA via CUPTI, 
                              default: enable if found by configure

<P>
</DD>
</DL>

<P>

<H2><A NAME="SECTION00724000000000000000">
Important Optional Packages</A>
</H2>

<P>
This a summary of the most important optional features. For a full list of all available 
      features run <TT>./configure -help</TT>.

<P>
<DL>
<DT><STRONG><TT>-with-platform=PLATFORM</TT></STRONG></DT>
<DD>&nbsp;
<BR>
configure for given platform
                              (<TT>altix,bgl,bgp,crayt3e,crayx1,crayxt,
<BR>
ibm,linux,macos,necsx,origin,sicortex,sun,generic</TT>),
                              default: automatically by configure

<P>
</DD>
<DT><STRONG><TT>-with-bitmode=32|64</TT></STRONG></DT>
<DD>&nbsp;
<BR>
specify bit mode

<P>
</DD>
<DT><STRONG><TT>-with-options=FILE</TT></STRONG></DT>
<DD>&nbsp;
<BR>
load options from FILE, default: configure
                              searches for a config file in config/defaults
                              based on given platform and bitmode

<P>
</DD>
<DT><STRONG><TT>-with-local-tmp-dir=DIR</TT></STRONG></DT>
<DD>&nbsp;
<BR>
give the path for node-local temporary directory 
                              to store local traces to, default: <TT>/tmp</TT>
</DD>
</DL>

<P>
If you would like to use an external version of OTF library, set:
<DL>
<DT><STRONG><TT>-with-extern-otf</TT></STRONG></DT>
<DD>&nbsp;
<BR>
use external OTF library, default: not set
</DD>
<DT><STRONG><TT>-with-extern-otf-dir=OTFDIR</TT></STRONG></DT>
<DD>&nbsp;
<BR>
give the path for OTF, default: <TT>/usr</TT>

<P>
</DD>
<DT><STRONG><TT>-with-otf-flags=FLAGS</TT></STRONG></DT>
<DD>&nbsp;
<BR>
pass FLAGS to the OTF distribution configuration
                              (only for internal OTF version)

<P>
</DD>
<DT><STRONG><TT>-with-otf-lib=OTFLIB</TT></STRONG></DT>
<DD>&nbsp;
<BR>
use given otf lib, default: <TT>-lopen-trace-format -lz</TT>

<P>
</DD>
</DL>

<P>
If the supplied OTF library was built without zlib support then OTFLIB will
be set to <TT>-lopen-trace-format</TT>.

<P>
<DL>
<DT><STRONG><TT>-with-dyninst-dir=DYNIDIR</TT></STRONG></DT>
<DD>&nbsp;
<BR>
give the path for DYNINST, default: <TT>/usr</TT>

<P>
</DD>
<DT><STRONG><TT>-with-dyninst-inc-dir=DYNIINCDIR</TT></STRONG></DT>
<DD>&nbsp;
<BR>
give the path for Dyninst-include files, default: <TT>DYNIDIR/include</TT>

<P>
</DD>
<DT><STRONG><TT>-with-dyninst-lib-dir=DYNILIBDIR</TT></STRONG></DT>
<DD>&nbsp;
<BR>
give the path for Dyninst-libraries, default: <TT>DYNIDIR/lib</TT>

<P>
</DD>
<DT><STRONG><TT>-with-dyninst-lib=DYNILIB</TT></STRONG></DT>
<DD>&nbsp;
<BR>
use given Dyninst lib, default: <TT>-ldyninstAPI</TT>

<P>
</DD>
<DT><STRONG><TT>-with-tau-instrumentor=TAUINSTUMENTOR</TT></STRONG></DT>
<DD>&nbsp;
<BR>
give the command for the TAU instrumentor, default: <TT>tau_instrumentor</TT>

<P>
</DD>
<DT><STRONG><TT>-with-pdt-cparse=PDTCPARSE</TT></STRONG></DT>
<DD>&nbsp;
<BR>
give the command for PDT C source code parser, default: <TT>cparse</TT>

<P>
</DD>
<DT><STRONG><TT>-with-pdt-cxxparse=PDTCXXPARSE</TT></STRONG></DT>
<DD>&nbsp;
<BR>
give the command for PDT C++ source code parser, default: <TT>cxxparse</TT>

<P>
</DD>
<DT><STRONG><TT>-with-pdt-fparse=PDTFPARSE</TT></STRONG></DT>
<DD>&nbsp;
<BR>
give the command for PDT Fortran source code parser, default: <TT>f95parse, f90parse, or gfparse</TT>

<P>
</DD>
<DT><STRONG><TT>-with-papi-dir=PAPIDIR</TT></STRONG></DT>
<DD>&nbsp;
<BR>
give the path for PAPI, default: <TT>/usr</TT>

<P>
</DD>
<DT><STRONG><TT>-with-cpc-dir=CPCDIR</TT></STRONG></DT>
<DD>&nbsp;
<BR>
give the path for CPC, default: <TT>/usr</TT>

<P>
</DD>
</DL>

<P>
If you have not specified the environment variable <TT>MPICC</TT>
(MPI compiler command) use the following options to set the location
of your MPI installation:

<P>
<DL>
<DT><STRONG><TT>-with-mpi-dir=MPIDIR</TT></STRONG></DT>
<DD>&nbsp;
<BR>
give the path for MPI, default: <TT>/usr/</TT>

<P>
</DD>
<DT><STRONG><TT>-with-mpi-inc-dir=MPIINCDIR</TT></STRONG></DT>
<DD>&nbsp;
<BR>
give the path for MPI-include files, 
<BR>
default: <TT>MPIDIR/include/</TT>

<P>
</DD>
<DT><STRONG><TT>-with-mpi-lib-dir=MPILIBDIR</TT></STRONG></DT>
<DD>&nbsp;
<BR>
give the path for MPI-libraries, default: <TT>MPIDIR/lib/</TT>

<P>
</DD>
<DT><STRONG><TT>-with-mpi-lib</TT></STRONG></DT>
<DD>&nbsp;
<BR>
use given mpi lib

<P>
</DD>
<DT><STRONG><TT>-with-pmpi-lib</TT></STRONG></DT>
<DD>&nbsp;
<BR>
use given pmpi lib
</DD>
</DL>

<P>
If your system does not have an MPI Fortran library
set <TT>-enable-fmpi-lib</TT> (see above), otherwise set:

<P>
<DL>
<DT><STRONG><TT>-with-fmpi-lib</TT></STRONG></DT>
<DD>&nbsp;
<BR>
use given fmpi lib

<P>
</DD>
</DL>

<P>
Use the following options to specify your MPI-implementation

<P>
<DL>
<DT><STRONG><TT>-with-hpmpi</TT></STRONG></DT>
<DD>&nbsp;
<BR>
set MPI-libs for HP MPI

<P>
</DD>
<DT><STRONG><TT>-with-pcmpi</TT></STRONG></DT>
<DD>&nbsp;
<BR>
set MPI-libs for Platform MPI

<P>
</DD>
<DT><STRONG><TT>-with-intelmpi</TT></STRONG></DT>
<DD>&nbsp;
<BR>
set MPI-libs for Intel MPI

<P>
</DD>
<DT><STRONG><TT>-with-intelmpi2</TT></STRONG></DT>
<DD>&nbsp;
<BR>
set MPI-libs for Intel MPI2

<P>
</DD>
<DT><STRONG><TT>-with-lam</TT></STRONG></DT>
<DD>&nbsp;
<BR>
set MPI-libs for LAM/MPI

<P>
</DD>
<DT><STRONG><TT>-with-mpibgl</TT></STRONG></DT>
<DD>&nbsp;
<BR>
set MPI-libs for IBM BG/L

<P>
</DD>
<DT><STRONG><TT>-with-mpibgp</TT></STRONG></DT>
<DD>&nbsp;
<BR>
set MPI-libs for IBM BG/P

<P>
</DD>
<DT><STRONG><TT>-with-mpich</TT></STRONG></DT>
<DD>&nbsp;
<BR>
set MPI-libs for MPICH

<P>
</DD>
<DT><STRONG><TT>-with-mpich2</TT></STRONG></DT>
<DD>&nbsp;
<BR>
set MPI-libs for MPICH2

<P>
</DD>
<DT><STRONG><TT>-with-mvapich</TT></STRONG></DT>
<DD>&nbsp;
<BR>
set MPI-libs for MVAPICH

<P>
</DD>
<DT><STRONG><TT>-with-mvapich2</TT></STRONG></DT>
<DD>&nbsp;
<BR>
set MPI-libs for MVAPICH2

<P>
</DD>
<DT><STRONG><TT>-with-mpisx</TT></STRONG></DT>
<DD>&nbsp;
<BR>
set MPI-libs for NEC MPI/SX

<P>
</DD>
<DT><STRONG><TT>-with-mpisx-ew</TT></STRONG></DT>
<DD>&nbsp;
<BR>
set MPI-libs for NEC MPI/SX with 8 Byte Fortran Integer

<P>
</DD>
<DT><STRONG><TT>-with-openmpi</TT></STRONG></DT>
<DD>&nbsp;
<BR>
set MPI-libs for Open MPI

<P>
</DD>
<DT><STRONG><TT>-with-sgimpt</TT></STRONG></DT>
<DD>&nbsp;
<BR>
set MPI-libs for SGI MPT

<P>
</DD>
<DT><STRONG><TT>-with-sunmpi</TT></STRONG></DT>
<DD>&nbsp;
<BR>
set MPI-libs for SUN MPI

<P>
</DD>
<DT><STRONG><TT>-with-sunmpi-mt</TT></STRONG></DT>
<DD>&nbsp;
<BR>
set MPI-libs for SUN MPI-MT
</DD>
</DL>

<P>
To enable enhanced timer synchronization a LAPACK library with C wrapper support is needed:

<P>
<DL>
<DT><STRONG><TT>-with-clapack-dir=LAPACKDIR</TT></STRONG></DT>
<DD>&nbsp;
<BR>
set the path for CLAPACK, default: /usr

<P>
</DD>
<DT><STRONG><TT>-with-clapack-lib</TT></STRONG></DT>
<DD>&nbsp;
<BR>
set CLAPACK-libs, default: -lclapack -lcblas -lf2c

<P>
</DD>
<DT><STRONG><TT>-with-clapack-acml</TT></STRONG></DT>
<DD>&nbsp;
<BR>
set CLAPACK-libs for ACML

<P>
</DD>
<DT><STRONG><TT>-with-clapack-essl</TT></STRONG></DT>
<DD>&nbsp;
<BR>
set CLAPACK-libs for ESSL

<P>
</DD>
<DT><STRONG><TT>-with-clapack-mkl</TT></STRONG></DT>
<DD>&nbsp;
<BR>
set CLAPACK-libs for MKL

<P>
</DD>
<DT><STRONG><TT>-with-clapack-sunperf</TT></STRONG></DT>
<DD>&nbsp;
<BR>
set CLAPACK-libs for SUN Performance Library

<P>
</DD>
</DL>

<P>
To enable Java support the JVM Tool Interface (JVMTI) version 1.0 or higher is required:

<P>
<DL>
<DT><STRONG><TT>-with-jvmti-dir=JVMTIDIR</TT></STRONG></DT>
<DD>&nbsp;
<BR>
give the path for JVMTI, default: <TT>$JAVA_HOME</TT>

<P>
</DD>
<DT><STRONG><TT>-with-jvmti-inc-dir=JVMTIINCDIR</TT></STRONG></DT>
<DD>&nbsp;
<BR>
give the path for JVMTI-include files, default:
                              JVMTI/include

<P>
</DD>
</DL>

<P>
To enable support for generating wrapper for 3th-Party libraries the C code parser CTool<A NAME="tex2html11"
  HREF="#foot1683"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A> is needed:

<P>
<DL>
<DT><STRONG><TT>-with-ctool-dir=CTOOLDIR</TT></STRONG></DT>
<DD>&nbsp;
<BR>
give the path for CTool, default: /usr

<P>
</DD>
<DT><STRONG><TT>-with-ctool-inc-dir=CTOOLINCDIR</TT></STRONG></DT>
<DD>&nbsp;
<BR>
give the path for CTool-include files, default:
                              CTOOLDIR/include

<P>
</DD>
<DT><STRONG><TT>-with-ctool-lib-dir=CTOOLLIBDIR</TT></STRONG></DT>
<DD>&nbsp;
<BR>
give the path for CTool-libraries, default:
                              CTOOLDIR/lib

<P>
</DD>
<DT><STRONG><TT>-with-ctool-lib=CTOOLLIB</TT></STRONG></DT>
<DD>&nbsp;
<BR>
use given CTool lib, default: automatically by configure

<P>
</DD>
</DL>

<P>
To enable support for CUDA API wrapping, the CUDA-Toolkit 
install path is needed:

<P>
<DL>
<DT><STRONG><TT>-with-cuda-dir=CUDATKDIR</TT></STRONG></DT>
<DD>&nbsp;
<BR>
give the path for CUDA Toolkit, default: /usr/local/cuda
</DD>
<DT><STRONG><TT>-with-cuda-inc-dir=CUDATKINCDIR</TT></STRONG></DT>
<DD>&nbsp;
<BR>
give the path for CUDA Toolkit-include files, default:                                          
                          CUDATKDIR/include                                                                         
</DD>
<DT><STRONG><TT>-with-cuda-lib-dir=CUDATKLIBDIR</TT></STRONG></DT>
<DD>&nbsp;
<BR>
give the path for CUDA Toolkit-libraries, default:                                              
                          CUDATKDIR/lib64                                                                             
</DD>
<DT><STRONG><TT>-with-cudart-lib=CUDARTLIB</TT></STRONG></DT>
<DD>&nbsp;
<BR>
use given cudart lib, default: -lcudart
</DD>
<DT><STRONG><TT>-with-cudart-shlib=CUDARTSHLIB</TT></STRONG></DT>
<DD>&nbsp;
<BR>
give the pathname for the shared CUDA runtime library, default:
			  automatically by configure

<P>
</DD>
</DL>

<P>
To enable support for CUPTI features, the CUPTI install path is needed:

<P>
<DL>
<DT><STRONG><TT>-with-cupti-dir=CUPTIDIR</TT></STRONG></DT>
<DD>&nbsp;
<BR>
give the path for CUPTI, default: /usr
</DD>
<DT><STRONG><TT>-with-cupti-inc-dir=CUPTIINCDIR</TT></STRONG></DT>
<DD>&nbsp;
<BR>
give the path for CUPTI-include files, default:                                          
                          CUPTIDIR/include                                                                         
</DD>
<DT><STRONG><TT>-with-cupti-lib-dir=CUPTILIBDIR</TT></STRONG></DT>
<DD>&nbsp;
<BR>
give the path for CUPTI-libraries, default:                                              
                          CUPTIDIR/lib64                                                                             
</DD>
<DT><STRONG><TT>-with-cupti-lib=CUPTILIB</TT></STRONG></DT>
<DD>&nbsp;
<BR>
use given cupti lib, default: -lcupti

<P>
</DD>
</DL>

<P>

<H1><A NAME="SECTION00730000000000000000">
Cross Compilation</A>
</H1>

<P>
Building VampirTrace on cross compilation platforms needs some special attention.
The compiler wrappers, OPARI, and the Library Wrapper Generator are built for the front-end (build system)
whereas the the VampirTrace libraries, <TT>vtdyn</TT>, <TT>vtunify</TT>, and <TT>vtfilter</TT> are built
for the back-end (host system). Some <TT>configure</TT> options which are of interest for cross compilation
are shown below:

<UL>
<LI>Set <TT>CC</TT>, <TT>CXX</TT>, and <TT>FC</TT> to the cross compilers installed on the front-end.
</LI>
<LI>Set <TT>CC_FOR_BUILD</TT> and <TT>CXX_FOR_BUILD</TT> to the native compilers of the front-end.
</LI>
<LI>Set <TT>-host=</TT> to the output of <TT>config.guess</TT> on the back-end.
</LI>
<LI>Set <TT>-with-cross-prefix=</TT> to a prefix which will be prepended to the executables of the compiler wrappers (default: ``cross-'')
</LI>
<LI>Maybe you also need to set additional commands and flags for the back-end (e.g.&nbsp;<TT>RANLIB</TT>, <TT>AR</TT>, <TT>MPICC</TT>, <TT>CXXFLAGS</TT>).
</LI>
</UL>
Examples:

<P>
BlueGene/P and BlueGene/Q:

<P>
<PRE>
% ./configure --host=powerpc64-ibm-linux-gnu
</PRE>

<P>
Cray XK6:

<P>
<PRE>
% ./configure --host=x86_64-cray-linux-gnu
              CC_FOR_BUILD=craycc
              CXX_FOR_BUILD=crayc++
</PRE>

<P>
NEC SX6:

<P>
<PRE>
% ./configure --host=sx6-nec-superux14.1
</PRE>

<P>

<H1><A NAME="SECTION00740000000000000000">
Environment Set-Up</A>
</H1>

<P>
Add the <TT>bin</TT> subdirectory of the installation directory to your 
    <TT>$PATH</TT> environment variable. To use VampirTrace with Dyninst, 
    you will also need to add the lib subdirectory to your 
    <TT>LD_LIBRARY_PATH</TT> environment variable:
<BR>
<BR>
<BR>
for csh and tcsh:
<PRE>
&gt; setenv PATH &lt;vt-install&gt;/bin:$PATH
&gt; setenv LD_LIBRARY_PATH &lt;vt-install&gt;/lib:$LD_LIBRARY_PATH
</PRE> 
    for bash and sh:
<PRE>
% export PATH=&lt;vt-install&gt;/bin:$PATH
% export LD_LIBRARY_PATH=&lt;vt-install&gt;/lib:$LD_LIBRARY_PATH
</PRE> 

<P>

<H1><A NAME="SECTION00750000000000000000">
Notes for Developers</A>
</H1>

<P>

<H2><A NAME="SECTION00751000000000000000">
Build from SVN</A>
</H2>

<P>
If you have checked out a <SPAN  CLASS="textit">developer's copy</SPAN> of VampirTrace (i.e.
      checked out from CVS), you should first run:

<P>
<PRE>
% ./bootstrap [--otf-package &lt;package&gt;]
              [--version &lt;version&gt;]
</PRE>
Note that GNU Autoconf &#8805;2.60 and GNU Automake &#8805;1.9.6 are required.
You can download them from http://www.gnu.org/software/autoconfand http://www.gnu.org/software/automake.

<P>

<H1><A NAME="SECTION00800000000000000000">
Command Reference</A>
</H1>

<H1><A NAME="SECTION00810000000000000000"></A>
<A NAME="sec:comm_wrappers"></A>
<BR>
Compiler Wrappers (vtcc,vtcxx,vtfort)
</H1>

<P>
<PRE>
vtcc,vtcxx,vtfort - compiler wrappers for C, C++, Fortran

Syntax: vt&lt;cc|cxx|fc&gt; [options] ...

options:
  -vt:help            Show this help message.
  -vt:version         Show VampirTrace version.
  -vt:&lt;cc|cxx|fc&gt; &lt;cmd&gt;
                      Set the underlying compiler command.

  -vt:inst &lt;insttype&gt; Set the instrumentation type.

   possible values:

    compinst          fully-automatic by compiler
    manual            manual by using VampirTrace's API
    dyninst           binary by using Dyninst (www.dyninst.org)
    tauinst           automatic source code instrumentation by
                      using PDT/TAU

  -vt:inst-exclude-file-list &lt;file&gt;[,file,...]
                      Set list of source files to be excluded
                      from the automatic instrumentation by the
                      compiler or PDT/TAU.
                      (file names can contain wildcards)

  -vt:inst-exclude-file &lt;file&gt;
                      Set pathname of file containing a list of
                      source files to be excluded from the
                      automatic instrumentation by the compiler
                      or PDT/TAU.
                      (file names can contain wildcards, one file
                       name per line)

   Note when using an exclusion list for automatic compiler
   instrumentation:
   If a source file from the exclusion list is involved in a
   compile step, the instrumentation is disabled for this step.

  -vt:opari &lt;!args&gt;   Set options for OPARI command. (see
                      share/vampirtrace/doc/opari/Readme.html)

  -vt:opari-rcfile &lt;file&gt;
                      Set pathname of the OPARI resource file.
                      (default: opari.rc)

  -vt:opari-table &lt;file&gt;
                      Set pathname of the OPARI runtime table file.
                      (default: opari.tab.c)

  -vt:opari-exclude-file-list &lt;file&gt;[,file,...]
                      Set list of source files to be excluded from
                      the instrumentation of OpenMP constructs by
                      OPARI.
                      (file names can contain wildcards)

  -vt:opari-exclude-file &lt;file&gt;
                      Set pathname of file containing a list of
                      source files to be excluded from the
                      instrumentation of OpenMP constructs by OPARI.
                      (file names can contain wildcards, one file name
                       per line)

  -vt:noopari         Disable instrumentation of OpenMP contructs
                      by OPARI.

  -vt:&lt;seq|mpi|mt|hyb&gt;
                      Enforce application's parallelization type.
                      It's only necessary if it could not be determined
                      automatically based on underlying compiler and flags.
                      seq = sequential
                      mpi = parallel (uses MPI)
                      mt = parallel (uses OpenMP/POSIX threads)
                      hyb = hybrid parallel (MPI + Threads)
                      (default: automatically)

  -vt:tau &lt;!args&gt;     Set options for the TAU instrumentor 
                      command.

  -vt:pdt &lt;!args&gt;     Set options for the PDT parse command.

  -vt:preprocess      Preprocess the source files before parsing
                      by OPARI and/or PDT.

  -vt:cpp &lt;cmd&gt;       Set C preprocessor command.

  -vt:cppflags &lt;[!]flags&gt;
                      Set/add flags for the C preprocessor.

  -vt:verbose         Enable verbose mode.

  -vt:keepfiles       Keep intermediate files.

  -vt:reusefiles      Reuse intermediate files, if exist.

  -vt:show[me]        Do not invoke the underlying compiler.
                      Instead, show the command line that would be
                      executed to compile and link the program.

  -vt:showme-compile  Do not invoke the underlying compiler.
                      Instead, show the compiler flags that would be
                      supplied to the compiler.

  -vt:showme-link     Do not invoke the underlying compiler.
                      Instead, show the linker flags that would be
                      supplied to the compiler.

  See the man page for your underlying compiler for other 
  options that can be passed through 'vt&lt;cc|cxx|fc&gt;'.

Environment variables:
  VT_INST             Equivalent to '-vt:inst'
  VT_CC               Equivalent to '-vt:cc '
  VT_CXX              Equivalent to '-vt:cxx '
  VT_FC               Equivalent to '-vt:fc'
  VT_CFLAGS           C compiler flags
  VT_CXXFLAGS         C++ compiler flags
  VT_FCFLAGS          Fortran compiler flags
  VT_LDFLAGS          Linker flags
  VT_LIBS             Libraries to pass to the linker

  The corresponding command line options overwrite the 
  environment variables setting.

Examples:
  automatically instrumentation by compiler:

     vtcc -vt:cc gcc -vt:inst compinst -c foo.c -o foo.o
     vtcc -vt:cc gcc -vt:inst compinst -c bar.c -o bar.o
     vtcc -vt:cc gcc -vt:inst compinst foo.o bar.o -o foo

  manually instrumentation by using VT's API:

     vtfort -vt:inst manual foobar.F90 -o foobar -DVTRACE

  IMPORTANT: Fortran source files instrumented by VT's API
             have to be preprocessed by CPP.
</PRE>

<P>

<H1><A NAME="SECTION00820000000000000000"></A>
<A NAME="sec:VTUNIFY"></A>
<BR>
Local Trace Unifier (vtunify)
</H1>

<P>
<PRE>
vtunify[-mpi] - local trace unifier for VampirTrace.

Syntax: vtunify[-mpi] [options] &lt;input trace prefix&gt;

options:
  -h, --help          Show this help message.

  -V, --version       Show VampirTrace version.

  -o PREFIX           Prefix of output trace filename.

  -f FILE             Function profile output filename.
                      (default=PREFIX.prof.txt)

  -k, --keeplocal     Don't remove input trace files.

  -p, --progress      Show progress.

  -v, --verbose       Increase output verbosity.
                      (can be used more than once)

  -q, --quiet         Enable quiet mode.
                      (only emergency output)

  --iofsl-servers LIST
                      Enable IOFSL mode where LIST contains a comma-separated
                      list of IOFSL server addresses.

  --iofsl-mode MODE   IOFSL mode (MULTIFILE or MULTIFILE_SPLIT).
                      (default: MULTIFILE_SPLIT)

  --iofsl-asyncio     Use asynchronous I/O in IOFSL mode.

  --stats             Unify only summarized information (*.stats), no events

  --nocompress        Don't compress output trace files.

  --nosnapshots       Don't create snapshots.

  --maxsnapshots N    Maximum number of snapshots.
                      (default: 1024)

  --nomsgmatch        Don't match messages.

  --droprecvs         Drop message receive events, if msg. matching
                      is enabled.
</PRE>

<P>

<H1><A NAME="SECTION00830000000000000000"></A>
<A NAME="sec:VTDYN"></A>
<BR>
Binary Instrumentor (vtdyn)
</H1>

<P>
<PRE>
vtdyn - binary instrumentor (Dyninst mutator) for VampirTrace.

Syntax: vtdyn [options] &lt;executable&gt; [arguments ...]

options:
  -h, --help          Show this help message.

  -V, --version       Show VampirTrace version.

  -v, --verbose       Increase output verbosity.
                      (can be used more than once)

  -q, --quiet         Enable quiet mode.
                      (only emergency output)

  -o, --output FILE   Rewrite instrumented executable to specified pathname.

  -f, --filter FILE   Pathname of input filter file.

  -s, --shlibs SHLIBS[,...]
                      Comma-separated list of shared libraries which shall
                      also be instrumented.

  --outer-loops       Do instrument outer loops within functions.

  --inner-loops       Do instrument inner loops within outer loops.
                      (implies --outer-loops)

  --loop-iters        Do instrument loop iterations.
                      (implies --outer-loops)

  --ignore-nodbg      Don't instrument functions which have no debug
                      information.
</PRE>

<P>

<H1><A NAME="SECTION00840000000000000000"></A>
<A NAME="sec:VTFILTER"></A>
<BR>
Trace Filter Tool (vtfilter)
</H1>

<P>
<PRE>
vtfilter[-mpi] - filter tool for VampirTrace.

Syntax: 
  Generate a filter file:
    vtfilter[-mpi] --gen [gen-options] &lt;input trace file&gt;

  Filter a trace using an already existing filter file:
    vtfilter[-mpi] [--filt] [filt-options]
      --filter=&lt;input filter file&gt; &lt;input trace file&gt;

options:
  --gen               Generate a filter file.
                      See 'gen-options' below for valid options.

  --filt              Filter a trace using an already existing
                      filter file. (default)
                      See 'filt-options' below for valid options.

  -h, --help          Show this help message.

  -V, --version       Show VampirTrace version.

  -p, --progress      Show progress.

  -v, --verbose       Increase output verbosity.
                      (can be used more than once)

gen-options:
  -o, --output=FILE   Pathname of output filter file.

  -r, --reduce=N      Reduce the trace size to N percent of the
                      original size. The program relies on the
                      fact that the major part of the trace are
                      function calls. The approximation of size
                      will get worse with a rising percentage of
                      communication and other non function
                      calling or performance counter records.                           

  -l, --limit=N       Limit the number of calls for filtered
                      function to N.
                      (default: 0)                                         

  -s, --stats         Prints out the desired and the expected
                      percentage of file size.                                     

  -e, --exclude=FUNC[;FUNC;...]
                      Exclude certain functions from filtering.
                      A function name may contain wildcards.   

  --exclude-file=FILE Pathname of file containing a list of
                      functions to be excluded from filtering.                             

  -i, --include=FUNC[;FUNC;...]
                      Force to include certain functions into
                      the filter. A function name may contain
                      wildcards.             

  --include-file=FILE Pathname of file containing a list of
                       functions to be included into the filter.                            

  --include-callees   Automatically include callees of included
                      functions as well into the filter.                           

filt-options:
  -o, --output=FILE   Pathname of output trace file.

  -f, --filter=FILE   Pathname of input filter file.

  -s, --max-streams=N Maximum number of output streams.
                      (default: 0)
            vtfilter: Set this to 0 to get the same number of
                      output streams as input streams.                                     
        vtfilter-mpi: Set this to 0 to get the same number of
                      output streams as MPI processes used, but
                      at least the number of input streams.

  --max-file-handles=N
                      Maximum number of files that are allowed
                      to be open simultaneously.
                      (default: 256)

  --nocompress        Don't compress output trace files.
</PRE>

<P>

<H1><A NAME="SECTION00850000000000000000"></A>
<A NAME="sec:VTLIBWRAPGEN"></A>
<BR>
Library Wrapper Generator (vtlibwrapgen)
</H1>

<P>
<PRE>
vtlibwrapgen - library wrapper generator for VampirTrace.

Syntax: 
  Generate a library wrapper source file:
    vtlibwrapgen [gen-options] &lt;input header file&gt; 
                 [input header file...]

  Build a wrapper library from a generated source file:
    vtlibwrapgen --build [build-options] 
                 &lt;input lib. wrapper source file&gt;

options:
  --gen              Generate a library wrapper source file. 
                     This is the default behavior. See 
                     'gen-options' below for valid options.

  --build            Build a wrapper library from a generated 
                     source file. See 'build-options' below 
                     for valid options.

  -h, --help         Show this help message.

  -V, --version      Show VampirTrace version.

  -q, --quiet        Enable quiet mode. 
                     (only emergency output)

  -v, --verbose      Increase output verbosity.
                     (can be used more than once)

gen-options:
  -o, --output=FILE  Pathname of output wrapper source file.
                     (default: wrap.c)                      

  -l, --shlib=SHLIB  Pathname of shared library that contains 
                     the actual library functions.
                     (can be used more then once)

  -f, --filter=FILE  Pathname of input filter file.

  -g, --group=NAME   Separate function group name for wrapped 
                     functions.

  -s, --sysheader=FILE
                     Header file to be included additionally.

  --nocpp            Don't use preprocessor.

  --keepcppfile      Don't remove preprocessed header files.

  --cpp=CPP          C preprocessor command
                     (default: gcc -E)     

  --cppflags=CPPFLAGS 
                     C preprocessor flags, e.g. 
                     -I&lt;include dir&gt;

  --cppdir=DIR       Change to this preprocessing directory.

environment variables:
  VT_CPP             C preprocessor command 
                     (equivalent to '--cpp')
  VT_CPPFLAGS        C preprocessor flags 
                     (equivalent to '--cppflags')

build-options:
  -o, --output=PREFIX
                     Prefix of output wrapper library.
                     (default: libwrap)               

  --shared           Do only build shared wrapper library.

  --static           Do only build static wrapper library.

  --libtool=LT       Libtool command

  --cc=CC            C compiler command (default: gcc)

  --cflags=CFLAGS    C compiler flags

  --ld=LD            linker command (default: CC)

  --ldflags=LDFLAGS  linker flags, e.g. -L&lt;lib dir&gt;
                     (default: CFLAGS)

  --libs=LIBS        libraries to pass to the linker, 
                     e.g. -l&lt;library&gt;

environment variables:
  VT_CC              C compiler command 
                     (equivalent to '--cc')
  VT_CFLAGS          C compiler flags 
                     (equivalent to '--cflags')
  VT_LD              linker command 
                     (equivalent to '--ld')
  VT_LDFLAGS         linker flags 
                     (equivalent to '--ldflags')
  VT_LIBS            libraries to pass to the linker
                     (equivalent to '--libs')

examples:
  Generating wrapper library 'libm_wrap' for the Math library
  'libm.so':

    vtlibwrapgen -l libm.so -g MATH -o mwrap.c \
    /usr/include/math.h
    vtlibwrapgen --build -o libm_wrap mwrap.c
    export LD_PRELOAD=$PWD/libm_wrap.so:libvt.so
</PRE>

<P>

<H1><A NAME="SECTION00860000000000000000"></A>
<A NAME="sec:VTRUN"></A>
<BR>
Application Execution Wrapper (vtrun)
</H1>

<P>
<PRE>
 vtrun - application execution wrapper for VampirTrace.

 Syntax: vtrun [options] &lt;executable&gt; [arguments]

   options:
     -h, --help          Show this help message.

     -V, --version       Show VampirTrace version.

     -v, --verbose       Increase output verbosity.
                         (can be used more than once)

     -q, --quiet         Enable quiet mode.
                         (only emergency output)

     -&lt;seq|mpi|mt|hyb&gt;   Set application's parallelization type.
                         It's only necessary if it could not 
                         be determined automatically.
                         seq = sequential
                         mpi = parallel (uses MPI)
                         mt  = parallel (uses OpenMP/POSIX threads)
                         hyb = hybrid parallel (MPI + Threads)
                         (default: automatically)

     --fortran           Set application's language to Fortran.
                         It's only necessary for MPI-applications 
                         and if it could not be determined 
                         automatically.

     --dyninst           Instrument user functions by Dyninst.

     --extra-libs=LIBS   Extra libraries to preload.

   example:
     original:
        mpirun -np 4 ./a.out
     with VampirTrace:
        mpirun -np 4 vtrun ./a.out
</PRE>

<P>

<H1><A NAME="SECTION00870000000000000000"></A>
<A NAME="sec:VTIOFSL-START"></A>
<BR>
IOFSL server startup script (vtiofsl-start)
</H1>

<P>
<PRE>
 vtiofsl-start - set environment variables and start IOFSL servers.

 Syntax: vtiofsl-start [options]

   options:
     -h, --help          Show this help message.

     -V, --version       Show VampirTrace version.

     -v, --verbose       Increase output verbosity.
                         (can be used more than once)

     -q, --quiet         Enable quiet mode.
                         (only emergency output)

     -n, --num NUM       Number of IOFSL servers to start.

     -m, --mode MODE     IOFSL mode (MULTIFILE or MULTIFILE_SPLIT).
                         (default: MULTIFILE_SPLIT)

     --asyncio           Use asynchronous I/O.

   environment variables:
     VT_IOFSL_NUM_SERVERS
                         equivalent to '-n' or '--num'
     VT_IOFSL_MODE       equivalent to '-m' or '--mode'
     VT_IOFSL_ASYNC_IO=&lt;yes|true|1&gt;
                         equivalent to '--asyncio'

   note:
     This script needs to be sourced from a shell, since it sets
     environment variables.
     Either -n or VT_IOFSL_NUM_SERVERS must be specified.
</PRE>

<P>

<H1><A NAME="SECTION00880000000000000000"></A>
<A NAME="sec:VTIOFSL-STOP"></A>
<BR>
IOFSL server shutdown script (vtiofsl-stop)
</H1>

<P>
<PRE>
 vtiofsl-stop - stop running IOFSL servers.

 Syntax: vtiofsl-stop [options]

   options:
     -h, --help          Show this help message.

     -V, --version       Show VampirTrace version.

     -v, --verbose       Increase output verbosity.
                         (can be used more than once)

     -q, --quiet         Enable quiet mode.
                         (only emergency output)

   note:
     This script needs to be sourced from a shell, since it sets
     environment variables.
</PRE>

<P>

<H1><A NAME="SECTION00900000000000000000">
Counter Specifications</A>
</H1>

<P>

<H1><A NAME="SECTION00910000000000000000"></A>
<A NAME="sec:papi"></A>
<BR>
PAPI
</H1>

<P>
Available counter names can be queried with the PAPI commands 
<TT>papi_avail</TT> and <TT>papi_native_avail</TT>.
Depending on the hardware there are limitations in the combination 
of different counters. To check whether your choice works properly, 
use the command <TT>papi_event_chooser</TT>.

<P>
<PRE>
PAPI_L[1|2|3]_[D|I|T]C[M|H|A|R|W]    
              Level 1/2/3 data/instruction/total cache 
              misses/hits/accesses/reads/writes

PAPI_L[1|2|3]_[LD|ST]M    
              Level 1/2/3 load/store misses                       

PAPI_CA_SNP   Requests for a snoop                                
PAPI_CA_SHR   Requests for exclusive access to shared cache line  
PAPI_CA_CLN   Requests for exclusive access to clean cache line   
PAPI_CA_INV   Requests for cache line invalidation                
PAPI_CA_ITV   Requests for cache line intervention                

PAPI_BRU_IDL  Cycles branch units are idle                        
PAPI_FXU_IDL  Cycles integer units are idle                       
PAPI_FPU_IDL  Cycles floating point units are idle                
PAPI_LSU_IDL  Cycles load/store units are idle                    

PAPI_TLB_DM   Data translation lookaside buffer misses            
PAPI_TLB_IM   Instruction translation lookaside buffer misses     
PAPI_TLB_TL   Total translation lookaside buffer misses           

PAPI_BTAC_M   Branch target address cache misses                  
PAPI_PRF_DM   Data prefetch cache misses                          
PAPI_TLB_SD   Translation lookaside buffer shootdowns             

PAPI_CSR_FAL  Failed store conditional instructions               
PAPI_CSR_SUC  Successful store conditional instructions           
PAPI_CSR_TOT  Total store conditional instructions                

PAPI_MEM_SCY  Cycles Stalled Waiting for memory accesses          
PAPI_MEM_RCY  Cycles Stalled Waiting for memory Reads             
PAPI_MEM_WCY  Cycles Stalled Waiting for memory writes            

PAPI_STL_ICY  Cycles with no instruction issue                    
PAPI_FUL_ICY  Cycles with maximum instruction issue               
PAPI_STL_CCY  Cycles with no instructions completed               
PAPI_FUL_CCY  Cycles with maximum instructions completed          

PAPI_BR_UCN   Unconditional branch instructions                   
PAPI_BR_CN    Conditional branch instructions                     
PAPI_BR_TKN   Conditional branch instructions taken               
PAPI_BR_NTK   Conditional branch instructions not taken           
PAPI_BR_MSP   Conditional branch instructions mispredicted        
PAPI_BR_PRC   Conditional branch instructions correctly
              predicted 

PAPI_FMA_INS  FMA instructions completed                          
PAPI_TOT_IIS  Instructions issued                                 
PAPI_TOT_INS  Instructions completed                              
PAPI_INT_INS  Integer instructions                                
PAPI_FP_INS   Floating point instructions                         
PAPI_LD_INS   Load instructions                                   
PAPI_SR_INS   Store instructions                                  
PAPI_BR_INS   Branch instructions                                 
PAPI_VEC_INS  Vector/SIMD instructions                            
PAPI_LST_INS  Load/store instructions completed                   
PAPI_SYC_INS  Synchronization instructions completed              
PAPI_FML_INS  Floating point multiply instructions                
PAPI_FAD_INS  Floating point add instructions                     
PAPI_FDV_INS  Floating point divide instructions                  
PAPI_FSQ_INS  Floating point square root instructions             
PAPI_FNV_INS  Floating point inverse instructions                 

PAPI_RES_STL  Cycles stalled on any resource    
PAPI_FP_STAL  Cycles the FP unit(s) are stalled 

PAPI_FP_OPS   Floating point operations         
PAPI_TOT_CYC  Total cycles                      
PAPI_HW_INT   Hardware interrupts
</PRE> 

<P>

<H1><A NAME="SECTION00920000000000000000"></A>
<A NAME="sec:cpc"></A>
<BR>
CPC
</H1>

<P>
Available counter names can be queried with the VampirTrace tool <TT>vtcpcavail</TT>.
In addition to the counter names, it shows how many performance counters can be
queried at a time. See below for a sample output.

<P>
<PRE>
% ./vtcpcavail
CPU performance counter interface: UltraSPARC T2
Number of concurrently readable performance counters
on the CPU: 2

Available events:
AES_busy_cycle
AES_op
Atomics
Br_completed
Br_taken
CPU_ifetch_to_PCX
CPU_ld_to_PCX
CPU_st_to_PCX
CRC_MPA_cksum
CRC_TCPIP_cksum
DC_miss
DES_3DES_busy_cycle
DES_3DES_op
DTLB_HWTW_miss_L2
DTLB_HWTW_ref_L2
DTLB_miss
IC_miss
ITLB_HWTW_miss_L2
ITLB_HWTW_ref_L2
ITLB_miss
Idle_strands
Instr_FGU_arithmetic
Instr_cnt
Instr_ld
Instr_other
Instr_st
Instr_sw
L2_dmiss_ld
L2_imiss
MA_busy_cycle
MA_op
MD5_SHA-1_SHA-256_busy_cycle
MD5_SHA-1_SHA-256_op
MMU_ld_to_PCX
RC4_busy_cycle
RC4_op
Stream_ld_to_PCX
Stream_st_to_PCX
TLB_miss

See the "UltraSPARC T2 User's Manual" for descriptions of these
events. Documentation for Sun processors can be found at:
http://www.sun.com/processors/manuals
</PRE>

<P>

<H1><A NAME="SECTION00930000000000000000"></A>
<A NAME="sec:necsx_pc"></A>
<BR>
NEC SX Hardware Performance Counter
</H1>
This is a list of all supported hardware performance counters for NEC SX machines.

<P>
<PRE>
SX_CTR_STM    System timer reg
SX_CTR_USRCC  User clock counter
SX_CTR_EX     Execution counter
SX_CTR_VX     Vector execution counter
SX_CTR_VE     Vector element counter
SX_CTR_VECC   Vector execution clock counter
SX_CTR_VAREC  Vector arithmetic execution clock counter
SX_CTR_VLDEC  Vector load execution clock counter
SX_CTR_FPEC   Floating point data execution counter
SX_CTR_BCCC   Bank conflict clock counter
SX_CTR_ICMCC  Instruction cache miss clock counter
SX_CTR_OCMCC  Operand cache miss clock counter
SX_CTR_IPHCC  Instruction pipeline hold clock counter
SX_CTR_MNCCC  Memory network conflict clock counter
SX_CTR_SRACC  Shared resource access clock counter
SX_CTR_BREC   Branch execution counter
SX_CTR_BPFC   Branch prediction failure counter
</PRE>

<P>

<H1><A NAME="SECTION00940000000000000000"></A>
<A NAME="sec:rusage_list"></A>
<BR>
Resource Usage
</H1>

<P>
The list of resource usage counters can also be found in the 
manual page of <TT>getrusage</TT>. Note that, depending on the operating
system, not all fields may be maintained. The fields supported
by the Linux 2.6 kernel are shown in the table.

<P>

<P>
<TABLE CELLPADDING=3>
<TR><TH ALIGN="LEFT"><SPAN  CLASS="textbf">Name</SPAN></TH>
<TH ALIGN="LEFT"><SPAN  CLASS="textbf">Unit</SPAN></TH>
<TH ALIGN="CENTER"><SPAN  CLASS="textbf">Linux</SPAN></TH>
<TH ALIGN="LEFT"><SPAN  CLASS="textbf">Description</SPAN></TH>
</TR>
<TR><TD ALIGN="LEFT"><TT>ru_utime</TT></TD>
<TD ALIGN="LEFT">ms</TD>
<TD ALIGN="CENTER">x</TD>
<TD ALIGN="LEFT">Total amount of user time used.</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>ru_stime</TT></TD>
<TD ALIGN="LEFT">ms</TD>
<TD ALIGN="CENTER">x</TD>
<TD ALIGN="LEFT">Total amount of system time used.</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>ru_maxrss</TT></TD>
<TD ALIGN="LEFT">kB</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="LEFT">Maximum resident set size.</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>ru_ixrss</TT></TD>
<TD ALIGN="LEFT">kB &#215; s</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="LEFT">Integral shared memory size (text segment) over the runtime.</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>ru_idrss</TT></TD>
<TD ALIGN="LEFT">kB &#215; s</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="LEFT">Integral data segment memory used over the runtime.</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>ru_isrss</TT></TD>
<TD ALIGN="LEFT">kB &#215; s</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="LEFT">Integral stack memory used over the runtime.</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>ru_minflt</TT></TD>
<TD ALIGN="LEFT">#</TD>
<TD ALIGN="CENTER">x</TD>
<TD ALIGN="LEFT">Number of soft page faults (i.e. those serviced by reclaiming a page from the list of pages awaiting reallocation).</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>ru_majflt</TT></TD>
<TD ALIGN="LEFT">#</TD>
<TD ALIGN="CENTER">x</TD>
<TD ALIGN="LEFT">Number of hard page faults (i.e. those that required I/O).</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>ru_nswap</TT></TD>
<TD ALIGN="LEFT">#</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="LEFT">Number of times a process was swapped out of physical memory.</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>ru_inblock</TT></TD>
<TD ALIGN="LEFT">#</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="LEFT">Number of input operations via the file system.  Note: This and <TT>ru_oublock</TT> do not include operations with the cache.</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>ru_oublock</TT></TD>
<TD ALIGN="LEFT">#</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="LEFT">Number of output operations via the file system.</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>ru_msgsnd</TT></TD>
<TD ALIGN="LEFT">#</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="LEFT">Number of IPC messages sent.</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>ru_msgrcv</TT></TD>
<TD ALIGN="LEFT">#</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="LEFT">Number of IPC messages received.</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>ru_nsignals</TT></TD>
<TD ALIGN="LEFT">#</TD>
<TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="LEFT">Number of signals delivered.</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>ru_nvcsw</TT></TD>
<TD ALIGN="LEFT">#</TD>
<TD ALIGN="CENTER">x</TD>
<TD ALIGN="LEFT">Number of voluntary context switches, i.e. because the process gave up the processor before it had to (usually to wait for some resource to be available).</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>ru_nivcsw</TT></TD>
<TD ALIGN="LEFT">#</TD>
<TD ALIGN="CENTER">x</TD>
<TD ALIGN="LEFT">Number of involuntary context switches, i.e. a higher priority process became runnable or the current process used up its time slice.</TD>
</TR>
</TABLE>

<P>

<P>

<H1><A NAME="SECTION001000000000000000000">
Using VampirTrace with IOFSL</A>
</H1>
<A NAME="chap:iofsl"></A>
<H1><A NAME="SECTION001010000000000000000">
Introduction</A>
</H1>

<P>
VampirTrace and OTF can make use of the I/O Forwarding Scalability Layer (IOFSL) which allows users to write the data of many streams of a parallel trace into one or few physical files (so called multifiles) during program run. Compared with the default of writing at least two files per stream, process or even thread, this can provide a substantial performance benefit and is especially important for stability when recording highly parallel traces.

<P>

<H1><A NAME="SECTION001020000000000000000">
Overview</A>
</H1>

<P>
This section gives an overview over the architecture and principles from a technical point of view.

<P>

<H2><A NAME="SECTION001021000000000000000">
File handling in OTF</A>
</H2>

<P>
The Open Trace Format (OTF) is utilized by VampirTrace to store its trace information obtained during a run of the instrumented application. The OTF library provides an interface for reading and writing trace files. A trace consists of one or more so called streams, each containing the data of one process or thread. The data is stored in records encoded using a plain ASCII format and can optionally be transparently compressed. Although it basically offers a way to store several streams in one physical file, it does not offer mechanisms to assure data consistency for concurrent writes into one file.

<P>
To allow for arbitrary thread creation during a trace run and to avoid expensive locking, VampirTrace writes the obtained data of each process or thread into separate OTF files causing the creation of at least two files per process/thread (definitions and events). With the ever increasing number of parallel processes and the limitations of today's parallel filesystem's meta-data processing, this can become a severe problem for system performance and stability. Consequently, the goal was to significantly reduce the number of physical files used by VampirTrace and OTF during a trace run from at least two files per process/thread to a number that is acceptable for today's filesystems.

<P>

<H2><A NAME="SECTION001022000000000000000">
I/O Forwarding Scalability Layer</A>
</H2>

<P>
The goal of the I/O Forwarding Scalability Layer IOFSL is to provide a forwarding layer on the basis of a client-server architecture. It allows clients to send I/O requests to a server which is able to execute the original I/O calls and even aggregate these requests to improve performance. Besides the aggregation of normal write requests, the server also offers non-blocking write requests and a so-called atomic append mode which allows many clients to write potentially large blocks of data concurrently into one single physical file (multifile) without the need for client-side locking. In this case, the data is appended to the end of the file and the corresponding offset can be obtained later. Additionally, this atomic append feature can be used with more than one server allowing the write requests of many clients into one file being distributed across a smaller number of servers.

<P>
IOFSL is being developed at Argonne National Laboratory and is available at www.iofsl.org. By relying on open software, it is portable to a wide range of machines and has been tested on a generic Linux cluster as well as on the leadership-class computing system Jaguar.

<P>

<H2><A NAME="SECTION001023000000000000000">
Architecture</A>
</H2>
Integrating the three previously described parts leads to an architecture with VampirTrace and OTF built on top of IOFSL.
The instrumented application generates events that are handled and buffered by the VampirTrace runtime library.
When the thread local buffer is full, the events are passed to the OTF library where they are compressed.
If the IOFSL mode is enabled, the resulting write buffers are passed to the IOFSL client library (zoidfs) which sends the data to the IO forwarding servers where it is aggregated (atomic append), buffered and finally sent out to the file system.

<P>
Since IOFSL servers can handle multiple clients, an N:M mapping of clients to servers is possible. The exact ratio depends on the amount of data the clients send and the bandwidth available for the server nodes. In our test cases, a ratio of up to 300 clients per server was used.

<P>
When using the IOFSL integration, all write requests in OTF are issued using the zoidfs API<A NAME="tex2html12"
  HREF="#foot3310"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A>. Those writes are handled by the IOFSL forwarding servers and aggregated into a single file using the atomic append feature. The offset in the multifile is returned to OTF and stored in a second file, the so called index file, in order to maintain the mapping between written blocks and streams. For any block of a stream written into the multifile, the index file contains the ID of the stream, the start of the block, and its length. This allows for an efficient reading of blocks since only the index file has to be scanned for entries for a given stream ID. Additionally, a large number of logical files (streams) can be stored using only two physical files.

<P>

<H1><A NAME="SECTION001030000000000000000">
Installation</A>
</H1>

<P>
In order to use this setup, IOFSL and VampirTrace have to be compiled in order.
In the following sections, the directory <TT>&lt;install_dir&gt;</TT> should be replaced with a - possibly user-local - directory used for installation, e.g. <TT>$HOME/local</TT><A NAME="tex2html13"
  HREF="#foot3314"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A>.
The installation procedure for IOFSL is described at https://trac.mcs.anl.gov/projects/iofsl/wiki/Building.
Currently the <TT>iofsl_vampir</TT> git branch is required.

<P>

<H2><A NAME="SECTION001031000000000000000">
Support Libraries</A>
</H2>
IOFSL requires several libraries in order to work correctly:

<UL>
<LI>GNU autoconf in version 2.61 or higher
</LI>
<LI>Boost packages <TT>date_time</TT>, <TT>program_options</TT>, <TT>regex</TT>, <TT>thread</TT>, and <TT>test</TT>, available at www.boost.org
</LI>
<LI>BMI/PVFS, available at www.pvfs.org
</LI>
<LI>OpenPA, available at https://trac.mcs.anl.gov/projects/openpa/
</LI>
</UL>

<P>
Note that building boost, OpenPA or BMI/PVFS is not required in case it is already present on the machine. Building GNU autoconf is not covered by this document.
For the use with VampirTrace, ROMIO and therefore rebuilding MPICH is not required.

<P>

<H4><A NAME="SECTION001031010000000000000">
Building Boost</A>
</H4>
Boost Version 1.46.1 is recommended, other Versions might be incompatible.
To build the required boost libraries, issue the following commands in the source directory:
<PRE>
$&gt; ./bootstrap.sh \
   --with-libraries=system,date_time,\
program_options,regex,thread,test \
   --prefix=&lt;install_dir&gt;

$&gt; ./bjam  --prefix=&lt;install_dir&gt; \
   --libdir=&lt;install_dir&gt;/lib \
   --includedir=&lt;install_dir&gt;/include \
   install
</PRE>

<P>

<H4><A NAME="SECTION001031020000000000000">
Building OpenPA</A>
</H4> To build the required OpenPA library, issue the following commands in the source directory:

<P>
<PRE>
$&gt; ./configure --prefix=&lt;install_dir&gt;
$&gt; make all install
</PRE>

<P>

<H4><A NAME="SECTION001031030000000000000">
Building BMI/PVFS</A>
</H4> To build the required BMI/PVFS library, issue the following commands in the source directory:

<P>
<PRE>
$&gt; ./configure --enable-bmi-only --prefix=&lt;install_dir&gt; \
   --with-openib=&lt;openib_install_dir&gt;
$&gt; make all install
</PRE>
Note that the option <TT>-with-openib</TT> can be omitted if support for direct access to InfiniBand is not required.

<P>

<H2><A NAME="SECTION001032000000000000000">
Building IOFSL</A>
</H2>
Create a local copy of the git reposotiry branch:

<P>
<PRE>
$&gt; mkdir iofsl
$&gt; cd iofsl
$&gt; git init
$&gt; git remote add -t iofsl_vampir \
   -f origin git://git.mcs.anl.gov/iofsl.git
$&gt; git checkout iofsl_vampir
$&gt; ./prepare
</PRE>

<P>
The following commands can be used to build the IOFSL client and server:

<P>
<PRE>
$&gt; ./configure --with-bmi=&lt;install_dir&gt; \
   --with-boost=&lt;install_dir&gt; --with-openpa=&lt;install_dir&gt; \
   --prefix=&lt;install_dir&gt; --with-cunit=no

$&gt; make all install
</PRE>

<P>

<H2><A NAME="SECTION001033000000000000000">
Building VampirTrace &amp; OTF</A>
</H2>
After extracting the source code from the archive, issue the following commands:
<PRE>
$&gt; ./configure                         \
   --prefix=&lt;install_dir&gt;              \
   --enable-iofsl                      \
   --with-zoidfs-dir=&lt;install_dir&gt;     \
   --with-bmi-dir=&lt;install_dir&gt;        \
# On Cray XK6 with PBS as batch system add
   --enable-iofsl-scripts=crayxk6
$&gt; make all install
</PRE>

<P>

<H1><A NAME="SECTION001040000000000000000"></A>
<A NAME="sec:examples"></A>
<BR>
Usage Examples
</H1>

<P>
The use of I/O forwarding servers implicates a system specific deployment.
VampirTrace mitigates this effort by providing convenient scripts for specific system setups.
Currently Cray XK6 systems are supported, which are described here.
Furthermore the IOFSL specific adjustable parameters of VampirTrace are described.

<P>

<H2><A NAME="SECTION001041000000000000000">
Using VampirTrace with IOFSL on Cray XK6 / with PBS</A>
</H2>

<H3><A NAME="SECTION001041100000000000000">
Building your application with VampirTrace</A>
</H3>

<P>
We assume that VampirTrace with IOFSL support has been installed as previously described.
This might be deployed to the user using a module.

<P>
<PRE>
   # Check module av vampirtrace to
   # see what is available at your system
$&gt; module load vampirtrace/5.13
</PRE>

<P>
Build your application as usual with VampirTrace.
For details please refer to the general part of this documentation.

<P>
<PRE>
$&gt; vtcc -vt:hyb application.c -o application
</PRE>

<P>

<H3><A NAME="SECTION001041200000000000000">
Running an Example</A>
</H3>

<P>
The scripts <TT>vtiofsl-start</TT> and <TT>vtiofsl-stop</TT> are provided to control the IOFSL server instances.
They will be launched on dedicated compute nodes that are part of the batch Job allocation.

<P>

<H4><A NAME="SECTION001041210000000000000">
PBS Options</A>
</H4>
It is important to reserve a sufficient number of processor cores. The number of cores requested must be large enough to contain the number of application cores plus the number of cores required for the IOFSL server instances. Each IOFSL server will run on a dedicated node<A NAME="tex2html14"
  HREF="#foot3358"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A>.Thus N_allocated &#8805;((N_IOFSL * 16) + N_Application) must hold.
<P>
Example using 64 server instances:
<PRE>
#!/bin/sh
#PBS...
[...]
## Allocate enough cores: (64 * 16) + 16384 =&gt; 17408
#PBS -l size=17408
## Preserve environment
#PBS -V
</PRE>

<P>

<H4><A NAME="SECTION001041220000000000000">
Environment Variables</A>
</H4>

<P>
It is highly recommended to set the following environment variable.

<UL>
<LI><TT>VT_PFORM_GDIR</TT>: The directory that will contain the final trace and some temporary IOFSL output.
</LI>
</UL>
Example:
<PRE>
[...]
# The directory to which the trace is written
mkdir trace
export VT_PFORM_GDIR=$PWD/trace
</PRE>

<P>

<H4><A NAME="SECTION001041230000000000000">
Execution</A>
</H4>
Launching and stopping the servers as is done using the supplied scripts.
The scripts are sourced from the job script or interactive shell to allow them setting required environment variables for VampirTrace.
<PRE>
[...]
# rca module need to be loaded!
. /opt/modules/default/etc/modules.sh
module load rca

# Start server
source vtiofsl-start -n 64

# Run application as usual
aprun -n 16384 application --parameter inputfile

# Shutdown server
source vtiofsl-stop
</PRE>

<P>

<H4><A NAME="SECTION001041240000000000000">
Interactive Jobs</A>
</H4>

<P>
Interactive jobs work the same way. You can either run a script similar to the job submission script, or run the commands from your shell. However the scripts are developed and tested on <TT>bash</TT>. Other shells are not supported.

<P>
The <TT>vtiofsl</TT>-scripts assume to be run within a PBS job. If you run them multiple times within one job, the detailed log files may be overwritten.

<P>

<H4><A NAME="SECTION001041250000000000000">
Log files and debug information</A>
</H4>

<P>
The <TT>vtiofsl</TT>-scripts create a number of log files and configuration files in the <TT>$VT_PFORM_GDIR/.iofsl</TT> directory.

<P>

<H2><A NAME="SECTION001042000000000000000"></A>
<A NAME="sec:iofsl-manual"></A>
<BR>
Manual Usage
</H2>
The machine specific installation strives to hide most of the complexity of the I/O forwarding solution from the end-user.
In the background, the forwarding server(s) are started and environment variables are set in order to point VampirTrace / OTF to them.

<P>

<H4><A NAME="SECTION001042010000000000000">
Configuring the Server</A>
</H4>
The server is configured using a configuration file.
At server start-up, this file is provided using the <TT>-config</TT> argument.
The cray XK6 configuration file is provided in the package<A NAME="tex2html15"
  HREF="#foot3498"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A>.
For more information about the options available please refer to the IOFSL documentation<A NAME="tex2html16"
  HREF="#foot3499"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A>.
The most important option is the <TT>serverlist</TT> entry in the <TT>bmi</TT> section which takes a list of server addresses, e.g. :
<PRE>
bmi
{
  serverlist =  ( "tcp://192.168.97.236:12345", 
                  "tcp://192.168.97.237:12345", 
                  "tcp://192.168.97.238:12346" );
}
</PRE>
At start-up, the server looks for the environment variable <TT>ZOIDFS_SEVER_RANK</TT> to determine its address, e.g. <TT>ZOIDFS_SEVER_RANK=0</TT> would cause the address
<TT>tcp://192.168.97.236:12345</TT> to be used. The configuration file can be shared between all server instances and lets the servers determine the coordination server, which is usually rank 0.

<P>

<H4><A NAME="SECTION001042020000000000000">
Launching the Servers</A>
</H4>

<P>
The I/O forwarding server (<TT>iofwd</TT>) can be deployed in multiple ways.
This is highly system specific, possible ways to do so are:

<UL>
<LI><TT>ssh</TT> to the compute nodes and execute <TT>iofwd</TT> there.
</LI>
<LI>Running <TT>iofwd</TT> on dedicated I/O nodes with user access.
</LI>
<LI>Using a system specific launcher, e.g. <TT>aprun</TT> on Cray systems.
</LI>
<LI>Making use of advanced batch system features.
</LI>
</UL>

<P>

<H4><A NAME="SECTION001042030000000000000">
Pointing VampirTrace to the servers</A>
</H4>

<P>
The list of available I/O forwarding servers is provided to VampirTrace by setting <TT>VT_IOFSL_SERVERS</TT> to a comma-separated list of addresses, e.g.

<P>
<PRE>
export VT_IOFSL_SERVERS= \
     "tcp://192.168.1.1:12345,tcp://192.168.1.2:12345"
</PRE>
VampirTrace / OTF will choose a server upon opening the file based on the stream identifier encoded in the original filename.

<P>

<H4><A NAME="SECTION001042040000000000000">
File modes</A>
</H4>

<P>
In the default setting, each server will create two files for each type of file, the actual file containing the appended data and an index file.
This mode is called <TT>MULTIFILE_SPLIT</TT>.
It provides a good workload for parallel file systems.
In the so called <TT>MULTIFILE</TT> mode, all servers share data and index files.
It requires additional synchronization between the servers.
Also the Lustre file system does not allow to stripe individual files over more than a maximum number of storage targets, introducing a performance-bottleneck.
The <TT>MULTIFILE</TT> mode should be considered experimental.
Therefore, using the default mode is recommended.
The mode can be set using <TT>VT_IOFSL_MODE</TT> to either <TT>MULTIFILE_SPLIT</TT> or <TT>MULTIFILE</TT>.

<P>

<H4><A NAME="SECTION001042050000000000000">
Asynchronous I/O</A>
</H4>

<P>
IOFSL offers a capability, where write requests are buffered on the forwarding server.
This can reduce the trace flush times, without consuming node local resources.
To enable this, <TT>VT_IOFSL_ASYNC_IO</TT> is set to <TT>yes</TT>.

<P>

<H4><A NAME="SECTION001042060000000000000">
Unification</A>
</H4>

<P>
The unification step can also use the IOFSL mode for writing the output trace.
This is controlled with the same environment variables.
Therefore if VampirTrace uses IOFSL, the implicit unification at the end of the trace run will also use IOFSL for output.
If <TT>VT_UNIFY=no</TT>, then one should make sure that the correct IOFSL environment is also available to the later <TT>vtunify(-mpi)</TT>, unless intended otherwise.

<P>

<H4><A NAME="SECTION001042070000000000000">
Compatibility of the generated trace</A>
</H4>

<P>
All tools that work on the generated trace need to be built with the appropriate OTF Version to ensure compatibility with traces generated with IOFSL.
This especially applies to the Vampir visualization server and GUI.
If backwards compatibility is required, the trace can be transformed using <TT>otfmerge</TT>, e.g.

<P>
<PRE>
$&gt; mpirun -np 1024 \
       otfmerge-mpi -n 0 -o merged-trace input-trace.otf
</PRE>

<P>

<H1><A NAME="SECTION001100000000000000000">
FAQ</A>
</H1>

<P>

<H1><A NAME="SECTION001110000000000000000"></A>
<A NAME="sec:faq_compiler"></A>
<BR>
Can I use different compilers for VampirTrace and my application?
</H1>

<P>
There are several limitations which make this generally a bad idea:

<UL>
<LI>Using different compilers when tracing OpenMP applications does not work.
</LI>
<LI>Both compilers should have the same naming style for Fortran symbols
       (i.e. uppercase/lowercase, appending underscores) when tracing Fortran MPI
       applications.
</LI>
<LI>VampirTrace must be built to support the instrumentation type of the
       compiler you use for the application.
</LI>
</UL>
For example, the combination of a GCC compiled VampirTrace with an Intel compiled
application will work except for OpenMP. But to avoid any trouble it is advisable
to compile both VampirTrace and the application with the same compiler.

<P>

<H1><A NAME="SECTION001120000000000000000"></A>
<A NAME="sec:gnu_getsrc"></A>
<BR>
Why does my application need such a long time for starting?
</H1>

<P>
If subroutines have been instrumented with automatic instrumentation by GNU, Intel,
PathScale, or Open64 compilers, VampirTrace needs to look-up the function names and
their source code line before program start. In certain cases, this may take very long.
To accelerate this process prepare a file with symbol information using the command <TT>nm</TT>
as explained in Section&nbsp;<A HREF="#sec:compinst">2.3</A> and set <TT>VT_GNU_NMFILE</TT>
to the pathname of this file. This method prevents VampirTrace from getting the
function names from the binary.

<P>

<H1><A NAME="SECTION001130000000000000000"></A>
<A NAME="sec:faq_limitcompilerinst"></A>
<BR>
How can I limit compiler instrumentation?
</H1>
Fully-automatic instrumentation by the compilers is the most convenient method to instrument your program.
However, a variety of functions will be instrumented and all calls of these functions will be traced.
Runtime filters do not eliminate complete overhead of tracing automatically instrumented functions.
Therefore, it is often desirable to limit compiler instrumentation to specific functions.
Several compilers provide options to configure function instrumentation.
Start with VampirTrace in Profiling Mode by setting <TT>VT_MODE</TT> to <TT>STAT</TT>.
The profiling information can be used to determine functions which may be excluded from automatic instrumentation.

<P>
The IBM C compiler &#8805;11 and Fortran compiler &#8805;13 provide <TT>-qfunctrace</TT> option to enable tracing for all functions.
To disable tracing for all functions you can use <TT>-qnofunctrace</TT>.
Regardless of <TT>-qnofunctrace</TT> both <TT>-qfunctrace+</TT> and <TT>-qfunctrace-</TT> can be used to enable resp. disable tracing for a colon-separated list of function names, classes, or namespaces.
For example, 

<P>
<BR>
<BR>
<code>   -qfunctrace -qfunctrace-myFunc1:myFunc2</code>
<BR>
<BR>
<BR>
enables tracing for all functions except for <TT>myFunc1</TT> and <TT>myFunc2</TT>.

<P>
Also GNU compiler &#8805;4.3 provides options to limit compiler instrumentation.
<TT>-finstrument-functions-exclude-file-list</TT> sets a list of files.
All functions defined in a file of this list will be excluded from instrumentation.
The option <TT>-finstrument-functions-exclude-function-list</TT> sets a list of function names that are excluded from instrumentation.
Arguments of both compiler options must be separated by comma.
Matching of arguments with function or file names is done on substrings.
For example,  

<P>
<BR>
<BR>
<code>   -finstrument-functions-exclude-file-list=include</code>
<BR>
<BR>
<BR>
will exclude any function defined in files whose pathnames contain "include".
Maybe such a rule is too restrictive, because the "include" directory of your own program code is affected too.
The pattern needs to be specified more precisely, for instance:

<P>
<BR>
<BR>
<code>   -finstrument-functions-exclude-file-list=/usr/include</code>
<BR>
<BR>
<BR>
This rule can be used to exclude Standard Template Library (STL) calls in C++ from tracing.

<P>

<H1><A NAME="SECTION001140000000000000000"></A>
<A NAME="sec:faq_fortranio"></A>
<BR>
Why do I see multiple
I/O operations for a single (un)formatted file read/write from my Fortran
application?
</H1>

<P>
VampirTrace does not implement any tracing at the Fortran language level.
Therefore it is unaware of any I/O function calls done by Fortran applications.

<P>
However, if you enable I/O tracing using <TT>VT_IOTRACE</TT>, VampirTrace
records all calls to LIBC's I/O functions. As Fortran uses the LIBC interface
for executing its I/O operations, these function calls will be part of the
trace. Depending on your Fortran compiler, a single Fortran file read/write
operation may be split into several LIBC read calls which you will then see in
your trace.

<P>
Beware that this may lead you to the (wrong) conclusion that your application
spends time between the LIBC I/O calls inside the user function that contains
the Fortran I/O call, especially when doing formatted I/O .
It is rather the Fortran I/O subsystem which does
all the formatting of the data that is eating your cpu cycles. But as this layer
is unknown to VampirTrace, it cannot be shown and the time is accounted to the
next higher function in the call stack - the user function.

<P>

<H1><A NAME="SECTION001150000000000000000">
The application has run to completion, but there is no *.otf file. What can I do?</A>
</H1>

<P>
The absence of an <TT>*.otf</TT> file usually means that the trace was not unified. This
is the case on certain platforms, e.g.&nbsp;when using DYNINST or when the local traces
are not available when the application ends and VampirTrace performs trace unification.

<P>
In those cases, a <TT>*.uctl</TT> file can be found in the directory of the trace file and the
user needs to perform trace unification manually. 
<H1><A NAME="SECTION001160000000000000000"></A>
<A NAME="sec:faq_onoff"></A>
<BR>
What limitations are associated with "on/off" and buffer rewind?
</H1>

<P>
Starting and stopping tracing by using the <TT>VT_ON/VT_OFF</TT> calls 
as well as the buffer rewind method are considered
advanced usage of VampirTrace and should be performed with care. When restarting
the recording of events, the call stack of the application has to have the same depth
as when the recording was stopped. The same applies for the rewind call, which
has to be at the same stack level as the rewind mark. If this is not the case, an error
message will be printed during runtime and VampirTrace will abort execution.
A safe method is to call <TT>VT_OFF</TT> and <TT>VT_ON</TT> in the same function.

<P>
It is allowed to use "on/off" in a section between a rewind mark and a buffer rewind call.
But it is not allowed to call <TT>VT_SET_REWIND_MARK</TT> or <TT>VT_REWIND</TT>
during a section deactivated by the "on/off" functionality.

<P>
Buffer flushes interfere with the rewind method: If the trace buffer is flushed
after the call to <TT>VT_SET_REWIND_MARK</TT>, the mark is removed and a subsequent 
call to <TT>VT_REWIND</TT> will not work and issue a warning message.

<P>
In addition, stopping or rewinding tracing while waiting for MPI messages can cause those MPI messages not to
be recorded in the trace. This can cause problems when analyzing the OTF trace afterwards, e.g.,&nbsp; with Vampir.

<P>

<H1><A NAME="SECTION001170000000000000000"></A>
<A NAME="sec:faq_filelock"></A>
<BR>
VampirTrace warns that it ``cannot lock file a.lock'', what's wrong?
</H1>

<P>
For unique naming of multiple trace files in the same directory, a file <TT>*.lock</TT>
is created and locked for exclusive access if <TT>VT_FILE_UNIQUE</TT>
is set to <TT>yes</TT> (&#8658;&nbsp;Section&nbsp;<A HREF="#sec:tracefilename">3.1</A>).
Some file systems do not implement file locking.
In this case, VampirTrace still tries to name the trace files uniquely, but this may fail
in certain cases.
Alternatively, you can manually control the unique file naming by setting 
<TT>VT_FILE_UNIQUE</TT> to a different numerical ID for each program run.

<P>

<H1><A NAME="SECTION001180000000000000000"></A>
<A NAME="sec:faq_relocate"></A>
<BR>
Can I relocate my VampirTrace installation without rebuilding from source?
</H1>

<P>
VampirTrace hard-codes some directory paths in its executables and libraries based on installation
paths specified by the <TT>configure</TT> script. However, it's possible to move an existing VampirTrace
installation to another location and use it without rebuild from source.
Therefore it's necessary to set the environment variable <TT>VT_PREFIX</TT> to the new installation prefix
before using VampirTrace's Compiler Wrappers (&#8658;&nbsp;Section&nbsp;<A HREF="#sec:compiler_wrappers">2.1</A>) or launching an
instrumented application. For example:

<P>
<PRE>
./configure --prefix=/opt/vampirtrace
make install
mv /opt/vampirtrace $HOME/vampirtrace
export VT_PREFIX=$HOME/vampirtrace
</PRE>

<P>

<H1><A NAME="SECTION001190000000000000000"></A>
<A NAME="sec:faq_collective_bytes"></A>
<BR>
What are the byte counts in collective communication records?
</H1>

<P>
The byte counts in collective communication records changed with version 5.10.

<P>
From 5.10 on, the byte counts of collective communication records show the 
bytes per rank given to the MPI call or returned by the MPI call. 
This is the MPI API perspective. It is next to impossible to find out how many 
bytes are actually sent or received during a collective operation by any other 
MPI implementation.

<P>
In the past (until VampirTrace version 5.9), the byte count in collective 
operation records was defined differently. It used a simple and naive 
hypothetical implementation of collectives based on point-to-point messages 
and derived the byte counts from that. This might have been more confusing than
helpful and was therefore changed. 

<P>
Thanks to Eugene Loh for pointing this out!

<P>

<H1><A NAME="SECTION0011100000000000000000"></A>
<A NAME="sec:faq_asm_error"></A>
<BR>
I get ``error: unknown asm constraint letter''
</H1>

<P>
It is a known issue with the tau_instrumentor that it doesn't support inline assembler code.
At the moment there is no other solution than using another kind of instrumentation like
compiler instrumenation (&#8658;&nbsp;Section&nbsp;<A HREF="#sec:compinst">2.3</A>) or manual instrumenation (&#8658;&nbsp;Section&nbsp;<A HREF="#sec:maninst">2.4</A>).

<P>

<H1><A NAME="SECTION0011110000000000000000"></A>
<A NAME="sec:faq_unanswered"></A>
<BR>
I have a question that is not answered in this document!
</H1>

<P>
You may contact us at mailto:vampirsupport@zih.tu-dresden.devampirsupport@zih.tu-dresden.de
for support on installing and using VampirTrace.

<P>

<H1><A NAME="SECTION0011120000000000000000"></A>
<A NAME="sec:faq_morefeatures"></A>
<BR>
I need support for additional features so I can trace application xyz.
</H1>

<P>
Suggestions are always welcome (contact: vampirsupport@zih.tu-dresden.de)
but there is a chance that we can not implement all your wishes as our resources
are limited.

<P>
Anyways, the source code of VampirTrace is open to everybody so you may
implement support for new stuff yourself.
If you provide us with your additions afterwards we will consider merging them
into the official VampirTrace package.
<BR><HR><H4>Footnotes</H4>
<DL>
<DT><A NAME="foot1614">... (OTF)</A><A
 HREF="#tex2html1"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD>http://www.tu-dresden.de/zih/otf

</DD>
<DT><A NAME="foot1615">... tool </A><A
 HREF="#tex2html2"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD>http://www.vampir.eu

</DD>
<DT><A NAME="foot1616">...
Open MPI </A><A
 HREF="#tex2html3"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD>http://www.open-mpi.org/faq/?category=vampirtrace

</DD>
<DT><A NAME="foot1640">... documentation </A><A
 HREF="#tex2html4"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD>http://www.cs.uoregon.edu/Research/tau/docs/newguide/bk05ch02.html#d0e3770

</DD>
<DT><A NAME="foot1641">...
Dyninst </A><A
 HREF="#tex2html5"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD>http://www.dyninst.org

</DD>
<DT><A NAME="foot1642">... library </A><A
 HREF="#tex2html6"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD>http://sourceforge.net/projects/ctool

</DD>
<DT><A NAME="foot1652">... CLAPACK</A><A
 HREF="#tex2html7"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD>www.netlib.org/clapack

</DD>
<DT><A NAME="foot1680">... Dyninst </A><A
 HREF="#tex2html8"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD>http://www.dyninst.org

</DD>
<DT><A NAME="foot1681">... PDToolkit </A><A
 HREF="#tex2html9"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD>http://www.cs.uoregon.edu/research/pdt/home.php

</DD>
<DT><A NAME="foot1682">... TAU </A><A
 HREF="#tex2html10"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD>http://tau.uoregon.edu

</DD>
<DT><A NAME="foot1683">... CTool </A><A
 HREF="#tex2html11"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD>http://sourceforge.net/projects/ctool

</DD>
<DT><A NAME="foot3310">... API</A><A
 HREF="#tex2html12"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD>The OTF master control file is written using POSIX I/O in any case.

</DD>
<DT><A NAME="foot3314">...$HOME/local</A><A
 HREF="#tex2html13"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD>The software packages can be installed in different directories.

</DD>
<DT><A NAME="foot3358">... node</A><A
 HREF="#tex2html14"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD>The server makes use of all the nodes resources by multithreading and allocating large I/O buffers

</DD>
<DT><A NAME="foot3498">... package</A><A
 HREF="#tex2html15"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD><TT>tools/vtiofsl/platform/crayxk6-iofwd.cf</TT>

</DD>
<DT><A NAME="foot3499">... documentation</A><A
 HREF="#tex2html16"><SUP><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="/usr/share/latex2html/icons/footnote.png"></SUP></A></DT>
<DD>https://trac.mcs.anl.gov/projects/iofsl/wiki/ConfigurationFile

</DD>
</DL>
<BR><HR>

</BODY>
</HTML>
