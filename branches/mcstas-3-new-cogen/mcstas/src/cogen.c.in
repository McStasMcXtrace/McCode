/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright (C) 1997-2006, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*         Copenhagen University, Copenhagen, Denmark
*
* Kernel: cogen.c
*
* %Identification
* Written by: K.N.
* Modifed for X-rays by E.K.
* Date: Aug  20, 1997
* Origin: Risoe
* Release: McStas 1.6
* Version: $Revision$
*
* Code generation from instrument definition.
*
*******************************************************************************/

#include <stdarg.h>
#include <string.h>
#include <stdio.h>
#include "mccode.h"


/*******************************************************************************
* Some general comments on code generation.
*
* Code is output in the form of strings using the following functions:
*   cout();                        (one line at a time)
*   coutf();                       (with printf-style formatting)
*
* The type of numbers used in the generated code is given by the macro MCNUM
* (defined in mccode-r.h).
*
* All generated identifiers are prefixed with the string ID_PRE, to make name
* clashes less likely to occur. Currently, for simplicity, we output modified
* names directly, eg.
*
*   cout("void " ID_PRE "init(void);");
*
* But to make a later transition to a better name generation scheme possible,
* it is important to use the ID_PRE macro everywhere identifiers are
* generated.
*
* After the ID_PRE prefix a few letters occur in generated names to
* distinguish different kinds of identifiers (instrument parameters,
* component definition parameters, internal temporary variables and so on).
* Care must be takes to choose these letters such that no name clashes will
* occur with names generated by other parts of the code or generated from
* user symbols.
*
* Finally, names generated from user symbols are generally chosen to match
* the originals as closely as possible to make the generated code more
* readable (for debugging purposes).
*
* The following is a list of the identifiers generated in the output. The
* ID_PRE prefix is denoted by ##. The first column gives the identifier as it
* appears in the generated code, the second explains the origin of the
* identifier in the instrument definition source (if any).
*
* ##ip<PAR>        From instrument parameter <PAR>.
* ##init           Function containing initialization code.
* ##inputtable     Table of instrument parameters.
* ##NUMIPAR        Macro giving the number of instrument parameters.
* ##numipar        Global variable with the value of ##NUMIPAR.
* ##c<C>_<P>       From definition or setting parameter <P> in component
*                  instance <C>.
* ##posa<COMP>     Absolute position of coordinate system of <COMP>.
* ##posr<COMP>     Position of <COMP> relative to previous component.
* ##rota<COMP>     Absolute rotation.
* ##rotr<COMP>     Relative rotation.
* ##tc1            Temporary variable used to compute transformations.
* ##tc2
* ##tr1
* ##nx             Neutron state (position, velocity, time, and spin).
* ##ny             or Xray state (position, wavevector, phase, polarisation, and weight).
* ##nz
* ##nvx   nkx
* ##nvy   nky
* ##nvz   nkz
* ##nt    nphi
* ##nsx   nEx
* ##nsy   nEy
* ##nsz   nEz
* ##np
* ##compcurname
* ##compcurtype
* ##compcurindex
* ##absorb          label for ABSORB (goto)
* ##Scattered       Incremented each time a SCATTER is done
* ##Restore         Flag indicating that @MCCODE_PARTICLE@ should be restored
* ##NCounter        Incremented each time a @MCCODE_PARTICLE@ is entering the component
* ##AbsorbProp      single counter for removed events in PROP calls
* ##comp_storein    Positions of @MCCODE_PARTICLE@ entering each comp (loc. coords)
* ##Group<GROUP>    Flag true when in an active group
* ##sig_message     Message for the signal handler (debug/trace, sim status)
* ##JumpCounter     iteration counter for JUMP
*******************************************************************************/



/*******************************************************************************
* Generation of declarations.
*
* The following declarations are generated (## denotes the value ID_PRE):
* 1. Header file #include - "mccode-r.h" for declarations for the
*    mcstas runtime.
* 2. Declarations of global variables to hold the values of the instrument
*    parameters. For example, for an instrument parameter OMM, the
*    declaration "MCNUM ##ipOMM;" is generated.
* 3. Declaration of a table ##inputtable containing the list of instrument
*    parameters. For each parameter, the name, a pointer to the
*    corresponding global variable, and the type (double, int,
*    string) is given. The macro ##NUMIPAR gives the number of
*    entries in the table and is also found as the value of the
*    variable ##numipar; in addition, the table is terminated by two
*    NULLs. This table is used to read the instrument parameters from
*    the user or from another program such as TASCOM.
* 4. User declarations copied verbatim from the instrument definition file.
* 5. Declarations for the component parameters. This uses #define for
*    definition parameters and global variables for setting parameters.
* X. User declarations from component definitions.
* X. Declarations of variables for coordinate system transformations.
* X. Declaration of variables for @MCCODE_PARTICLE@ state.
* X. Function prototypes.
*******************************************************************************/

/* PROJECT=1 for McStas, 2 for McXtrace. Now using @MCCODE_PARTICLE@ @MCCODE_NAME@ */
#ifndef MCCODE_PROJECT
#define MCCODE_PROJECT @MCCODE_PROJECT@
#endif

#ifndef MCCODE_LIBENV
#define MCCODE_LIBENV @MCCODE_LIBENV@
#endif

#ifndef MCCODE_PARTICLE
#define MCCODE_PARTICLE @MCCODE_PARTICLE@
#endif

/* Functions for outputting code. */

/* Handle for output file. */
static FILE *output_handle           = NULL;  /* Handle for output file. */
static int   num_next_output_line    = 1;     /* Line number for next output line. */
static char *quoted_output_file_name = NULL;  /* str_quote()'ed name
                                                 of output file. */

/* Convert instrument formal parameter type numbers to their enum name. */
char *instr_formal_type_names[] =
  { "instr_type_int", "instr_type_string", "instr_type_char", "instr_type_vector", "instr_type_double" };

/* 'char' and 'MCNUM' are for static array allocations */
char *instr_formal_type_names_real[] =
  { "long", "char*", "char", "MCNUM*", "MCNUM"}; 
  
/*******************************************************************************
* Output a line of code
* Assumes that the output does not contain newlines.
*******************************************************************************/
static void
cout(char *s)
{
  fprintf(output_handle, "%s\n", s);
  num_next_output_line++;
}

/*******************************************************************************
* Output a line of code using printf-style format string.
* Assumes that the output does not contain newlines.
*******************************************************************************/
static void
coutf(char *format, ...)
{
  va_list ap;

  va_start(ap, format);
  vfprintf(output_handle, format, ap);
  va_end(ap);
  fprintf(output_handle, "\n");
  num_next_output_line++;
}

/*******************************************************************************
* Output #line directive to handle code coming from a different file.
* The filename is assumed to be already properly quoted for special chars.
*******************************************************************************/
static void
code_set_source(char *filename, int linenum)
{
  if(linenum > 0)
    coutf("#line %d \"%s\"", linenum, filename);
}

/*******************************************************************************
* Output #line directive to reset back to the generated output C file.
*******************************************************************************/
static void
code_reset_source(void)
{
  /* Note: the number after #line refers to the line AFTER the directive. */
  coutf("#line %d \"%s\"", num_next_output_line + 1, quoted_output_file_name);
}


static void
codeblock_out(struct code_block *code)
{
  List_handle liter;                /* For list iteration. */
  char *line;                        /* Single code line. */

  if(list_len(code->lines) <= 0)
    return;
  code_set_source(code->quoted_filename, code->linenum + 1);
  liter = list_iterate(code->lines);
  while(line = list_next(liter))
  {
    fprintf(output_handle, "%s", line);
    num_next_output_line++;
  }
  list_iterate_end(liter);
  code_reset_source();
}

static void
codeblock_out_brace(struct code_block *code)
{
  List_handle liter;                /* For list iteration. */
  char *line;                        /* Single code line. */

  if(list_len(code->lines) <= 0)
    return;
  code_set_source(code->quoted_filename, code->linenum);
  cout("{");
  liter = list_iterate(code->lines);
  while(line = list_next(liter))
  {
    fprintf(output_handle, "%s", line);
    num_next_output_line++;
  }
  list_iterate_end(liter);
  cout("}");
  code_reset_source();
}


struct code_block *
codeblock_new(void)
{
  struct code_block *cb;

  palloc(cb);
  cb->filename = NULL;
  cb->quoted_filename = NULL;
  cb->linenum  = -1;
  cb->lines    = list_create();
  return cb;
}

/*******************************************************************************
* Read a file and output it to the generated simulation code. Uses a
* fixed-size buffer, and will silently and arbitrarily break long lines.
*******************************************************************************/
static void
embed_file(char *name)
{
  char buf[4096];
  FILE *f;
  int last;

  if (!symtab_lookup(lib_instances, name))
  {
    /* First look in the system directory. */
    f = open_file_search_sys(name);
    /* If not found, look in the full search path. */
    if(f == NULL) {
      f = open_file_search(name);
      /* If still not found, abort. */
      if(f == NULL)
        fatal_error("Could not find file '%s'\n", name);
      else if (verbose) fprintf(stderr, "Embedding file      %s (user path)\n", name);
    } else if (verbose) fprintf(stderr, "Embedding file      %s (%s)\n", name, get_sys_dir());

    cout("");
    code_set_source(name, 1);
    /* Now loop, reading lines and outputting them in the code. */
    while(!feof(f))
    {
      if(fgets(buf, 4096, f) == NULL)
        break;
      last = strlen(buf) - 1;
      if(last >= 0 && (buf[last] == '\n' || buf[last] == '\r'))
        buf[last--] = '\0';
      if(last >= 0 && (buf[last] == '\n' || buf[last] == '\r'))
        buf[last--] = '\0';
      cout(buf);
    }
    fclose(f);
    coutf("/* End of file \"%s\". */", name);
    cout("");
    code_reset_source();
    symtab_add(lib_instances, name, NULL);
  } /* else file has already been embedded */
} /* embed_file */

/* *****************************************************************************
* cogen_decls: write the declaration part from the instrument description
*   that is the particle definition, the instrument parameters, the DECLARE part,
*   and all SHARE sections from components.
* input:  an instrument definition structure
* output: number of warnings/errors to fix.
*
* code is generated at root level of C file: only C definitions, no initialisers !
* calls: cogen_comp_declare
***************************************************************************** */
int cogen_decls(struct instr_def *instr)
{
  List_handle liter;            /* For list iteration. */
  struct comp_inst *comp;       /* Component instance. */
  struct instr_formal *i_formal;/* Name of instrument formal parameter. */
  long index   =0;
  int  warnings=0;
  
  /* a previous call to cogen_runtime writes the file header */
  
  if (verbose) fprintf(stderr, "Writing instrument %s and components DECLARE\n", instr->name);
  cout("");
  cout("/* *****************************************************************************");
  coutf("* instrument %s and components DECLARE", instr->name);
  cout("***************************************************************************** */");
  cout("");
  
  /* 1. particle definition */
  cout("typedef struct {");
  cout("  double x,y,z; /* position [m] */");
#if MCCODE_PROJECT == 1   /* neutron */
  cout("  double vx,vy,vz; /* velocity [m/s] */");
  cout("  double sx,sy,sz; /* spin [0-1] */");
#elif MCCODE_PROJECT == 2 /* xray */
  cout("  double kx,ky,kz; /* wave-vector */");
  cout("  double phi, Ex,Ey,Ez; /* phase and electrical field */");
#endif
  cout("  double t, p; /* time, event weight */");
  cout("  long long uid; /* event ID */");
 cout("  long cid; /* event current component ID */");
 cout("} " ID_PRE "particle;");
  cout("");
  cout("#define " ID_PRE MCCODE_PARTICLE " " ID_PRE "particle");
  
#if MCCODE_PROJECT == 1   /* neutron */
  cout(ID_PRE "particle " ID_PRE "null_particle = {0,0,0, 0,0,0, 0,0,0, 0,0,0,0};");
#elif MCCODE_PROJECT == 2 /* xray */
  cout(ID_PRE "particle " ID_PRE "null_particle = {0,0,0, 0,0,0, 0,0,0,0, 0,0,0,0};");
#endif
  cout("");
  
  /* 2. Global variables for instrument parameters. */
  cout("/* Instrument parameters: structure and a table for the initialisation");
  cout("   (Used in e.g. " ID_PRE "inputparse and I/O function (e.g. detector_out) */");
  cout("");
  
  liter = list_iterate(instr->formals);
  int numipar=0;
  /* TODO: what if no instrument parameters ? empty structure ? */
  cout("struct " ID_PRE "instrument_parameters_struct {");
  while(i_formal = list_next(liter))
  {
    if (strlen(i_formal->id)) {
      coutf("  %s %s;", instr_formal_type_names_real[i_formal->type], i_formal->id);
      numipar++;
    }
    else
      coutf("  char %s_has_no_parameter;", instr->name);
  }
  list_iterate_end(liter);
  cout("} " ID_PRE "instrument_parameters;");
  cout("");
  
  /* 5. Compatibility definitions */
  /* TODO: misses: ABSORB, Group, SCATTERED, RESTORE */  
  coutf("#define " ID_PRE "ip " ID_PRE "instrument_parameters");
  coutf("#define %scompcurname  %s", ID_PRE, instr->name);
  coutf("#define %scompcurtype  %s", ID_PRE, "instrument");
  coutf("#define %scompcurindex %i", ID_PRE, 0);
  cout("");
  
  /* 3. Table of instrument parameters. Used in mcparseoptions and various output functions */
  coutf("int %snumipar = %d;", ID_PRE, numipar);
  coutf("struct %sinputtable_struct %sinputtable[] = {",
        ID_PRE, ID_PRE, ID_PRE);
  liter = list_iterate(instr->formals);
  while(i_formal = list_next(liter))
  {
    if (strlen(i_formal->id)) {
      if (i_formal->isoptional 
          && !strcmp(instr_formal_type_names[i_formal->type],"instr_type_string"))
        coutf("  \"%s\", &%sip.%s, %s, %s, ", i_formal->id, ID_PRE,
            i_formal->id, instr_formal_type_names[i_formal->type],
            exp_tostring(i_formal->default_value));
      else
        coutf("  \"%s\", &%sip%s, %s, \"%s\", ", i_formal->id, ID_PRE, i_formal->id,
            instr_formal_type_names[i_formal->type],
            i_formal->isoptional ? exp_tostring(i_formal->default_value) : "");
    }
  }
  list_iterate_end(liter);
  coutf("  NULL, NULL, instr_type_double, \"\"");
  coutf("};");
  cout("");
  
  /* 4. User's declarations from the instrument definition file. */
  cout("/* User declarations from instrument definition. */");
  codeblock_out(instr->decls);
  cout("");
  
  /* 5. Component SHAREs. */
  liter = list_iterate(instr->complist);
  index=0;
  while(comp = list_next(liter))
  {
    if((list_len(comp->def->share_code->lines) > 0) && (!comp->def->flag_defined_share))
    {
      if (!index) {
        cout("");
        cout("/* ************************************************************************** */");
        cout("/*             SHARE user declarations for all components                     */");
        cout("/* ************************************************************************** */");
        cout("");
      }
      coutf("/* Shared user declarations for all components types '%s'. */", comp->def->name);
      codeblock_out(comp->def->share_code);
      comp->def->flag_defined_share = 1; /* flag the component so that SHARE outputs only once */
      cout("");
      index++;
    }
  }
  if (index) {
    cout("");
    cout("/* ************************************************************************** */");
    cout("/*             End of SHARE user declarations for all components              */");
    cout("/* ************************************************************************** */");
    cout("");
  }
  list_iterate_end(liter);
  
  /* 7. write component declares */
  cout("");
  cout("/* ********************** component definition declarations. **************** */");
  cout("");
  liter = list_iterate(instr->complist);
  index=0;
  while(comp = list_next(liter)) {
    comp->index=index;        /* comp index starts at 0 */
    warnings += cogen_comp_declare(comp);
    index++;
  }
  
  /* undefines */
  coutf("#undef %scompcurname", ID_PRE);
  coutf("#undef %scompcurtype", ID_PRE);
  coutf("#undef %scompcurindex", ID_PRE);
  
  coutf("/* end of instrument %s and components DECLARE */", instr->name);
  cout("");
  
  return(warnings);

} /* cogen_decls */

/* *****************************************************************************
* cogen_init: write the INITIALIZE part from the instrument description
*   and calls all component definition init
* input:  an instrument definition structure
*
* generates a mcinit() function, called by mccode_main
*   after mcparseoptions, calling itself mcreadparams
***************************************************************************** */
int cogen_init(struct instr_def *instr)
{
  long        index    =0;
  int         warnings =0;
  List_handle liter;
  struct comp_inst *comp, *last;
  
  /* instrument initialisation */
  if (verbose) fprintf(stderr, "Writing instrument %s and components INITIALIZE\n", instr->name);
  
  cout("/* *****************************************************************************");
  coutf("* instrument %s and components INITIALIZE", instr->name);
  cout("***************************************************************************** */");
  cout("");
  
  /* call component init functions to write their init code */
  liter = list_iterate(instr->complist);
  last  = NULL;
  liter = list_iterate(instr->complist);
  while((comp = list_next(liter)) != NULL)
  {
    warnings += cogen_comp_init(comp, last, instr);
    last = comp;
  }
  cout("");
  
  /* then write the instrument main init code, which calls component ones */
  coutf("int %sinit(void) { /* called by %scode_main for INITIALIZE */", ID_PRE, ID_PRE);
  cout("");
  coutf("  %sDEBUG_INSTR()", ID_PRE);
  cout("");
  /* default values for instrument parameters are set in mcreadparams */
  cout("  /* " ID_PRE "code_main/" ID_PRE "parseoptions/" ID_PRE "readparams "
    "sets instrument parameters value */");
  cout("");
  
  /* User initialisations from instrument definition. */
  
  if (list_len(instr->inits->lines) > 0) {
    coutf("  /* Instrument %s INITIALIZE */", instr->name);
    codeblock_out(instr->inits);
  }
  
  /* component init calls: one call for each component instance */
  cout("  /* Component initialisations: call iteratively all components INITIALIZE */");
  liter = list_iterate(instr->complist);
  while((comp = list_next(liter)) != NULL)
  {
    index++;
    coutf("  if (" ID_PRE"%s_instance_init()) return(%i); /* type %s */", 
      comp->name, index, comp->def->name);
  }
  cout("");
  /* Output graphics representation of components. */
  coutf("  if (%sdotrace) %sdisplay();", ID_PRE, ID_PRE);
  coutf("  %sDEBUG_INSTR_END()", ID_PRE);
  
  cout("  return(0);");
  cout("} /* " ID_PRE"init */");
  cout("");
  
  return(warnings);
} /* cogen_init */

/* *****************************************************************************
* cogen_comp_declare: write the declaration part from the component instance
*   that is the component parameter structure, with positioning stuff
* input:  a component instance structure pointer (not modified)
* output: number of warning/errors to fix.
*
* code is generated at root level of C file: only C definitions, no initialisers !
* called by: cogen_decls
***************************************************************************** */
int cogen_comp_declare(struct comp_inst *comp)
{
  int warnings     =0;
  int nb_parameters=0;
  
  if (verbose) fprintf(stderr, "Writing component %s=%s() [%i] DECLARE\n", 
    comp->name, comp->def->name, comp->index);
  
  if (!comp->def->flag_defined_structure) {
    int index=0;
    
    coutf("/* component %s=%s() [%i] DECLARE */",
      comp->name, comp->def->name, comp->index);
    /* TODO: what if no parameter or no DECLARE code ? */
  
    comp->def->flag_defined_structure = 1;
    coutf("/* Parameter definition for component type '%s' */", 
      comp->def->name);
    coutf("struct " ID_PRE "%s_parameters_struct {", comp->def->name);
    
    /* put there setting, output and declare code */
    for (index=0; index <2; index++) {
      List l = (index == 0 ? comp->def->set_par : comp->def->out_par);
      
      if(list_len(l) > 0)
      {
        List_handle liter;
        liter = list_iterate(comp->def->set_par);
        struct comp_iformal *c_formal;/* Name of component formal input parameter */
        
        coutf("  /* Component type '%s' %s parameters */", 
          comp->def->name, index == 0 ? "setting" : "private");
        
        while(c_formal = list_next(liter))
        {
          nb_parameters++;
          /* scalar parameter */
          if (c_formal->type != instr_type_string)
            coutf("  %s %s;", instr_formal_type_names_real[c_formal->type], c_formal->id);
          else  /* array parameter */
            coutf("  %s %s[16384];", 
              instr_formal_type_names_real[c_formal->type+1], c_formal->id);
        }
        list_iterate_end(liter);
      }
    } /* for List in (setpar outpar) */
    
    /* Output the user declaration code block. */
    if (list_len(comp->def->decl_code->lines) > 0) {
      List_handle liter;                /* For list iteration. */
      char *line;                       /* Single code line. */
      coutf("  /* Component type '%s' DECLARE code stored as structure members */", comp->def->name);
      codeblock_out(comp->def->decl_code);
      /* warning/error if decl_code contains '=' char */
      if(list_len(comp->def->decl_code->lines) > 0) {
        liter = list_iterate(comp->def->decl_code->lines);
        while(line = list_next(liter))
          if (strchr(line, '=')) warnings++;
      }
      if (warnings)
        fprintf(stderr,"Warning: Component %s=%s() DECLARE block contains %i assignments (= sign).\n"
                       "         Move them into the INITIALIZE section.\n"
                       "         File: %s\n",
        	comp->name, comp->def->name, warnings, comp->def->decl_code->quoted_filename);
    }
    if (!nb_parameters)
      coutf("  char %s_has_no_parameters;", comp->def->name);
    coutf("}; /* " ID_PRE "%s_parameters_struct */", comp->def->name);
    cout("");
    
    coutf("/* Parameters for component type '%s' */", 
     comp->def->name);
    coutf("struct " ID_PRE "%s_definition_struct {", comp->def->name); 
      /* make struct: set, pos, rot, declare block */
    coutf("  char     name[256]; /* e.g. %s */", comp->name);
    coutf("  char     type[256]; /* %s */", comp->def->name);
    coutf("  long     index; /* e.g. %i index in TRACE list */",
      index);
    cout( "  Coords   position_absolute;");
    cout( "  Coords   position_relative; /* wrt PREVIOUS */");
    cout( "  Rotation rotation_absolute;");
    cout( "  Rotation rotation_relative; /* wrt PREVIOUS */");
    coutf("  struct " ID_PRE "%s_parameters_struct parameters;", comp->def->name);
    cout ("};");
  } /* define class type parameter structure when not done yet (only once) */
  
  /* instantiate one structure per component instance */
  coutf("struct " ID_PRE "%s_definition_struct " ID_PRE "%s_instance;",
    comp->def->name, comp->name);
  cout("");
  
  return(warnings);
} /* cogen_comp_declare */

/* *****************************************************************************
* cogen_comp_init_setpar: write the setting parameter allocation in INIT
* input:  a component instance structure pointer (not modified)
*
* code is generated in function [comp]_init
* called by: cogen_comp_init
***************************************************************************** */
/* TODO: handle vectors */
static void cogen_comp_init_setpar(struct comp_inst *comp, struct instr_def *instr)
{
  if(list_len(comp->def->set_par) > 0)
  {
    List_handle setpar = list_iterate(comp->def->set_par);
    struct comp_iformal *par;
    
    while((par = list_next(setpar)) != NULL)
    {
      char *val;
      struct Symtab_entry *entry;

      entry = symtab_lookup(comp->setpar, par->id);
      val   = exp_tostring(entry->val);
      code_set_source(instr->quoted_source, exp_getlineno(entry->val));

      if (par->type == instr_type_string) {
        coutf("  if(%s && strlen(%s))", val, val);
        coutf("    strncpy(" ID_PRE "%s_instance.parameters.%s, %s ? %s : \"\", 16384);", 
          comp->name, par->id, val, val);
        coutf("  else " ID_PRE "%s_instance.parameters.%s[0]='\\0';", 
          comp->name, par->id);
      } else
        coutf("  " ID_PRE "%s_instance.parameters.%s = %s;", comp->name, par->id, val);
      str_free(val);
    }
    list_iterate_end(setpar);
    if(list_len(comp->def->set_par) > 0)
      code_reset_source();
    cout("");
  }
} /* cogen_comp_init_setpar */

/* *****************************************************************************
* cogen_comp_init_outpar: write the private parameter allocation in INIT
* input:  a component instance structure pointer (not modified)
*
* code is generated in function [comp]_init
* called by: cogen_comp_init
***************************************************************************** */
/* TODO: handle vectors */
static void cogen_comp_init_outpar(struct comp_inst *comp, struct instr_def *instr)
{
  if(list_len(comp->def->out_par) > 0) 
  {
    List_handle outpar = list_iterate(comp->def->out_par);
    struct comp_iformal *par;
    while((par = list_next(outpar)) != NULL)
    {
      if (par->isoptional) {
        char *val =  exp_tostring(par->default_value);

        if (par->type == instr_type_string) {
          coutf("  if(%s && strlen(%s))", val, val);
          coutf("    strncpy(" ID_PRE "%s_instance.parameters.%s, %s ? %s : \"\", 16384);", 
            comp->name, par->id, val, val);
          coutf("  else " ID_PRE "%s_instance.parameters.%s[0]='\\0';", 
            comp->name, par->id);
        } else
          coutf("  " ID_PRE "%s_instance.parameters.%s = %s;", comp->name, par->id, val);
        str_free(val);
      }
    }
    list_iterate_end(outpar);
    cout("");
  }
} /* cogen_comp_init_outpar */

/* *****************************************************************************
* cogen_comp_init_defpar: write the definition parameters in INIT
* input:  a component instance structure pointer (not modified)
*
* code is generated in function [comp]_init
* called by: cogen_comp_init
***************************************************************************** */
int cogen_comp_init_defpar(struct comp_inst *comp)
{
  int warnings=0;
  
  if(list_len(comp->def->def_par) > 0)
  {
    List_handle liter;                /* For list iteration. */
    
    liter = list_iterate(comp->def->def_par);
    struct comp_iformal *c_formal;/* Name of component formal input parameter */
    
    while(c_formal = list_next(liter))
    {
      struct Symtab_entry *entry = symtab_lookup(comp->defpar, c_formal->id);
      char                *val   = exp_tostring(entry->val);
      coutf("  #define %s %s", c_formal->id, val);
      if (c_formal->type == instr_type_string || c_formal->type == instr_type_vector)
      {
        /* a string definition parameter should be converted into a setting parameter to avoid e.g.
         * warning: format ‘%s’ expects type ‘char *’, but argument X has type ‘int’    */
        fprintf(stderr,"Warning: Component %s=%s(string or vector %s) DEFINITION \n"
                       "         parameter may be changed into a SETTING parameter\n"
                       "         File: %s\n",
        	comp->name, comp->def->name, c_formal->id, comp->def->source);
        warnings++;
		  }
      str_free(val);
    }
    list_iterate_end(liter);
  }

  return(warnings);
} /* cogen_comp_init_defpar */

/* *****************************************************************************
* cogen_comp_init_defundef: define/undefine a symbol from a List
* input:  a list
*         a flag: 1=define, 2=define with 'comp' as structure name, 0=undefine
*
* code is generated in function [comp]_init
* called by: cogen_comp_init
***************************************************************************** */
static void cogen_comp_init_defundef(struct comp_inst *comp, List l, char define_it)
{
  if(list_len(l) > 0) {
    List_handle liter;
    struct comp_iformal *c_formal;/* Name of component formal input parameter */
  
    liter = list_iterate(l);
    while(c_formal = list_next(liter)) {
      if (define_it == 1)
        coutf("  #define %s " ID_PRE "%s_instance.parameters.%s", 
          c_formal->id, comp->name, c_formal->id);
      else if (define_it == 2)
        coutf("  #define %s " ID_PRE "comp.parameters.%s", 
          c_formal->id, c_formal->id);
      else
        coutf("  #undef %s", c_formal->id);
    }
    list_iterate_end(liter);
  }
} /* cogen_comp_init_defundef */

/* *****************************************************************************
* cogen_comp_init_position: write the position/rotation data
* input:  a component instance structure pointer (not modified)
*         previous component pointer or NULL (for relative stuff)
*         the instrument structure
*
* code is generated in function [comp]_init
* called by: cogen_comp_init
***************************************************************************** */
static void cogen_comp_init_position(struct comp_inst *comp, struct comp_inst *last, 
                             struct instr_def *instr)
{
  char d2r[] = "DEG2RAD";
  struct comp_inst *relcomp; /* Component relative to. */
  char *x, *y, *z;
  
  /* compute coordinates. Can use current instance parameters */
  /* Absolute rotation. */
  x = exp_tostring(comp->pos->orientation.x);
  y = exp_tostring(comp->pos->orientation.y);
  z = exp_tostring(comp->pos->orientation.z);
  relcomp = comp->pos->orientation_rel;
  coutf("  /* component %s=%s() AT ROTATED */",
    comp->name, comp->def->name);
  cout("  {");
  coutf("    Coords %stc1, %stc2;", ID_PRE, ID_PRE);
  coutf("    Rotation %str1;", ID_PRE);
  
  if(relcomp == NULL)
  {                                /* Absolute orientation. */
    coutf("    rot_set_rotation(%s%s_instance.rotation_absolute,", ID_PRE, comp->name);
    code_set_source(instr->quoted_source,
                    exp_getlineno(comp->pos->orientation.x));
    coutf("      (%s)*%s, (%s)*%s, (%s)*%s);", x, d2r, y, d2r, z, d2r);
    code_reset_source();
  }
  else
  {
    coutf("    rot_set_rotation(%str1,", ID_PRE);
    code_set_source(instr->quoted_source,
                    exp_getlineno(comp->pos->orientation.x));
    coutf("      (%s)*%s, (%s)*%s, (%s)*%s);", x, d2r, y, d2r, z, d2r);
    code_reset_source();
    coutf("    rot_mul(%str1, %s%s_instance.rotation_absolute, %s%s_instance.rotation_absolute);",
          ID_PRE, ID_PRE, relcomp->name, ID_PRE, comp->name);
  }
  str_free(z);
  str_free(y);
  str_free(x);

  /* Relative rotation. */
  if(last == NULL)
  {                                /* First component. */
    coutf("    rot_copy(%srotr%s, %s%s_instance.rotation_absolute);",
          ID_PRE, comp->name, ID_PRE, comp->name);
  }
  else
  {
    coutf("    rot_transpose(%s%s_instance.rotation_absolute, %str1);", ID_PRE, last->name, ID_PRE);
    coutf("    rot_mul(%s%s_instance.rotation_absolute, %str1, %srotr%s);",
          ID_PRE, comp->name, ID_PRE, ID_PRE, comp->name);
  }

  /* Absolute position. */
  x = exp_tostring(comp->pos->place.x);
  y = exp_tostring(comp->pos->place.y);
  z = exp_tostring(comp->pos->place.z);
  relcomp = comp->pos->place_rel;
  if(relcomp == NULL)
  {
    coutf("    %sposa%s = coords_set(", ID_PRE, comp->name);
    code_set_source(instr->quoted_source, exp_getlineno(comp->pos->place.x));
    coutf("      %s, %s, %s);", x,y ,z);
    code_reset_source();
  }
  else
  {
    coutf("    %stc1 = coords_set(", ID_PRE);
    code_set_source(instr->quoted_source, exp_getlineno(comp->pos->place.x));
    coutf("      %s, %s, %s);", x,y ,z);
    code_reset_source();
    coutf("    rot_transpose(%s%s_instance.rotation_absolute, %str1);",
          ID_PRE, relcomp->name, ID_PRE);
    coutf("    %stc2 = rot_apply(%str1, %stc1);",
          ID_PRE, ID_PRE, ID_PRE);
    coutf("    %sposa%s = coords_add(%sposa%s, %stc2);",
          ID_PRE, comp->name, ID_PRE, relcomp->name, ID_PRE);
  }

  str_free(z);
  str_free(y);
  str_free(x);

  /* Relative position. */
  if(last == NULL)
    coutf("    %stc1 = coords_neg(%sposa%s);", ID_PRE, ID_PRE, comp->name);
  else
    coutf("    %stc1 = coords_sub(%sposa%s, %sposa%s);",
          ID_PRE, ID_PRE, last->name, ID_PRE, comp->name);
  coutf("    %sposr%s = rot_apply(%s%s_instance.rotation_absolute, %stc1);",
        ID_PRE, comp->name, ID_PRE, comp->name, ID_PRE);
  cout("  }");

  coutf("  %sDEBUG_COMPONENT(\"%s\", %sposa%s, %s%s_instance.rotation_absolute)",
        ID_PRE, comp->name, ID_PRE, comp->name, ID_PRE, comp->name);

  coutf("  %scomp_posa[%i] = %sposa%s;", ID_PRE, comp->index, ID_PRE, comp->name);
  coutf("  %scomp_posr[%i] = %sposr%s;", ID_PRE, comp->index, ID_PRE, comp->name);

} /* cogen_comp_init_position */

/* *****************************************************************************
* cogen_comp_init: write the INITIALIZE part for each component instance
*   generates an init(*comp) function which sets all component parameters
*   computes absolute position and rotation, and executes INIT code.
*
* input:  a component instance structure pointer
* output: 0 when all is fine, non-0 when error found
*
* called by: cogen_init
***************************************************************************** */
int cogen_comp_init(struct comp_inst *comp, struct comp_inst *last, struct instr_def *instr)
{
  int warnings=0;
  
  if (verbose) fprintf(stderr, "Writing component instance %s=%s() [%i] INITIALIZE\n", 
    comp->name, comp->def->name, comp->index);
  
  coutf("/* component %s=%s() INITIALIZE */",
    comp->name, comp->def->name);
  if (list_len(comp->def->def_par) == 0 
      && list_len(comp->def->init_code->lines) > 0
      && !comp->def->flag_defined_init) {
    /* we may use a common init function for each comp type */
    comp->def->flag_defined_init = 1;
    cout("");
    coutf("/* this function is common to all component type %s with INIT code */", 
      comp->def->name);
    coutf("struct " ID_PRE "%s_definition_struct " ID_PRE "%s_definition_init("
            "struct " ID_PRE "%s_definition_struct " ID_PRE "comp)",
      comp->def->name, comp->def->name, comp->def->name);
    cout("{");
    cogen_comp_init_defundef(comp, comp->def->set_par, 2);
    cogen_comp_init_defundef(comp, comp->def->out_par, 2);

    codeblock_out(comp->def->init_code); // common to all instances, needs defines
    
    /* undefine aliases */
    cogen_comp_init_defundef(comp, comp->def->set_par, 0);
    cogen_comp_init_defundef(comp, comp->def->out_par, 0);
    coutf("} /* " ID_PRE "%s_definition_init */", comp->def->name);
    cout("");
  }
  
  coutf("void " ID_PRE "%s_instance_init(void)", 
    comp->name, comp->def->name);
  cout("{");
  
  /* init parameters. These can then be used in position/rotation syntax */
  /* all these parameters have a #define pointing to the real name space in structure */
  
  /* definition parameters of the component */
  coutf("  #define %scompcurname  %s", ID_PRE, comp->name);
  coutf("  #define %scompcurtype  %s", ID_PRE, comp->def->name);
  coutf("  #define %scompcurindex %i", ID_PRE, comp->index);
  coutf("  strncpy(" ID_PRE "%s_instance.name, \"%s\", 16384);", comp->name, comp->name);
  coutf("  strncpy(" ID_PRE "%s_instance.type, \"%s\", 16384);", comp->name, comp->def->name);
  cout("");
  warnings += cogen_comp_init_defpar(comp); // specific to each instance

  /* setting parameters of the component */
  cogen_comp_init_setpar(comp, instr);  // specific to each instance
  
  /* output parameters of the component (private/declare) */
  cogen_comp_init_outpar(comp, instr);  // specific to each instance
  
  /* define alias to SETTING and OUTPUT parameters */
  cogen_comp_init_defundef(comp, comp->def->set_par, 1);
  cogen_comp_init_defundef(comp, comp->def->out_par, 1);
  cout("");
  cogen_comp_init_position(comp, last, instr); // specific to each instance
  
  /* init code. Can use component instance parameters */
  /* Users initializations. Embraced as it may contain local C definitions */
  cout("");
  /* if there are definition parameters, we must put the specific INIT code here */
  if (list_len(comp->def->init_code->lines) > 0) {
    if (list_len(comp->def->def_par) > 0)
      codeblock_out_brace(comp->def->init_code);
    else /* else we call the common init function for each comp type */
      coutf("  " ID_PRE "%s_instance=" ID_PRE "%s_definition_init(" ID_PRE "%s_instance);",
        comp->name, comp->def->name, comp->name);
  }
  cout("");
  /* undefine aliases */
  cogen_comp_init_defundef(comp, comp->def->set_par, 0);
  cogen_comp_init_defundef(comp, comp->def->out_par, 0);
  cogen_comp_init_defundef(comp, comp->def->def_par, 0);
  
  coutf("  %sNCounter[%i]  = %sPCounter[%i] = %sP2Counter[%i] = 0;",
        ID_PRE, comp->index, ID_PRE, comp->index, ID_PRE, comp->index);
  coutf("  %sAbsorbProp[%i]= 0;", ID_PRE, comp->index);
  coutf("  #undef %scompcurname", ID_PRE);
  coutf("  #undef %scompcurtype", ID_PRE);
  coutf("  #undef %scompcurindex", ID_PRE);
  
  coutf("} /* " ID_PRE "%s_instance_init */", comp->name);
  cout("");
  return(warnings);
} /* cogen_comp_init */

cogen_comp_trace()
{
}

cogen_comp_save()
{
}

cogen_comp_finally()
{
}

cogen_comp_display()
{
}

/*******************************************************************************
* Output code for the mcstas runtime system. Default is to copy the runtime
* code into the generated executable, to minimize problems with finding the
* right files during compilation and linking, but this may be changed using
* the --no-runtime compiler switch.
*******************************************************************************/
static void
cogen_runtime(struct instr_def *instr)
{
  char *sysdir_orig;
  char *sysdir_new;
  char  pathsep[3];
  int   i,j=0;
  /* handles Windows '\' chararcters for embedding sys_dir into source code */
  if (MC_PATHSEP_C != '\\') strcpy(pathsep, MC_PATHSEP_S); else strcpy(pathsep, "\\\\");
  sysdir_orig = get_sys_dir();
  sysdir_new  = (char *)mem(2*strlen(sysdir_orig));
  for (i=0; i < strlen(sysdir_orig); i++)
  {
    if (sysdir_orig[i] == '\\')
    { sysdir_new[j] = '\\'; j++; sysdir_new[j] = '\\'; }
    else sysdir_new[j] = sysdir_orig[i];
    j++;
  }
  sysdir_new[j] = '\0';
  if(instr->use_default_main)
    cout("#define MC_USE_DEFAULT_MAIN");
  if(instr->enable_trace)
    cout("#define MC_TRACE_ENABLED");
  if(instr->portable)
    cout("#define MC_PORTABLE");
  if(instr->include_runtime)
  {
    cout("#define MC_EMBEDDED_RUNTIME"); /* Some stuff will be static. */
    embed_file("mccode-r.h");
#if MCCODE_PROJECT == 1     /* neutron */
    embed_file("mcstas-r.h");
#elif MCCODE_PROJECT == 2   /* xray */
    embed_file("mcxtrace-r.h");
#endif
    /* NeXus support, only active with -DUSE_NEXUS */
    if (verbose) fprintf(stderr, "Specify             -DUSE_NEXUS -lNeXus to enable NeXus support\n");
    embed_file("mccode-r.c");
#if MCCODE_PROJECT == 1     /* neutron */
    embed_file("mcstas-r.c");
#elif MCCODE_PROJECT == 2   /* xray */
    embed_file("mcxtrace-r.c");
#endif
  }
  else
  {
    coutf("#include \"%s%sshare%smccode-r.h\"",  sysdir_new, pathsep, pathsep);
    fprintf(stderr,"Dependency: %s.o\n", "mccode-r");
#if MCCODE_PROJECT == 1     /* neutron */
    coutf("#include \"%s%sshare%smcstas-r.h\"",  sysdir_new, pathsep, pathsep);
    fprintf(stderr,"Dependency: %s.o\n", "mcstas-r");
#elif MCCODE_PROJECT == 2   /* xray */
    coutf("#include \"%s%sshare%smcxtrace-r.h\"",  sysdir_new, pathsep, pathsep);
    fprintf(stderr,"Dependency: %s.o\n", "mcxtrace-r");
#endif

    fprintf(stderr,"Dependency: %s.o\n", "mcstas-r");
    fprintf(stderr,"Dependency: '-DUSE_NEXUS -lNeXus' to enable NeXus support\n");
    fprintf(stderr,"To build instrument %s, compile and link with these libraries (in %s%sshare)\n",
      instrument_definition->quoted_source, sysdir_new, pathsep);
  }

  coutf("#ifdef MC_TRACE_ENABLED");
  coutf("int %straceenabled = 1;", ID_PRE);
  coutf("#else");
  coutf("int %straceenabled = 0;", ID_PRE);
  coutf("#endif");
  
  coutf("#define MCSTAS \"%s%s\"", sysdir_new,pathsep); /* TODO: use MCXTRACE for xrays ? */
  
  coutf("int %sdefaultmain = %d;", ID_PRE, instr->use_default_main);
  coutf("char %sinstrument_name[] = \"%s\";", ID_PRE, instr->name);
  coutf("char %sinstrument_source[] = \"%s\";", ID_PRE, instr->source);
  coutf("char *%sinstrument_exe=NULL; /* will be set to argv[0] in main */", ID_PRE);
  if(instr->use_default_main)
    cout("int main(int argc, char *argv[]){return mccode_main(argc, argv);}");
} /* cogen_runtime */

/*******************************************************************************
* cogen: the code generator
*   Generate the output file (in C).
*******************************************************************************/
void
cogen(char *output_name, struct instr_def *instr)
{
  time_t t;
  char date[64];
  int warnings=0;

  time(&t);
  strncpy(date, ctime(&t), 64);
  if (strlen(date)) date[strlen(date)-1] = '\0';

  /* Initialize output file. */
  if(!output_name || !output_name[0] || !strcmp(output_name, "-"))
  {
    output_handle = fdopen(1, "w");
    quoted_output_file_name = str_quote("<stdout>");
  }
  else
  {
    output_handle = fopen(output_name, "w");
    quoted_output_file_name = str_quote(output_name);
  }
  num_next_output_line = 1;
  if(output_handle == NULL)
    fatal_error("Error opening output file '%s'\n", output_name);

  /* the file header */
  cout("/* Automatically generated file. Do not edit. ");
  cout(" * Format:     ANSI C source code");
#if MCCODE_PROJECT == 1     /* neutron */
  cout(" * Creator:    McStas <http://www.mcstas.org>");
#elif MCCODE_PROJECT == 2   /* xray */
  cout(" * Creator:    McXtrace <http://www.mcxtrace.org>");
#endif
  coutf(" * Instrument: %s (%s)", instr->source, instr->name);
  coutf(" * Date:       %s", date);
  coutf(" * File:       %s", output_name);
  cout(" */");
  cout("");
  coutf("#define MCCODE_STRING \"%s\"", MCCODE_STRING);
  coutf("#define FLAVOR        \"%s\"", FLAVOR);
  coutf("#define FLAVOR_UPPER  \"%s\"", FLAVOR_UPPER);
  
  /* and we now call the writers */
  cogen_runtime(instr);
  warnings += cogen_decls(instr); /* return nb of warnings */
  warnings += cogen_init(instr);
  /*
  cogen_trace(instr);
  cogen_save(instr);
  cogen_finally(instr);
  cogen_mcdisplay(instr);
  */
  if (warnings)
    fprintf(stderr,"Warning: The build of the instrument %s has %i warning/errors.\n",
        	instr->name, warnings);
  coutf("/* end of generated C code %s */", output_name);
} /* cogen */
