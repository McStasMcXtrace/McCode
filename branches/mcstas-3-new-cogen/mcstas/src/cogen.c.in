/* Convert instrument formal parameter type numbers to their enum name. */
char *instr_formal_type_names[] =
  { "instr_type_int", "instr_type_string", "", "instr_type_array", "instr_type_double" };

char *instr_formal_type_names_real[] =
  { "long", "char*", "char", "MCNUM*", "MCNUM"}; /* 'char' and 'double' are for static array allocations */

cogen_runtime(instr);

codeblock_out;

/* *****************************************************************************
* cogen_instr_declare: write the declaration part from the instrument description
*   that is the particle definition, the instrument parameters, the DECLARE part,
*   and all SHARE sections from components.
* input:  an instrument definition structure
* output: 0 when all is fine, non-0 when error found
*
* code is generated at root level of C file: only C definitions, no initialisers !
***************************************************************************** */
int cogen_instr_declare(struct instr_def *instr)
{
  List_handle liter;            /* For list iteration. */
  struct comp_inst *comp;       /* Component instance. */
  struct instr_formal *i_formal;/* Name of instrument formal parameter. */
  long index=0;
  
  /* a previous call to cogen_runtime writes the file header */
  /* TODO: should we merge this here ?*/
  /* TODO: move some of this in mccode-r.h ? or the other way round ? */
  
  /* 1. particle definition */
  coutf(
    "typedef struct {\n"
    "  double x,y,z; /* position [m] */\n"
#if MCCODE_PROJECT == 1   /* neutron */
    "  double vx,vy,vz; /* velocity [m/s] */\n"
    "  double sx,sy,sz; /* spin [0-1] */\n"
#elif MCCODE_PROJECT == 2 /* xray */
    "  double kx,ky,kz; /* wave-vector */\n"
    "  double phi, Ex,Ey,Ez; /* phase and electrical field */\n"
#endif
    "  double t, p; /* time, event weight */\n"
    "  long long uid; /* event ID */\n"
    "  long cid; /* event current component ID */\n"
    "} " ID_PRE "particle;");
  
#if MCCODE_PROJECT == 1   /* neutron */
  cout("#define " ID_PRE "neutron " ID_PRE "particle");
  cout("particle " ID_PRE "null_particle = {0,0,0, 0,0,0, 0,0,0, 0,0,0,0};");
#elif MCCODE_PROJECT == 2 /* xray */
  cout("#define " ID_PRE "photon " ID_PRE "particle");
  cout("particle " ID_PRE "null_particle = {0,0,0, 0,0,0, 0,0,0,0, 0,0,0,0};");
#endif
  cout("");
  
  /* 2. Global variables for instrument parameters. */
  cout("/* Instrument parameters: structure and a table for the initialisation\n"
       "   (e.g. " ID_PRE "inputparse). Also used in various I/O function (e.g. detector_out) */");
  liter = list_iterate(instr->formals);
  int numipar=0;
  /* TODO: what if no instrument parameters ? empty structure ? */
  cout("struct " ID_PRE "instrument_parameters_struct {");
  while(i_formal = list_next(liter))
  {
    if (strlen(i_formal->id)) {
      coutf("  %s %s;", instr_formal_type_names_real[i_formal->type], i_formal->id);
      numipar++;
    }
  }
  list_iterate_end(liter);
  cout("}" ID_PRE "instrument_parameters;");
  
  /* 3. Table of instrument parameters. Used in mcparseoptions and various output functions */
  coutf("int %snumipar = %d;", ID_PRE, numipar);
  coutf("struct %sinputtable_struct %sinputtable[] = {",
        ID_PRE, ID_PRE, ID_PRE);
  liter = list_iterate(instr->formals);
  while(i_formal = list_next(liter))
  {
    if (strlen(i_formal->id)) {
      if (i_formal->isoptional && !strcmp(instr_formal_type_names[i_formal->type],"instr_type_string"))
        coutf("  \"%s\", &%sip.%s, %s, %s, ", i_formal->id, ID_PRE,
            i_formal->id, instr_formal_type_names[i_formal->type],
            exp_tostring(i_formal->default_value));
      else
        coutf("  \"%s\", &%sip%s, %s, \"%s\", ", i_formal->id, ID_PRE, i_formal->id,
            instr_formal_type_names[i_formal->type],
            i_formal->isoptional ? exp_tostring(i_formal->default_value) : "");
    }
  }
  list_iterate_end(liter);
  coutf("  NULL, NULL, instr_type_double, \"\"");
  coutf("};");
  cout("");
  
  /* 4. User's declarations from the instrument definition file. */
  cout("/* User declarations from instrument definition. */");
  cogen_instrument_scope(instr, (void (*)(void *))codeblock_out, instr->decls);
  cout("");

  /* 5. Compatibility definitions */
  coutf("#define " ID_PRE "ip " ID_PRE "instrument_parameters");  
  
  /* 6. Component SHAREs. */
  liter = list_iterate(instr->complist);
  while(comp = list_next(liter))
  {
    if((list_len(comp->def->share_code->lines) > 0) && (!comp->def->flag_defined_share))
    {
      coutf("/* Shared user declarations for all components '%s'. */", comp->def->name);
      codeblock_out(comp->def->share_code);
      comp->def->flag_defined_share = 1; /* flag the component so that SHARE outputs only once */
      cout("");
    }
  }
  list_iterate_end(liter);
  
  /* 7. call component declare functions */
  cout("/* Call component instance declarations. */");
  liter = list_iterate(instr->complist);
  index=0;
  while(comp = list_next(liter)) {
    cogen_comp_declare(comp, index); /* comp index, aka 'cid', starts at 0 */
    index++;
  }
  
  /* TODO: misses: ABSORB, Group, SCATTERED, RESTORE */
  
  return(0);
} /* cogen_instr_declare */




int cogen_instr_init()
{
  long   index=0;
  struct comp_inst *comp;
  
  /* instrument initialisation */
  if (verbose) fprintf(stderr, "Writing instrument and components INITIALIZE\n");

  coutf("int %sinit(void) {", ID_PRE);
  
  /* User initializations from instrument definition. */
  cogen_instrument_scope(instr, (void (*)(void *))codeblock_out_brace,
                         instr->inits);
  
  /* component init calls */
  cout("  /* Component initializations. */");
  liter = list_iterate(instr->complist);
  while((comp = list_next(liter)) != NULL)
  {
    index++;
    coutf("  if (%s_init()) return(%i);", comp->name, index);
  }
  cout("  return(0);");
  cout("} /* " ID_PRE"init */");
  return(0);
} /* cogen_instr_init */

/* *****************************************************************************
* cogen_comp_declare: write the declaration part from the component instance
*   that is the component parameter structure, with positioning stuff
* input:  a component instance structure
* output: 0 when all is fine, non-0 when error found
*
* code is generated at root level of C file: only C definitions, no initialisers !
***************************************************************************** */
int cogen_comp_declare(struct comp_inst *comp, long index)
{
  List_handle liter;
  
  comp->index = index; /* should match the one defined with bison */
  
  if (!comp->def->flag_defined_structure) {
    comp->def->flag_defined_structure = 1;
    coutf("/* Parameter definition for component type '%s' [%i]. */", 
      comp->def->name, comp->index);
    coutf("struct " ID_PRE "%s_definition_struct {", comp->def->name);
      /* put there setting and declare code */
    if(list_len(comp->def->set_par) > 0)
    {
      coutf("/* Component type '%s' [%i] setting parameters */", 
        comp->def->name, comp->index);
      liter = list_iterate(comp->def->set_par);
      while(c_formal = list_next(liter))
      {
        /* scalar parameter */
        if (c_formal->type != instr_type_string && c_formal->type != instr_type_pdouble)
          coutf("%s %s;", instr_formal_type_names_real[c_formal->type], c_formal->id);
        else  /* array parameter */
          coutf("%s %s[16384];", 
            instr_formal_type_names_real[c_formal->type+1], c_formal->id);
      }
      list_iterate_end(liter);
    }
    
    /* Output the user declaration code block. */
    if (list_len(comp->def->decl_code->lines) > 0) {
      coutf("/* Component type '%s' [%i] declare */", 
        comp->def->name, comp->index);
      codeblock_out(comp->def->decl_code);
      /* TODO: warning/error if decl_code contains '=' char ? 
         or handle this in the grammar ?
         OUTPUT(<type> name=value, ...) would work, or rename keyword to
         DECLARE PARAMETERS ?
         could even handle "double * name=definition par"
         SETTING PARAMETERS should support more types, e.g. double* int* ...
         not for instrument parameters (double, int, char* only ?)
         which would limit the use of DEFINITION PARAMETERS
       */
    }
    coutf("} /* " ID_PRE "%s_parameters_struct */", comp->def->name);
    cout("");
  } /* define class type parameter structure when not done yet (only once) */
  
  coutf("/* Parameters for component '%s' [%i] = %s() */", comp->name, comp->index, comp->def->name);
  coutf("struct " ID_PRE "%s_instance_struct {", comp->name); 
    /* make struct: set, pos, rot, declare block */
  coutf("  char     name[256]; /* %s */", comp->name);
  coutf("  char     type[256]; /* %s */", comp->def->name);
  coutf("  long     index; /* %i index in TRACE list, matches the particle.cid when active */",
    index);
  cout( "  Coords   position_absolute;");
  cout( "  Coords   position_relative; /* wrt PREVIOUS */");
  cout( "  Rotation rotation_absolute;");
  cout( "  Rotation rotation_relative; /* wrt PREVIOUS */");
  coutf("  struct " ID_PRE "%s_definition_struct parameters;", comp->name);
  coutf("} " ID_PRE "%s_instance;", comp->name);
  
  return(0);
} /* cogen_comp_declare */

cogen_comp_init(comp)
{
  coutf("void %s_init(*comp)", comp->name);
  /* def -> comp struct or used in init code */
  #define parameters ID_PRE comp->parameters
  #define parameter comp->parameters->parameter
  #define mccompcurname
  #define mccompcurtype
  
  #undef...
}

cogen_comp_trace()
{
}

cogen_comp_save()
{
}

cogen_comp_finally()
{
}

cogen_comp_display()
{
}
