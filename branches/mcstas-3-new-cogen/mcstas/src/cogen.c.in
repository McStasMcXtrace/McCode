/* Convert instrument formal parameter type numbers to their enum name. */
char *instr_formal_type_names[] =
  { "instr_type_int", "instr_type_string", "", "instr_type_array", "instr_type_double" };

char *instr_formal_type_names_real[] =
  { "long", "char*", "char", "MCNUM*", "MCNUM"}; /* 'char' and 'double' are for static array allocations */

cogen_runtime(instr);

codeblock_out;

/* *****************************************************************************
* cogen_instr_declare: write the declaration part from the instrument description
*   that is the particle definition, the instrument parameters, the DECLARE part,
*   and all SHARE sections from components.
* input:  an instrument definition structure
* output: 0 when all is fine, non-0 when error found
*
* code is generated at root level of C file: only C definitions, no initialisers !
* calls: cogen_comp_declare
***************************************************************************** */
int cogen_instr_declare(struct instr_def *instr)
{
  List_handle liter;            /* For list iteration. */
  struct comp_inst *comp;       /* Component instance. */
  struct instr_formal *i_formal;/* Name of instrument formal parameter. */
  long index=0;
  
  /* a previous call to cogen_runtime writes the file header */
  /* TODO: should we merge this here ?*/
  /* TODO: move some of this in mccode-r.h ? or the other way round ? */
  
  if (verbose) fprintf(stderr, "Writing instrument %s and components DECLARE\n", instr->name);
  
  coutf("/* ***************** instrument %s and components DECLARE ********************** */",
    instr->name);
  /* 1. particle definition */
  coutf(
    "typedef struct {\n"
    "  double x,y,z; /* position [m] */\n"
#if MCCODE_PROJECT == 1   /* neutron */
    "  double vx,vy,vz; /* velocity [m/s] */\n"
    "  double sx,sy,sz; /* spin [0-1] */\n"
#elif MCCODE_PROJECT == 2 /* xray */
    "  double kx,ky,kz; /* wave-vector */\n"
    "  double phi, Ex,Ey,Ez; /* phase and electrical field */\n"
#endif
    "  double t, p; /* time, event weight */\n"
    "  long long uid; /* event ID */\n"
    "  long cid; /* event current component ID */\n"
    "} " ID_PRE "particle;");
  
#if MCCODE_PROJECT == 1   /* neutron */
  cout("#define " ID_PRE "neutron " ID_PRE "particle");
  cout("particle " ID_PRE "null_particle = {0,0,0, 0,0,0, 0,0,0, 0,0,0,0};");
#elif MCCODE_PROJECT == 2 /* xray */
  cout("#define " ID_PRE "photon " ID_PRE "particle");
  cout("particle " ID_PRE "null_particle = {0,0,0, 0,0,0, 0,0,0,0, 0,0,0,0};");
#endif
  cout("");
  
  /* 2. Global variables for instrument parameters. */
  cout("/* Instrument parameters: structure and a table for the initialisation\n"
       "   (e.g. " ID_PRE "inputparse). Also used in various I/O function (e.g. detector_out) */");
  liter = list_iterate(instr->formals);
  int numipar=0;
  /* TODO: what if no instrument parameters ? empty structure ? */
  cout("struct " ID_PRE "instrument_parameters_struct {");
  while(i_formal = list_next(liter))
  {
    if (strlen(i_formal->id)) {
      coutf("  %s %s;", instr_formal_type_names_real[i_formal->type], i_formal->id);
      numipar++;
    }
  }
  list_iterate_end(liter);
  cout("}" ID_PRE "instrument_parameters;");
  
  /* 3. Table of instrument parameters. Used in mcparseoptions and various output functions */
  coutf("int %snumipar = %d;", ID_PRE, numipar);
  coutf("struct %sinputtable_struct %sinputtable[] = {",
        ID_PRE, ID_PRE, ID_PRE);
  liter = list_iterate(instr->formals);
  while(i_formal = list_next(liter))
  {
    if (strlen(i_formal->id)) {
      if (i_formal->isoptional && !strcmp(instr_formal_type_names[i_formal->type],"instr_type_string"))
        coutf("  \"%s\", &%sip.%s, %s, %s, ", i_formal->id, ID_PRE,
            i_formal->id, instr_formal_type_names[i_formal->type],
            exp_tostring(i_formal->default_value));
      else
        coutf("  \"%s\", &%sip%s, %s, \"%s\", ", i_formal->id, ID_PRE, i_formal->id,
            instr_formal_type_names[i_formal->type],
            i_formal->isoptional ? exp_tostring(i_formal->default_value) : "");
    }
  }
  list_iterate_end(liter);
  coutf("  NULL, NULL, instr_type_double, \"\"");
  coutf("};");
  cout("");
  
  /* 4. User's declarations from the instrument definition file. */
  cout("/* User declarations from instrument definition. */");
  cogen_instrument_scope(instr, (void (*)(void *))codeblock_out, instr->decls);
  cout("");

  /* 5. Compatibility definitions */
  coutf("#define " ID_PRE "ip " ID_PRE "instrument_parameters");  
  
  /* 6. Component SHAREs. */
  liter = list_iterate(instr->complist);
  index=0;
  while(comp = list_next(liter))
  {
    if((list_len(comp->def->share_code->lines) > 0) && (!comp->def->flag_defined_share))
    {
      if (!index) {
        cout("/* ************************************************************************** */"):
        cout("/*             SHARE user declarations for all components                    */")
        cout("/* ************************************************************************** */"):
        cout("");
      }
      coutf("/* Shared user declarations for all components types '%s'. */", comp->def->name);
      codeblock_out(comp->def->share_code);
      comp->def->flag_defined_share = 1; /* flag the component so that SHARE outputs only once */
      cout("");
      index++;
    }
  }
  if (index) {
    cout("/* ************************************************************************** */"):
    cout("/*             End of SHARE user declarations for all components             */")
    cout("/* ************************************************************************** */"):
    cout("");
  }
  list_iterate_end(liter);
  
  /* 7. call component declare functions */
  cout("/* ********************** component instance declarations. ****************** */");
  liter = list_iterate(instr->complist);
  index=0;
  while(comp = list_next(liter)) {
    comp->index=index;
    cogen_comp_declare(comp, index); /* comp index, aka 'cid', starts at 0 */
    index++;
  }
  
  /* TODO: misses: ABSORB, Group, SCATTERED, RESTORE */
  
  coutf("/* *************** end of instrument %s and components DECLARE ***************** */",
    instr->name);
  return(0);
} /* cogen_instr_declare */

/* *****************************************************************************
* cogen_instr_init: write the INITIALIZE part from the instrument description
*   and calls all component definition init
* input:  an instrument definition structure
* output: 0 when all is fine, non-0 when error found
*
* generates a mcinit() function, called by mccode_main
*   after mcparseoptions, calling itself mcreadparams
***************************************************************************** */
int cogen_instr_init(struct instr_def *instr)
{
  long        index=0;
  List_handle liter;
  struct comp_inst *comp, *last;
  
  /* instrument initialisation */
  if (verbose) fprintf(stderr, "Writing instrument %s and components INITIALIZE\n", instr->name);
  
  coutf("/* ***************** instrument %s and components INITIALIZE ******************* */",
    instr->name);
    
  /* first call component init functions */
  liter = list_iterate(instr->complist);
  last = NULL;
  coutf("    %sDEBUG_INSTR()", ID_PRE);
  cout("");
  liter = list_iterate(instr->complist);
  while((comp = list_next(liter)) != NULL)
  {
    cogen_comp_init(comp, last);
    last = comp;
  }
  cout("");
  /* then write the instrument main init code, which calls component ones */
  coutf("int %sinit(void) { /* called by %scode_main */", ID_PRE, ID_PRE);
  cout("");
  /* default values for instrument parameters are set in mcreadparams */
  cout("/* mccode_main/mcparseoptions/mcreadparams sets instrument parameters value */");
  cout("");
  
  /* User initialisations from instrument definition. */
  coutf("  /* Instrument %s INITIALIZE */", instr->name);
  cogen_instrument_scope(instr, (void (*)(void *))codeblock_out_brace,
                         instr->inits);
  
  /* component init calls */
  cout("  /* Component initialisations: call iteratively all components INITIALIZE */");
  liter = list_iterate(instr->complist);
  while((comp = list_next(liter)) != NULL)
  {
    index++;
    coutf("  if (" ID_PRE" %s_init(&" ID_PRE "%s_instance)) return(%i); /* type %s */", 
      comp->name, comp->name, index, comp->def->name);
  }
  cout("  return(0);");
  cout("} /* " ID_PRE"init */");
  return(0);
} /* cogen_instr_init */

/* *****************************************************************************
* cogen_comp_declare: write the declaration part from the component instance
*   that is the component parameter structure, with positioning stuff
* input:  a component instance structure pointer (not modified)
* output: 0 when all is fine, non-0 when error found
*
* code is generated at root level of C file: only C definitions, no initialisers !
* called by: cogen_instr_declare
***************************************************************************** */
int cogen_comp_declare(struct comp_inst *comp)
{
  List_handle liter;
  
  if (verbose) fprintf(stderr, "Writing component %s=%s() [%i] DECLARE\n", 
    comp->name, comp->def->name, comp->index);
  
  if (!comp->def->flag_defined_structure) {
    coutf("/* ******************* component %s=%s() [%i] DECLARE ******************** */",
      comp->name, comp->def->name, comp->index);
    /* TODO: what if no parameter or no DECLARE code ? */
  
    comp->def->flag_defined_structure = 1;
    coutf("/* Parameter definition for component type '%s' */", 
      comp->def->name);
    coutf("struct " ID_PRE "%s_parameters_struct {", comp->def->name);
      /* put there setting and declare code */
    if(list_len(comp->def->set_par) > 0)
    {
      coutf("/* Component type '%s' setting parameters */", 
        comp->def->name);
      liter = list_iterate(comp->def->set_par);
      while(c_formal = list_next(liter))
      {
        /* scalar parameter */
        if (c_formal->type != instr_type_string && c_formal->type != instr_type_pdouble)
          coutf("  %s %s;", instr_formal_type_names_real[c_formal->type], c_formal->id);
        else  /* array parameter */
          coutf("  %s %s[16384];", 
            instr_formal_type_names_real[c_formal->type+1], c_formal->id);
      }
      list_iterate_end(liter);
    }
    
    /* Output the user declaration code block. */
    if (list_len(comp->def->decl_code->lines) > 0) {
      coutf("/* Component type '%s' DECLARE code */", comp->def->name);
      codeblock_out(comp->def->decl_code);
      /* TODO: warning/error if decl_code contains '=' char ? 
         or handle this in the grammar ?
         OUTPUT(<type> name=value, ...) would work, or rename keyword to
         DECLARE PARAMETERS ?
         could even handle "double * name=definition par"
         SETTING PARAMETERS should support more types, e.g. double* int* ...
         not for instrument parameters (double, int, char* only ?)
         which would limit the use of DEFINITION PARAMETERS
       */
    }
    coutf("}; /* " ID_PRE "%s_parameters_struct */", comp->def->name);
    cout("");
    
    coutf("/* Parameters for component type '%s' */", 
     comp->def->name);
    coutf("struct " ID_PRE "%s_definition_struct {", comp->def->name); 
      /* make struct: set, pos, rot, declare block */
    coutf("  char     name[256]; /* e.g. %s */", comp->name);
    coutf("  char     type[256]; /* %s */", comp->def->name);
    coutf("  long     index; /* e.g. %i index in TRACE list */",
      index);
    cout( "  Coords   position_absolute;");
    cout( "  Coords   position_relative; /* wrt PREVIOUS */");
    cout( "  Rotation rotation_absolute;");
    cout( "  Rotation rotation_relative; /* wrt PREVIOUS */");
    coutf("  struct " ID_PRE "%s_parameters_struct parameters;", comp->name);
    cout ("};");
  } /* define class type parameter structure when not done yet (only once) */
  
  coutf("struct " ID_PRE "%s_definition_struct " ID_PRE "%s_instance;",
    comp->def->name, comp->name);
  
  return(0);
} /* cogen_comp_declare */

/* *****************************************************************************
* cogen_comp_init: write the INITIALIZE part for each component instance
*   generates an init(*comp) function which sets all component parameters
*   computes absolute position and rotation, and executes INIT code.
*
* input:  a component instance structure pointer
* output: 0 when all is fine, non-0 when error found
*
* code is generated at root level of C file: only C definitions, no initialisers !
* called by: cogen_instr_init
***************************************************************************** */
cogen_comp_init(struct comp_inst *comp, struct comp_inst *last)
{
  if (verbose) fprintf(stderr, "Writing component instance %s=%s() [%i] INITIALIZE\n", 
    comp->name, comp->def->name, comp->index);
  
  coutf("/* ******************* component %s=%s() INITIALIZE ******************** */",
    comp->name, comp->def->name);
  coutf("void " ID_PRE "%s_init(" ID_PRE "%s_definition_struct *comp)", 
    comp->name, comp->def->name);
  cout("{");
  
  /* init parameters. These can then be used in position/rotation syntax */
  
  /* Setting parameters of the component */
  setpar = list_iterate(comp->def->set_par);
  while((par = list_next(setpar)) != NULL)
  {
    char *val;
    struct Symtab_entry *entry;

    entry = symtab_lookup(comp->setpar, par->id);
    val = exp_tostring(entry->val);
    code_set_source(instr->quoted_source, exp_getlineno(entry->val));

    if (par->type == instr_type_string)
    {
      coutf("  if(%s && strlen(%s)) strncpy(%s, %s ? %s : \"\", 16384); else %s[0]='\\0';", 
        val, val, par->id, val, val, par->id);
    }
    else
    {
      coutf("  %s = %s;", par->id, val);
    }
    str_free(val);
  }
  list_iterate_end(setpar);
  if(list_len(comp->def->set_par) > 0)
    code_reset_source();
  cout("");
  /* TODO: should do the same for OUTPUT PARAMETERS */
  /* TODO: check for DEFINITION PARAMETERS to appear in INIT code ? */
  
  /* compute coordinates. Can use current instance parameters */
  
  
  
  

  /* init code. Can use component instance parameters */
  #define parameters ID_PRE comp->parameters
  #define parameter comp->parameters->parameter
  #define mccompcurname
  #define mccompcurtype
  
  #undef...
  coutf("} /* " ID_PRE "%s_init */", comp->name);
  
  return(0);
} /* cogen_comp_init */

cogen_comp_trace()
{
}

cogen_comp_save()
{
}

cogen_comp_finally()
{
}

cogen_comp_display()
{
}
