/*******************************************************************************
*
* McXtrace, X-ray tracing package
*         Copyright 1997-2002, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Component: Scatter_log_iterator.comp
*
* %I
*
* Written by: Erik B Knudsen 
* Date: November 2012
* Version: $Revision: 1.21 $
* Release: McStas 2.1
* Origin: DTU Physics
*
* Iteration element for a Scatter_log
*
* %D
*
* This component marks the beginning of the region in trace in which pseudo-neutrons
* are to be propagated. Pseudo-neutrons are neutrons which are generated by the function
* <i>compute_func</i> from before and after SCATTER neutron states which have been logged by
* a set of Scatter_logger/Scatter_logger_stop components.
* N.B. This component should be immediately preceeded by an Arm. Any components between this one
* and a subsequent Scatter_log_iterator_stop-component will be visited by the set of pseudo-neutrons
* as if they were regular neutrons in the classical McStas-manner.
*
* %P
* Input parameters:
*
* compute_func: [ ] Address of the function that computes a psuedo photon from before and after scatter states.
*
* %E
*******************************************************************************/

DEFINE COMPONENT Scatter_log_iterator
DEFINITION PARAMETERS (compute_func=NULL)
SETTING PARAMETERS ()
OUTPUT PARAMETERS (nstate_initial,s0,s1,optics_not_hit, absorbed_in_optics)
/* X-ray parameters: (x,y,z,kx,ky,kz,phi,t,Ex,Ey,Ez,p) */ 

SHARE 
%{
  /*This is the specialized pseudo-neutron function that computes
    an escaping neutron from logged before and after SCATTER neutron states*/
  int exit_photon(double *ns_tilde, struct Generalized_State_t *S0, struct Generalized_State_t *S1){
    /*!!Note that the transformation into global coordinate system must be done while logging
      as we do not have access to neither the component name nor can get the component rotation by index.*/
    Coords c1,c2;
    Rotation R1,R2;

    /*so now compute the pseudo neutron state and possibly user variables*/
    /*position comes from "new" state*/
    ns_tilde[0]=S1->_x;ns_tilde[1]=S1->_y;ns_tilde[2]=S1->_z;
    /*velocity is the "old" state*/
    ns_tilde[3]=S0->_kx;ns_tilde[4]=S0->_ky;ns_tilde[5]=S0->_kz;
    /*time from new*/
    ns_tilde[6]=S1->_t;
    /*phase from new*/
    ns_tilde[7]=S1->_phi;
      /*spin comes from "new" state*/
    ns_tilde[8]=S1->_Ex;ns_tilde[9]=S1->_Ey;ns_tilde[10]=S1->_Ez;
    /*weight is difference old-new to mean the photons "transmitted" through the mirror wall*/
    ns_tilde[11]=S0->_p-S1->_p;
    return 0;
  }

#define NOABS						     \
  do {/* Nothing*/} while(0)
  
%}

DECLARE
%{
  int (*pseudo_photon_state_function) (double *, struct Generalized_State_t *, struct Generalized_State_t *); 

  struct Generalized_State_t *s1,*s0;

  double *nstate_initial;
  
  int optics_not_hit;
  int absorbed_in_optics;

  /*need a pointer to the structure set up by the logger*/
%}

INITIALIZE 
%{
  if (compute_func) {
    pseudo_photon_state_function=compute_func;
  }else{
    pseudo_photon_state_function=exit_photon;
  }
  nstate_initial=NULL;
    
  optics_not_hit=0;
%}


TRACE
%{

  /*I am the start of the pseudo neutron iterator*/
  if (nstate_initial==NULL){
    optics_not_hit=0; /* Fresh start, resetting variable */
    double *ns;
    nstate_initial=calloc(12,sizeof(double));
    ns=nstate_initial;
    ns[0]=x;ns[1]=y; ns[2]=z;
    ns[3]=kx;ns[4]=ky;ns[5]=kz;
    ns[6]=t;
    ns[7]=phi;
    ns[8]=Ex;ns[9]=Ey;ns[10]=Ez;
    ns[11]=p;

    s0=Bounce_store;
    s1=Bounce_store+1;
    /* Remove std. ABSORB to avoid breaking analysis loop */
#undef mcabsorb
#define mcabsorb scatter_iterator_stop
  }

  if (s1->_abs){
    absorbed_in_optics=1;
  }else{
    absorbed_in_optics=0;
  }

  if (s1->_p>=0){
    /*a photon weight of -1 is nonsensical. I.e. if s1->p>=0, it means there are two states in the log from which we can compute a pseudo-photon*/
    double nstate[12];
    if ( pseudo_photon_state_function(nstate,s0,s1) ){
      printf("WARNING: (%s): error reported when computing pseudo photon\n",NAME_CURRENT_COMP);
    }
    /*set photon state for subsequent components*/
    x=nstate[0];y=nstate[1];z=nstate[2];
    kx=nstate[3];ky=nstate[4];kz=nstate[5];
    t=nstate[6];phi=nstate[7];
    Ex=nstate[8];Ey=nstate[9];Ez=nstate[10];
    p=nstate[11];
    s0++;
    s1++;
  }else if (Bounce_store[1]._p==-1){
  /*This can happen now only in the case optics was not hit, i.e. no reflection, no absorption*/
    x=s0->_x;y=s0->_y;z=s0->_z;
    kx=s0->_kx;ky=s0->_ky;kz=s0->_kz;
    t=s0->_t;
    phi=s0->_phi;
    Ex=s0->_Ex;Ey=s0->_Ey;Ez=s0->_Ez;
    p=s0->_p;
    optics_not_hit = 1;
    /*  fprintf(stdout,"No interactions with optics. Use \"optics_not_hit\" variable to avoid detecting such neutrons in monitors.\n");*/
  } else {
    fprintf(stderr,"This should not happen. Period.\n");
    exit(1);
  }

%}

MCDISPLAY
%{
  /* A bit ugly; hard-coded dimensions. */
  
  line(0,0,0,0.2,0,0);
  line(0,0,0,0,0.2,0);
  line(0,0,0,0,0,0.2);
%}

END
