/*******************************************************************************
*
* McXtrace, xray-tracing package
*         Copyright, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Component: Mirror_parabolic
*
* %I
* Written by: Erik Knudsen
* Date: Feb 11, 2010
* Version: $Revision$
* Origin: Risoe
*
* Idealized parabolic mirror
* 
* %D
* Takes a reflectivity (default=1) as input and reflects rays in a ideal geometry
* parabolic mirror. The mirror is positioned in the zx-plane curving towards positive y.
* I.e. the focal point is (0,0,f(a,b))
* The geometry of the paraboloid is governed by the equation: y = x^2 / a^2 + z^2 / b^2
* Hence, the focal length for the 'x' curve is f=a^2 / 4, and analogous for z.
*
* %P
* INPUT PARAMETERS
* R: [1]       Reflectivity of mirror.
* a: [sqrt(m)]       Transverse curvature scale, if zero - the mirror is flat along x.
* b: [sqrt(m)]       Longitudinal curvature scale, if zero, flat along z.
* xwidth: [m]  Width of mirror.
* zdepth: [m]  Length of mirror.
* yheight: [m] Thickness of mirror. If 0 (the default) the mirror is mathemticlly thin. Only has an effect for hitting the mirror from the side.
* 
* OUTPUT PARAMETERS
* xmax: [m] Mirrors' extent along x.
* zmax: [m] Mirrors' extent along z.
* %E
*******************************************************************************/


DEFINE COMPONENT Mirror_parabolic
DEFINITION PARAMETERS ()
SETTING PARAMETERS (R=1, a=1, b=1, xwidth=0.1, zdepth=0.1, yheight=0)
OUTPUT PARAMETERS (a2inv,b2inv,xmax,zmax, focusx,focusz)
/* X-ray parameters: (x,y,z,kx,ky,kz,phi,t,Ex,Ey,Ez,p) */ 

SHARE
%{

%}


DECLARE
%{
  double a2inv,b2inv, focusx,focusz;
  double xmax,zmax;

%}

INITIALIZE
%{
  a2inv=(a!=0)?(1.0/(a*a)):0; /* if a==0, it is really infinity */
  b2inv=(b!=0)?(1.0/(b*b)):0; /* if b==0, it is really infinity */
  focusx=a*a/4.0;
  focusz=b*b/4.0;
%}

TRACE
%{
  int status;
  double l0,l1,sx,sz;
  double nx,ny,nz,zz;
  do {
    if (b==0 && kx==0 && ky==0){
      /*k || z and mirror invariant in z*/
      zz=x*x*a2inv;
      if(fabs(z-zz)<=yheight){
        ABSORB;
      }
    }
    if (a==0 && ky==0 && kz==0){
      /*k || x and mirror invariant in x*/
      zz=y*y*b2inv;
      if(fabs(z-zz)<=yheight){
        ABSORB;
      }
    }



    /*The intersect routine assumes a parabola opening towards positive z
     so swap y and z.*/
    status=paraboloid_intersect(&l0,&l1,x,z,y,kx,kz,ky, a,b,1);
    
    if (status){
      /*if l0==0, assume that we should pick l1 instead (if it is positive).*/
      if (l0>0){
        PROP_DL(l0);
      } else if (l1>0) {
        PROP_DL(l1);
      } else {
        /*both l0 and l1 <=0*/
        status=0;break;
      }
       /*need a check for mirror limits here*/
      if(a!=0){
        sx= (a*a)/2.0 * ( x*a2inv * sqrt( (2*x*a2inv)*(2*x*a2inv) + 1) + asinh(2*x*a2inv)/2.0 );
      }else{
        sx=fabs(x);
      }
      if(b!=0){
        sz= (b*b)/2.0 * ( z*b2inv * sqrt( (2*z*b2inv)*(2*z*b2inv) + 1) + asinh(2*z*b2inv)/2.0 );
      }else{
        sz=fabs(z);
      }
      
      if( sx>xwidth/2.0 || sz>zdepth/2.0 ){
        /*Path length to either x or z coordinate bigger than mirror limits
         * => we have missed the mirror.*/
        RESTORE_XRAY(INDEX_CURRENT_COMP,x,y,z,kx,ky,kz,phi,t,Ex,Ey,Ez,p);
        status=0;
        break;
      }

      /*reflect in normal - again swap y and z.*/
      paraboloid_normal(&nx,&nz,&ny, x,z,y, a,b,1);

      double s=scalar_prod(kx,ky,kz,nx,ny,nz);
      if (s!=0){
        kx -= s*2*nx;
        ky -= s*2*ny;
        kz -= s*2*nz;
      }
      SCATTER;

      p*=R;
      /*update phase - as an approximation turn by 180 deg.*/
      phi+=M_PI;
      first=0; 
      status=paraboloid_intersect(&l0,&l1,x,z,y,kx,kz,ky, a,b,1);
    }
%}

MCDISPLAY
%{
  const int Ni=5;
  const int Nj=25;


  double dx=xwidth/(Ni);
  double dz=zdepth/(Nj);
  double x0,x1,z0,z1,y[4],xmax,zmax;
  int i,j;

  /*find the limits in x and z*/  
  x0=0;x1=xwidth/2.0;

  if(a!=0){
    double xx=(x1-x0)/2.0;
    double sx= (a*a)/2.0 * ( xx*a2inv * sqrt( (2*xx*a2inv)*(2*xx*a2inv) + 1) + asinh(2*xx*a2inv)/2.0 );
    i=0;
    while ( fabs(sx-xwidth/2.0)>1e-4 && i<100){
      //printf("MCDISDEBUG: %d  %g %g %g   %g\n",i,x0,xx,x1,sx); 
      if ((sx-xwidth/2.0)>0){
        x0=(x1-x0)/2.0;
      }else{
        x1=(x1-x0)/2.0;
      }
      xx=(x1-x0)/2.0;
      sx= (a*a)/2.0 * ( xx*a2inv * sqrt( (2*xx*a2inv)*(2*xx*a2inv) + 1) + asinh(2*xx*a2inv)/2.0 );
      i++;

    }
    xmax=xx;
  }else{
    xmax=xwidth/2.0;
  }

  z0=0;z1=zdepth/2.0;
  if(b!=0){
    double zz=(z1+z0)/2.0;
    double sz= (b*b)/2.0 * ( zz*b2inv * sqrt( (2*zz*b2inv)*(2*zz*b2inv) + 1) + asinh(2*zz*b2inv)/2.0 );
    j=0;
    while ( fabs(sz-zdepth/2.0)>1e-4 & j<100){
      if ((sz-zdepth/2.0)>0){
        z1=zz;
      }else{
        z0=zz;;
      }
      zz=(z1+z0)/2.0;
      sz= (b*b)/2.0 * ( zz*b2inv * sqrt( (2*zz*b2inv)*(2*zz*b2inv) + 1) + asinh(2*zz*b2inv)/2.0 );
      j++;
    }
    zmax=zz;
  }else{
    zmax=zdepth/2.0;
  }

  dx=2.0*xmax/(Ni);
  dz=2.0*zmax/(Nj);
  
  /*approximate the mirror bounds by width and depth to avoid inverting the sx and sz functions*/
  /*mirror is symmetric around x,z=0,0. so we c an use xmax and zmax.*/
  for (i=0;i<Ni;i++){
    x0=i*dx - xmax;
    x1=(i+1)*dx - xmax;
    for (j=0;j<Nj;j++){
      z0=j*dz - zmax;
      z1=(j+1)*dz - zmax;
      y[0]=x0*x0*a2inv + z0*z0*b2inv;
      y[1]=x1*x1*a2inv + z0*z0*b2inv;
      y[2]=x0*x0*a2inv + z1*z1*b2inv;
      y[3]=x1*x1*a2inv + z1*z1*b2inv;
    
      line(x0,y[0],z0, x1,y[1],z0);
      line(x0,y[0],z0, x0,y[2],z1);
      if(i==Ni-1) line(x1,y[1],z0, x1,y[3],z1);
      if(j==Nj-1) line(x0,y[2],z1, x1,y[3],z1);
    }
  }

%}

END
