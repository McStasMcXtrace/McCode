/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright 1997-2008, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Component: MirrorPara
*
* %I
* Written by: <a href="mailto:desert@drecam.cea.fr">Sylvain Desert</a>
* Date: 2007
* Version: $Revision: 1.1 $
* Origin: <a href="http://www-llb.cea.fr/">LLB</a>
* Release: McStas 1.12
*
* Parabolic mirror.
*
* %D
* Models a parabolic mirror. The reflectivity profile is given by a 2-column reflectivity free 
* text file with format [q(Angs-1) R(0-1)].
*
* Example:  MirrorPara(reflect="supermirror_m3.rfl", deltaxfaisceau = 0.05, ecartx=0.05,
*				  yheight = 2e-4, focus = 6.6e-4) 
*
*
* %P
* INPUT PARAMETERS:
* deltaxfaisceau: width of the lighntened parrabola (m)
* ecartx: distance between the beam centre and the symetric axis of the parrabolla (m)
* yheight: height of the mirror (m)
* focus: focal length (m)
* reflect: (str)  Reflectivity file name. Format [q(Angs-1) R(0-1)]
*
* %D
* Example values: reflect="supermirror_m3.rfl" deltafaisceau=0.05 yheight=2e-4 focus=6.6e-4 ecartx=0.05
*
* Example instrumentfile FocalisationMirrors.instr is available in the examples/ folder.
*
* %E
*******************************************************************************/

DEFINE COMPONENT MirrorPara
DEFINITION PARAMETERS (string reflect=0)
SETTING PARAMETERS (deltaxfaisceau, ecartx=0.019, yheight, focus)
OUTPUT PARAMETERS (beta1, gamma1, err,nom,vz_neg,p_0)
STATE PARAMETERS (x,y,z,vx,vy,vz,t,s1,s2,p)

SHARE
%{
%include "read_table-lib"
%}

DECLARE
%{
  double  beta1, gamma1;             /* parabola half-axis */
  double a, b;                       /* parameters for neutron propagation */
  double delta, angle;               /* angle: angle between themirror and z-axis */
  t_Table pTable;
  double old_x,old_y,old_z;
  int err,nom,vz_neg,p_0;            /* counts neutron absorbed for anormal reasons */
%}  

INITIALIZE
%{
  double alpha1;                       /* width of the parrabola */
  if (reflect && strlen(reflect)) {
    if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
      exit(fprintf(stderr,"MirrorPara: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
  }
  else{
    exit(fprintf(stderr,"MirrorPara: %s: no file %s\n", NAME_CURRENT_COMP, reflect));
  }
  alpha1 = deltaxfaisceau+ecartx;
  gamma1 = -1/(4*focus);
  beta1 = -gamma1*alpha1*alpha1;
  err = 0;
  nom = 0;                      /* number of reflections on the mirror */
  vz_neg = 0;
  p_0=0;
  yheight/=2;  
%}

TRACE
%{
  double q, B;
  double div,z1,x1,z2,x2;
  double v;
  double vx_2,vz_2;
  int i=-1;
  double oa,ob,ab,xa,za;
  
  /* First check if neutron has the right direction. */
  if((vz != 0.0 && -z/vz >= 0) && x-deltaxfaisceau-ecartx < 0)
  {
    do{
      i++;
      old_z=z;
      old_x=x;
      old_y=y;
      a=vz/vx;
      b=z-a*x;

      /*calculation of intersection with the parabola*/
      delta = sqrt(4*gamma1*(b-beta1)+a*a);
      x1 = (a - delta)/(2*gamma1);
      x2 = (a + delta)/(2*gamma1);
      z1 = gamma1*x1*x1+beta1;
      z2 = gamma1*x2*x2+beta1;

      /*choose the correct answer*/
      if(z1>z2){
          z=z1;
          x=x1;
      }
      else{
          z=z2;
          x=x2;
      }
      /* absorbs the neutron if the difference between the 2 calculation methods is larger than 1% */
      if(fabs(z-a*x-b)>0.01){
            err++;
            ABSORB;
      }
        
        
      /* calculation of y*/
      y+=vy*(z-old_z)/vz;

      /*reflection*/
      if((x-ecartx)>0 && fabs(y)<=yheight){
           nom++;
           
           /* reflection angle in the xz plane */
           div = -atan(vx/vz);
           angle = atan(1/(2*gamma1*x));
           
           /* vx and vz calculation after reflection */
           v=sqrt(vx*vx+vz*vz);
           vz = v*cos(2*angle+div);
           vx = v*sin(2*angle+div);
           
           /*incidence angle in 3D*/
           ob = sqrt((old_x-x)*(old_x-x)+(old_z-z)*(old_z-z));
           ab = ob*cos(-div+angle);
	   /*           printf("%e = %e * cos(%e)",ab,ob,div+angle); */
           xa = x+ab*sin(-angle);
           za = z+ab*cos(-angle);
           oa = sqrt((old_x-xa)*(old_x-xa)+(old_z-za)*(old_z-za));
           ob = sqrt((old_x-x)*(old_x-x)+(old_y-y)*(old_y-y)+(old_z-z)*(old_z-z));
	   /*         printf("\nob : %e / ab : %e\nO: %e / %f / %f\nA : %e / %f / %f\nB : %e / %f / %f\nAngle : %e rad / Div : %e rad\n",ob,ab,old_x,old_y,old_z,xa,old_y,za,x,y,z,angle,div); */
           
           ab = sqrt((xa-x)*(xa-x)+(old_y-y)*(old_y-y)+(za-z)*(za-z));
           angle = acos((-ab*ab-ob*ob+oa*oa)/(2*ab*ob));
           
           v=sqrt(vx*vx+vy*vy+vz*vz);
           q = fabs(2*sin(angle)*v*V2Q);
           /* Reflectivity (see component Guide). */
           B=Table_Value(pTable, q, 1);
           if (B <= 0){
                  p_0++;
                  ABSORB;
           }
           else if (B > 1) B=1;
           /* now handle either probability weight */
           p *= B;
      }
      if(vz<0){
           vz_neg++;
           ABSORB;
      }
    }while((x-ecartx)>0 && fabs(y)<=yheight);
    if (i<0) printf("out !!");
    y=old_y;
    x=old_x;
    z=old_z;    
    SCATTER;
  }
  else{
    ABSORB;
  }
%}

FINALLY
%{
  /*   printf("\n %d neutrons were reflected on the component %s.\n",nom,NAME_CURRENT_COMP);*/
  if(err!=0||vz_neg!=0||p_0!=0){
    fprintf(stderr," \n %d  lost neutrons for inadapted divergence \n\t%d for vz <0 \n\t%d B=0 \n neutrons absorbed inside the component %s\n",err,vz_neg,p_0,NAME_CURRENT_COMP);
  }
%}

MCDISPLAY
%{
  double delta,xi,xf,zi,zf;
  
  delta = deltaxfaisceau/99;
  xi = deltaxfaisceau+ecartx;
  line (xi,-yheight,0, xi,yheight,0);
  do
  {
       xf = xi - delta;
       zi = gamma1*xi*xi+beta1;
       zf = gamma1*xf*xf+beta1;
       line (xi,yheight,zi, xf,yheight,zf);
       line (xi,-yheight,zi, xf,-yheight,zf);
       line (xf,yheight,zf, xf,-yheight,zf);
       xi = xf;
  }while(xf>=ecartx);
%}
END
